{"config":{"indexing":"full","lang":["en","pt"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;"},"docs":[{"location":"","text":"Medusa Simulation This repository holds the Medusa Simulation code stack for underwater marine vehicles of DSOR-ISR (Dynamical Systems for Ocean Robotics - Institute for System Robotics). It contains the necessary components to simulate and control the MEDUSA class of marine vehicles. It provides 2 types of simulation. A matlab like simulation written in C++ and another using gazebo simulator. Requirements This code stack was developed with ROS1 in mind. In order to use, you are required to have: - Ubuntu 20.04LTS (64-bit) - ROS1 Noetic - Python 3","title":"Introduction"},{"location":"#medusa-simulation","text":"This repository holds the Medusa Simulation code stack for underwater marine vehicles of DSOR-ISR (Dynamical Systems for Ocean Robotics - Institute for System Robotics). It contains the necessary components to simulate and control the MEDUSA class of marine vehicles. It provides 2 types of simulation. A matlab like simulation written in C++ and another using gazebo simulator.","title":"Medusa Simulation"},{"location":"#requirements","text":"This code stack was developed with ROS1 in mind. In order to use, you are required to have: - Ubuntu 20.04LTS (64-bit) - ROS1 Noetic - Python 3","title":"Requirements"},{"location":"MBlack/","text":"","title":"Overview"},{"location":"MRed/","text":"","title":"Overview"},{"location":"MVector/","text":"","title":"Overview"},{"location":"MYellow/","text":"","title":"Overview"},{"location":"Waypoint/","text":"","title":"Reference"},{"location":"acoustic-vehicle-state-broadcaster/","text":"acoustic_converters documentation","title":"Reference"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/","text":"Classes class CircularDelay A class that functions as a sample buffer. class const_iterator class const_reverse_iterator class iterator class reverse_iterator namespace DSOR struct VehicleState State class - used to save the state of a vehicle (using SNAME convention) class Differentiator Class for the differentiator. class DigitalFilter Abstract base class for digital moving filters. class HighPassFilter Class for high pass filter using bilinear transform. class HighPassFilter3 Class for third order high pass filter. This is designed using the bilinear transform. class LowPassFilter Class for a low pass filter. class LowPassFilter2 Class for a 2nd order low pass filter. class LowPassFilter3 Class for third order high pass filter. This is designed using the bilinear transform. class LowPassFilter3DiffApprox Class for third order high pass filter. This is designed using the approximated differtial approuch where s=(Z-1)/(Z*T). class LowPassFilter3MatchedZ Class for third order low pass filter. This is designed using the matched Z transform. class MovingAvarageFilter namespace tps Updated on 2022-05-30 at 18:35:06 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/#classes","text":"class CircularDelay A class that functions as a sample buffer. class const_iterator class const_reverse_iterator class iterator class reverse_iterator namespace DSOR struct VehicleState State class - used to save the state of a vehicle (using SNAME convention) class Differentiator Class for the differentiator. class DigitalFilter Abstract base class for digital moving filters. class HighPassFilter Class for high pass filter using bilinear transform. class HighPassFilter3 Class for third order high pass filter. This is designed using the bilinear transform. class LowPassFilter Class for a low pass filter. class LowPassFilter2 Class for a 2nd order low pass filter. class LowPassFilter3 Class for third order high pass filter. This is designed using the bilinear transform. class LowPassFilter3DiffApprox Class for third order high pass filter. This is designed using the approximated differtial approuch where s=(Z-1)/(Z*T). class LowPassFilter3MatchedZ Class for third order low pass filter. This is designed using the matched Z transform. class MovingAvarageFilter namespace tps Updated on 2022-05-30 at 18:35:06 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay/","text":"CircularDelay A class that functions as a sample buffer. More... #include <circular_buffer.hpp> Public Classes Name class const_iterator class const_reverse_iterator class iterator class reverse_iterator Public Functions Name CircularDelay () Constructor that initializes that buffer and its set index. type push (type input) With this function you can insert a new sample into the buffer. type get (size_t delay) With this function you can retrieve a sample from the past. iterator end () iterator begin () reverse_iterator rend () reverse_iterator rbegin () Detailed Description template <typename type , size_t size> class CircularDelay; A class that functions as a sample buffer. Template Parameters : type Type of sample that needs to be stored. size Size of how big the history buffer is. Copyright : GPL V3 Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/CircularDelay/tree/master Brief: Circular delay software library. Here data can be stored and retrieved is a LiFo manner. License: GNU Copyright (C) 2018 Jimmy van den Berg This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see http://www.gnu.org/licenses/ . You can use this to insert samples and use the get function to get a sample from the past. Public Functions Documentation function CircularDelay CircularDelay() Constructor that initializes that buffer and its set index. Template Parameters : type Type of sample that needs to be stored. size Size of how big the history buffer is. function push type push( type input ) With this function you can insert a new sample into the buffer. Parameters : input Sample to push into. Template Parameters : type Type of sample that needs to be stored. size Size of how big the history buffer is. Return : Value that has been pushed. function get type get( size_t delay ) With this function you can retrieve a sample from the past. Parameters : delay How many samples you ago you want to get. Template Parameters : type Type of sample that needs to be stored. size Size of how big the history buffer is. Return : The sample of delay ago. Maximum delay is the size of the CircularDelay - 1. function end inline iterator end() function begin inline iterator begin() function rend inline reverse_iterator rend() function rbegin inline reverse_iterator rbegin() Updated on 2022-05-30 at 18:35:06 +0000","title":"CircularDelay"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay/#circulardelay","text":"A class that functions as a sample buffer. More... #include <circular_buffer.hpp>","title":"CircularDelay"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay/#public-classes","text":"Name class const_iterator class const_reverse_iterator class iterator class reverse_iterator","title":"Public Classes"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay/#public-functions","text":"Name CircularDelay () Constructor that initializes that buffer and its set index. type push (type input) With this function you can insert a new sample into the buffer. type get (size_t delay) With this function you can retrieve a sample from the past. iterator end () iterator begin () reverse_iterator rend () reverse_iterator rbegin ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay/#detailed-description","text":"template <typename type , size_t size> class CircularDelay; A class that functions as a sample buffer. Template Parameters : type Type of sample that needs to be stored. size Size of how big the history buffer is. Copyright : GPL V3 Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/CircularDelay/tree/master Brief: Circular delay software library. Here data can be stored and retrieved is a LiFo manner. License: GNU Copyright (C) 2018 Jimmy van den Berg This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see http://www.gnu.org/licenses/ . You can use this to insert samples and use the get function to get a sample from the past.","title":"Detailed Description"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay/#function-circulardelay","text":"CircularDelay() Constructor that initializes that buffer and its set index. Template Parameters : type Type of sample that needs to be stored. size Size of how big the history buffer is.","title":"function CircularDelay"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay/#function-push","text":"type push( type input ) With this function you can insert a new sample into the buffer. Parameters : input Sample to push into. Template Parameters : type Type of sample that needs to be stored. size Size of how big the history buffer is. Return : Value that has been pushed.","title":"function push"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay/#function-get","text":"type get( size_t delay ) With this function you can retrieve a sample from the past. Parameters : delay How many samples you ago you want to get. Template Parameters : type Type of sample that needs to be stored. size Size of how big the history buffer is. Return : The sample of delay ago. Maximum delay is the size of the CircularDelay - 1.","title":"function get"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay/#function-end","text":"inline iterator end()","title":"function end"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay/#function-begin","text":"inline iterator begin()","title":"function begin"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay/#function-rend","text":"inline reverse_iterator rend()","title":"function rend"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay/#function-rbegin","text":"inline reverse_iterator rbegin() Updated on 2022-05-30 at 18:35:06 +0000","title":"function rbegin"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/","text":"CircularDelay::const_iterator Public Types Name typedef const_iterator self_type typedef std::bidirectional_iterator_tag iterator_category typedef int difference_type Public Functions Name const_iterator (const CircularDelay < type, size >:: const_iterator & it) self_type operator++ () self_type operator++ (int ) self_type operator-- () self_type operator-- (int ) const type & operator* () const type * operator-> () const type & operator[] (unsigned int index) bool operator== (const self_type & rhs) bool operator!= (const self_type & rhs) Friends Name class CircularDelay Public Types Documentation typedef self_type typedef const_iterator CircularDelay< type, size >::const_iterator::self_type; typedef iterator_category typedef std::bidirectional_iterator_tag CircularDelay< type, size >::const_iterator::iterator_category; typedef difference_type typedef int CircularDelay< type, size >::const_iterator::difference_type; Public Functions Documentation function const_iterator inline const_iterator( const CircularDelay< type, size >::const_iterator & it ) function operator++ inline self_type operator++() function operator++ inline self_type operator++( int ) function operator-- inline self_type operator--() function operator-- inline self_type operator--( int ) function operator* inline const type & operator*() function operator-> inline const type * operator->() function operator[] inline const type & operator[]( unsigned int index ) function operator== inline bool operator==( const self_type & rhs ) function operator!= inline bool operator!=( const self_type & rhs ) Friends friend CircularDelay friend class CircularDelay; Updated on 2022-05-30 at 18:35:06 +0000","title":"CircularDelay::const_iterator"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#circulardelayconst_iterator","text":"","title":"CircularDelay::const_iterator"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#public-types","text":"Name typedef const_iterator self_type typedef std::bidirectional_iterator_tag iterator_category typedef int difference_type","title":"Public Types"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#public-functions","text":"Name const_iterator (const CircularDelay < type, size >:: const_iterator & it) self_type operator++ () self_type operator++ (int ) self_type operator-- () self_type operator-- (int ) const type & operator* () const type * operator-> () const type & operator[] (unsigned int index) bool operator== (const self_type & rhs) bool operator!= (const self_type & rhs)","title":"Public Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#friends","text":"Name class CircularDelay","title":"Friends"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#typedef-self_type","text":"typedef const_iterator CircularDelay< type, size >::const_iterator::self_type;","title":"typedef self_type"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#typedef-iterator_category","text":"typedef std::bidirectional_iterator_tag CircularDelay< type, size >::const_iterator::iterator_category;","title":"typedef iterator_category"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#typedef-difference_type","text":"typedef int CircularDelay< type, size >::const_iterator::difference_type;","title":"typedef difference_type"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#function-const_iterator","text":"inline const_iterator( const CircularDelay< type, size >::const_iterator & it )","title":"function const_iterator"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#function-operator","text":"inline self_type operator++()","title":"function operator++"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#function-operator_1","text":"inline self_type operator++( int )","title":"function operator++"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#function-operator-","text":"inline self_type operator--()","title":"function operator--"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#function-operator-_1","text":"inline self_type operator--( int )","title":"function operator--"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#function-operator_2","text":"inline const type & operator*()","title":"function operator*"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#function-operator-_2","text":"inline const type * operator->()","title":"function operator-&gt;"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#function-operator_3","text":"inline const type & operator[]( unsigned int index )","title":"function operator[]"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#function-operator_4","text":"inline bool operator==( const self_type & rhs )","title":"function operator=="},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#function-operator_5","text":"inline bool operator!=( const self_type & rhs )","title":"function operator!="},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#friends_1","text":"","title":"Friends"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#friend-circulardelay","text":"friend class CircularDelay; Updated on 2022-05-30 at 18:35:06 +0000","title":"friend CircularDelay"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/","text":"CircularDelay::const_reverse_iterator Public Types Name typedef const_reverse_iterator self_type typedef std::bidirectional_iterator_tag iterator_category typedef int difference_type Public Functions Name const_reverse_iterator (const CircularDelay < type, size >:: const_reverse_iterator & it) self_type operator++ () self_type operator++ (int ) self_type operator-- () self_type operator-- (int ) const type & operator* () const type * operator-> () const type & operator[] (int index) bool operator== (const self_type & rhs) bool operator!= (const self_type & rhs) Friends Name class CircularDelay Public Types Documentation typedef self_type typedef const_reverse_iterator CircularDelay< type, size >::const_reverse_iterator::self_type; typedef iterator_category typedef std::bidirectional_iterator_tag CircularDelay< type, size >::const_reverse_iterator::iterator_category; typedef difference_type typedef int CircularDelay< type, size >::const_reverse_iterator::difference_type; Public Functions Documentation function const_reverse_iterator inline const_reverse_iterator( const CircularDelay< type, size >::const_reverse_iterator & it ) function operator++ inline self_type operator++() function operator++ inline self_type operator++( int ) function operator-- inline self_type operator--() function operator-- inline self_type operator--( int ) function operator* inline const type & operator*() function operator-> inline const type * operator->() function operator[] inline const type & operator[]( int index ) function operator== inline bool operator==( const self_type & rhs ) function operator!= inline bool operator!=( const self_type & rhs ) Friends friend CircularDelay friend class CircularDelay; Updated on 2022-05-30 at 18:35:06 +0000","title":"CircularDelay::const_reverse_iterator"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#circulardelayconst_reverse_iterator","text":"","title":"CircularDelay::const_reverse_iterator"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#public-types","text":"Name typedef const_reverse_iterator self_type typedef std::bidirectional_iterator_tag iterator_category typedef int difference_type","title":"Public Types"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#public-functions","text":"Name const_reverse_iterator (const CircularDelay < type, size >:: const_reverse_iterator & it) self_type operator++ () self_type operator++ (int ) self_type operator-- () self_type operator-- (int ) const type & operator* () const type * operator-> () const type & operator[] (int index) bool operator== (const self_type & rhs) bool operator!= (const self_type & rhs)","title":"Public Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#friends","text":"Name class CircularDelay","title":"Friends"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#typedef-self_type","text":"typedef const_reverse_iterator CircularDelay< type, size >::const_reverse_iterator::self_type;","title":"typedef self_type"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#typedef-iterator_category","text":"typedef std::bidirectional_iterator_tag CircularDelay< type, size >::const_reverse_iterator::iterator_category;","title":"typedef iterator_category"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#typedef-difference_type","text":"typedef int CircularDelay< type, size >::const_reverse_iterator::difference_type;","title":"typedef difference_type"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#function-const_reverse_iterator","text":"inline const_reverse_iterator( const CircularDelay< type, size >::const_reverse_iterator & it )","title":"function const_reverse_iterator"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#function-operator","text":"inline self_type operator++()","title":"function operator++"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#function-operator_1","text":"inline self_type operator++( int )","title":"function operator++"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#function-operator-","text":"inline self_type operator--()","title":"function operator--"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#function-operator-_1","text":"inline self_type operator--( int )","title":"function operator--"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#function-operator_2","text":"inline const type & operator*()","title":"function operator*"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#function-operator-_2","text":"inline const type * operator->()","title":"function operator-&gt;"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#function-operator_3","text":"inline const type & operator[]( int index )","title":"function operator[]"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#function-operator_4","text":"inline bool operator==( const self_type & rhs )","title":"function operator=="},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#function-operator_5","text":"inline bool operator!=( const self_type & rhs )","title":"function operator!="},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#friends_1","text":"","title":"Friends"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#friend-circulardelay","text":"friend class CircularDelay; Updated on 2022-05-30 at 18:35:06 +0000","title":"friend CircularDelay"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/","text":"CircularDelay::iterator Public Types Name typedef iterator self_type typedef std::bidirectional_iterator_tag iterator_category typedef int difference_type Public Functions Name iterator (const CircularDelay < type, size >:: iterator & it) self_type operator++ () self_type operator++ (int ) self_type operator-- () self_type operator-- (int ) type & operator* () type * operator-> () type & operator[] (unsigned int index) bool operator== (const self_type & rhs) bool operator!= (const self_type & rhs) Friends Name class CircularDelay Public Types Documentation typedef self_type typedef iterator CircularDelay< type, size >::iterator::self_type; typedef iterator_category typedef std::bidirectional_iterator_tag CircularDelay< type, size >::iterator::iterator_category; typedef difference_type typedef int CircularDelay< type, size >::iterator::difference_type; Public Functions Documentation function iterator inline iterator( const CircularDelay< type, size >::iterator & it ) function operator++ inline self_type operator++() function operator++ inline self_type operator++( int ) function operator-- inline self_type operator--() function operator-- inline self_type operator--( int ) function operator* inline type & operator*() function operator-> inline type * operator->() function operator[] inline type & operator[]( unsigned int index ) function operator== inline bool operator==( const self_type & rhs ) function operator!= inline bool operator!=( const self_type & rhs ) Friends friend CircularDelay friend class CircularDelay; Updated on 2022-05-30 at 18:35:06 +0000","title":"CircularDelay::iterator"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#circulardelayiterator","text":"","title":"CircularDelay::iterator"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#public-types","text":"Name typedef iterator self_type typedef std::bidirectional_iterator_tag iterator_category typedef int difference_type","title":"Public Types"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#public-functions","text":"Name iterator (const CircularDelay < type, size >:: iterator & it) self_type operator++ () self_type operator++ (int ) self_type operator-- () self_type operator-- (int ) type & operator* () type * operator-> () type & operator[] (unsigned int index) bool operator== (const self_type & rhs) bool operator!= (const self_type & rhs)","title":"Public Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#friends","text":"Name class CircularDelay","title":"Friends"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#typedef-self_type","text":"typedef iterator CircularDelay< type, size >::iterator::self_type;","title":"typedef self_type"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#typedef-iterator_category","text":"typedef std::bidirectional_iterator_tag CircularDelay< type, size >::iterator::iterator_category;","title":"typedef iterator_category"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#typedef-difference_type","text":"typedef int CircularDelay< type, size >::iterator::difference_type;","title":"typedef difference_type"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#function-iterator","text":"inline iterator( const CircularDelay< type, size >::iterator & it )","title":"function iterator"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#function-operator","text":"inline self_type operator++()","title":"function operator++"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#function-operator_1","text":"inline self_type operator++( int )","title":"function operator++"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#function-operator-","text":"inline self_type operator--()","title":"function operator--"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#function-operator-_1","text":"inline self_type operator--( int )","title":"function operator--"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#function-operator_2","text":"inline type & operator*()","title":"function operator*"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#function-operator-_2","text":"inline type * operator->()","title":"function operator-&gt;"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#function-operator_3","text":"inline type & operator[]( unsigned int index )","title":"function operator[]"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#function-operator_4","text":"inline bool operator==( const self_type & rhs )","title":"function operator=="},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#function-operator_5","text":"inline bool operator!=( const self_type & rhs )","title":"function operator!="},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#friends_1","text":"","title":"Friends"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#friend-circulardelay","text":"friend class CircularDelay; Updated on 2022-05-30 at 18:35:06 +0000","title":"friend CircularDelay"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/","text":"CircularDelay::reverse_iterator Public Types Name typedef reverse_iterator self_type typedef std::bidirectional_iterator_tag iterator_category typedef int difference_type Public Functions Name reverse_iterator (const CircularDelay < type, size >:: reverse_iterator & it) self_type operator++ () self_type operator++ (int ) self_type operator-- () self_type operator-- (int ) type & operator* () type * operator-> () type & operator[] (int index) bool operator== (const self_type & rhs) bool operator!= (const self_type & rhs) Friends Name class CircularDelay Public Types Documentation typedef self_type typedef reverse_iterator CircularDelay< type, size >::reverse_iterator::self_type; typedef iterator_category typedef std::bidirectional_iterator_tag CircularDelay< type, size >::reverse_iterator::iterator_category; typedef difference_type typedef int CircularDelay< type, size >::reverse_iterator::difference_type; Public Functions Documentation function reverse_iterator inline reverse_iterator( const CircularDelay< type, size >::reverse_iterator & it ) function operator++ inline self_type operator++() function operator++ inline self_type operator++( int ) function operator-- inline self_type operator--() function operator-- inline self_type operator--( int ) function operator* inline type & operator*() function operator-> inline type * operator->() function operator[] inline type & operator[]( int index ) function operator== inline bool operator==( const self_type & rhs ) function operator!= inline bool operator!=( const self_type & rhs ) Friends friend CircularDelay friend class CircularDelay; Updated on 2022-05-30 at 18:35:06 +0000","title":"CircularDelay::reverse_iterator"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#circulardelayreverse_iterator","text":"","title":"CircularDelay::reverse_iterator"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#public-types","text":"Name typedef reverse_iterator self_type typedef std::bidirectional_iterator_tag iterator_category typedef int difference_type","title":"Public Types"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#public-functions","text":"Name reverse_iterator (const CircularDelay < type, size >:: reverse_iterator & it) self_type operator++ () self_type operator++ (int ) self_type operator-- () self_type operator-- (int ) type & operator* () type * operator-> () type & operator[] (int index) bool operator== (const self_type & rhs) bool operator!= (const self_type & rhs)","title":"Public Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#friends","text":"Name class CircularDelay","title":"Friends"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#typedef-self_type","text":"typedef reverse_iterator CircularDelay< type, size >::reverse_iterator::self_type;","title":"typedef self_type"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#typedef-iterator_category","text":"typedef std::bidirectional_iterator_tag CircularDelay< type, size >::reverse_iterator::iterator_category;","title":"typedef iterator_category"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#typedef-difference_type","text":"typedef int CircularDelay< type, size >::reverse_iterator::difference_type;","title":"typedef difference_type"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#function-reverse_iterator","text":"inline reverse_iterator( const CircularDelay< type, size >::reverse_iterator & it )","title":"function reverse_iterator"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#function-operator","text":"inline self_type operator++()","title":"function operator++"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#function-operator_1","text":"inline self_type operator++( int )","title":"function operator++"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#function-operator-","text":"inline self_type operator--()","title":"function operator--"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#function-operator-_1","text":"inline self_type operator--( int )","title":"function operator--"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#function-operator_2","text":"inline type & operator*()","title":"function operator*"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#function-operator-_2","text":"inline type * operator->()","title":"function operator-&gt;"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#function-operator_3","text":"inline type & operator[]( int index )","title":"function operator[]"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#function-operator_4","text":"inline bool operator==( const self_type & rhs )","title":"function operator=="},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#function-operator_5","text":"inline bool operator!=( const self_type & rhs )","title":"function operator!="},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#friends_1","text":"","title":"Friends"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#friend-circulardelay","text":"friend class CircularDelay; Updated on 2022-05-30 at 18:35:06 +0000","title":"friend CircularDelay"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classDifferentiator/","text":"Differentiator Class for the differentiator. More... #include <differentiator.hpp> Inherits from DigitalFilter< T > Public Functions Name Differentiator (T sampleTime) Constructor to set sample time and the tau constant. virtual T update (T input) Update function to push new value into the differentiator. virtual T getOutput () Gets the output. Detailed Description template <typename T > class Differentiator; Class for the differentiator. Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/DigitalFilters License: GNU Brief: Class for a differentiator, inherited from the DigitalFilter class of moving filters. A differentiator is a filter that is designed such that the output is approximately directly proportionalto the rate of change (the time derivative) of the input. Public Functions Documentation function Differentiator inline Differentiator( T sampleTime ) Constructor to set sample time and the tau constant. Parameters : sampleTime Sample time for the low pass filter function update inline virtual T update( T input ) Update function to push new value into the differentiator. Parameters : input The new value after dt time Return : The new output value Reimplements : DigitalFilter::update function getOutput inline virtual T getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput Updated on 2022-05-30 at 18:35:06 +0000","title":"Differentiator"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classDifferentiator/#differentiator","text":"Class for the differentiator. More... #include <differentiator.hpp> Inherits from DigitalFilter< T >","title":"Differentiator"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classDifferentiator/#public-functions","text":"Name Differentiator (T sampleTime) Constructor to set sample time and the tau constant. virtual T update (T input) Update function to push new value into the differentiator. virtual T getOutput () Gets the output.","title":"Public Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classDifferentiator/#detailed-description","text":"template <typename T > class Differentiator; Class for the differentiator. Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/DigitalFilters License: GNU Brief: Class for a differentiator, inherited from the DigitalFilter class of moving filters. A differentiator is a filter that is designed such that the output is approximately directly proportionalto the rate of change (the time derivative) of the input.","title":"Detailed Description"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classDifferentiator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classDifferentiator/#function-differentiator","text":"inline Differentiator( T sampleTime ) Constructor to set sample time and the tau constant. Parameters : sampleTime Sample time for the low pass filter","title":"function Differentiator"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classDifferentiator/#function-update","text":"inline virtual T update( T input ) Update function to push new value into the differentiator. Parameters : input The new value after dt time Return : The new output value Reimplements : DigitalFilter::update","title":"function update"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classDifferentiator/#function-getoutput","text":"inline virtual T getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput Updated on 2022-05-30 at 18:35:06 +0000","title":"function getOutput"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classDigitalFilter/","text":"DigitalFilter Abstract base class for digital moving filters. More... #include <digital_filter.hpp> Public Functions Name virtual Type update (Type newValue) =0 virtual Type getOutput () =0 Detailed Description template <typename Type > class DigitalFilter; Abstract base class for digital moving filters. Template Parameters : Type Floating point type used. Public Functions Documentation function update virtual Type update( Type newValue ) =0 Reimplemented by : HighPassFilter::update , LowPassFilter::update , LowPassFilter2::update , HighPassFilter3::update , LowPassFilter3::update , LowPassFilter3MatchedZ::update , LowPassFilter3DiffApprox::update , Differentiator::update function getOutput virtual Type getOutput() =0 Reimplemented by : Differentiator::getOutput , LowPassFilter::getOutput , HighPassFilter::getOutput , LowPassFilter2::getOutput , HighPassFilter3::getOutput , LowPassFilter3::getOutput , LowPassFilter3MatchedZ::getOutput , LowPassFilter3DiffApprox::getOutput Updated on 2022-05-30 at 18:35:06 +0000","title":"DigitalFilter"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classDigitalFilter/#digitalfilter","text":"Abstract base class for digital moving filters. More... #include <digital_filter.hpp>","title":"DigitalFilter"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classDigitalFilter/#public-functions","text":"Name virtual Type update (Type newValue) =0 virtual Type getOutput () =0","title":"Public Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classDigitalFilter/#detailed-description","text":"template <typename Type > class DigitalFilter; Abstract base class for digital moving filters. Template Parameters : Type Floating point type used.","title":"Detailed Description"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classDigitalFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classDigitalFilter/#function-update","text":"virtual Type update( Type newValue ) =0 Reimplemented by : HighPassFilter::update , LowPassFilter::update , LowPassFilter2::update , HighPassFilter3::update , LowPassFilter3::update , LowPassFilter3MatchedZ::update , LowPassFilter3DiffApprox::update , Differentiator::update","title":"function update"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classDigitalFilter/#function-getoutput","text":"virtual Type getOutput() =0 Reimplemented by : Differentiator::getOutput , LowPassFilter::getOutput , HighPassFilter::getOutput , LowPassFilter2::getOutput , HighPassFilter3::getOutput , LowPassFilter3::getOutput , LowPassFilter3MatchedZ::getOutput , LowPassFilter3DiffApprox::getOutput Updated on 2022-05-30 at 18:35:06 +0000","title":"function getOutput"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter/","text":"HighPassFilter Class for high pass filter using bilinear transform. More... #include <highpass_filter.hpp> Inherits from DigitalFilter< float > Public Functions Name HighPassFilter (float idt, float omega_c) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the low pass filter. virtual float getOutput () Gets the output. void configOutput (float newOutput) Force the output to a desired value. const float * outputPointer () Detailed Description class HighPassFilter; Class for high pass filter using bilinear transform. Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/DigitalFilters License: GNU Brief: Multiple classes for low pass filters of different orders, inherited from the DigitalFilter class of moving filters. A low-pass filter is a filter that passes signals with a frequency lower than a selected cutoff frequency and attenuates signals with frequencies higher than the cutoff frequency. Public Functions Documentation function HighPassFilter inline HighPassFilter( float idt, float omega_c ) Constructor to set sample time and the tau constant. Parameters : idt Sample time for the low pass filter omega_c Cutoff angular frequency \\( \\omega_c = 2 pi f_c\\) where \\( f_c \\) is the cutoff frequency function update inline virtual float update( float newValue ) Update function to push new value into the low pass filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update function getOutput inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput function configOutput inline void configOutput( float newOutput ) Force the output to a desired value. Parameters : newOutput The new output This can be useful when the output needs to be forced in case of extreme inputs or such function outputPointer inline const float * outputPointer() Updated on 2022-05-30 at 18:35:06 +0000","title":"HighPassFilter"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter/#highpassfilter","text":"Class for high pass filter using bilinear transform. More... #include <highpass_filter.hpp> Inherits from DigitalFilter< float >","title":"HighPassFilter"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter/#public-functions","text":"Name HighPassFilter (float idt, float omega_c) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the low pass filter. virtual float getOutput () Gets the output. void configOutput (float newOutput) Force the output to a desired value. const float * outputPointer ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter/#detailed-description","text":"class HighPassFilter; Class for high pass filter using bilinear transform. Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/DigitalFilters License: GNU Brief: Multiple classes for low pass filters of different orders, inherited from the DigitalFilter class of moving filters. A low-pass filter is a filter that passes signals with a frequency lower than a selected cutoff frequency and attenuates signals with frequencies higher than the cutoff frequency.","title":"Detailed Description"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter/#function-highpassfilter","text":"inline HighPassFilter( float idt, float omega_c ) Constructor to set sample time and the tau constant. Parameters : idt Sample time for the low pass filter omega_c Cutoff angular frequency \\( \\omega_c = 2 pi f_c\\) where \\( f_c \\) is the cutoff frequency","title":"function HighPassFilter"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter/#function-update","text":"inline virtual float update( float newValue ) Update function to push new value into the low pass filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update","title":"function update"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter/#function-getoutput","text":"inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput","title":"function getOutput"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter/#function-configoutput","text":"inline void configOutput( float newOutput ) Force the output to a desired value. Parameters : newOutput The new output This can be useful when the output needs to be forced in case of extreme inputs or such","title":"function configOutput"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter/#function-outputpointer","text":"inline const float * outputPointer() Updated on 2022-05-30 at 18:35:06 +0000","title":"function outputPointer"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter3/","text":"HighPassFilter3 Class for third order high pass filter. This is designed using the bilinear transform. #include <highpass_filter.hpp> Inherits from DigitalFilter< float > Public Functions Name HighPassFilter3 (float sampleTime, float omega_c, float ioutput =0) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the low pass filter. virtual float getOutput () Gets the output. Public Functions Documentation function HighPassFilter3 inline HighPassFilter3( float sampleTime, float omega_c, float ioutput =0 ) Constructor to set sample time and the tau constant. Parameters : idt Sample time for the low pass filter omega_c Cutoff angular frequency \\( \\omega_c = 2 pi f_c\\) where \\( f_c \\) is the cutoff frequency function update inline virtual float update( float newValue ) Update function to push new value into the low pass filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update function getOutput inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput Updated on 2022-05-30 at 18:35:06 +0000","title":"HighPassFilter3"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter3/#highpassfilter3","text":"Class for third order high pass filter. This is designed using the bilinear transform. #include <highpass_filter.hpp> Inherits from DigitalFilter< float >","title":"HighPassFilter3"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter3/#public-functions","text":"Name HighPassFilter3 (float sampleTime, float omega_c, float ioutput =0) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the low pass filter. virtual float getOutput () Gets the output.","title":"Public Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter3/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter3/#function-highpassfilter3","text":"inline HighPassFilter3( float sampleTime, float omega_c, float ioutput =0 ) Constructor to set sample time and the tau constant. Parameters : idt Sample time for the low pass filter omega_c Cutoff angular frequency \\( \\omega_c = 2 pi f_c\\) where \\( f_c \\) is the cutoff frequency","title":"function HighPassFilter3"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter3/#function-update","text":"inline virtual float update( float newValue ) Update function to push new value into the low pass filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update","title":"function update"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter3/#function-getoutput","text":"inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput Updated on 2022-05-30 at 18:35:06 +0000","title":"function getOutput"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter/","text":"LowPassFilter Class for a low pass filter. More... #include <lowpass_filter.hpp> Inherits from DigitalFilter< float > Public Functions Name LowPassFilter (float idt, float omega_c, float ioutput =0) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the low pass filter. virtual float getOutput () Gets the output. void configOutput (float newOutput) Force the output to a desired value. const float * outputPointer () Detailed Description class LowPassFilter; Class for a low pass filter. Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/DigitalFilters License: GNU Brief: Multiple classes for low pass filters of different orders, inherited from the DigitalFilter class of moving filters. A low-pass filter is a filter that passes signals with a frequency lower than a selected cutoff frequency and attenuates signals with frequencies higher than the cutoff frequency. Design to be a first order Butterworth low pass filter. Transformation done using the matched-Z-transform method Public Functions Documentation function LowPassFilter inline LowPassFilter( float idt, float omega_c, float ioutput =0 ) Constructor to set sample time and the tau constant. Parameters : idt Sample time for the low pass filter omega_c Cutoff angular frequency \\( \\omega_c = 2 pi f_c\\) where \\( f_c \\) is the cutoff frequency function update inline virtual float update( float newValue ) Update function to push new value into the low pass filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update function getOutput inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput function configOutput inline void configOutput( float newOutput ) Force the output to a desired value. Parameters : newOutput The new output This can be useful when the output needs to be forced in case of extreme inputs or such function outputPointer inline const float * outputPointer() Updated on 2022-05-30 at 18:35:06 +0000","title":"LowPassFilter"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter/#lowpassfilter","text":"Class for a low pass filter. More... #include <lowpass_filter.hpp> Inherits from DigitalFilter< float >","title":"LowPassFilter"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter/#public-functions","text":"Name LowPassFilter (float idt, float omega_c, float ioutput =0) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the low pass filter. virtual float getOutput () Gets the output. void configOutput (float newOutput) Force the output to a desired value. const float * outputPointer ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter/#detailed-description","text":"class LowPassFilter; Class for a low pass filter. Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/DigitalFilters License: GNU Brief: Multiple classes for low pass filters of different orders, inherited from the DigitalFilter class of moving filters. A low-pass filter is a filter that passes signals with a frequency lower than a selected cutoff frequency and attenuates signals with frequencies higher than the cutoff frequency. Design to be a first order Butterworth low pass filter. Transformation done using the matched-Z-transform method","title":"Detailed Description"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter/#function-lowpassfilter","text":"inline LowPassFilter( float idt, float omega_c, float ioutput =0 ) Constructor to set sample time and the tau constant. Parameters : idt Sample time for the low pass filter omega_c Cutoff angular frequency \\( \\omega_c = 2 pi f_c\\) where \\( f_c \\) is the cutoff frequency","title":"function LowPassFilter"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter/#function-update","text":"inline virtual float update( float newValue ) Update function to push new value into the low pass filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update","title":"function update"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter/#function-getoutput","text":"inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput","title":"function getOutput"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter/#function-configoutput","text":"inline void configOutput( float newOutput ) Force the output to a desired value. Parameters : newOutput The new output This can be useful when the output needs to be forced in case of extreme inputs or such","title":"function configOutput"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter/#function-outputpointer","text":"inline const float * outputPointer() Updated on 2022-05-30 at 18:35:06 +0000","title":"function outputPointer"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter2/","text":"LowPassFilter2 Class for a 2nd order low pass filter. More... #include <lowpass_filter.hpp> Inherits from DigitalFilter< float > Public Functions Name LowPassFilter2 (float dt, float tau_c, float ioutput =0) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the filter. virtual float getOutput () Gets the output. void configOutput (float newOutput) Force the output to a desired value. Detailed Description class LowPassFilter2; Class for a 2nd order low pass filter. Design to be a 2nd order Butterworth low pass filter. Transformation done using the bilinear transform method Public Functions Documentation function LowPassFilter2 inline LowPassFilter2( float dt, float tau_c, float ioutput =0 ) Constructor to set sample time and the tau constant. Parameters : dt Sample time for the low pass filter tau_c The time constant for the filter \\( \\tau_c = \\frac{1}{2 pi f_c}\\) , where \\( f_c \\) is the cutoff frequency function update inline virtual float update( float newValue ) Update function to push new value into the filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update function getOutput inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput function configOutput inline void configOutput( float newOutput ) Force the output to a desired value. Parameters : newOutput The new output This can be useful when the output needs to be forced in case of extreme inputs or such Updated on 2022-05-30 at 18:35:06 +0000","title":"LowPassFilter2"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter2/#lowpassfilter2","text":"Class for a 2nd order low pass filter. More... #include <lowpass_filter.hpp> Inherits from DigitalFilter< float >","title":"LowPassFilter2"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter2/#public-functions","text":"Name LowPassFilter2 (float dt, float tau_c, float ioutput =0) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the filter. virtual float getOutput () Gets the output. void configOutput (float newOutput) Force the output to a desired value.","title":"Public Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter2/#detailed-description","text":"class LowPassFilter2; Class for a 2nd order low pass filter. Design to be a 2nd order Butterworth low pass filter. Transformation done using the bilinear transform method","title":"Detailed Description"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter2/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter2/#function-lowpassfilter2","text":"inline LowPassFilter2( float dt, float tau_c, float ioutput =0 ) Constructor to set sample time and the tau constant. Parameters : dt Sample time for the low pass filter tau_c The time constant for the filter \\( \\tau_c = \\frac{1}{2 pi f_c}\\) , where \\( f_c \\) is the cutoff frequency","title":"function LowPassFilter2"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter2/#function-update","text":"inline virtual float update( float newValue ) Update function to push new value into the filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update","title":"function update"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter2/#function-getoutput","text":"inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput","title":"function getOutput"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter2/#function-configoutput","text":"inline void configOutput( float newOutput ) Force the output to a desired value. Parameters : newOutput The new output This can be useful when the output needs to be forced in case of extreme inputs or such Updated on 2022-05-30 at 18:35:06 +0000","title":"function configOutput"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3/","text":"LowPassFilter3 Class for third order high pass filter. This is designed using the bilinear transform. #include <lowpass_filter.hpp> Inherits from DigitalFilter< float > Public Functions Name LowPassFilter3 (float sampleTime, float omega_c, float ioutput =0) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the filter. virtual float getOutput () Gets the output. Public Functions Documentation function LowPassFilter3 inline LowPassFilter3( float sampleTime, float omega_c, float ioutput =0 ) Constructor to set sample time and the tau constant. Parameters : sampleTime Sample time for the low pass filter omega_c Cutoff angular frequency \\( \\omega_c = 2 pi f_c\\) where \\( f_c \\) is the cutoff frequency function update inline virtual float update( float newValue ) Update function to push new value into the filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update function getOutput inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput Updated on 2022-05-30 at 18:35:06 +0000","title":"LowPassFilter3"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3/#lowpassfilter3","text":"Class for third order high pass filter. This is designed using the bilinear transform. #include <lowpass_filter.hpp> Inherits from DigitalFilter< float >","title":"LowPassFilter3"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3/#public-functions","text":"Name LowPassFilter3 (float sampleTime, float omega_c, float ioutput =0) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the filter. virtual float getOutput () Gets the output.","title":"Public Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3/#function-lowpassfilter3","text":"inline LowPassFilter3( float sampleTime, float omega_c, float ioutput =0 ) Constructor to set sample time and the tau constant. Parameters : sampleTime Sample time for the low pass filter omega_c Cutoff angular frequency \\( \\omega_c = 2 pi f_c\\) where \\( f_c \\) is the cutoff frequency","title":"function LowPassFilter3"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3/#function-update","text":"inline virtual float update( float newValue ) Update function to push new value into the filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update","title":"function update"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3/#function-getoutput","text":"inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput Updated on 2022-05-30 at 18:35:06 +0000","title":"function getOutput"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3DiffApprox/","text":"LowPassFilter3DiffApprox Class for third order high pass filter. This is designed using the approximated differtial approuch where s=(Z-1)/(Z*T). #include <lowpass_filter.hpp> Inherits from DigitalFilter< float > Public Functions Name LowPassFilter3DiffApprox (float sampleTime, float omega_c, float ioutput =0) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the filter. virtual float getOutput () Gets the output. Public Functions Documentation function LowPassFilter3DiffApprox inline LowPassFilter3DiffApprox( float sampleTime, float omega_c, float ioutput =0 ) Constructor to set sample time and the tau constant. Parameters : sampleTime Sample time for the low pass filter omega_c Cutoff angular frequency \\( \\omega_c = 2 pi f_c\\) where \\( f_c \\) is the cutoff frequency function update inline virtual float update( float newValue ) Update function to push new value into the filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update function getOutput inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput Updated on 2022-05-30 at 18:35:06 +0000","title":"LowPassFilter3DiffApprox"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3DiffApprox/#lowpassfilter3diffapprox","text":"Class for third order high pass filter. This is designed using the approximated differtial approuch where s=(Z-1)/(Z*T). #include <lowpass_filter.hpp> Inherits from DigitalFilter< float >","title":"LowPassFilter3DiffApprox"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3DiffApprox/#public-functions","text":"Name LowPassFilter3DiffApprox (float sampleTime, float omega_c, float ioutput =0) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the filter. virtual float getOutput () Gets the output.","title":"Public Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3DiffApprox/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3DiffApprox/#function-lowpassfilter3diffapprox","text":"inline LowPassFilter3DiffApprox( float sampleTime, float omega_c, float ioutput =0 ) Constructor to set sample time and the tau constant. Parameters : sampleTime Sample time for the low pass filter omega_c Cutoff angular frequency \\( \\omega_c = 2 pi f_c\\) where \\( f_c \\) is the cutoff frequency","title":"function LowPassFilter3DiffApprox"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3DiffApprox/#function-update","text":"inline virtual float update( float newValue ) Update function to push new value into the filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update","title":"function update"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3DiffApprox/#function-getoutput","text":"inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput Updated on 2022-05-30 at 18:35:06 +0000","title":"function getOutput"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3MatchedZ/","text":"LowPassFilter3MatchedZ Class for third order low pass filter. This is designed using the matched Z transform. #include <lowpass_filter.hpp> Inherits from DigitalFilter< float > Public Functions Name LowPassFilter3MatchedZ (float sampleTime, float omega_c) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the filter. virtual float getOutput () Gets the output. Public Functions Documentation function LowPassFilter3MatchedZ inline LowPassFilter3MatchedZ( float sampleTime, float omega_c ) Constructor to set sample time and the tau constant. Parameters : sampleTime Sample time for the low pass filter omega_c Cutoff angular frequency \\( \\omega_c = 2 pi f_c\\) where \\( f_c \\) is the cutoff frequency function update inline virtual float update( float newValue ) Update function to push new value into the filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update function getOutput inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput Updated on 2022-05-30 at 18:35:06 +0000","title":"LowPassFilter3MatchedZ"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3MatchedZ/#lowpassfilter3matchedz","text":"Class for third order low pass filter. This is designed using the matched Z transform. #include <lowpass_filter.hpp> Inherits from DigitalFilter< float >","title":"LowPassFilter3MatchedZ"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3MatchedZ/#public-functions","text":"Name LowPassFilter3MatchedZ (float sampleTime, float omega_c) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the filter. virtual float getOutput () Gets the output.","title":"Public Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3MatchedZ/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3MatchedZ/#function-lowpassfilter3matchedz","text":"inline LowPassFilter3MatchedZ( float sampleTime, float omega_c ) Constructor to set sample time and the tau constant. Parameters : sampleTime Sample time for the low pass filter omega_c Cutoff angular frequency \\( \\omega_c = 2 pi f_c\\) where \\( f_c \\) is the cutoff frequency","title":"function LowPassFilter3MatchedZ"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3MatchedZ/#function-update","text":"inline virtual float update( float newValue ) Update function to push new value into the filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update","title":"function update"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3MatchedZ/#function-getoutput","text":"inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput Updated on 2022-05-30 at 18:35:06 +0000","title":"function getOutput"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classMovingAvarageFilter/","text":"MovingAvarageFilter More... #include <moving_average_filter.hpp> Public Functions Name double update (double input) Update function to push new value into the moving average filter. Detailed Description template <size_t size> class MovingAvarageFilter; Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/DigitalFilters License: GNU Brief: Class for a moving average filter, inherited from the DigitalFilter class of moving filters. A moving average filter is operates by averaging a number of points from the input signal to produce each point in the output signal. Public Functions Documentation function update inline double update( double input ) Update function to push new value into the moving average filter. Parameters : input The new value after dt time Return : The new output value Updated on 2022-05-30 at 18:35:06 +0000","title":"MovingAvarageFilter"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classMovingAvarageFilter/#movingavaragefilter","text":"More... #include <moving_average_filter.hpp>","title":"MovingAvarageFilter"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classMovingAvarageFilter/#public-functions","text":"Name double update (double input) Update function to push new value into the moving average filter.","title":"Public Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classMovingAvarageFilter/#detailed-description","text":"template <size_t size> class MovingAvarageFilter; Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/DigitalFilters License: GNU Brief: Class for a moving average filter, inherited from the DigitalFilter class of moving filters. A moving average filter is operates by averaging a number of points from the input signal to produce each point in the output signal.","title":"Detailed Description"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classMovingAvarageFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classMovingAvarageFilter/#function-update","text":"inline double update( double input ) Update function to push new value into the moving average filter. Parameters : input The new value after dt time Return : The new output value Updated on 2022-05-30 at 18:35:06 +0000","title":"function update"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/structDSOR_1_1VehicleState/","text":"DSOR::VehicleState State class - used to save the state of a vehicle (using SNAME convention) More... #include <vehicle_state.hpp> Public Attributes Name Eigen::Vector3d eta1 Eigen::Vector3d eta2 Eigen::Vector3d v1 Eigen::Vector3d v2 Detailed Description struct DSOR::VehicleState; State class - used to save the state of a vehicle (using SNAME convention) Author : Eduardo Cunha Andre Potes Marcelo Jacinto Version : 1.0.0 Date : 2022/05/26 Copyright : MIT Public Attributes Documentation variable eta1 Eigen::Vector3d eta1 {0.0, 0.0, 0.0}; The position of the vehicle expressed in the inertial frame eta1=[x,y,z]^T variable eta2 Eigen::Vector3d eta2 {0.0, 0.0, 0.0}; The orientation of the vehicle expressed in the inertial frame, using euler angles eta2=[roll, pitch, yaw]^T variable v1 Eigen::Vector3d v1 {0.0, 0.0, 0.0}; The body velocity of the vehicle v1=[u,v,w]^T variable v2 Eigen::Vector3d v2 {0.0, 0.0, 0.0}; The body angular velocity of the vehicle v2=[p,q,r]^T Updated on 2022-05-30 at 18:35:06 +0000","title":"DSOR::VehicleState"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/structDSOR_1_1VehicleState/#dsorvehiclestate","text":"State class - used to save the state of a vehicle (using SNAME convention) More... #include <vehicle_state.hpp>","title":"DSOR::VehicleState"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/structDSOR_1_1VehicleState/#public-attributes","text":"Name Eigen::Vector3d eta1 Eigen::Vector3d eta2 Eigen::Vector3d v1 Eigen::Vector3d v2","title":"Public Attributes"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/structDSOR_1_1VehicleState/#detailed-description","text":"struct DSOR::VehicleState; State class - used to save the state of a vehicle (using SNAME convention) Author : Eduardo Cunha Andre Potes Marcelo Jacinto Version : 1.0.0 Date : 2022/05/26 Copyright : MIT","title":"Detailed Description"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/structDSOR_1_1VehicleState/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/structDSOR_1_1VehicleState/#variable-eta1","text":"Eigen::Vector3d eta1 {0.0, 0.0, 0.0}; The position of the vehicle expressed in the inertial frame eta1=[x,y,z]^T","title":"variable eta1"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/structDSOR_1_1VehicleState/#variable-eta2","text":"Eigen::Vector3d eta2 {0.0, 0.0, 0.0}; The orientation of the vehicle expressed in the inertial frame, using euler angles eta2=[roll, pitch, yaw]^T","title":"variable eta2"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/structDSOR_1_1VehicleState/#variable-v1","text":"Eigen::Vector3d v1 {0.0, 0.0, 0.0}; The body velocity of the vehicle v1=[u,v,w]^T","title":"variable v1"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/structDSOR_1_1VehicleState/#variable-v2","text":"Eigen::Vector3d v2 {0.0, 0.0, 0.0}; The body angular velocity of the vehicle v2=[p,q,r]^T Updated on 2022-05-30 at 18:35:06 +0000","title":"variable v2"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:06 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:06 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:06 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:06 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/","text":"Namespaces namespace DSOR namespace tps Updated on 2022-05-30 at 18:35:06 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/#namespaces","text":"namespace DSOR namespace tps Updated on 2022-05-30 at 18:35:06 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/","text":"DSOR More... Classes Name struct DSOR::VehicleState State class - used to save the state of a vehicle (using SNAME convention) Functions Name template <typename T > T saturateControlDepthUsingMinAltitude (T depth_command, T altitude_min, T measured_depth, T measured_altitude) Method to saturate the control in depth. template <typename T > T saturateControlAltitudeUsingMinAltitude (T altitude_command, T altitude_min) Method to saturate the control in altitude. template <typename T > T saturateControlDepthUsingMaxDepth (T depth_command, T max_depth) Method to saturate the control in depth. template <typename T > T saturateControlAltitudeUsingMaxDepth (T altitude_command, T measured_depth, T measured_altitude, T max_depth) Method to saturate the control in altitude. const Eigen::PermutationMatrix< 3 > NED_ENU_REFLECTION_XY (Eigen::Vector3i(1, 0, 2) ) Use reflections instead of rotations for NED <-> ENU transformation to avoid NaN/Inf floating point pollution across different axes since in NED <-> ENU the axes are perfectly aligned. template <typename T > const Eigen::DiagonalMatrix< T, 3 > NED_ENU_REFLECTION_Z (1 , 1 , - 1) template <typename T > Eigen::Quaternion< T > rot_body_rotation (const Eigen::Quaternion< T > & q) Transform a rotation (as a quaternion) from body expressed in ENU (or NED) to inertial frame to a similar rotation (as quaternion) from body expressed in NED (or ENU) to inertial frame. template <typename T > Eigen::Quaternion< T > rot_inertial_rotation (const Eigen::Quaternion< T > & q) Transform a rotation (as a quaternion) from body to inertial frame expressed in ENU (or NED) to a similar rotation (as quaternion) from body to inertial frame expressed in NED (or ENU) template <typename T > Eigen::Quaternion< T > rot_body_to_inertial (const Eigen::Quaternion< T > & q) Transform a rotation of a rigid body (as a quaternion) from body (ENU or NED) to inertial frame (ENU or NED) to a similar rotation (as quaternion) from body (NED or ENU) to inertial frame (NED or ENU) template <typename T > Eigen::Matrix< T, 3, 1 > transform_vect_body_enu_ned (const Eigen::Matrix< T, 3, 1 > & vec) Transform vector in ENU (or NED) to NED (or ENU), expressed in body-frame. +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU). template <typename T > Eigen::Matrix< T, 3, 1 > transform_vect_between_arbitrary_ref (const Eigen::Matrix< T, 3, 1 > & vec, const Eigen::Quaternion< T > & q) Transform a vector in a given frame of reference to another frame of reference. template <typename T > Eigen::Matrix< T, 3, 1 > transform_vect_inertial_enu_ned (const Eigen::Matrix< T, 3, 1 > & vec) Transform vector in ENU (or NED) to NED (or ENU), expressed in inertial-frame. ENU <\u2014> NED - Invert the Z axis and switch the XY axis. template <typename T > Eigen::Matrix< T, 3, 3 > transform_cov3_body_enu_ned (const Eigen::Matrix< T, 3, 3 > & cov_in) Transform 3x3 covariance matrix in ENU (or NED) to NED (or ENU), expressed in body-frame. template <typename T > Eigen::Matrix< T, 3, 3 > transform_cov3_inertial_enu_ned (const Eigen::Matrix< T, 3, 3 > & cov_in) Transform 3x3 covariance matrix in ENU (or NED) to NED (or ENU), expressed in inertial-frame. template <typename T > int sign (T v) Returns the sign of the number. template <typename T > T saturation (T value, T min, T max) A function that saturates 2 values linearly. template <typename T > bool approximatelyEquals (T a, T b, T tolerance =1e-6) A function to check if two numbers are equal (int, float, double, etc) template <typename T > Eigen::Matrix< T, 3, 1 > quaternion_to_euler (const Eigen::Quaternion< T > & q) Function to convert from quaternion to (roll, pitch and yaw), according to Z-Y-X convention This function is from: https://github.com/mavlink/mavros/issues/444 and the logic is also available at: https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles . template <typename T > Eigen::Quaternion< T > euler_to_quaternion (const Eigen::Matrix< T, 3, 1 > & v) Converts a vector of euler angles according to Z-Y-X convention into a quaternion. template <typename T > T yaw_from_quaternion (const Eigen::Quaternion< T > & q) Gets the yaw angle from a quaternion (assumed a Z-Y-X rotation) NOTE: this function is based on: https://github.com/mavlink/mavros/blob/ros2/mavros/src/lib/ftf_quaternion_utils.cpp which in turn has the theory explained in: https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles . template <typename T > T wrapTo2pi (T angle) Wrap angle between [0, 2PI]. template <typename T > T wrapTopi (T angle) Wrap angle between [-PI, PI]. template <typename T > T radToDeg (T angle) Convert an angle in radian to degrees. template <typename T > T degToRad (T angle) Convert an angle in degrees to radians. template <typename T > T angleDiff (T a, T b) Method to calculate the diference between angles correctly even if they wrap between -pi and pi. template <typename T > Eigen::Matrix< T, 3, 3 > computeSkewSymmetric3 (const Eigen::Matrix< T, 3, 1 > & v) Compute the 3x3 skew-symmetric matrix from a vector 3x1. template <typename T > Eigen::Matrix< T, 2, 2 > computeSkewSymmetric2 (T c) Compute the 2x2 skew-symmetric matrix from a constant (int, float or double) template <typename T > Eigen::Matrix< T, 3, 3 > rotationAngularBodyToInertial (const Eigen::Matrix< T, 3, 1 > & v) Compute the rotation matrix that converts angular velocities expressed in the body frame to angular velocities expressed in the inertial frame (according to Z-Y-X convention) - makes use of small angle approximation. template <typename T > Eigen::Matrix< T, 3, 3 > rotationBodyToInertial (const Eigen::Matrix< T, 3, 1 > & v) Method that returns a rotation matrix from body frame to inertial frame, assuming a Z-Y-X convention. template <typename T > Eigen::Matrix< T, 3, 1 > spherical_to_cartesian (T bearing, T elevation, T range) Convert from spherical to cartesian coordinates. Used mainly with usbl fixes. Attributes Name const Eigen::Quaternion< T > ENU_NED_INERTIAL_Q Static quaternion to convert a rotation expressed in ENU to a rotation expressed in NED (Z->Y->X convention) on the inertial frame Rotate PI/2 about Z-axis -> Rotate 0 about Y-axis -> Rotate PI about X-axis. const Eigen::Quaternion< T > ENU_NED_BODY_Q Static quaternion to convert a rotation expressed in ENU body frame (ROS base_link) to a rotation expressed in NED body frame (Z->Y->X convention) Rotate 0 about Z-axis -> Rotate 0 about Y-axis -> Rotate PI about X-axis. const Eigen::Quaternion< T > BODY_ENU_NED_Q Static quaternion needed for rotating vectors in body frames between ENU and NED +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU). const Eigen::Transform< T, 3, Eigen::Affine > BODY_ENU_NED_TF Static affine matrix to roate vectors ENU (or NED) -> NED (or ENU) expressed in body frame +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU). Detailed Description Authors: Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 10/02/2022 License: MIT File: [vehicle_saturations.hpp] Brief: Defines functions used for saturating the vehicle inputs to the system Authors: Andr\u00e9 Potes ( andre.potes@gmail.com ) Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 14/12/2021 License: MIT File: [frames.hpp] Brief: Defines all functions related to conversions between ENU do NED frames and vice-versa NOTE: Most of this code is adapted from mavros https://github.com/mavlink/mavros/blob/master/mavros/src/lib/ftf_frame_conversions.cpp which had as authors Nuno Marques ( n.marques21@hotmail.com ) and Eddy Scott ( scott.edward@aurora.aero ) Authors: Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Joao Quintas ( jquintas@gmail.com ) Joao Cruz ( joao.pedro.cruz@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 14/12/2021 License: MIT File: [math.hpp] Brief: Defines all functions related to general math functions that can be used anywhere Authors: Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Andre Potes ( andre.potes@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 14/12/2021 License: MIT File: [rotations.hpp] Brief: Defines all functions related to angle wrapping, rotation matrices, euler angles, convertion to quaternions, etc. Authors: Joao Quintas ( jquintas@gmail.com ) Joao Cruz ( joao.pedro.cruz@tecnico.ulisboa.pt ) Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 14/12/2021 License: MIT File: [spherical_coordinates.hpp] Brief: Defines all functions related to spherical coordinates conversions Functions Documentation function saturateControlDepthUsingMinAltitude template <typename T > inline T saturateControlDepthUsingMinAltitude( T depth_command, T altitude_min, T measured_depth, T measured_altitude ) Method to saturate the control in depth. Parameters : depth_command The input command in depth altitude_min The minimum altitude (positive distance from the vehicle to the bottom in m) measured_depth The measured depth of the vehicle measured_altitude The measured altitude of the vehicle Return : The saturated control of depth such that the vehicle does not surpass the minimum altitude function saturateControlAltitudeUsingMinAltitude template <typename T > inline T saturateControlAltitudeUsingMinAltitude( T altitude_command, T altitude_min ) Method to saturate the control in altitude. Parameters : altitude_command The input command in altitude altitude_min The minimum altitude to keep from the ground Return : The output command of the altitude saturated such that the vehicle does not surpass the minimum altitude function saturateControlDepthUsingMaxDepth template <typename T > inline T saturateControlDepthUsingMaxDepth( T depth_command, T max_depth ) Method to saturate the control in depth. Parameters : depth_command The input command in depth max_depth The max depth Return : The output command of the depth saturated such that the vehicle does not surpass the maximum depth function saturateControlAltitudeUsingMaxDepth template <typename T > inline T saturateControlAltitudeUsingMaxDepth( T altitude_command, T measured_depth, T measured_altitude, T max_depth ) Method to saturate the control in altitude. Parameters : altitude_command The input command in altitude measured_depth The measured depth of the vehicle measured_altitude The measured altitude of the vehicle max_depth The maximum depth allowed Return : The output command of the altitude saturated such that the vehicle does not surpass the maximum depth function NED_ENU_REFLECTION_XY static const Eigen::PermutationMatrix< 3 > NED_ENU_REFLECTION_XY( Eigen::Vector3i(1, 0, 2) ) Use reflections instead of rotations for NED <-> ENU transformation to avoid NaN/Inf floating point pollution across different axes since in NED <-> ENU the axes are perfectly aligned. function NED_ENU_REFLECTION_Z template <typename T > static const Eigen::DiagonalMatrix< T, 3 > NED_ENU_REFLECTION_Z( 1 , 1 , - 1 ) function rot_body_rotation template <typename T > inline Eigen::Quaternion< T > rot_body_rotation( const Eigen::Quaternion< T > & q ) Transform a rotation (as a quaternion) from body expressed in ENU (or NED) to inertial frame to a similar rotation (as quaternion) from body expressed in NED (or ENU) to inertial frame. Parameters : q quaternion representing a rotation: body frame ENU (or NED) -> inertial frame (in arbitrary convention) Return : quaternion represeting a rotation: body frame NED (or ENU) -> inertial frame (in arbitrary convention) NOTE: Check http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/transforms/ for more details behind these type of transformations towards obtaining rotations in different frames of reference. function rot_inertial_rotation template <typename T > inline Eigen::Quaternion< T > rot_inertial_rotation( const Eigen::Quaternion< T > & q ) Transform a rotation (as a quaternion) from body to inertial frame expressed in ENU (or NED) to a similar rotation (as quaternion) from body to inertial frame expressed in NED (or ENU) Parameters : q quaternion representing a rotation: body frame (in arbitrary convention) -> inertial frame ENU (or NED) Return : quaternion represeting a rotation: body frame (in arbitrary convention) -> inertial frame NED (or ENU) NOTE: Check http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/transforms/ for more details behind these type of transformations towards obtaining rotations in different frames of reference. function rot_body_to_inertial template <typename T > inline Eigen::Quaternion< T > rot_body_to_inertial( const Eigen::Quaternion< T > & q ) Transform a rotation of a rigid body (as a quaternion) from body (ENU or NED) to inertial frame (ENU or NED) to a similar rotation (as quaternion) from body (NED or ENU) to inertial frame (NED or ENU) Parameters : q quaternion representing a rotation: body frame (ENU or NED) -> inertial frame (ENU or NED) Return : quaternion representing a rotation: body frame (NED or ENU) -> inertial frame (NED or ENU) NOTE: This function is usefull to convert the attitude of a vehicle from \"ROS\" quaternion to a typicall literature quaternion (where both the body frame and inertial frames are in ENU). If you are converting a quaternion that expresses the orientation of a sensor with respect to a rigid body's body frame (and not the inertial frame), then you DO NOT WANT TO USE THIS FUNCTION. Body-FRAME NED is not the same as INERTIAL-FRAME NED (this comes once again from the fact that in ned body the x-y axis don't switch like in inertial frame) as explained in the documentation. Essencial only use this if you are representing a body in inertial frame! NOTE: Check http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/transforms/ for more details behind these type of transformations towards obtaining rotations in different frames of reference. function transform_vect_body_enu_ned template <typename T > inline Eigen::Matrix< T, 3, 1 > transform_vect_body_enu_ned( const Eigen::Matrix< T, 3, 1 > & vec ) Transform vector in ENU (or NED) to NED (or ENU), expressed in body-frame. +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU). Parameters : vec Vector expressed in body-frame (ENU or NED) Return : Vector expressed in body-frame (NED or ENU) function transform_vect_between_arbitrary_ref template <typename T > inline Eigen::Matrix< T, 3, 1 > transform_vect_between_arbitrary_ref( const Eigen::Matrix< T, 3, 1 > & vec, const Eigen::Quaternion< T > & q ) Transform a vector in a given frame of reference to another frame of reference. Parameters : vec Vector expressed in the original frame of reference q Quaternion that expresses the orientation of the original frame of reference with respect to the final frame of reference Return : Vector expressed in the new frame of reference function transform_vect_inertial_enu_ned template <typename T > inline Eigen::Matrix< T, 3, 1 > transform_vect_inertial_enu_ned( const Eigen::Matrix< T, 3, 1 > & vec ) Transform vector in ENU (or NED) to NED (or ENU), expressed in inertial-frame. ENU <\u2014> NED - Invert the Z axis and switch the XY axis. Parameters : vec Vector expressed in inertial-frame (ENU or NED) Return : Vector expressed in inertial-frame (NED or ENU) function transform_cov3_body_enu_ned template <typename T > inline Eigen::Matrix< T, 3, 3 > transform_cov3_body_enu_ned( const Eigen::Matrix< T, 3, 3 > & cov_in ) Transform 3x3 covariance matrix in ENU (or NED) to NED (or ENU), expressed in body-frame. Parameters : cov_in Covariance matrix expressed in body-frame (ENU or NED) Return : Covariance matrix expressed in body-frame (NED or ENU) NOTE: Check https://robotics.stackexchange.com/questions/2556/how-to-rotate-covariance for a detailed explanation of the actual conversion proof for covariance matrices function transform_cov3_inertial_enu_ned template <typename T > inline Eigen::Matrix< T, 3, 3 > transform_cov3_inertial_enu_ned( const Eigen::Matrix< T, 3, 3 > & cov_in ) Transform 3x3 covariance matrix in ENU (or NED) to NED (or ENU), expressed in inertial-frame. Parameters : cov_in Covariance matrix expressed in inertial-frame (ENU or NED) Return : Covariance matrix expressed in inertial-frame (NED or ENU) NOTE: Check https://robotics.stackexchange.com/questions/2556/how-to-rotate-covariance for a detailed explanation of the actual conversion proof for covariance matrices function sign template <typename T > inline int sign( T v ) Returns the sign of the number. Parameters : v A number Return : 1 if value is positive 0 if value is 0 -1 if value is negative function saturation template <typename T > inline T saturation( T value, T min, T max ) A function that saturates 2 values linearly. Parameters : value A number to saturate min The minimum value max The maximum value Return : A value such that value in [min, max] function approximatelyEquals template <typename T > inline bool approximatelyEquals( T a, T b, T tolerance =1e-6 ) A function to check if two numbers are equal (int, float, double, etc) Parameters : a a number to compare b another number to compare tolerance tolerance of comparison Return : A boolean for true if equal within tolerance, or otherwise function quaternion_to_euler template <typename T > inline Eigen::Matrix< T, 3, 1 > quaternion_to_euler( const Eigen::Quaternion< T > & q ) Function to convert from quaternion to (roll, pitch and yaw), according to Z-Y-X convention This function is from: https://github.com/mavlink/mavros/issues/444 and the logic is also available at: https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles . Parameters : q An eigen quaternion Return : A Vector with the [roll, pitch, yaw] obtained according to Z-Y-X convention function euler_to_quaternion template <typename T > inline Eigen::Quaternion< T > euler_to_quaternion( const Eigen::Matrix< T, 3, 1 > & v ) Converts a vector of euler angles according to Z-Y-X convention into a quaternion. Parameters : v An eigen vector of either floats or doubles [roll, pitch, yaw] Return : An Eigen Quaternion function yaw_from_quaternion template <typename T > inline T yaw_from_quaternion( const Eigen::Quaternion< T > & q ) Gets the yaw angle from a quaternion (assumed a Z-Y-X rotation) NOTE: this function is based on: https://github.com/mavlink/mavros/blob/ros2/mavros/src/lib/ftf_quaternion_utils.cpp which in turn has the theory explained in: https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles . Parameters : q A eigen quaternion Return : The yaw angle in radians (assumed a Z-Y-X rotation) function wrapTo2pi template <typename T > inline T wrapTo2pi( T angle ) Wrap angle between [0, 2PI]. Parameters : angle angle in radians Return : The wraped angle function wrapTopi template <typename T > inline T wrapTopi( T angle ) Wrap angle between [-PI, PI]. Parameters : angle angle in radians Return : The wraped angle function radToDeg template <typename T > inline T radToDeg( T angle ) Convert an angle in radian to degrees. Parameters : angle in radians Return : angle in degrees function degToRad template <typename T > inline T degToRad( T angle ) Convert an angle in degrees to radians. Parameters : angle in degrees Return : angle in radians function angleDiff template <typename T > inline T angleDiff( T a, T b ) Method to calculate the diference between angles correctly even if they wrap between -pi and pi. Parameters : a angle 1 in radians b angle 2 in radians Return : The minimum difference between the two angles function computeSkewSymmetric3 template <typename T > inline Eigen::Matrix< T, 3, 3 > computeSkewSymmetric3( const Eigen::Matrix< T, 3, 1 > & v ) Compute the 3x3 skew-symmetric matrix from a vector 3x1. Parameters : v A vector with 3 elements Return : A 3x3 skew-symmetric matrix function computeSkewSymmetric2 template <typename T > inline Eigen::Matrix< T, 2, 2 > computeSkewSymmetric2( T c ) Compute the 2x2 skew-symmetric matrix from a constant (int, float or double) Parameters : v A constant Return : A 2x2 skew-symmetric matrix function rotationAngularBodyToInertial template <typename T > inline Eigen::Matrix< T, 3, 3 > rotationAngularBodyToInertial( const Eigen::Matrix< T, 3, 1 > & v ) Compute the rotation matrix that converts angular velocities expressed in the body frame to angular velocities expressed in the inertial frame (according to Z-Y-X convention) - makes use of small angle approximation. Parameters : v A vector with 3 elements (roll, pitch, yaw) Return : A 3x3 rotation matrix function rotationBodyToInertial template <typename T > inline Eigen::Matrix< T, 3, 3 > rotationBodyToInertial( const Eigen::Matrix< T, 3, 1 > & v ) Method that returns a rotation matrix from body frame to inertial frame, assuming a Z-Y-X convention. Parameters : v A vector with euler angles (roll, pith, yaw) according to Z-Y-X convention Return : A 3x3 rotation matrix function spherical_to_cartesian template <typename T > Eigen::Matrix< T, 3, 1 > spherical_to_cartesian( T bearing, T elevation, T range ) Convert from spherical to cartesian coordinates. Used mainly with usbl fixes. Parameters : bearing Horizontal angle between the direction of an object and another object or between it and the true north direction in degrees. elevation Angle measured between the horizontal and the vehicle line of sight to the object range Distance to the object bearing Horizontal angle between the direction of an object and another object or between it and the true north direction in degrees. elevation Angle measured between the horizontal and the vehicle line of sight to the object range Distance to the object Return : Eigen Vector with cartesian coordinates Eigen Vector with cartesian coordinates Authors: Joao Quintas ( jquintas@gmail.com ) Joao Cruz ( joao.pedro.cruz@tecnico.ulisboa.pt ) Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 14/12/2021 License: MIT File: spherical_coordinates.cpp Brief: Defines all functions related to spherical coordinates conversions Attributes Documentation variable ENU_NED_INERTIAL_Q static const Eigen::Quaternion< T > ENU_NED_INERTIAL_Q = euler_to_quaternion(Eigen::Matrix<T, 3, 1>(M_PI, 0.0, M_PI_2)); Static quaternion to convert a rotation expressed in ENU to a rotation expressed in NED (Z->Y->X convention) on the inertial frame Rotate PI/2 about Z-axis -> Rotate 0 about Y-axis -> Rotate PI about X-axis. NOTE: this quaternion is as valid as the quaternion representing the rotation from NED to ENU (quaternion ambiguity) on the inertial frame variable ENU_NED_BODY_Q static const Eigen::Quaternion< T > ENU_NED_BODY_Q = euler_to_quaternion(Eigen::Matrix<T, 3, 1>(M_PI, 0.0, 0.0)); Static quaternion to convert a rotation expressed in ENU body frame (ROS base_link) to a rotation expressed in NED body frame (Z->Y->X convention) Rotate 0 about Z-axis -> Rotate 0 about Y-axis -> Rotate PI about X-axis. NOTE: this quaternion is as valid as the quaternion representing the rotation from NED to ENU (quaternion ambiguity) on the body frame variable BODY_ENU_NED_Q static const Eigen::Quaternion< T > BODY_ENU_NED_Q = euler_to_quaternion(Eigen::Matrix<T, 3, 1>(M_PI, 0.0, 0.0)); Static quaternion needed for rotating vectors in body frames between ENU and NED +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU). variable BODY_ENU_NED_TF static const Eigen::Transform< T, 3, Eigen::Affine > BODY_ENU_NED_TF = Eigen::Transform<T, 3, Eigen::Affine>(BODY_ENU_NED_Q<T>); Static affine matrix to roate vectors ENU (or NED) -> NED (or ENU) expressed in body frame +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU). Updated on 2022-05-30 at 18:35:06 +0000","title":"DSOR"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#dsor","text":"More...","title":"DSOR"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#classes","text":"Name struct DSOR::VehicleState State class - used to save the state of a vehicle (using SNAME convention)","title":"Classes"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#functions","text":"Name template <typename T > T saturateControlDepthUsingMinAltitude (T depth_command, T altitude_min, T measured_depth, T measured_altitude) Method to saturate the control in depth. template <typename T > T saturateControlAltitudeUsingMinAltitude (T altitude_command, T altitude_min) Method to saturate the control in altitude. template <typename T > T saturateControlDepthUsingMaxDepth (T depth_command, T max_depth) Method to saturate the control in depth. template <typename T > T saturateControlAltitudeUsingMaxDepth (T altitude_command, T measured_depth, T measured_altitude, T max_depth) Method to saturate the control in altitude. const Eigen::PermutationMatrix< 3 > NED_ENU_REFLECTION_XY (Eigen::Vector3i(1, 0, 2) ) Use reflections instead of rotations for NED <-> ENU transformation to avoid NaN/Inf floating point pollution across different axes since in NED <-> ENU the axes are perfectly aligned. template <typename T > const Eigen::DiagonalMatrix< T, 3 > NED_ENU_REFLECTION_Z (1 , 1 , - 1) template <typename T > Eigen::Quaternion< T > rot_body_rotation (const Eigen::Quaternion< T > & q) Transform a rotation (as a quaternion) from body expressed in ENU (or NED) to inertial frame to a similar rotation (as quaternion) from body expressed in NED (or ENU) to inertial frame. template <typename T > Eigen::Quaternion< T > rot_inertial_rotation (const Eigen::Quaternion< T > & q) Transform a rotation (as a quaternion) from body to inertial frame expressed in ENU (or NED) to a similar rotation (as quaternion) from body to inertial frame expressed in NED (or ENU) template <typename T > Eigen::Quaternion< T > rot_body_to_inertial (const Eigen::Quaternion< T > & q) Transform a rotation of a rigid body (as a quaternion) from body (ENU or NED) to inertial frame (ENU or NED) to a similar rotation (as quaternion) from body (NED or ENU) to inertial frame (NED or ENU) template <typename T > Eigen::Matrix< T, 3, 1 > transform_vect_body_enu_ned (const Eigen::Matrix< T, 3, 1 > & vec) Transform vector in ENU (or NED) to NED (or ENU), expressed in body-frame. +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU). template <typename T > Eigen::Matrix< T, 3, 1 > transform_vect_between_arbitrary_ref (const Eigen::Matrix< T, 3, 1 > & vec, const Eigen::Quaternion< T > & q) Transform a vector in a given frame of reference to another frame of reference. template <typename T > Eigen::Matrix< T, 3, 1 > transform_vect_inertial_enu_ned (const Eigen::Matrix< T, 3, 1 > & vec) Transform vector in ENU (or NED) to NED (or ENU), expressed in inertial-frame. ENU <\u2014> NED - Invert the Z axis and switch the XY axis. template <typename T > Eigen::Matrix< T, 3, 3 > transform_cov3_body_enu_ned (const Eigen::Matrix< T, 3, 3 > & cov_in) Transform 3x3 covariance matrix in ENU (or NED) to NED (or ENU), expressed in body-frame. template <typename T > Eigen::Matrix< T, 3, 3 > transform_cov3_inertial_enu_ned (const Eigen::Matrix< T, 3, 3 > & cov_in) Transform 3x3 covariance matrix in ENU (or NED) to NED (or ENU), expressed in inertial-frame. template <typename T > int sign (T v) Returns the sign of the number. template <typename T > T saturation (T value, T min, T max) A function that saturates 2 values linearly. template <typename T > bool approximatelyEquals (T a, T b, T tolerance =1e-6) A function to check if two numbers are equal (int, float, double, etc) template <typename T > Eigen::Matrix< T, 3, 1 > quaternion_to_euler (const Eigen::Quaternion< T > & q) Function to convert from quaternion to (roll, pitch and yaw), according to Z-Y-X convention This function is from: https://github.com/mavlink/mavros/issues/444 and the logic is also available at: https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles . template <typename T > Eigen::Quaternion< T > euler_to_quaternion (const Eigen::Matrix< T, 3, 1 > & v) Converts a vector of euler angles according to Z-Y-X convention into a quaternion. template <typename T > T yaw_from_quaternion (const Eigen::Quaternion< T > & q) Gets the yaw angle from a quaternion (assumed a Z-Y-X rotation) NOTE: this function is based on: https://github.com/mavlink/mavros/blob/ros2/mavros/src/lib/ftf_quaternion_utils.cpp which in turn has the theory explained in: https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles . template <typename T > T wrapTo2pi (T angle) Wrap angle between [0, 2PI]. template <typename T > T wrapTopi (T angle) Wrap angle between [-PI, PI]. template <typename T > T radToDeg (T angle) Convert an angle in radian to degrees. template <typename T > T degToRad (T angle) Convert an angle in degrees to radians. template <typename T > T angleDiff (T a, T b) Method to calculate the diference between angles correctly even if they wrap between -pi and pi. template <typename T > Eigen::Matrix< T, 3, 3 > computeSkewSymmetric3 (const Eigen::Matrix< T, 3, 1 > & v) Compute the 3x3 skew-symmetric matrix from a vector 3x1. template <typename T > Eigen::Matrix< T, 2, 2 > computeSkewSymmetric2 (T c) Compute the 2x2 skew-symmetric matrix from a constant (int, float or double) template <typename T > Eigen::Matrix< T, 3, 3 > rotationAngularBodyToInertial (const Eigen::Matrix< T, 3, 1 > & v) Compute the rotation matrix that converts angular velocities expressed in the body frame to angular velocities expressed in the inertial frame (according to Z-Y-X convention) - makes use of small angle approximation. template <typename T > Eigen::Matrix< T, 3, 3 > rotationBodyToInertial (const Eigen::Matrix< T, 3, 1 > & v) Method that returns a rotation matrix from body frame to inertial frame, assuming a Z-Y-X convention. template <typename T > Eigen::Matrix< T, 3, 1 > spherical_to_cartesian (T bearing, T elevation, T range) Convert from spherical to cartesian coordinates. Used mainly with usbl fixes.","title":"Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#attributes","text":"Name const Eigen::Quaternion< T > ENU_NED_INERTIAL_Q Static quaternion to convert a rotation expressed in ENU to a rotation expressed in NED (Z->Y->X convention) on the inertial frame Rotate PI/2 about Z-axis -> Rotate 0 about Y-axis -> Rotate PI about X-axis. const Eigen::Quaternion< T > ENU_NED_BODY_Q Static quaternion to convert a rotation expressed in ENU body frame (ROS base_link) to a rotation expressed in NED body frame (Z->Y->X convention) Rotate 0 about Z-axis -> Rotate 0 about Y-axis -> Rotate PI about X-axis. const Eigen::Quaternion< T > BODY_ENU_NED_Q Static quaternion needed for rotating vectors in body frames between ENU and NED +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU). const Eigen::Transform< T, 3, Eigen::Affine > BODY_ENU_NED_TF Static affine matrix to roate vectors ENU (or NED) -> NED (or ENU) expressed in body frame +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU).","title":"Attributes"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#detailed-description","text":"Authors: Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 10/02/2022 License: MIT File: [vehicle_saturations.hpp] Brief: Defines functions used for saturating the vehicle inputs to the system Authors: Andr\u00e9 Potes ( andre.potes@gmail.com ) Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 14/12/2021 License: MIT File: [frames.hpp] Brief: Defines all functions related to conversions between ENU do NED frames and vice-versa NOTE: Most of this code is adapted from mavros https://github.com/mavlink/mavros/blob/master/mavros/src/lib/ftf_frame_conversions.cpp which had as authors Nuno Marques ( n.marques21@hotmail.com ) and Eddy Scott ( scott.edward@aurora.aero ) Authors: Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Joao Quintas ( jquintas@gmail.com ) Joao Cruz ( joao.pedro.cruz@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 14/12/2021 License: MIT File: [math.hpp] Brief: Defines all functions related to general math functions that can be used anywhere Authors: Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Andre Potes ( andre.potes@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 14/12/2021 License: MIT File: [rotations.hpp] Brief: Defines all functions related to angle wrapping, rotation matrices, euler angles, convertion to quaternions, etc. Authors: Joao Quintas ( jquintas@gmail.com ) Joao Cruz ( joao.pedro.cruz@tecnico.ulisboa.pt ) Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 14/12/2021 License: MIT File: [spherical_coordinates.hpp] Brief: Defines all functions related to spherical coordinates conversions","title":"Detailed Description"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-saturatecontroldepthusingminaltitude","text":"template <typename T > inline T saturateControlDepthUsingMinAltitude( T depth_command, T altitude_min, T measured_depth, T measured_altitude ) Method to saturate the control in depth. Parameters : depth_command The input command in depth altitude_min The minimum altitude (positive distance from the vehicle to the bottom in m) measured_depth The measured depth of the vehicle measured_altitude The measured altitude of the vehicle Return : The saturated control of depth such that the vehicle does not surpass the minimum altitude","title":"function saturateControlDepthUsingMinAltitude"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-saturatecontrolaltitudeusingminaltitude","text":"template <typename T > inline T saturateControlAltitudeUsingMinAltitude( T altitude_command, T altitude_min ) Method to saturate the control in altitude. Parameters : altitude_command The input command in altitude altitude_min The minimum altitude to keep from the ground Return : The output command of the altitude saturated such that the vehicle does not surpass the minimum altitude","title":"function saturateControlAltitudeUsingMinAltitude"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-saturatecontroldepthusingmaxdepth","text":"template <typename T > inline T saturateControlDepthUsingMaxDepth( T depth_command, T max_depth ) Method to saturate the control in depth. Parameters : depth_command The input command in depth max_depth The max depth Return : The output command of the depth saturated such that the vehicle does not surpass the maximum depth","title":"function saturateControlDepthUsingMaxDepth"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-saturatecontrolaltitudeusingmaxdepth","text":"template <typename T > inline T saturateControlAltitudeUsingMaxDepth( T altitude_command, T measured_depth, T measured_altitude, T max_depth ) Method to saturate the control in altitude. Parameters : altitude_command The input command in altitude measured_depth The measured depth of the vehicle measured_altitude The measured altitude of the vehicle max_depth The maximum depth allowed Return : The output command of the altitude saturated such that the vehicle does not surpass the maximum depth","title":"function saturateControlAltitudeUsingMaxDepth"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-ned_enu_reflection_xy","text":"static const Eigen::PermutationMatrix< 3 > NED_ENU_REFLECTION_XY( Eigen::Vector3i(1, 0, 2) ) Use reflections instead of rotations for NED <-> ENU transformation to avoid NaN/Inf floating point pollution across different axes since in NED <-> ENU the axes are perfectly aligned.","title":"function NED_ENU_REFLECTION_XY"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-ned_enu_reflection_z","text":"template <typename T > static const Eigen::DiagonalMatrix< T, 3 > NED_ENU_REFLECTION_Z( 1 , 1 , - 1 )","title":"function NED_ENU_REFLECTION_Z"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-rot_body_rotation","text":"template <typename T > inline Eigen::Quaternion< T > rot_body_rotation( const Eigen::Quaternion< T > & q ) Transform a rotation (as a quaternion) from body expressed in ENU (or NED) to inertial frame to a similar rotation (as quaternion) from body expressed in NED (or ENU) to inertial frame. Parameters : q quaternion representing a rotation: body frame ENU (or NED) -> inertial frame (in arbitrary convention) Return : quaternion represeting a rotation: body frame NED (or ENU) -> inertial frame (in arbitrary convention) NOTE: Check http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/transforms/ for more details behind these type of transformations towards obtaining rotations in different frames of reference.","title":"function rot_body_rotation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-rot_inertial_rotation","text":"template <typename T > inline Eigen::Quaternion< T > rot_inertial_rotation( const Eigen::Quaternion< T > & q ) Transform a rotation (as a quaternion) from body to inertial frame expressed in ENU (or NED) to a similar rotation (as quaternion) from body to inertial frame expressed in NED (or ENU) Parameters : q quaternion representing a rotation: body frame (in arbitrary convention) -> inertial frame ENU (or NED) Return : quaternion represeting a rotation: body frame (in arbitrary convention) -> inertial frame NED (or ENU) NOTE: Check http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/transforms/ for more details behind these type of transformations towards obtaining rotations in different frames of reference.","title":"function rot_inertial_rotation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-rot_body_to_inertial","text":"template <typename T > inline Eigen::Quaternion< T > rot_body_to_inertial( const Eigen::Quaternion< T > & q ) Transform a rotation of a rigid body (as a quaternion) from body (ENU or NED) to inertial frame (ENU or NED) to a similar rotation (as quaternion) from body (NED or ENU) to inertial frame (NED or ENU) Parameters : q quaternion representing a rotation: body frame (ENU or NED) -> inertial frame (ENU or NED) Return : quaternion representing a rotation: body frame (NED or ENU) -> inertial frame (NED or ENU) NOTE: This function is usefull to convert the attitude of a vehicle from \"ROS\" quaternion to a typicall literature quaternion (where both the body frame and inertial frames are in ENU). If you are converting a quaternion that expresses the orientation of a sensor with respect to a rigid body's body frame (and not the inertial frame), then you DO NOT WANT TO USE THIS FUNCTION. Body-FRAME NED is not the same as INERTIAL-FRAME NED (this comes once again from the fact that in ned body the x-y axis don't switch like in inertial frame) as explained in the documentation. Essencial only use this if you are representing a body in inertial frame! NOTE: Check http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/transforms/ for more details behind these type of transformations towards obtaining rotations in different frames of reference.","title":"function rot_body_to_inertial"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-transform_vect_body_enu_ned","text":"template <typename T > inline Eigen::Matrix< T, 3, 1 > transform_vect_body_enu_ned( const Eigen::Matrix< T, 3, 1 > & vec ) Transform vector in ENU (or NED) to NED (or ENU), expressed in body-frame. +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU). Parameters : vec Vector expressed in body-frame (ENU or NED) Return : Vector expressed in body-frame (NED or ENU)","title":"function transform_vect_body_enu_ned"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-transform_vect_between_arbitrary_ref","text":"template <typename T > inline Eigen::Matrix< T, 3, 1 > transform_vect_between_arbitrary_ref( const Eigen::Matrix< T, 3, 1 > & vec, const Eigen::Quaternion< T > & q ) Transform a vector in a given frame of reference to another frame of reference. Parameters : vec Vector expressed in the original frame of reference q Quaternion that expresses the orientation of the original frame of reference with respect to the final frame of reference Return : Vector expressed in the new frame of reference","title":"function transform_vect_between_arbitrary_ref"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-transform_vect_inertial_enu_ned","text":"template <typename T > inline Eigen::Matrix< T, 3, 1 > transform_vect_inertial_enu_ned( const Eigen::Matrix< T, 3, 1 > & vec ) Transform vector in ENU (or NED) to NED (or ENU), expressed in inertial-frame. ENU <\u2014> NED - Invert the Z axis and switch the XY axis. Parameters : vec Vector expressed in inertial-frame (ENU or NED) Return : Vector expressed in inertial-frame (NED or ENU)","title":"function transform_vect_inertial_enu_ned"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-transform_cov3_body_enu_ned","text":"template <typename T > inline Eigen::Matrix< T, 3, 3 > transform_cov3_body_enu_ned( const Eigen::Matrix< T, 3, 3 > & cov_in ) Transform 3x3 covariance matrix in ENU (or NED) to NED (or ENU), expressed in body-frame. Parameters : cov_in Covariance matrix expressed in body-frame (ENU or NED) Return : Covariance matrix expressed in body-frame (NED or ENU) NOTE: Check https://robotics.stackexchange.com/questions/2556/how-to-rotate-covariance for a detailed explanation of the actual conversion proof for covariance matrices","title":"function transform_cov3_body_enu_ned"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-transform_cov3_inertial_enu_ned","text":"template <typename T > inline Eigen::Matrix< T, 3, 3 > transform_cov3_inertial_enu_ned( const Eigen::Matrix< T, 3, 3 > & cov_in ) Transform 3x3 covariance matrix in ENU (or NED) to NED (or ENU), expressed in inertial-frame. Parameters : cov_in Covariance matrix expressed in inertial-frame (ENU or NED) Return : Covariance matrix expressed in inertial-frame (NED or ENU) NOTE: Check https://robotics.stackexchange.com/questions/2556/how-to-rotate-covariance for a detailed explanation of the actual conversion proof for covariance matrices","title":"function transform_cov3_inertial_enu_ned"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-sign","text":"template <typename T > inline int sign( T v ) Returns the sign of the number. Parameters : v A number Return : 1 if value is positive 0 if value is 0 -1 if value is negative","title":"function sign"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-saturation","text":"template <typename T > inline T saturation( T value, T min, T max ) A function that saturates 2 values linearly. Parameters : value A number to saturate min The minimum value max The maximum value Return : A value such that value in [min, max]","title":"function saturation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-approximatelyequals","text":"template <typename T > inline bool approximatelyEquals( T a, T b, T tolerance =1e-6 ) A function to check if two numbers are equal (int, float, double, etc) Parameters : a a number to compare b another number to compare tolerance tolerance of comparison Return : A boolean for true if equal within tolerance, or otherwise","title":"function approximatelyEquals"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-quaternion_to_euler","text":"template <typename T > inline Eigen::Matrix< T, 3, 1 > quaternion_to_euler( const Eigen::Quaternion< T > & q ) Function to convert from quaternion to (roll, pitch and yaw), according to Z-Y-X convention This function is from: https://github.com/mavlink/mavros/issues/444 and the logic is also available at: https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles . Parameters : q An eigen quaternion Return : A Vector with the [roll, pitch, yaw] obtained according to Z-Y-X convention","title":"function quaternion_to_euler"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-euler_to_quaternion","text":"template <typename T > inline Eigen::Quaternion< T > euler_to_quaternion( const Eigen::Matrix< T, 3, 1 > & v ) Converts a vector of euler angles according to Z-Y-X convention into a quaternion. Parameters : v An eigen vector of either floats or doubles [roll, pitch, yaw] Return : An Eigen Quaternion","title":"function euler_to_quaternion"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-yaw_from_quaternion","text":"template <typename T > inline T yaw_from_quaternion( const Eigen::Quaternion< T > & q ) Gets the yaw angle from a quaternion (assumed a Z-Y-X rotation) NOTE: this function is based on: https://github.com/mavlink/mavros/blob/ros2/mavros/src/lib/ftf_quaternion_utils.cpp which in turn has the theory explained in: https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles . Parameters : q A eigen quaternion Return : The yaw angle in radians (assumed a Z-Y-X rotation)","title":"function yaw_from_quaternion"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-wrapto2pi","text":"template <typename T > inline T wrapTo2pi( T angle ) Wrap angle between [0, 2PI]. Parameters : angle angle in radians Return : The wraped angle","title":"function wrapTo2pi"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-wraptopi","text":"template <typename T > inline T wrapTopi( T angle ) Wrap angle between [-PI, PI]. Parameters : angle angle in radians Return : The wraped angle","title":"function wrapTopi"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-radtodeg","text":"template <typename T > inline T radToDeg( T angle ) Convert an angle in radian to degrees. Parameters : angle in radians Return : angle in degrees","title":"function radToDeg"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-degtorad","text":"template <typename T > inline T degToRad( T angle ) Convert an angle in degrees to radians. Parameters : angle in degrees Return : angle in radians","title":"function degToRad"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-anglediff","text":"template <typename T > inline T angleDiff( T a, T b ) Method to calculate the diference between angles correctly even if they wrap between -pi and pi. Parameters : a angle 1 in radians b angle 2 in radians Return : The minimum difference between the two angles","title":"function angleDiff"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-computeskewsymmetric3","text":"template <typename T > inline Eigen::Matrix< T, 3, 3 > computeSkewSymmetric3( const Eigen::Matrix< T, 3, 1 > & v ) Compute the 3x3 skew-symmetric matrix from a vector 3x1. Parameters : v A vector with 3 elements Return : A 3x3 skew-symmetric matrix","title":"function computeSkewSymmetric3"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-computeskewsymmetric2","text":"template <typename T > inline Eigen::Matrix< T, 2, 2 > computeSkewSymmetric2( T c ) Compute the 2x2 skew-symmetric matrix from a constant (int, float or double) Parameters : v A constant Return : A 2x2 skew-symmetric matrix","title":"function computeSkewSymmetric2"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-rotationangularbodytoinertial","text":"template <typename T > inline Eigen::Matrix< T, 3, 3 > rotationAngularBodyToInertial( const Eigen::Matrix< T, 3, 1 > & v ) Compute the rotation matrix that converts angular velocities expressed in the body frame to angular velocities expressed in the inertial frame (according to Z-Y-X convention) - makes use of small angle approximation. Parameters : v A vector with 3 elements (roll, pitch, yaw) Return : A 3x3 rotation matrix","title":"function rotationAngularBodyToInertial"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-rotationbodytoinertial","text":"template <typename T > inline Eigen::Matrix< T, 3, 3 > rotationBodyToInertial( const Eigen::Matrix< T, 3, 1 > & v ) Method that returns a rotation matrix from body frame to inertial frame, assuming a Z-Y-X convention. Parameters : v A vector with euler angles (roll, pith, yaw) according to Z-Y-X convention Return : A 3x3 rotation matrix","title":"function rotationBodyToInertial"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-spherical_to_cartesian","text":"template <typename T > Eigen::Matrix< T, 3, 1 > spherical_to_cartesian( T bearing, T elevation, T range ) Convert from spherical to cartesian coordinates. Used mainly with usbl fixes. Parameters : bearing Horizontal angle between the direction of an object and another object or between it and the true north direction in degrees. elevation Angle measured between the horizontal and the vehicle line of sight to the object range Distance to the object bearing Horizontal angle between the direction of an object and another object or between it and the true north direction in degrees. elevation Angle measured between the horizontal and the vehicle line of sight to the object range Distance to the object Return : Eigen Vector with cartesian coordinates Eigen Vector with cartesian coordinates Authors: Joao Quintas ( jquintas@gmail.com ) Joao Cruz ( joao.pedro.cruz@tecnico.ulisboa.pt ) Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 14/12/2021 License: MIT File: spherical_coordinates.cpp Brief: Defines all functions related to spherical coordinates conversions","title":"function spherical_to_cartesian"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#variable-enu_ned_inertial_q","text":"static const Eigen::Quaternion< T > ENU_NED_INERTIAL_Q = euler_to_quaternion(Eigen::Matrix<T, 3, 1>(M_PI, 0.0, M_PI_2)); Static quaternion to convert a rotation expressed in ENU to a rotation expressed in NED (Z->Y->X convention) on the inertial frame Rotate PI/2 about Z-axis -> Rotate 0 about Y-axis -> Rotate PI about X-axis. NOTE: this quaternion is as valid as the quaternion representing the rotation from NED to ENU (quaternion ambiguity) on the inertial frame","title":"variable ENU_NED_INERTIAL_Q"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#variable-enu_ned_body_q","text":"static const Eigen::Quaternion< T > ENU_NED_BODY_Q = euler_to_quaternion(Eigen::Matrix<T, 3, 1>(M_PI, 0.0, 0.0)); Static quaternion to convert a rotation expressed in ENU body frame (ROS base_link) to a rotation expressed in NED body frame (Z->Y->X convention) Rotate 0 about Z-axis -> Rotate 0 about Y-axis -> Rotate PI about X-axis. NOTE: this quaternion is as valid as the quaternion representing the rotation from NED to ENU (quaternion ambiguity) on the body frame","title":"variable ENU_NED_BODY_Q"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#variable-body_enu_ned_q","text":"static const Eigen::Quaternion< T > BODY_ENU_NED_Q = euler_to_quaternion(Eigen::Matrix<T, 3, 1>(M_PI, 0.0, 0.0)); Static quaternion needed for rotating vectors in body frames between ENU and NED +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU).","title":"variable BODY_ENU_NED_Q"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#variable-body_enu_ned_tf","text":"static const Eigen::Transform< T, 3, Eigen::Affine > BODY_ENU_NED_TF = Eigen::Transform<T, 3, Eigen::Affine>(BODY_ENU_NED_Q<T>); Static affine matrix to roate vectors ENU (or NED) -> NED (or ENU) expressed in body frame +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU). Updated on 2022-05-30 at 18:35:06 +0000","title":"variable BODY_ENU_NED_TF"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespacetps/","text":"tps More... Functions Name template <typename T > constexpr T pow (T input, unsigned int power) Detailed Description Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/DigitalFilters License: GNU Brief: Abstract class for moving filters. Moving filter are real time filter used for applications where continuous filtering is necessary as it can be part of an control system. Functions Documentation function pow template <typename T > constexpr T pow( T input, unsigned int power ) Updated on 2022-05-30 at 18:35:06 +0000","title":"tps"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespacetps/#tps","text":"More...","title":"tps"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespacetps/#functions","text":"Name template <typename T > constexpr T pow (T input, unsigned int power)","title":"Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespacetps/#detailed-description","text":"Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/DigitalFilters License: GNU Brief: Abstract class for moving filters. Moving filter are real time filter used for applications where continuous filtering is necessary as it can be part of an control system.","title":"Detailed Description"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespacetps/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespacetps/#function-pow","text":"template <typename T > constexpr T pow( T input, unsigned int power ) Updated on 2022-05-30 at 18:35:06 +0000","title":"function pow"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/","text":"Classes class ConsolePathParserNode Class Responsible for parsing a mission from the console Yebisu to medusa_vx stack format. class Formation Contains Formation variables for cooperative path following. class Section Contains Section variables for path followin algorithms. Updated on 2022-05-30 at 18:35:15 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/#classes","text":"class ConsolePathParserNode Class Responsible for parsing a mission from the console Yebisu to medusa_vx stack format. class Formation Contains Formation variables for cooperative path following. class Section Contains Section variables for path followin algorithms. Updated on 2022-05-30 at 18:35:15 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/","text":"ConsolePathParserNode Class Responsible for parsing a mission from the console Yebisu to medusa_vx stack format. #include <ConsolePathParserNode.h> Public Functions Name ConsolePathParserNode (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) Construct a new Console Path Parser Node object. ~ConsolePathParserNode () Destroy the Console Path Parser Node object. double nodeFrequency () Method to setup the frequency of the node. Public Attributes Name std::list< Section > mission std::list< Formation > formation std::list< Section >::iterator act_section medusa_msgs::Section section_copy ros::Time depth_end int own_id double xrefpoint double yrefpoint double gamma_s double gamma_e double x_act double y_act double gamma double gamma_old double u_est double x_forma double y_forma float DesiredDepth bool wpOrient bool ENABLE bool formation_mode bool biased_formation_mode float node_frequency std::string path_folder Public Functions Documentation function ConsolePathParserNode ConsolePathParserNode( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private ) Construct a new Console Path Parser Node object. Parameters : nodehandle nodehandle_private nodehandle the public ros nodehandle nodehandle_private the private ros nodehandle Console Path Parser node constructor. function ~ConsolePathParserNode ~ConsolePathParserNode() Destroy the Console Path Parser Node object. Console Path Parser node destructor. function nodeFrequency double nodeFrequency() Method to setup the frequency of the node. Return : double Public Attributes Documentation variable mission std::list< Section > mission; variable formation std::list< Formation > formation; variable act_section std::list< Section >::iterator act_section; variable section_copy medusa_msgs::Section section_copy; variable depth_end ros::Time depth_end; variable own_id int own_id {0}; variable xrefpoint double xrefpoint = 0; variable yrefpoint double yrefpoint = 0; variable gamma_s double gamma_s = 0; variable gamma_e double gamma_e = 0; variable x_act double x_act = 0; variable y_act double y_act = 0; variable gamma double gamma = 0; variable gamma_old double gamma_old = 0; variable u_est double u_est = 0; variable x_forma double x_forma = 0; variable y_forma double y_forma = 0; variable DesiredDepth float DesiredDepth = 0.0; variable wpOrient bool wpOrient; variable ENABLE bool ENABLE = false; variable formation_mode bool formation_mode = false; variable biased_formation_mode bool biased_formation_mode = false; variable node_frequency float node_frequency; variable path_folder std::string path_folder; Updated on 2022-05-30 at 18:35:15 +0000","title":"ConsolePathParserNode"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#consolepathparsernode","text":"Class Responsible for parsing a mission from the console Yebisu to medusa_vx stack format. #include <ConsolePathParserNode.h>","title":"ConsolePathParserNode"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#public-functions","text":"Name ConsolePathParserNode (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) Construct a new Console Path Parser Node object. ~ConsolePathParserNode () Destroy the Console Path Parser Node object. double nodeFrequency () Method to setup the frequency of the node.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#public-attributes","text":"Name std::list< Section > mission std::list< Formation > formation std::list< Section >::iterator act_section medusa_msgs::Section section_copy ros::Time depth_end int own_id double xrefpoint double yrefpoint double gamma_s double gamma_e double x_act double y_act double gamma double gamma_old double u_est double x_forma double y_forma float DesiredDepth bool wpOrient bool ENABLE bool formation_mode bool biased_formation_mode float node_frequency std::string path_folder","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#function-consolepathparsernode","text":"ConsolePathParserNode( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private ) Construct a new Console Path Parser Node object. Parameters : nodehandle nodehandle_private nodehandle the public ros nodehandle nodehandle_private the private ros nodehandle Console Path Parser node constructor.","title":"function ConsolePathParserNode"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#function-consolepathparsernode_1","text":"~ConsolePathParserNode() Destroy the Console Path Parser Node object. Console Path Parser node destructor.","title":"function ~ConsolePathParserNode"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#function-nodefrequency","text":"double nodeFrequency() Method to setup the frequency of the node. Return : double","title":"function nodeFrequency"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-mission","text":"std::list< Section > mission;","title":"variable mission"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-formation","text":"std::list< Formation > formation;","title":"variable formation"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-act_section","text":"std::list< Section >::iterator act_section;","title":"variable act_section"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-section_copy","text":"medusa_msgs::Section section_copy;","title":"variable section_copy"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-depth_end","text":"ros::Time depth_end;","title":"variable depth_end"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-own_id","text":"int own_id {0};","title":"variable own_id"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-xrefpoint","text":"double xrefpoint = 0;","title":"variable xrefpoint"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-yrefpoint","text":"double yrefpoint = 0;","title":"variable yrefpoint"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-gamma_s","text":"double gamma_s = 0;","title":"variable gamma_s"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-gamma_e","text":"double gamma_e = 0;","title":"variable gamma_e"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-x_act","text":"double x_act = 0;","title":"variable x_act"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-y_act","text":"double y_act = 0;","title":"variable y_act"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-gamma","text":"double gamma = 0;","title":"variable gamma"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-gamma_old","text":"double gamma_old = 0;","title":"variable gamma_old"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-u_est","text":"double u_est = 0;","title":"variable u_est"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-x_forma","text":"double x_forma = 0;","title":"variable x_forma"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-y_forma","text":"double y_forma = 0;","title":"variable y_forma"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-desireddepth","text":"float DesiredDepth = 0.0;","title":"variable DesiredDepth"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-wporient","text":"bool wpOrient;","title":"variable wpOrient"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-enable","text":"bool ENABLE = false;","title":"variable ENABLE"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-formation_mode","text":"bool formation_mode = false;","title":"variable formation_mode"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-biased_formation_mode","text":"bool biased_formation_mode = false;","title":"variable biased_formation_mode"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-node_frequency","text":"float node_frequency;","title":"variable node_frequency"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-path_folder","text":"std::string path_folder; Updated on 2022-05-30 at 18:35:15 +0000","title":"variable path_folder"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classFormation/","text":"Formation Contains Formation variables for cooperative path following. #include <Formation.h> Public Functions Name Formation () Public Attributes Name int id vehicle id double x x value to change xi and xe in section double y y value to change yi and ye in section Public Functions Documentation function Formation inline Formation() Public Attributes Documentation variable id int id; vehicle id variable x double x; x value to change xi and xe in section variable y double y; y value to change yi and ye in section Updated on 2022-05-30 at 18:35:15 +0000","title":"Formation"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classFormation/#formation","text":"Contains Formation variables for cooperative path following. #include <Formation.h>","title":"Formation"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classFormation/#public-functions","text":"Name Formation ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classFormation/#public-attributes","text":"Name int id vehicle id double x x value to change xi and xe in section double y y value to change yi and ye in section","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classFormation/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classFormation/#function-formation","text":"inline Formation()","title":"function Formation"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classFormation/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classFormation/#variable-id","text":"int id; vehicle id","title":"variable id"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classFormation/#variable-x","text":"double x; x value to change xi and xe in section","title":"variable x"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classFormation/#variable-y","text":"double y; y value to change yi and ye in section Updated on 2022-05-30 at 18:35:15 +0000","title":"variable y"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/","text":"Section Contains Section variables for path followin algorithms. More... #include <Section.h> Public Functions Name Section () Public Attributes Name int type 1= WP; 2=Line; 3=Arc; 4=Depth double xi initial x of section double yi initial y of section double xc x of center of arc (-1 if line or point) double yc y of center of arc (-1 if line or point) double xe ending x of section double ye ending y of section float velocity velocity desired of the vehicle int adirection -1 if vehicle is turning clockwise, -1 otherwise (only applied to arcs) float radius adius of the arc float heading yaw of the vehicle float time only used for point, depth and alt, time to use the reference int nVehicle number of the vehicle (possible id) double gamma_s Starting gamma (not normalized) double gamma_e Ending gamma (not normalized) float depth Depth of the section. Detailed Description class Section; Contains Section variables for path followin algorithms. Note : nVehicle is always -1, probably not being used Public Functions Documentation function Section inline Section() Public Attributes Documentation variable type int type; 1= WP; 2=Line; 3=Arc; 4=Depth variable xi double xi; initial x of section variable yi double yi; initial y of section variable xc double xc; x of center of arc (-1 if line or point) variable yc double yc; y of center of arc (-1 if line or point) variable xe double xe; ending x of section variable ye double ye; ending y of section variable velocity float velocity; velocity desired of the vehicle variable adirection int adirection; -1 if vehicle is turning clockwise, -1 otherwise (only applied to arcs) variable radius float radius; adius of the arc variable heading float heading; yaw of the vehicle variable time float time; only used for point, depth and alt, time to use the reference variable nVehicle int nVehicle; number of the vehicle (possible id) variable gamma_s double gamma_s; Starting gamma (not normalized) variable gamma_e double gamma_e; Ending gamma (not normalized) variable depth float depth; Depth of the section. Updated on 2022-05-30 at 18:35:15 +0000","title":"Section"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#section","text":"Contains Section variables for path followin algorithms. More... #include <Section.h>","title":"Section"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#public-functions","text":"Name Section ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#public-attributes","text":"Name int type 1= WP; 2=Line; 3=Arc; 4=Depth double xi initial x of section double yi initial y of section double xc x of center of arc (-1 if line or point) double yc y of center of arc (-1 if line or point) double xe ending x of section double ye ending y of section float velocity velocity desired of the vehicle int adirection -1 if vehicle is turning clockwise, -1 otherwise (only applied to arcs) float radius adius of the arc float heading yaw of the vehicle float time only used for point, depth and alt, time to use the reference int nVehicle number of the vehicle (possible id) double gamma_s Starting gamma (not normalized) double gamma_e Ending gamma (not normalized) float depth Depth of the section.","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#detailed-description","text":"class Section; Contains Section variables for path followin algorithms. Note : nVehicle is always -1, probably not being used","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#function-section","text":"inline Section()","title":"function Section"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#variable-type","text":"int type; 1= WP; 2=Line; 3=Arc; 4=Depth","title":"variable type"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#variable-xi","text":"double xi; initial x of section","title":"variable xi"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#variable-yi","text":"double yi; initial y of section","title":"variable yi"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#variable-xc","text":"double xc; x of center of arc (-1 if line or point)","title":"variable xc"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#variable-yc","text":"double yc; y of center of arc (-1 if line or point)","title":"variable yc"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#variable-xe","text":"double xe; ending x of section","title":"variable xe"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#variable-ye","text":"double ye; ending y of section","title":"variable ye"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#variable-velocity","text":"float velocity; velocity desired of the vehicle","title":"variable velocity"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#variable-adirection","text":"int adirection; -1 if vehicle is turning clockwise, -1 otherwise (only applied to arcs)","title":"variable adirection"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#variable-radius","text":"float radius; adius of the arc","title":"variable radius"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#variable-heading","text":"float heading; yaw of the vehicle","title":"variable heading"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#variable-time","text":"float time; only used for point, depth and alt, time to use the reference","title":"variable time"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#variable-nvehicle","text":"int nVehicle; number of the vehicle (possible id)","title":"variable nVehicle"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#variable-gamma_s","text":"double gamma_s; Starting gamma (not normalized)","title":"variable gamma_s"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#variable-gamma_e","text":"double gamma_e; Ending gamma (not normalized)","title":"variable gamma_e"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#variable-depth","text":"float depth; Depth of the section. Updated on 2022-05-30 at 18:35:15 +0000","title":"variable depth"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:15 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:15 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:15 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:15 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Namespaces/","text":"Namespaces Updated on 2022-05-30 at 18:35:15 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Namespaces/#namespaces","text":"Updated on 2022-05-30 at 18:35:15 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/","text":"Classes namespace console class CallbackEcho class ERROR_Struct class HTTP_Handler class ROSTopicException class ROSTopicIOException class ThreadedHTTPServer class Topic_Struct class subscriber_Thread namespace setup namespace waypoint::srv Updated on 2022-05-30 at 18:35:06 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/#classes","text":"namespace console class CallbackEcho class ERROR_Struct class HTTP_Handler class ROSTopicException class ROSTopicIOException class ThreadedHTTPServer class Topic_Struct class subscriber_Thread namespace setup namespace waypoint::srv Updated on 2022-05-30 at 18:35:06 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/","text":"console::CallbackEcho More... Inherits from object Public Functions Name def init (self self, topic topic) def callback (self self, data data, topic topic, current_time current_time =None) Public Attributes Name topic count prefix suffix done str_fn first last_msg_eval last_topic Detailed Description class console::CallbackEcho; Callback instance that can print callback data in a variety of formats. Used for all variants of rostopic echo Public Functions Documentation function init def __init__( self self, topic topic ) :param plot: if ``True``, echo in plotting-friendly format, ``bool`` :param filter_fn: function that evaluates to ``True`` if message is to be echo'd, ``fn(topic, msg)`` :param echo_all_topics: (optional) if ``True``, echo all messages in bag, ``bool`` :param offset_time: (optional) if ``True``, display time as offset from current time, ``bool`` :param count: number of messages to echo, ``None`` for infinite, ``int`` :param field_filter_fn: filter the fields that are strified for Messages, ``fn(Message)->iter(str)`` function callback def callback( self self, data data, topic topic, current_time current_time =None ) Callback to pass to rospy.Subscriber or to call manually. rospy.Subscriber constructor must also pass in the topic name as an additional arg :param data: Message :param topic: topic name, ``str`` :param current_time: override calculation of current time, :class:`genpy.Time` Public Attributes Documentation variable topic topic; variable count count; variable prefix prefix; variable suffix suffix; variable done done; variable str_fn str_fn; variable first first; variable last_msg_eval last_msg_eval; variable last_topic last_topic; Updated on 2022-05-30 at 18:35:06 +0000","title":"console::CallbackEcho"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#consolecallbackecho","text":"More... Inherits from object","title":"console::CallbackEcho"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#public-functions","text":"Name def init (self self, topic topic) def callback (self self, data data, topic topic, current_time current_time =None)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#public-attributes","text":"Name topic count prefix suffix done str_fn first last_msg_eval last_topic","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#detailed-description","text":"class console::CallbackEcho; Callback instance that can print callback data in a variety of formats. Used for all variants of rostopic echo","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#function-init","text":"def __init__( self self, topic topic ) :param plot: if ``True``, echo in plotting-friendly format, ``bool`` :param filter_fn: function that evaluates to ``True`` if message is to be echo'd, ``fn(topic, msg)`` :param echo_all_topics: (optional) if ``True``, echo all messages in bag, ``bool`` :param offset_time: (optional) if ``True``, display time as offset from current time, ``bool`` :param count: number of messages to echo, ``None`` for infinite, ``int`` :param field_filter_fn: filter the fields that are strified for Messages, ``fn(Message)->iter(str)``","title":"function init"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#function-callback","text":"def callback( self self, data data, topic topic, current_time current_time =None ) Callback to pass to rospy.Subscriber or to call manually. rospy.Subscriber constructor must also pass in the topic name as an additional arg :param data: Message :param topic: topic name, ``str`` :param current_time: override calculation of current time, :class:`genpy.Time`","title":"function callback"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#variable-topic","text":"topic;","title":"variable topic"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#variable-count","text":"count;","title":"variable count"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#variable-prefix","text":"prefix;","title":"variable prefix"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#variable-suffix","text":"suffix;","title":"variable suffix"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#variable-done","text":"done;","title":"variable done"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#variable-str_fn","text":"str_fn;","title":"variable str_fn"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#variable-first","text":"first;","title":"variable first"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#variable-last_msg_eval","text":"last_msg_eval;","title":"variable last_msg_eval"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#variable-last_topic","text":"last_topic; Updated on 2022-05-30 at 18:35:06 +0000","title":"variable last_topic"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ERROR__Struct/","text":"console::ERROR_Struct Inherits from object Public Functions Name def init (self self) def clear (self self) def clearitem (self self, i i) def str (self self) def add_error (self self, topic_name topic_name, data data) Public Attributes Name node_name line msg time time_rcv Public Functions Documentation function init def __init__( self self ) function clear def __clear__( self self ) function clearitem def __clearitem__( self self, i i ) function str def __str__( self self ) function add_error def add_error( self self, topic_name topic_name, data data ) Public Attributes Documentation variable node_name node_name; variable line line; variable msg msg; variable time time; variable time_rcv time_rcv; Updated on 2022-05-30 at 18:35:06 +0000","title":"console::ERROR_Struct"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ERROR__Struct/#consoleerror_struct","text":"Inherits from object","title":"console::ERROR_Struct"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ERROR__Struct/#public-functions","text":"Name def init (self self) def clear (self self) def clearitem (self self, i i) def str (self self) def add_error (self self, topic_name topic_name, data data)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ERROR__Struct/#public-attributes","text":"Name node_name line msg time time_rcv","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ERROR__Struct/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ERROR__Struct/#function-init","text":"def __init__( self self )","title":"function init"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ERROR__Struct/#function-clear","text":"def __clear__( self self )","title":"function clear"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ERROR__Struct/#function-clearitem","text":"def __clearitem__( self self, i i )","title":"function clearitem"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ERROR__Struct/#function-str","text":"def __str__( self self )","title":"function str"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ERROR__Struct/#function-add_error","text":"def add_error( self self, topic_name topic_name, data data )","title":"function add_error"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ERROR__Struct/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ERROR__Struct/#variable-node_name","text":"node_name;","title":"variable node_name"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ERROR__Struct/#variable-line","text":"line;","title":"variable line"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ERROR__Struct/#variable-msg","text":"msg;","title":"variable msg"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ERROR__Struct/#variable-time","text":"time;","title":"variable time"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ERROR__Struct/#variable-time_rcv","text":"time_rcv; Updated on 2022-05-30 at 18:35:06 +0000","title":"variable time_rcv"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1HTTP__Handler/","text":"console::HTTP_Handler Inherits from BaseHTTPRequestHandler Public Functions Name def do_GET (self self) def do_POST (self self) def do_HEAD (self self) def address_string (self self) def log_request (self self, inputs inputs) Public Functions Documentation function do_GET def do_GET( self self ) function do_POST def do_POST( self self ) function do_HEAD def do_HEAD( self self ) function address_string def address_string( self self ) function log_request def log_request( self self, inputs inputs ) Updated on 2022-05-30 at 18:35:06 +0000","title":"console::HTTP_Handler"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1HTTP__Handler/#consolehttp_handler","text":"Inherits from BaseHTTPRequestHandler","title":"console::HTTP_Handler"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1HTTP__Handler/#public-functions","text":"Name def do_GET (self self) def do_POST (self self) def do_HEAD (self self) def address_string (self self) def log_request (self self, inputs inputs)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1HTTP__Handler/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1HTTP__Handler/#function-do_get","text":"def do_GET( self self )","title":"function do_GET"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1HTTP__Handler/#function-do_post","text":"def do_POST( self self )","title":"function do_POST"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1HTTP__Handler/#function-do_head","text":"def do_HEAD( self self )","title":"function do_HEAD"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1HTTP__Handler/#function-address_string","text":"def address_string( self self )","title":"function address_string"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1HTTP__Handler/#function-log_request","text":"def log_request( self self, inputs inputs ) Updated on 2022-05-30 at 18:35:06 +0000","title":"function log_request"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ROSTopicException/","text":"console::ROSTopicException More... Inherits from Exception Inherited by console.ROSTopicIOException Detailed Description class console::ROSTopicException; Base exception class of rostopic-related errors Updated on 2022-05-30 at 18:35:06 +0000","title":"console::ROSTopicException"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ROSTopicException/#consolerostopicexception","text":"More... Inherits from Exception Inherited by console.ROSTopicIOException","title":"console::ROSTopicException"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ROSTopicException/#detailed-description","text":"class console::ROSTopicException; Base exception class of rostopic-related errors Updated on 2022-05-30 at 18:35:06 +0000","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ROSTopicIOException/","text":"console::ROSTopicIOException More... Inherits from console.ROSTopicException , Exception Detailed Description class console::ROSTopicIOException; rostopic errors related to network I/O failures Updated on 2022-05-30 at 18:35:06 +0000","title":"console::ROSTopicIOException"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ROSTopicIOException/#consolerostopicioexception","text":"More... Inherits from console.ROSTopicException , Exception","title":"console::ROSTopicIOException"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ROSTopicIOException/#detailed-description","text":"class console::ROSTopicIOException; rostopic errors related to network I/O failures Updated on 2022-05-30 at 18:35:06 +0000","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ThreadedHTTPServer/","text":"console::ThreadedHTTPServer More... Inherits from ThreadingMixIn, HTTPServer Detailed Description class console::ThreadedHTTPServer; Handle requests in a separate thread. Updated on 2022-05-30 at 18:35:06 +0000","title":"console::ThreadedHTTPServer"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ThreadedHTTPServer/#consolethreadedhttpserver","text":"More... Inherits from ThreadingMixIn, HTTPServer","title":"console::ThreadedHTTPServer"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ThreadedHTTPServer/#detailed-description","text":"class console::ThreadedHTTPServer; Handle requests in a separate thread. Updated on 2022-05-30 at 18:35:06 +0000","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1Topic__Struct/","text":"console::Topic_Struct Inherits from object Public Functions Name def init (self self) def str (self self) def add_value (self self, topic_name topic_name, data data) def del_value (self self, topic_name topic_name) def data_topic (self self, topic_name topic_name) def count (self self, topic_name topic_name) def str_list (self self) Public Attributes Name time_rcv topics topics_data Public Functions Documentation function init def __init__( self self ) function str def __str__( self self ) function add_value def add_value( self self, topic_name topic_name, data data ) function del_value def del_value( self self, topic_name topic_name ) function data_topic def data_topic( self self, topic_name topic_name ) function count def count( self self, topic_name topic_name ) function str_list def str_list( self self ) Public Attributes Documentation variable time_rcv time_rcv; variable topics topics; variable topics_data topics_data; Updated on 2022-05-30 at 18:35:06 +0000","title":"console::Topic_Struct"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1Topic__Struct/#consoletopic_struct","text":"Inherits from object","title":"console::Topic_Struct"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1Topic__Struct/#public-functions","text":"Name def init (self self) def str (self self) def add_value (self self, topic_name topic_name, data data) def del_value (self self, topic_name topic_name) def data_topic (self self, topic_name topic_name) def count (self self, topic_name topic_name) def str_list (self self)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1Topic__Struct/#public-attributes","text":"Name time_rcv topics topics_data","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1Topic__Struct/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1Topic__Struct/#function-init","text":"def __init__( self self )","title":"function init"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1Topic__Struct/#function-str","text":"def __str__( self self )","title":"function str"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1Topic__Struct/#function-add_value","text":"def add_value( self self, topic_name topic_name, data data )","title":"function add_value"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1Topic__Struct/#function-del_value","text":"def del_value( self self, topic_name topic_name )","title":"function del_value"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1Topic__Struct/#function-data_topic","text":"def data_topic( self self, topic_name topic_name )","title":"function data_topic"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1Topic__Struct/#function-count","text":"def count( self self, topic_name topic_name )","title":"function count"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1Topic__Struct/#function-str_list","text":"def str_list( self self )","title":"function str_list"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1Topic__Struct/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1Topic__Struct/#variable-time_rcv","text":"time_rcv;","title":"variable time_rcv"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1Topic__Struct/#variable-topics","text":"topics;","title":"variable topics"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1Topic__Struct/#variable-topics_data","text":"topics_data; Updated on 2022-05-30 at 18:35:06 +0000","title":"variable topics_data"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1subscriber__Thread/","text":"console::subscriber_Thread Inherits from Thread Public Functions Name def init (self self, topic topic) def run (self self) Public Attributes Name topic callback_echo msg_eval Public Functions Documentation function init def __init__( self self, topic topic ) function run def run( self self ) Public Attributes Documentation variable topic topic; variable callback_echo callback_echo; variable msg_eval msg_eval; Updated on 2022-05-30 at 18:35:06 +0000","title":"console::subscriber_Thread"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1subscriber__Thread/#consolesubscriber_thread","text":"Inherits from Thread","title":"console::subscriber_Thread"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1subscriber__Thread/#public-functions","text":"Name def init (self self, topic topic) def run (self self)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1subscriber__Thread/#public-attributes","text":"Name topic callback_echo msg_eval","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1subscriber__Thread/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1subscriber__Thread/#function-init","text":"def __init__( self self, topic topic )","title":"function init"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1subscriber__Thread/#function-run","text":"def run( self self )","title":"function run"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1subscriber__Thread/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1subscriber__Thread/#variable-topic","text":"topic;","title":"variable topic"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1subscriber__Thread/#variable-callback_echo","text":"callback_echo;","title":"variable callback_echo"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1subscriber__Thread/#variable-msg_eval","text":"msg_eval; Updated on 2022-05-30 at 18:35:06 +0000","title":"variable msg_eval"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:06 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:06 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:06 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:06 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/","text":"Namespaces namespace console namespace setup namespace waypoint::srv Updated on 2022-05-30 at 18:35:06 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/#namespaces","text":"namespace console namespace setup namespace waypoint::srv Updated on 2022-05-30 at 18:35:06 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/","text":"console Classes Name class console::CallbackEcho class console::ERROR_Struct class console::HTTP_Handler class console::ROSTopicException class console::ROSTopicIOException class console::subscriber_Thread class console::ThreadedHTTPServer class console::Topic_Struct Functions Name def get_topic_class (topic topic, blocking blocking =False) def get_topic_type (topic topic, blocking blocking =False) def msgevalgen (pattern pattern) def ros2xml (msg msg, name name, depth depth =0) def moos2xml (msg msg, name name, time time, depth depth =0) def create_publisher (topic_name topic_name, topic_type topic_type) def publish_message (pub pub, msg_class msg_class, pub_args pub_args) def cmd_set_topic (args args) def getfiles (dirpath dirpath) def populenv (self self) def signal_handler (signal signal, frame frame) Attributes Name string NAME string MISSION_PATH string pages_folder int NFILE ALL_TOPICS SUBSCRIBED_TOPICS UNKNOWN_TOPICS ALL_ERRORs int g_list_topic_thrsh int g_list_topic_stamp SIGNALS_TO_NAMES_DICT argv anonymous True disable_rosout disable_rostime server_port ROOT_NAMESPACE command server Functions Documentation function get_topic_class def get_topic_class( topic topic, blocking blocking =False ) Get the topic message class :returns: message class for topic, real topic name, and function for evaluating message objects into the subtopic (or ``None``). ``(Message, str, str)`` :raises: :exc:`ROSTopicException` If topic type cannot be determined or loaded function get_topic_type def get_topic_type( topic topic, blocking blocking =False ) Get the topic type. :param topic: topic name, ``str`` :param blocking: (default False) block until topic becomes available, ``bool`` :returns: topic type, real topic name and fn to evaluate the message instance if the topic points to a field within a topic, e.g. /rosout/msg. fn is None otherwise. ``(str, str, fn)`` :raises: :exc:`ROSTopicException` If master cannot be contacted function msgevalgen def msgevalgen( pattern pattern ) Generates a function that returns the relevant field (aka 'subtopic') of a Message object :param pattern: subtopic, e.g. /x. Must have a leading '/' if specified, ``str`` :returns: function that converts a message into the desired value, ``fn(Message) -> value`` function ros2xml def ros2xml( msg msg, name name, depth depth =0 ) function moos2xml def moos2xml( msg msg, name name, time time, depth depth =0 ) function create_publisher def create_publisher( topic_name topic_name, topic_type topic_type ) Create rospy.Publisher instance from the string topic name and type. This is a powerful method as it allows creation of rospy.Publisher and Message instances using the topic and type names. This enables more dynamic publishing from Python programs. :param topic_name: name of topic, ``str`` :param topic_type: name of topic type, ``str`` :param latch: latching topic, ``bool`` :returns: topic :class:`rospy.Publisher`, :class:`Message` class function publish_message def publish_message( pub pub, msg_class msg_class, pub_args pub_args ) Create new instance of msg_class, populate with pub_args, and publish. This may print output to screen. :param pub: :class:`rospy.Publisher` instance for topic :param msg_class: Message type, ``Class`` :param pub_args: Arguments to initialize message that is published, ``[val]`` function cmd_set_topic def cmd_set_topic( args args ) function getfiles def getfiles( dirpath dirpath ) function populenv def populenv( self self ) function signal_handler def signal_handler( signal signal, frame frame ) Attributes Documentation variable NAME string NAME = 'Console'; variable MISSION_PATH string MISSION_PATH = \"/home/cog/cog-sw/Missions_FOLDER\"; variable pages_folder string pages_folder = \"\"; variable NFILE int NFILE = 0; variable ALL_TOPICS ALL_TOPICS = Topic_Struct(); variable SUBSCRIBED_TOPICS SUBSCRIBED_TOPICS = Topic_Struct(); variable UNKNOWN_TOPICS UNKNOWN_TOPICS = Topic_Struct(); variable ALL_ERRORs ALL_ERRORs = ERROR_Struct(); variable g_list_topic_thrsh int g_list_topic_thrsh = 30; variable g_list_topic_stamp int g_list_topic_stamp = 0; variable SIGNALS_TO_NAMES_DICT SIGNALS_TO_NAMES_DICT = dict((getattr(signal, n), n) \\ for n in dir(signal) if n.startswith('SIG') and '_' not in n ); variable argv argv = sys.argv; variable anonymous anonymous; variable True True; variable disable_rosout disable_rosout; variable disable_rostime disable_rostime; variable server_port server_port = rospy.get_param('~PORT',7080); variable ROOT_NAMESPACE ROOT_NAMESPACE = rospy.get_param('~ROOT_NAMESPACE',True); variable command command = argv[1]; variable server server = ThreadedHTTPServer(('', server_port), HTTP_Handler); Updated on 2022-05-30 at 18:35:06 +0000","title":"console"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#console","text":"","title":"console"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#classes","text":"Name class console::CallbackEcho class console::ERROR_Struct class console::HTTP_Handler class console::ROSTopicException class console::ROSTopicIOException class console::subscriber_Thread class console::ThreadedHTTPServer class console::Topic_Struct","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#functions","text":"Name def get_topic_class (topic topic, blocking blocking =False) def get_topic_type (topic topic, blocking blocking =False) def msgevalgen (pattern pattern) def ros2xml (msg msg, name name, depth depth =0) def moos2xml (msg msg, name name, time time, depth depth =0) def create_publisher (topic_name topic_name, topic_type topic_type) def publish_message (pub pub, msg_class msg_class, pub_args pub_args) def cmd_set_topic (args args) def getfiles (dirpath dirpath) def populenv (self self) def signal_handler (signal signal, frame frame)","title":"Functions"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#attributes","text":"Name string NAME string MISSION_PATH string pages_folder int NFILE ALL_TOPICS SUBSCRIBED_TOPICS UNKNOWN_TOPICS ALL_ERRORs int g_list_topic_thrsh int g_list_topic_stamp SIGNALS_TO_NAMES_DICT argv anonymous True disable_rosout disable_rostime server_port ROOT_NAMESPACE command server","title":"Attributes"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#function-get_topic_class","text":"def get_topic_class( topic topic, blocking blocking =False ) Get the topic message class :returns: message class for topic, real topic name, and function for evaluating message objects into the subtopic (or ``None``). ``(Message, str, str)`` :raises: :exc:`ROSTopicException` If topic type cannot be determined or loaded","title":"function get_topic_class"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#function-get_topic_type","text":"def get_topic_type( topic topic, blocking blocking =False ) Get the topic type. :param topic: topic name, ``str`` :param blocking: (default False) block until topic becomes available, ``bool`` :returns: topic type, real topic name and fn to evaluate the message instance if the topic points to a field within a topic, e.g. /rosout/msg. fn is None otherwise. ``(str, str, fn)`` :raises: :exc:`ROSTopicException` If master cannot be contacted","title":"function get_topic_type"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#function-msgevalgen","text":"def msgevalgen( pattern pattern ) Generates a function that returns the relevant field (aka 'subtopic') of a Message object :param pattern: subtopic, e.g. /x. Must have a leading '/' if specified, ``str`` :returns: function that converts a message into the desired value, ``fn(Message) -> value``","title":"function msgevalgen"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#function-ros2xml","text":"def ros2xml( msg msg, name name, depth depth =0 )","title":"function ros2xml"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#function-moos2xml","text":"def moos2xml( msg msg, name name, time time, depth depth =0 )","title":"function moos2xml"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#function-create_publisher","text":"def create_publisher( topic_name topic_name, topic_type topic_type ) Create rospy.Publisher instance from the string topic name and type. This is a powerful method as it allows creation of rospy.Publisher and Message instances using the topic and type names. This enables more dynamic publishing from Python programs. :param topic_name: name of topic, ``str`` :param topic_type: name of topic type, ``str`` :param latch: latching topic, ``bool`` :returns: topic :class:`rospy.Publisher`, :class:`Message` class","title":"function create_publisher"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#function-publish_message","text":"def publish_message( pub pub, msg_class msg_class, pub_args pub_args ) Create new instance of msg_class, populate with pub_args, and publish. This may print output to screen. :param pub: :class:`rospy.Publisher` instance for topic :param msg_class: Message type, ``Class`` :param pub_args: Arguments to initialize message that is published, ``[val]``","title":"function publish_message"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#function-cmd_set_topic","text":"def cmd_set_topic( args args )","title":"function cmd_set_topic"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#function-getfiles","text":"def getfiles( dirpath dirpath )","title":"function getfiles"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#function-populenv","text":"def populenv( self self )","title":"function populenv"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#function-signal_handler","text":"def signal_handler( signal signal, frame frame )","title":"function signal_handler"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-name","text":"string NAME = 'Console';","title":"variable NAME"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-mission_path","text":"string MISSION_PATH = \"/home/cog/cog-sw/Missions_FOLDER\";","title":"variable MISSION_PATH"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-pages_folder","text":"string pages_folder = \"\";","title":"variable pages_folder"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-nfile","text":"int NFILE = 0;","title":"variable NFILE"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-all_topics","text":"ALL_TOPICS = Topic_Struct();","title":"variable ALL_TOPICS"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-subscribed_topics","text":"SUBSCRIBED_TOPICS = Topic_Struct();","title":"variable SUBSCRIBED_TOPICS"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-unknown_topics","text":"UNKNOWN_TOPICS = Topic_Struct();","title":"variable UNKNOWN_TOPICS"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-all_errors","text":"ALL_ERRORs = ERROR_Struct();","title":"variable ALL_ERRORs"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-g_list_topic_thrsh","text":"int g_list_topic_thrsh = 30;","title":"variable g_list_topic_thrsh"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-g_list_topic_stamp","text":"int g_list_topic_stamp = 0;","title":"variable g_list_topic_stamp"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-signals_to_names_dict","text":"SIGNALS_TO_NAMES_DICT = dict((getattr(signal, n), n) \\ for n in dir(signal) if n.startswith('SIG') and '_' not in n );","title":"variable SIGNALS_TO_NAMES_DICT"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-argv","text":"argv = sys.argv;","title":"variable argv"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-anonymous","text":"anonymous;","title":"variable anonymous"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-true","text":"True;","title":"variable True"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-disable_rosout","text":"disable_rosout;","title":"variable disable_rosout"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-disable_rostime","text":"disable_rostime;","title":"variable disable_rostime"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-server_port","text":"server_port = rospy.get_param('~PORT',7080);","title":"variable server_port"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-root_namespace","text":"ROOT_NAMESPACE = rospy.get_param('~ROOT_NAMESPACE',True);","title":"variable ROOT_NAMESPACE"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-command","text":"command = argv[1];","title":"variable command"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-server","text":"server = ThreadedHTTPServer(('', server_port), HTTP_Handler); Updated on 2022-05-30 at 18:35:06 +0000","title":"variable server"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespacesetup/","text":"setup Updated on 2022-05-30 at 18:35:06 +0000","title":"setup"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespacesetup/#setup","text":"Updated on 2022-05-30 at 18:35:06 +0000","title":"setup"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespacewaypoint_1_1srv/","text":"waypoint::srv Updated on 2022-05-30 at 18:35:06 +0000","title":"waypoint::srv"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespacewaypoint_1_1srv/#waypointsrv","text":"Updated on 2022-05-30 at 18:35:06 +0000","title":"waypoint::srv"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Classes/","text":"Classes namespace MedusaDiagnostics MedusaDiagnostics namespace. Updated on 2022-05-30 at 18:35:07 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Classes/#classes","text":"namespace MedusaDiagnostics MedusaDiagnostics namespace. Updated on 2022-05-30 at 18:35:07 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:07 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:07 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:07 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:07 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Namespaces/","text":"Namespaces namespace MedusaDiagnostics MedusaDiagnostics namespace. Updated on 2022-05-30 at 18:35:07 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Namespaces/#namespaces","text":"namespace MedusaDiagnostics MedusaDiagnostics namespace. Updated on 2022-05-30 at 18:35:07 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Namespaces/namespaceMedusaDiagnostics/","text":"MedusaDiagnostics MedusaDiagnostics namespace. Functions Name diagnostic_msgs::DiagnosticStatus setDiagnosisMsg (const uint8_t & level, const std::string & name, const std::string & message, const std::string & hardware_id) Set the Diagnosis Msg object (DiagnosticStatus) void addKeyValue (diagnostic_msgs::DiagnosticArray * diagnostic_msg, const std::string & key_name, const std::string & value, const unsigned int & index) add key values to diagnostic message template <typename T > bool checkLowerBound (const T & value, const T & lower_bound) Check lower bound value. template <typename T > bool checkUpperBound (const T & value, const T & upper_bound) void warnLevel (diagnostic_msgs::DiagnosticArray * diagnostic_msg, const std::string & message, const unsigned int & index) Define the level as WARN and change the message in diagnostics. void errorLevel (diagnostic_msgs::DiagnosticArray * diagnostic_msg, const std::string & message, const unsigned int & index) Define the level as Error and change the message in diagnostics. Functions Documentation function setDiagnosisMsg diagnostic_msgs::DiagnosticStatus setDiagnosisMsg( const uint8_t & level, const std::string & name, const std::string & message, const std::string & hardware_id ) Set the Diagnosis Msg object (DiagnosticStatus) Parameters : level 0->OK, 1-> WARN, 2-> ERROR, 3->STALE name name of what sensor/node is being diagnosed, ex: /sensors/ + node_name message Say if it is ok or not hardware_id name of the sensor Return : diagnostic_msgs::DiagnosticStatus function addKeyValue void addKeyValue( diagnostic_msgs::DiagnosticArray * diagnostic_msg, const std::string & key_name, const std::string & value, const unsigned int & index ) add key values to diagnostic message Parameters : diagnostic_msg array(DiagnosticArray) of diagnostic_msgs key_name name of what we are diagnosing ex: Temperature, Current, Yaw value value being diagnosed, ex: from sensor index of the diagnostic_msg array function checkLowerBound template <typename T > bool checkLowerBound( const T & value, const T & lower_bound ) Check lower bound value. Parameters : value value being diagnosed, ex: received by the sensor lower_bound value of lower bound defined by the user Template Parameters : T type of the values to be compared (int, double, float) Return : true if the sensor value is lower than the lower bound false if the sensor value is bigger than the lower bound function checkUpperBound template <typename T > bool checkUpperBound( const T & value, const T & upper_bound ) Parameters : value received by the sensor upper_bound value of the upper bound defined by the user Template Parameters : T type of the values to be compared (int, double, float) Return : true if the sensor value is bigger than the upper bound false if the sensor value is lower thant the upper bound function warnLevel void warnLevel( diagnostic_msgs::DiagnosticArray * diagnostic_msg, const std::string & message, const unsigned int & index ) Define the level as WARN and change the message in diagnostics. Parameters : diagnostic_msg array(DiagnosticArray) of diagnostic_msgs message to clarify warning index of the diagnostic_msg array function errorLevel void errorLevel( diagnostic_msgs::DiagnosticArray * diagnostic_msg, const std::string & message, const unsigned int & index ) Define the level as Error and change the message in diagnostics. Parameters : diagnostic_msg array(DiagnosticArray) of diagnostic_msgs message to clarify error index of the diagnostic_msg array Updated on 2022-05-30 at 18:35:07 +0000","title":"MedusaDiagnostics"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Namespaces/namespaceMedusaDiagnostics/#medusadiagnostics","text":"MedusaDiagnostics namespace.","title":"MedusaDiagnostics"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Namespaces/namespaceMedusaDiagnostics/#functions","text":"Name diagnostic_msgs::DiagnosticStatus setDiagnosisMsg (const uint8_t & level, const std::string & name, const std::string & message, const std::string & hardware_id) Set the Diagnosis Msg object (DiagnosticStatus) void addKeyValue (diagnostic_msgs::DiagnosticArray * diagnostic_msg, const std::string & key_name, const std::string & value, const unsigned int & index) add key values to diagnostic message template <typename T > bool checkLowerBound (const T & value, const T & lower_bound) Check lower bound value. template <typename T > bool checkUpperBound (const T & value, const T & upper_bound) void warnLevel (diagnostic_msgs::DiagnosticArray * diagnostic_msg, const std::string & message, const unsigned int & index) Define the level as WARN and change the message in diagnostics. void errorLevel (diagnostic_msgs::DiagnosticArray * diagnostic_msg, const std::string & message, const unsigned int & index) Define the level as Error and change the message in diagnostics.","title":"Functions"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Namespaces/namespaceMedusaDiagnostics/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Namespaces/namespaceMedusaDiagnostics/#function-setdiagnosismsg","text":"diagnostic_msgs::DiagnosticStatus setDiagnosisMsg( const uint8_t & level, const std::string & name, const std::string & message, const std::string & hardware_id ) Set the Diagnosis Msg object (DiagnosticStatus) Parameters : level 0->OK, 1-> WARN, 2-> ERROR, 3->STALE name name of what sensor/node is being diagnosed, ex: /sensors/ + node_name message Say if it is ok or not hardware_id name of the sensor Return : diagnostic_msgs::DiagnosticStatus","title":"function setDiagnosisMsg"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Namespaces/namespaceMedusaDiagnostics/#function-addkeyvalue","text":"void addKeyValue( diagnostic_msgs::DiagnosticArray * diagnostic_msg, const std::string & key_name, const std::string & value, const unsigned int & index ) add key values to diagnostic message Parameters : diagnostic_msg array(DiagnosticArray) of diagnostic_msgs key_name name of what we are diagnosing ex: Temperature, Current, Yaw value value being diagnosed, ex: from sensor index of the diagnostic_msg array","title":"function addKeyValue"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Namespaces/namespaceMedusaDiagnostics/#function-checklowerbound","text":"template <typename T > bool checkLowerBound( const T & value, const T & lower_bound ) Check lower bound value. Parameters : value value being diagnosed, ex: received by the sensor lower_bound value of lower bound defined by the user Template Parameters : T type of the values to be compared (int, double, float) Return : true if the sensor value is lower than the lower bound false if the sensor value is bigger than the lower bound","title":"function checkLowerBound"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Namespaces/namespaceMedusaDiagnostics/#function-checkupperbound","text":"template <typename T > bool checkUpperBound( const T & value, const T & upper_bound ) Parameters : value received by the sensor upper_bound value of the upper bound defined by the user Template Parameters : T type of the values to be compared (int, double, float) Return : true if the sensor value is bigger than the upper bound false if the sensor value is lower thant the upper bound","title":"function checkUpperBound"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Namespaces/namespaceMedusaDiagnostics/#function-warnlevel","text":"void warnLevel( diagnostic_msgs::DiagnosticArray * diagnostic_msg, const std::string & message, const unsigned int & index ) Define the level as WARN and change the message in diagnostics. Parameters : diagnostic_msg array(DiagnosticArray) of diagnostic_msgs message to clarify warning index of the diagnostic_msg array","title":"function warnLevel"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Namespaces/namespaceMedusaDiagnostics/#function-errorlevel","text":"void errorLevel( diagnostic_msgs::DiagnosticArray * diagnostic_msg, const std::string & message, const unsigned int & index ) Define the level as Error and change the message in diagnostics. Parameters : diagnostic_msg array(DiagnosticArray) of diagnostic_msgs message to clarify error index of the diagnostic_msg array Updated on 2022-05-30 at 18:35:07 +0000","title":"function errorLevel"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Classes/","text":"Classes namespace MedusaGimmicks MedusaGimmicks namespace. Updated on 2022-05-30 at 18:35:07 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Classes/#classes","text":"namespace MedusaGimmicks MedusaGimmicks namespace. Updated on 2022-05-30 at 18:35:07 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:07 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:07 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:07 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:07 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/","text":"Namespaces namespace MedusaGimmicks MedusaGimmicks namespace. Updated on 2022-05-30 at 18:35:07 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/#namespaces","text":"namespace MedusaGimmicks MedusaGimmicks namespace. Updated on 2022-05-30 at 18:35:07 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/","text":"MedusaGimmicks MedusaGimmicks namespace. More... Functions Name template <typename T > T getParameters (ros::NodeHandle & _nh, std::string const & parameter_name) Get the Parameters object. template <typename T > T getParameters (ros::NodeHandle & _nh, std::string const & parameter_name, T default_value) Get the Parameters object. template <typename T > T getParameters (ros::NodeHandle & _nh, std::string const & parameter_name, T default_value, bool delete_param) Get the Parameters object. void spherical_to_cartesian (double bearing, double elevation, double range, double * out_pos_cart) Convert from spherical to cartesian coordinates. Used mainly with usbl fixes. int signVal (double v) Returns the sign of a double. double wrap2pi (double theta, const int mode) Wraps angle between [0, 2PI] or [-PI, PI]. double wrapTo2pi (double in) Wrap angle between [0, 2PI]. double angleDiff (double a, double b) Method to calculate the diference between angles correctly even if they wrap between -pi and pi. template <typename A ,typename B > void publishValue (ros::Publisher & pub, B & value) Attributes Name const double PI PI value. Detailed Description MedusaGimmicks namespace. Note : why the code of templates is here -> because linkage problems see https://stackoverflow.com/a/1353981 Functions Documentation function getParameters template <typename T > T getParameters( ros::NodeHandle & _nh, std::string const & parameter_name ) Get the Parameters object. Parameters : _nh ros nodehandle parameter_name string with paramenter name Template Parameters : T the type of data of a desired parameter Return : T parameter value Note : Option not considering default value, so the config file must have the parameter; function getParameters template <typename T > T getParameters( ros::NodeHandle & _nh, std::string const & parameter_name, T default_value ) Get the Parameters object. Parameters : _nh ros nodehandle parameter_name string with parameter name default_value default value of the parameter Template Parameters : T the type of data of a desired parameter Return : T parameter value Note : Option considering default value. Even if the parameter doesn't exist in config file it is possible to use a default value. function getParameters template <typename T > T getParameters( ros::NodeHandle & _nh, std::string const & parameter_name, T default_value, bool delete_param ) Get the Parameters object. Parameters : _nh ros nodehandle parameter_name string with parameter name default_value default value of the parameter delete_param boolean to delete or not the parameter from parameter server Template Parameters : T the type of data of a desired parameter Return : T parameter value Note : Option considering default value. Even if the parameter doesn't exist in config file it is possible to use a default value. Removes parameter from parameter server function spherical_to_cartesian void spherical_to_cartesian( double bearing, double elevation, double range, double * out_pos_cart ) Convert from spherical to cartesian coordinates. Used mainly with usbl fixes. Parameters : bearing horizontal angle between the direction of an object and another object or between it and the true north direction in degrees. elevation angle measured between the horizontal and the vehicle line of sight to the object range distance to the object out_pos_cart cartesian coordinates pointer function signVal int signVal( double v ) Returns the sign of a double. Parameters : v double value Return : int 1 if value is positive int 0 if value is 0 int -1 if value is negative function wrap2pi double wrap2pi( double theta, const int mode ) Wraps angle between [0, 2PI] or [-PI, PI]. Parameters : theta angle in radians mode 0 = Wrap from [0, 2*pi]; 1 = Wrap from [-pi, pi] Return : double wraped angle function wrapTo2pi double wrapTo2pi( double in ) Wrap angle between [0, 2PI]. Parameters : in angle in radians Return : double wraped angle function angleDiff double angleDiff( double a, double b ) Method to calculate the diference between angles correctly even if they wrap between -pi and pi. Parameters : a angle 1 in radians b angle 2 in radians Return : double function publishValue template <typename A , typename B > void publishValue( ros::Publisher & pub, B & value ) Parameters : pub publisher value value Template Parameters : A value type B publisher type Attributes Documentation variable PI const double PI = 3.14159265; PI value. Updated on 2022-05-30 at 18:35:07 +0000","title":"MedusaGimmicks"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/#medusagimmicks","text":"MedusaGimmicks namespace. More...","title":"MedusaGimmicks"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/#functions","text":"Name template <typename T > T getParameters (ros::NodeHandle & _nh, std::string const & parameter_name) Get the Parameters object. template <typename T > T getParameters (ros::NodeHandle & _nh, std::string const & parameter_name, T default_value) Get the Parameters object. template <typename T > T getParameters (ros::NodeHandle & _nh, std::string const & parameter_name, T default_value, bool delete_param) Get the Parameters object. void spherical_to_cartesian (double bearing, double elevation, double range, double * out_pos_cart) Convert from spherical to cartesian coordinates. Used mainly with usbl fixes. int signVal (double v) Returns the sign of a double. double wrap2pi (double theta, const int mode) Wraps angle between [0, 2PI] or [-PI, PI]. double wrapTo2pi (double in) Wrap angle between [0, 2PI]. double angleDiff (double a, double b) Method to calculate the diference between angles correctly even if they wrap between -pi and pi. template <typename A ,typename B > void publishValue (ros::Publisher & pub, B & value)","title":"Functions"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/#attributes","text":"Name const double PI PI value.","title":"Attributes"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/#detailed-description","text":"MedusaGimmicks namespace. Note : why the code of templates is here -> because linkage problems see https://stackoverflow.com/a/1353981","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/#function-getparameters","text":"template <typename T > T getParameters( ros::NodeHandle & _nh, std::string const & parameter_name ) Get the Parameters object. Parameters : _nh ros nodehandle parameter_name string with paramenter name Template Parameters : T the type of data of a desired parameter Return : T parameter value Note : Option not considering default value, so the config file must have the parameter;","title":"function getParameters"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/#function-getparameters_1","text":"template <typename T > T getParameters( ros::NodeHandle & _nh, std::string const & parameter_name, T default_value ) Get the Parameters object. Parameters : _nh ros nodehandle parameter_name string with parameter name default_value default value of the parameter Template Parameters : T the type of data of a desired parameter Return : T parameter value Note : Option considering default value. Even if the parameter doesn't exist in config file it is possible to use a default value.","title":"function getParameters"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/#function-getparameters_2","text":"template <typename T > T getParameters( ros::NodeHandle & _nh, std::string const & parameter_name, T default_value, bool delete_param ) Get the Parameters object. Parameters : _nh ros nodehandle parameter_name string with parameter name default_value default value of the parameter delete_param boolean to delete or not the parameter from parameter server Template Parameters : T the type of data of a desired parameter Return : T parameter value Note : Option considering default value. Even if the parameter doesn't exist in config file it is possible to use a default value. Removes parameter from parameter server","title":"function getParameters"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/#function-spherical_to_cartesian","text":"void spherical_to_cartesian( double bearing, double elevation, double range, double * out_pos_cart ) Convert from spherical to cartesian coordinates. Used mainly with usbl fixes. Parameters : bearing horizontal angle between the direction of an object and another object or between it and the true north direction in degrees. elevation angle measured between the horizontal and the vehicle line of sight to the object range distance to the object out_pos_cart cartesian coordinates pointer","title":"function spherical_to_cartesian"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/#function-signval","text":"int signVal( double v ) Returns the sign of a double. Parameters : v double value Return : int 1 if value is positive int 0 if value is 0 int -1 if value is negative","title":"function signVal"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/#function-wrap2pi","text":"double wrap2pi( double theta, const int mode ) Wraps angle between [0, 2PI] or [-PI, PI]. Parameters : theta angle in radians mode 0 = Wrap from [0, 2*pi]; 1 = Wrap from [-pi, pi] Return : double wraped angle","title":"function wrap2pi"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/#function-wrapto2pi","text":"double wrapTo2pi( double in ) Wrap angle between [0, 2PI]. Parameters : in angle in radians Return : double wraped angle","title":"function wrapTo2pi"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/#function-anglediff","text":"double angleDiff( double a, double b ) Method to calculate the diference between angles correctly even if they wrap between -pi and pi. Parameters : a angle 1 in radians b angle 2 in radians Return : double","title":"function angleDiff"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/#function-publishvalue","text":"template <typename A , typename B > void publishValue( ros::Publisher & pub, B & value ) Parameters : pub publisher value value Template Parameters : A value type B publisher type","title":"function publishValue"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/#variable-pi","text":"const double PI = 3.14159265; PI value. Updated on 2022-05-30 at 18:35:07 +0000","title":"variable PI"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/","text":"Classes namespace RemoteControllerNode class RemoteControllerNode Updated on 2022-05-30 at 18:35:10 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/#classes","text":"namespace RemoteControllerNode class RemoteControllerNode Updated on 2022-05-30 at 18:35:10 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/","text":"RemoteControllerNode::RemoteControllerNode More... Public Functions Name def init (self self) def timerCallback (self self, event event) def initializeTimer (self self) def initializeSubscribers (self self) def initializePublishers (self self) def initializeJoystick (self self) def state_callback (self self, msg msg) Public Attributes Name node_frequency h_timerActivate yaw_state_ timer state_sub surge_pub sway_pub heave_pub yaw_rate_pub yaw_pub depth_pub control_assignment Detailed Description class RemoteControllerNode::RemoteControllerNode; Remote controller ROS node class. Receives from a joystick (using pygame) the desired controls for the inner-loops and publishes these periodically (at a pre-defined frequency) to the inner-loops of the vehicle Public Functions Documentation function init def __init__( self self ) Class constructor. Initializes the ros node, loads the parameters from the ros parameter server, creates the inner-loops publishers and initializes the timer that publishes the desired inputs to the inner-loops function timerCallback def timerCallback( self self, event event ) Callback used to publish to the inner-loops the desired control inputs :param event: A timer event - unused but required by the ROS API function initializeTimer def initializeTimer( self self ) Method that starts the system timer that periodically calls a callback function initializeSubscribers def initializeSubscribers( self self ) Method that initializes the ROS subscribers (to receive the current state of the AUV) function initializePublishers def initializePublishers( self self ) Method that initializes the ROS publishers (to publish the references for the inner-loops) function initializeJoystick def initializeJoystick( self self ) Method that initializes the joystick driver (using pygame) function state_callback def state_callback( self self, msg msg ) Callback that is called when a message with the current state of the AUV is received. Currently only the yaw orientation is saved (used to switch between yaw and yaw-rate controllers) :param msg: NavigationStatus message Public Attributes Documentation variable node_frequency node_frequency; variable h_timerActivate h_timerActivate; variable yaw_state_ yaw_state_; variable timer timer; variable state_sub state_sub; variable surge_pub surge_pub; variable sway_pub sway_pub; variable heave_pub heave_pub; variable yaw_rate_pub yaw_rate_pub; variable yaw_pub yaw_pub; variable depth_pub depth_pub; variable control_assignment control_assignment; Updated on 2022-05-30 at 18:35:10 +0000","title":"RemoteControllerNode::RemoteControllerNode"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#remotecontrollernoderemotecontrollernode","text":"More...","title":"RemoteControllerNode::RemoteControllerNode"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#public-functions","text":"Name def init (self self) def timerCallback (self self, event event) def initializeTimer (self self) def initializeSubscribers (self self) def initializePublishers (self self) def initializeJoystick (self self) def state_callback (self self, msg msg)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#public-attributes","text":"Name node_frequency h_timerActivate yaw_state_ timer state_sub surge_pub sway_pub heave_pub yaw_rate_pub yaw_pub depth_pub control_assignment","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#detailed-description","text":"class RemoteControllerNode::RemoteControllerNode; Remote controller ROS node class. Receives from a joystick (using pygame) the desired controls for the inner-loops and publishes these periodically (at a pre-defined frequency) to the inner-loops of the vehicle","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#function-init","text":"def __init__( self self ) Class constructor. Initializes the ros node, loads the parameters from the ros parameter server, creates the inner-loops publishers and initializes the timer that publishes the desired inputs to the inner-loops","title":"function init"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#function-timercallback","text":"def timerCallback( self self, event event ) Callback used to publish to the inner-loops the desired control inputs :param event: A timer event - unused but required by the ROS API","title":"function timerCallback"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#function-initializetimer","text":"def initializeTimer( self self ) Method that starts the system timer that periodically calls a callback","title":"function initializeTimer"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#function-initializesubscribers","text":"def initializeSubscribers( self self ) Method that initializes the ROS subscribers (to receive the current state of the AUV)","title":"function initializeSubscribers"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#function-initializepublishers","text":"def initializePublishers( self self ) Method that initializes the ROS publishers (to publish the references for the inner-loops)","title":"function initializePublishers"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#function-initializejoystick","text":"def initializeJoystick( self self ) Method that initializes the joystick driver (using pygame)","title":"function initializeJoystick"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#function-state_callback","text":"def state_callback( self self, msg msg ) Callback that is called when a message with the current state of the AUV is received. Currently only the yaw orientation is saved (used to switch between yaw and yaw-rate controllers) :param msg: NavigationStatus message","title":"function state_callback"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#variable-node_frequency","text":"node_frequency;","title":"variable node_frequency"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#variable-h_timeractivate","text":"h_timerActivate;","title":"variable h_timerActivate"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#variable-yaw_state_","text":"yaw_state_;","title":"variable yaw_state_"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#variable-timer","text":"timer;","title":"variable timer"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#variable-state_sub","text":"state_sub;","title":"variable state_sub"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#variable-surge_pub","text":"surge_pub;","title":"variable surge_pub"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#variable-sway_pub","text":"sway_pub;","title":"variable sway_pub"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#variable-heave_pub","text":"heave_pub;","title":"variable heave_pub"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#variable-yaw_rate_pub","text":"yaw_rate_pub;","title":"variable yaw_rate_pub"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#variable-yaw_pub","text":"yaw_pub;","title":"variable yaw_pub"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#variable-depth_pub","text":"depth_pub;","title":"variable depth_pub"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#variable-control_assignment","text":"control_assignment; Updated on 2022-05-30 at 18:35:10 +0000","title":"variable control_assignment"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:10 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:10 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:10 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:10 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Namespaces/","text":"Namespaces namespace RemoteControllerNode Updated on 2022-05-30 at 18:35:10 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Namespaces/#namespaces","text":"namespace RemoteControllerNode Updated on 2022-05-30 at 18:35:10 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Namespaces/namespaceRemoteControllerNode/","text":"RemoteControllerNode More... Classes Name class RemoteControllerNode::RemoteControllerNode Functions Name def main () Detailed Description @author: Marcelo Fialho Jacinto @email: marcelo.jacinto@tecnico.ulisboa.pt @date: 25/11/2021 @licence: MIT Functions Documentation function main def main() Initialize the RemoteControllerNode and let the timer callback do all the work Updated on 2022-05-30 at 18:35:10 +0000","title":"RemoteControllerNode"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Namespaces/namespaceRemoteControllerNode/#remotecontrollernode","text":"More...","title":"RemoteControllerNode"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Namespaces/namespaceRemoteControllerNode/#classes","text":"Name class RemoteControllerNode::RemoteControllerNode","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Namespaces/namespaceRemoteControllerNode/#functions","text":"Name def main ()","title":"Functions"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Namespaces/namespaceRemoteControllerNode/#detailed-description","text":"@author: Marcelo Fialho Jacinto @email: marcelo.jacinto@tecnico.ulisboa.pt @date: 25/11/2021 @licence: MIT","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Namespaces/namespaceRemoteControllerNode/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Namespaces/namespaceRemoteControllerNode/#function-main","text":"def main() Initialize the RemoteControllerNode and let the timer callback do all the work Updated on 2022-05-30 at 18:35:10 +0000","title":"function main"},{"location":"api/markdown/medusa_base/medusa_addons/safety_feature/Classes/","text":"Classes Updated on 2022-05-30 at 18:35:10 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_addons/safety_feature/Classes/#classes","text":"Updated on 2022-05-30 at 18:35:10 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_addons/safety_feature/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:10 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_addons/safety_feature/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:10 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_addons/safety_feature/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:10 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_addons/safety_feature/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:10 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_addons/safety_feature/Namespaces/","text":"Namespaces Updated on 2022-05-30 at 18:35:10 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_addons/safety_feature/Namespaces/#namespaces","text":"Updated on 2022-05-30 at 18:35:10 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Classes/","text":"Classes namespace diagnostic_aggregator Construct a new pluginlib export class object. class StatusAnalyzer Class StatusAnalyzer derived from AnalyzerGroup. Updated on 2022-05-30 at 18:35:11 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Classes/#classes","text":"namespace diagnostic_aggregator Construct a new pluginlib export class object. class StatusAnalyzer Class StatusAnalyzer derived from AnalyzerGroup. Updated on 2022-05-30 at 18:35:11 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Classes/classdiagnostic__aggregator_1_1StatusAnalyzer/","text":"diagnostic_aggregator::StatusAnalyzer Class StatusAnalyzer derived from AnalyzerGroup. #include <StatusAnalyzer.h> Inherits from AnalyzerGroup Public Functions Name StatusAnalyzer () Construct a new Status Analyzer object. bool init (const std::string base_path, const ros::NodeHandle & n) override Initializes StatusAnalyzer from namespace. std::vector< diagnostic_msgs::DiagnosticStatusPtr > report () override Reports current state, returns vector of formatted status messages. Public Functions Documentation function StatusAnalyzer StatusAnalyzer() Construct a new Status Analyzer object. function init bool init( const std::string base_path, const ros::NodeHandle & n ) override Initializes StatusAnalyzer from namespace. Parameters : base_path : Prefix for all analyzers (ex: 'Sensors') n : NodeHandle in full namespace Return : True if initialization succeed, false if no errors function report std::vector< diagnostic_msgs::DiagnosticStatusPtr > report() override Reports current state, returns vector of formatted status messages. Return : std::vector Updated on 2022-05-30 at 18:35:11 +0000","title":"diagnostic_aggregator::StatusAnalyzer"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Classes/classdiagnostic__aggregator_1_1StatusAnalyzer/#diagnostic_aggregatorstatusanalyzer","text":"Class StatusAnalyzer derived from AnalyzerGroup. #include <StatusAnalyzer.h> Inherits from AnalyzerGroup","title":"diagnostic_aggregator::StatusAnalyzer"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Classes/classdiagnostic__aggregator_1_1StatusAnalyzer/#public-functions","text":"Name StatusAnalyzer () Construct a new Status Analyzer object. bool init (const std::string base_path, const ros::NodeHandle & n) override Initializes StatusAnalyzer from namespace. std::vector< diagnostic_msgs::DiagnosticStatusPtr > report () override Reports current state, returns vector of formatted status messages.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Classes/classdiagnostic__aggregator_1_1StatusAnalyzer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Classes/classdiagnostic__aggregator_1_1StatusAnalyzer/#function-statusanalyzer","text":"StatusAnalyzer() Construct a new Status Analyzer object.","title":"function StatusAnalyzer"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Classes/classdiagnostic__aggregator_1_1StatusAnalyzer/#function-init","text":"bool init( const std::string base_path, const ros::NodeHandle & n ) override Initializes StatusAnalyzer from namespace. Parameters : base_path : Prefix for all analyzers (ex: 'Sensors') n : NodeHandle in full namespace Return : True if initialization succeed, false if no errors","title":"function init"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Classes/classdiagnostic__aggregator_1_1StatusAnalyzer/#function-report","text":"std::vector< diagnostic_msgs::DiagnosticStatusPtr > report() override Reports current state, returns vector of formatted status messages. Return : std::vector Updated on 2022-05-30 at 18:35:11 +0000","title":"function report"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:11 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:11 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:11 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:11 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Namespaces/","text":"Namespaces namespace diagnostic_aggregator Construct a new pluginlib export class object. Updated on 2022-05-30 at 18:35:11 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Namespaces/#namespaces","text":"namespace diagnostic_aggregator Construct a new pluginlib export class object. Updated on 2022-05-30 at 18:35:11 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Namespaces/namespacediagnostic__aggregator/","text":"diagnostic_aggregator Construct a new pluginlib export class object. Classes Name class diagnostic_aggregator::StatusAnalyzer Class StatusAnalyzer derived from AnalyzerGroup. Updated on 2022-05-30 at 18:35:11 +0000","title":"diagnostic_aggregator"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Namespaces/namespacediagnostic__aggregator/#diagnostic_aggregator","text":"Construct a new pluginlib export class object.","title":"diagnostic_aggregator"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Namespaces/namespacediagnostic__aggregator/#classes","text":"Name class diagnostic_aggregator::StatusAnalyzer Class StatusAnalyzer derived from AnalyzerGroup. Updated on 2022-05-30 at 18:35:11 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/","text":"Classes namespace medusa_bringup_algorithms namespace MedusaSetup class MedusaSetup class Process class ProcessActionType class ProcessNotFound namespace medusa_bringup_ros namespace MedusaBringupVxNode class MedusaBringupVxNode namespace setup Updated on 2022-05-30 at 18:35:07 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/#classes","text":"namespace medusa_bringup_algorithms namespace MedusaSetup class MedusaSetup class Process class ProcessActionType class ProcessNotFound namespace medusa_bringup_ros namespace MedusaBringupVxNode class MedusaBringupVxNode namespace setup Updated on 2022-05-30 at 18:35:07 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/","text":"medusa_bringup_algorithms::MedusaSetup::MedusaSetup Public Functions Name def init (self self, vehicle_name vehicle_name, config_package_path config_package_path, folder folder, namespace namespace, vehicle_configuration vehicle_configuration =None) def publish_process_state (self self, event event) def callback_manage_process (self self, req req) def clean_ros_processes (self self) def create_processes (self self) def start_init_processes (self self) def start_all_processes (self self) def stop_all_processes (self self) def get_process_from_name (self self, name name) def get_dependency_process_list (self self, process process) def are_dependencies_met (self self, process process) def check_and_start_dependencies (self self, process process) def start_process (self self, p p, start_dependencies start_dependencies =False) def start_process_from_name (self self, name name, start_dependencies start_dependencies =False) def stop_process_from_name (self self, name name) def restart_process_from_name (self self, name name) def kill_process_from_name (self self, name name) def create_response (status status, message message) def stop_process (p p) def restart_process (p p) def kill_process (p p) Public Attributes Name vehicle_name config_package_path folder namespace vehicle_configuration process_list process_config process_state_publish_rate process_state_publisher manage_process_server Public Functions Documentation function init def __init__( self self, vehicle_name vehicle_name, config_package_path config_package_path, folder folder, namespace namespace, vehicle_configuration vehicle_configuration =None ) function publish_process_state def publish_process_state( self self, event event ) function callback_manage_process def callback_manage_process( self self, req req ) function clean_ros_processes def clean_ros_processes( self self ) function create_processes def create_processes( self self ) function start_init_processes def start_init_processes( self self ) function start_all_processes def start_all_processes( self self ) function stop_all_processes def stop_all_processes( self self ) function get_process_from_name def get_process_from_name( self self, name name ) function get_dependency_process_list def get_dependency_process_list( self self, process process ) function are_dependencies_met def are_dependencies_met( self self, process process ) function check_and_start_dependencies def check_and_start_dependencies( self self, process process ) function start_process def start_process( self self, p p, start_dependencies start_dependencies =False ) function start_process_from_name def start_process_from_name( self self, name name, start_dependencies start_dependencies =False ) function stop_process_from_name def stop_process_from_name( self self, name name ) function restart_process_from_name def restart_process_from_name( self self, name name ) function kill_process_from_name def kill_process_from_name( self self, name name ) function create_response static def create_response( status status, message message ) function stop_process static def stop_process( p p ) function restart_process static def restart_process( p p ) function kill_process static def kill_process( p p ) Public Attributes Documentation variable vehicle_name vehicle_name; variable config_package_path config_package_path; variable folder folder; variable namespace namespace; variable vehicle_configuration vehicle_configuration; variable process_list process_list; variable process_config process_config; variable process_state_publish_rate process_state_publish_rate; variable process_state_publisher process_state_publisher; variable manage_process_server manage_process_server; Updated on 2022-05-30 at 18:35:07 +0000","title":"medusa_bringup_algorithms::MedusaSetup::MedusaSetup"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#medusa_bringup_algorithmsmedusasetupmedusasetup","text":"","title":"medusa_bringup_algorithms::MedusaSetup::MedusaSetup"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#public-functions","text":"Name def init (self self, vehicle_name vehicle_name, config_package_path config_package_path, folder folder, namespace namespace, vehicle_configuration vehicle_configuration =None) def publish_process_state (self self, event event) def callback_manage_process (self self, req req) def clean_ros_processes (self self) def create_processes (self self) def start_init_processes (self self) def start_all_processes (self self) def stop_all_processes (self self) def get_process_from_name (self self, name name) def get_dependency_process_list (self self, process process) def are_dependencies_met (self self, process process) def check_and_start_dependencies (self self, process process) def start_process (self self, p p, start_dependencies start_dependencies =False) def start_process_from_name (self self, name name, start_dependencies start_dependencies =False) def stop_process_from_name (self self, name name) def restart_process_from_name (self self, name name) def kill_process_from_name (self self, name name) def create_response (status status, message message) def stop_process (p p) def restart_process (p p) def kill_process (p p)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#public-attributes","text":"Name vehicle_name config_package_path folder namespace vehicle_configuration process_list process_config process_state_publish_rate process_state_publisher manage_process_server","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-init","text":"def __init__( self self, vehicle_name vehicle_name, config_package_path config_package_path, folder folder, namespace namespace, vehicle_configuration vehicle_configuration =None )","title":"function init"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-publish_process_state","text":"def publish_process_state( self self, event event )","title":"function publish_process_state"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-callback_manage_process","text":"def callback_manage_process( self self, req req )","title":"function callback_manage_process"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-clean_ros_processes","text":"def clean_ros_processes( self self )","title":"function clean_ros_processes"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-create_processes","text":"def create_processes( self self )","title":"function create_processes"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-start_init_processes","text":"def start_init_processes( self self )","title":"function start_init_processes"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-start_all_processes","text":"def start_all_processes( self self )","title":"function start_all_processes"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-stop_all_processes","text":"def stop_all_processes( self self )","title":"function stop_all_processes"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-get_process_from_name","text":"def get_process_from_name( self self, name name )","title":"function get_process_from_name"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-get_dependency_process_list","text":"def get_dependency_process_list( self self, process process )","title":"function get_dependency_process_list"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-are_dependencies_met","text":"def are_dependencies_met( self self, process process )","title":"function are_dependencies_met"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-check_and_start_dependencies","text":"def check_and_start_dependencies( self self, process process )","title":"function check_and_start_dependencies"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-start_process","text":"def start_process( self self, p p, start_dependencies start_dependencies =False )","title":"function start_process"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-start_process_from_name","text":"def start_process_from_name( self self, name name, start_dependencies start_dependencies =False )","title":"function start_process_from_name"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-stop_process_from_name","text":"def stop_process_from_name( self self, name name )","title":"function stop_process_from_name"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-restart_process_from_name","text":"def restart_process_from_name( self self, name name )","title":"function restart_process_from_name"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-kill_process_from_name","text":"def kill_process_from_name( self self, name name )","title":"function kill_process_from_name"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-create_response","text":"static def create_response( status status, message message )","title":"function create_response"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-stop_process","text":"static def stop_process( p p )","title":"function stop_process"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-restart_process","text":"static def restart_process( p p )","title":"function restart_process"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-kill_process","text":"static def kill_process( p p )","title":"function kill_process"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#variable-vehicle_name","text":"vehicle_name;","title":"variable vehicle_name"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#variable-config_package_path","text":"config_package_path;","title":"variable config_package_path"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#variable-folder","text":"folder;","title":"variable folder"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#variable-namespace","text":"namespace;","title":"variable namespace"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#variable-vehicle_configuration","text":"vehicle_configuration;","title":"variable vehicle_configuration"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#variable-process_list","text":"process_list;","title":"variable process_list"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#variable-process_config","text":"process_config;","title":"variable process_config"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#variable-process_state_publish_rate","text":"process_state_publish_rate;","title":"variable process_state_publish_rate"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#variable-process_state_publisher","text":"process_state_publisher;","title":"variable process_state_publisher"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#variable-manage_process_server","text":"manage_process_server; Updated on 2022-05-30 at 18:35:07 +0000","title":"variable manage_process_server"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/","text":"medusa_bringup_algorithms::MedusaSetup::Process Public Functions Name def init (self self, name name, cmd cmd, vehicle_name vehicle_name, config_package_path config_package_path, folder folder, namespace namespace, vehicle_configuration vehicle_configuration =None, args args =None, launch_on_startup launch_on_startup =False, delay_before_start delay_before_start =0.0, dependencies dependencies =None) def start (self self) def restart (self self) def stop (self self) def kill (self self) def is_active (self self) Public Attributes Name name config_package_path cmd folder namespace vehicle_configuration args dependencies launch_on_startup delay_before_start process vehicle_name Public Functions Documentation function init def __init__( self self, name name, cmd cmd, vehicle_name vehicle_name, config_package_path config_package_path, folder folder, namespace namespace, vehicle_configuration vehicle_configuration =None, args args =None, launch_on_startup launch_on_startup =False, delay_before_start delay_before_start =0.0, dependencies dependencies =None ) function start def start( self self ) function restart def restart( self self ) function stop def stop( self self ) function kill def kill( self self ) function is_active def is_active( self self ) Public Attributes Documentation variable name name; variable config_package_path config_package_path; variable cmd cmd; variable folder folder; variable namespace namespace; variable vehicle_configuration vehicle_configuration; variable args args; variable dependencies dependencies; variable launch_on_startup launch_on_startup; variable delay_before_start delay_before_start; variable process process; variable vehicle_name vehicle_name; Updated on 2022-05-30 at 18:35:07 +0000","title":"medusa_bringup_algorithms::MedusaSetup::Process"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#medusa_bringup_algorithmsmedusasetupprocess","text":"","title":"medusa_bringup_algorithms::MedusaSetup::Process"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#public-functions","text":"Name def init (self self, name name, cmd cmd, vehicle_name vehicle_name, config_package_path config_package_path, folder folder, namespace namespace, vehicle_configuration vehicle_configuration =None, args args =None, launch_on_startup launch_on_startup =False, delay_before_start delay_before_start =0.0, dependencies dependencies =None) def start (self self) def restart (self self) def stop (self self) def kill (self self) def is_active (self self)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#public-attributes","text":"Name name config_package_path cmd folder namespace vehicle_configuration args dependencies launch_on_startup delay_before_start process vehicle_name","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#function-init","text":"def __init__( self self, name name, cmd cmd, vehicle_name vehicle_name, config_package_path config_package_path, folder folder, namespace namespace, vehicle_configuration vehicle_configuration =None, args args =None, launch_on_startup launch_on_startup =False, delay_before_start delay_before_start =0.0, dependencies dependencies =None )","title":"function init"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#function-start","text":"def start( self self )","title":"function start"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#function-restart","text":"def restart( self self )","title":"function restart"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#function-stop","text":"def stop( self self )","title":"function stop"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#function-kill","text":"def kill( self self )","title":"function kill"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#function-is_active","text":"def is_active( self self )","title":"function is_active"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#variable-name","text":"name;","title":"variable name"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#variable-config_package_path","text":"config_package_path;","title":"variable config_package_path"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#variable-cmd","text":"cmd;","title":"variable cmd"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#variable-folder","text":"folder;","title":"variable folder"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#variable-namespace","text":"namespace;","title":"variable namespace"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#variable-vehicle_configuration","text":"vehicle_configuration;","title":"variable vehicle_configuration"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#variable-args","text":"args;","title":"variable args"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#variable-dependencies","text":"dependencies;","title":"variable dependencies"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#variable-launch_on_startup","text":"launch_on_startup;","title":"variable launch_on_startup"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#variable-delay_before_start","text":"delay_before_start;","title":"variable delay_before_start"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#variable-process","text":"process;","title":"variable process"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#variable-vehicle_name","text":"vehicle_name; Updated on 2022-05-30 at 18:35:07 +0000","title":"variable vehicle_name"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1ProcessActionType/","text":"medusa_bringup_algorithms::MedusaSetup::ProcessActionType Inherits from object Public Attributes Name int START int STOP int RESTART int KILL int START_ALL int STOP_ALL Public Attributes Documentation variable START static int START = 1; variable STOP static int STOP = 2; variable RESTART static int RESTART = 3; variable KILL static int KILL = 4; variable START_ALL static int START_ALL = 5; variable STOP_ALL static int STOP_ALL = 6; Updated on 2022-05-30 at 18:35:07 +0000","title":"medusa_bringup_algorithms::MedusaSetup::ProcessActionType"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1ProcessActionType/#medusa_bringup_algorithmsmedusasetupprocessactiontype","text":"Inherits from object","title":"medusa_bringup_algorithms::MedusaSetup::ProcessActionType"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1ProcessActionType/#public-attributes","text":"Name int START int STOP int RESTART int KILL int START_ALL int STOP_ALL","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1ProcessActionType/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1ProcessActionType/#variable-start","text":"static int START = 1;","title":"variable START"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1ProcessActionType/#variable-stop","text":"static int STOP = 2;","title":"variable STOP"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1ProcessActionType/#variable-restart","text":"static int RESTART = 3;","title":"variable RESTART"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1ProcessActionType/#variable-kill","text":"static int KILL = 4;","title":"variable KILL"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1ProcessActionType/#variable-start_all","text":"static int START_ALL = 5;","title":"variable START_ALL"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1ProcessActionType/#variable-stop_all","text":"static int STOP_ALL = 6; Updated on 2022-05-30 at 18:35:07 +0000","title":"variable STOP_ALL"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1ProcessNotFound/","text":"medusa_bringup_algorithms::MedusaSetup::ProcessNotFound Inherits from Exception Updated on 2022-05-30 at 18:35:07 +0000","title":"medusa_bringup_algorithms::MedusaSetup::ProcessNotFound"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1ProcessNotFound/#medusa_bringup_algorithmsmedusasetupprocessnotfound","text":"Inherits from Exception Updated on 2022-05-30 at 18:35:07 +0000","title":"medusa_bringup_algorithms::MedusaSetup::ProcessNotFound"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__ros_1_1MedusaBringupVxNode_1_1MedusaBringupVxNode/","text":"medusa_bringup_ros::MedusaBringupVxNode::MedusaBringupVxNode Public Functions Name def init (self self) def loadParams (self self) Public Attributes Name name config_package_path folder namespace vehicle_configuration Public Functions Documentation function init def __init__( self self ) Constructor for ros node ########################################################################################### @.@ Init node ########################################################################################### function loadParams def loadParams( self self ) Public Attributes Documentation variable name name; variable config_package_path config_package_path; variable folder folder; variable namespace namespace; variable vehicle_configuration vehicle_configuration; Updated on 2022-05-30 at 18:35:07 +0000","title":"medusa_bringup_ros::MedusaBringupVxNode::MedusaBringupVxNode"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__ros_1_1MedusaBringupVxNode_1_1MedusaBringupVxNode/#medusa_bringup_rosmedusabringupvxnodemedusabringupvxnode","text":"","title":"medusa_bringup_ros::MedusaBringupVxNode::MedusaBringupVxNode"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__ros_1_1MedusaBringupVxNode_1_1MedusaBringupVxNode/#public-functions","text":"Name def init (self self) def loadParams (self self)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__ros_1_1MedusaBringupVxNode_1_1MedusaBringupVxNode/#public-attributes","text":"Name name config_package_path folder namespace vehicle_configuration","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__ros_1_1MedusaBringupVxNode_1_1MedusaBringupVxNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__ros_1_1MedusaBringupVxNode_1_1MedusaBringupVxNode/#function-init","text":"def __init__( self self ) Constructor for ros node ########################################################################################### @.@ Init node ###########################################################################################","title":"function init"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__ros_1_1MedusaBringupVxNode_1_1MedusaBringupVxNode/#function-loadparams","text":"def loadParams( self self )","title":"function loadParams"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__ros_1_1MedusaBringupVxNode_1_1MedusaBringupVxNode/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__ros_1_1MedusaBringupVxNode_1_1MedusaBringupVxNode/#variable-name","text":"name;","title":"variable name"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__ros_1_1MedusaBringupVxNode_1_1MedusaBringupVxNode/#variable-config_package_path","text":"config_package_path;","title":"variable config_package_path"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__ros_1_1MedusaBringupVxNode_1_1MedusaBringupVxNode/#variable-folder","text":"folder;","title":"variable folder"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__ros_1_1MedusaBringupVxNode_1_1MedusaBringupVxNode/#variable-namespace","text":"namespace;","title":"variable namespace"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__ros_1_1MedusaBringupVxNode_1_1MedusaBringupVxNode/#variable-vehicle_configuration","text":"vehicle_configuration; Updated on 2022-05-30 at 18:35:07 +0000","title":"variable vehicle_configuration"},{"location":"api/markdown/medusa_base/medusa_bringup/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:07 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_bringup/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:07 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_bringup/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:07 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_bringup/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:07 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/","text":"Namespaces namespace medusa_bringup_algorithms namespace MedusaSetup namespace medusa_bringup_ros namespace MedusaBringupVxNode namespace setup Updated on 2022-05-30 at 18:35:07 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/#namespaces","text":"namespace medusa_bringup_algorithms namespace MedusaSetup namespace medusa_bringup_ros namespace MedusaBringupVxNode namespace setup Updated on 2022-05-30 at 18:35:07 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__algorithms/","text":"medusa_bringup_algorithms Namespaces Name medusa_bringup_algorithms::MedusaSetup Updated on 2022-05-30 at 18:35:07 +0000","title":"medusa_bringup_algorithms"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__algorithms/#medusa_bringup_algorithms","text":"","title":"medusa_bringup_algorithms"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__algorithms/#namespaces","text":"Name medusa_bringup_algorithms::MedusaSetup Updated on 2022-05-30 at 18:35:07 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__algorithms_1_1MedusaSetup/","text":"medusa_bringup_algorithms::MedusaSetup Classes Name class medusa_bringup_algorithms::MedusaSetup::MedusaSetup class medusa_bringup_algorithms::MedusaSetup::Process class medusa_bringup_algorithms::MedusaSetup::ProcessActionType class medusa_bringup_algorithms::MedusaSetup::ProcessNotFound Functions Name def kill_rosmaster () Attributes Name float PROCESS_TIMEOUT_RESTART Functions Documentation function kill_rosmaster def kill_rosmaster() Attributes Documentation variable PROCESS_TIMEOUT_RESTART float PROCESS_TIMEOUT_RESTART = 5.0; Updated on 2022-05-30 at 18:35:07 +0000","title":"medusa_bringup_algorithms::MedusaSetup"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__algorithms_1_1MedusaSetup/#medusa_bringup_algorithmsmedusasetup","text":"","title":"medusa_bringup_algorithms::MedusaSetup"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__algorithms_1_1MedusaSetup/#classes","text":"Name class medusa_bringup_algorithms::MedusaSetup::MedusaSetup class medusa_bringup_algorithms::MedusaSetup::Process class medusa_bringup_algorithms::MedusaSetup::ProcessActionType class medusa_bringup_algorithms::MedusaSetup::ProcessNotFound","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__algorithms_1_1MedusaSetup/#functions","text":"Name def kill_rosmaster ()","title":"Functions"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__algorithms_1_1MedusaSetup/#attributes","text":"Name float PROCESS_TIMEOUT_RESTART","title":"Attributes"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__algorithms_1_1MedusaSetup/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__algorithms_1_1MedusaSetup/#function-kill_rosmaster","text":"def kill_rosmaster()","title":"function kill_rosmaster"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__algorithms_1_1MedusaSetup/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__algorithms_1_1MedusaSetup/#variable-process_timeout_restart","text":"float PROCESS_TIMEOUT_RESTART = 5.0; Updated on 2022-05-30 at 18:35:07 +0000","title":"variable PROCESS_TIMEOUT_RESTART"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__ros/","text":"medusa_bringup_ros Namespaces Name medusa_bringup_ros::MedusaBringupVxNode Updated on 2022-05-30 at 18:35:07 +0000","title":"medusa_bringup_ros"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__ros/#medusa_bringup_ros","text":"","title":"medusa_bringup_ros"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__ros/#namespaces","text":"Name medusa_bringup_ros::MedusaBringupVxNode Updated on 2022-05-30 at 18:35:07 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__ros_1_1MedusaBringupVxNode/","text":"medusa_bringup_ros::MedusaBringupVxNode More... Classes Name class medusa_bringup_ros::MedusaBringupVxNode::MedusaBringupVxNode Functions Name def main () Detailed Description Developers: DSOR Team -> @isr.ist.pt Instituto Superior Tecnico Description: Please check the documentation of this package for more info. Functions Documentation function main def main() Updated on 2022-05-30 at 18:35:07 +0000","title":"medusa_bringup_ros::MedusaBringupVxNode"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__ros_1_1MedusaBringupVxNode/#medusa_bringup_rosmedusabringupvxnode","text":"More...","title":"medusa_bringup_ros::MedusaBringupVxNode"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__ros_1_1MedusaBringupVxNode/#classes","text":"Name class medusa_bringup_ros::MedusaBringupVxNode::MedusaBringupVxNode","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__ros_1_1MedusaBringupVxNode/#functions","text":"Name def main ()","title":"Functions"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__ros_1_1MedusaBringupVxNode/#detailed-description","text":"Developers: DSOR Team -> @isr.ist.pt Instituto Superior Tecnico Description: Please check the documentation of this package for more info.","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__ros_1_1MedusaBringupVxNode/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__ros_1_1MedusaBringupVxNode/#function-main","text":"def main() Updated on 2022-05-30 at 18:35:07 +0000","title":"function main"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacesetup/","text":"setup Attributes Name d Attributes Documentation variable d d = generate_distutils_setup( packages=['medusa_bringup_algorithms', 'medusa_bringup_ros'], package_dir={'medusa_bringup_algorithms': 'src/medusa_bringup_algorithms', 'medusa_bringup_ros': 'src/medusa_bringup_ros'} ); Updated on 2022-05-30 at 18:35:07 +0000","title":"setup"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacesetup/#setup","text":"","title":"setup"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacesetup/#attributes","text":"Name d","title":"Attributes"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacesetup/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacesetup/#variable-d","text":"d = generate_distutils_setup( packages=['medusa_bringup_algorithms', 'medusa_bringup_ros'], package_dir={'medusa_bringup_algorithms': 'src/medusa_bringup_algorithms', 'medusa_bringup_ros': 'src/medusa_bringup_ros'} ); Updated on 2022-05-30 at 18:35:07 +0000","title":"variable d"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/","text":"Classes class Gnss2State class State2Gnss class UsblFix2State Updated on 2022-05-30 at 18:35:07 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/#classes","text":"class Gnss2State class State2Gnss class UsblFix2State Updated on 2022-05-30 at 18:35:07 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classGnss2State/","text":"Gnss2State Public Functions Name Gnss2State (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~Gnss2State () Public Functions Documentation function Gnss2State Gnss2State( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private ) function ~Gnss2State ~Gnss2State() Updated on 2022-05-30 at 18:35:07 +0000","title":"Gnss2State"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classGnss2State/#gnss2state","text":"","title":"Gnss2State"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classGnss2State/#public-functions","text":"Name Gnss2State (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~Gnss2State ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classGnss2State/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classGnss2State/#function-gnss2state","text":"Gnss2State( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private )","title":"function Gnss2State"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classGnss2State/#function-gnss2state_1","text":"~Gnss2State() Updated on 2022-05-30 at 18:35:07 +0000","title":"function ~Gnss2State"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classState2Gnss/","text":"State2Gnss Public Functions Name State2Gnss (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~State2Gnss () Public Functions Documentation function State2Gnss State2Gnss( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private ) function ~State2Gnss ~State2Gnss() Updated on 2022-05-30 at 18:35:07 +0000","title":"State2Gnss"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classState2Gnss/#state2gnss","text":"","title":"State2Gnss"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classState2Gnss/#public-functions","text":"Name State2Gnss (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~State2Gnss ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classState2Gnss/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classState2Gnss/#function-state2gnss","text":"State2Gnss( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private )","title":"function State2Gnss"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classState2Gnss/#function-state2gnss_1","text":"~State2Gnss() Updated on 2022-05-30 at 18:35:07 +0000","title":"function ~State2Gnss"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classUsblFix2State/","text":"UsblFix2State Public Functions Name UsblFix2State (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~UsblFix2State () Public Functions Documentation function UsblFix2State UsblFix2State( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private ) function ~UsblFix2State ~UsblFix2State() Updated on 2022-05-30 at 18:35:07 +0000","title":"UsblFix2State"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classUsblFix2State/#usblfix2state","text":"","title":"UsblFix2State"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classUsblFix2State/#public-functions","text":"Name UsblFix2State (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~UsblFix2State ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classUsblFix2State/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classUsblFix2State/#function-usblfix2state","text":"UsblFix2State( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private )","title":"function UsblFix2State"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classUsblFix2State/#function-usblfix2state_1","text":"~UsblFix2State() Updated on 2022-05-30 at 18:35:07 +0000","title":"function ~UsblFix2State"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:07 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:07 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:07 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:07 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Namespaces/","text":"Namespaces Updated on 2022-05-30 at 18:35:07 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Namespaces/#namespaces","text":"Updated on 2022-05-30 at 18:35:07 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Classes/","text":"Classes namespace data_serializer_algorithms namespace DataSerializerAlgorithm namespace data_serializer_ros namespace DataSerializerNode class DataSerializerNode namespace setup Updated on 2022-05-30 at 18:35:07 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Classes/#classes","text":"namespace data_serializer_algorithms namespace DataSerializerAlgorithm namespace data_serializer_ros namespace DataSerializerNode class DataSerializerNode namespace setup Updated on 2022-05-30 at 18:35:07 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Classes/classdata__serializer__ros_1_1DataSerializerNode_1_1DataSerializerNode/","text":"data_serializer_ros::DataSerializerNode::DataSerializerNode Public Functions Name def init (self self) def initializeSubscribers (self self) def initializePublishers (self self) def loadParams (self self) def generic_callback (self self, msg_data msg_data, channel_info channel_info) def from_modem_callback (self self, msg_data msg_data) def trigger_serialization_callback (self self, msg_data msg_data) Public Functions Documentation function init def __init__( self self ) Constructor for ros node ########################################################################################### @.@ Init node ########################################################################################### function initializeSubscribers def initializeSubscribers( self self ) function initializePublishers def initializePublishers( self self ) function loadParams def loadParams( self self ) function generic_callback def generic_callback( self self, msg_data msg_data, channel_info channel_info ) function from_modem_callback def from_modem_callback( self self, msg_data msg_data ) function trigger_serialization_callback def trigger_serialization_callback( self self, msg_data msg_data ) Updated on 2022-05-30 at 18:35:07 +0000","title":"data_serializer_ros::DataSerializerNode::DataSerializerNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Classes/classdata__serializer__ros_1_1DataSerializerNode_1_1DataSerializerNode/#data_serializer_rosdataserializernodedataserializernode","text":"","title":"data_serializer_ros::DataSerializerNode::DataSerializerNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Classes/classdata__serializer__ros_1_1DataSerializerNode_1_1DataSerializerNode/#public-functions","text":"Name def init (self self) def initializeSubscribers (self self) def initializePublishers (self self) def loadParams (self self) def generic_callback (self self, msg_data msg_data, channel_info channel_info) def from_modem_callback (self self, msg_data msg_data) def trigger_serialization_callback (self self, msg_data msg_data)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Classes/classdata__serializer__ros_1_1DataSerializerNode_1_1DataSerializerNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Classes/classdata__serializer__ros_1_1DataSerializerNode_1_1DataSerializerNode/#function-init","text":"def __init__( self self ) Constructor for ros node ########################################################################################### @.@ Init node ###########################################################################################","title":"function init"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Classes/classdata__serializer__ros_1_1DataSerializerNode_1_1DataSerializerNode/#function-initializesubscribers","text":"def initializeSubscribers( self self )","title":"function initializeSubscribers"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Classes/classdata__serializer__ros_1_1DataSerializerNode_1_1DataSerializerNode/#function-initializepublishers","text":"def initializePublishers( self self )","title":"function initializePublishers"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Classes/classdata__serializer__ros_1_1DataSerializerNode_1_1DataSerializerNode/#function-loadparams","text":"def loadParams( self self )","title":"function loadParams"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Classes/classdata__serializer__ros_1_1DataSerializerNode_1_1DataSerializerNode/#function-generic_callback","text":"def generic_callback( self self, msg_data msg_data, channel_info channel_info )","title":"function generic_callback"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Classes/classdata__serializer__ros_1_1DataSerializerNode_1_1DataSerializerNode/#function-from_modem_callback","text":"def from_modem_callback( self self, msg_data msg_data )","title":"function from_modem_callback"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Classes/classdata__serializer__ros_1_1DataSerializerNode_1_1DataSerializerNode/#function-trigger_serialization_callback","text":"def trigger_serialization_callback( self self, msg_data msg_data ) Updated on 2022-05-30 at 18:35:07 +0000","title":"function trigger_serialization_callback"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:07 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:07 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:07 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:07 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/","text":"Namespaces namespace data_serializer_algorithms namespace DataSerializerAlgorithm namespace data_serializer_ros namespace DataSerializerNode namespace setup Updated on 2022-05-30 at 18:35:07 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/#namespaces","text":"namespace data_serializer_algorithms namespace DataSerializerAlgorithm namespace data_serializer_ros namespace DataSerializerNode namespace setup Updated on 2022-05-30 at 18:35:07 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__algorithms/","text":"data_serializer_algorithms Namespaces Name data_serializer_algorithms::DataSerializerAlgorithm Updated on 2022-05-30 at 18:35:07 +0000","title":"data_serializer_algorithms"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__algorithms/#data_serializer_algorithms","text":"","title":"data_serializer_algorithms"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__algorithms/#namespaces","text":"Name data_serializer_algorithms::DataSerializerAlgorithm Updated on 2022-05-30 at 18:35:07 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__algorithms_1_1DataSerializerAlgorithm/","text":"data_serializer_algorithms::DataSerializerAlgorithm Functions Name def payload_to_bytes (bits_string bits_string) def payload_to_bits (bytes_string bytes_string) def dec_to_bin (dec_value dec_value, low low, high high, bits bits, is_int is_int =False) def bin_to_dec (bin_value bin_value, low low, high high, bits bits, is_int is_int =False) def extract_field (msg_data msg_data, field_address field_address) def add_field_to_dict (final_dict final_dict, field_address field_address, field_value field_value) Functions Documentation function payload_to_bytes def payload_to_bytes( bits_string bits_string ) function payload_to_bits def payload_to_bits( bytes_string bytes_string ) function dec_to_bin def dec_to_bin( dec_value dec_value, low low, high high, bits bits, is_int is_int =False ) function bin_to_dec def bin_to_dec( bin_value bin_value, low low, high high, bits bits, is_int is_int =False ) function extract_field def extract_field( msg_data msg_data, field_address field_address ) function add_field_to_dict def add_field_to_dict( final_dict final_dict, field_address field_address, field_value field_value ) Updated on 2022-05-30 at 18:35:07 +0000","title":"data_serializer_algorithms::DataSerializerAlgorithm"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__algorithms_1_1DataSerializerAlgorithm/#data_serializer_algorithmsdataserializeralgorithm","text":"","title":"data_serializer_algorithms::DataSerializerAlgorithm"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__algorithms_1_1DataSerializerAlgorithm/#functions","text":"Name def payload_to_bytes (bits_string bits_string) def payload_to_bits (bytes_string bytes_string) def dec_to_bin (dec_value dec_value, low low, high high, bits bits, is_int is_int =False) def bin_to_dec (bin_value bin_value, low low, high high, bits bits, is_int is_int =False) def extract_field (msg_data msg_data, field_address field_address) def add_field_to_dict (final_dict final_dict, field_address field_address, field_value field_value)","title":"Functions"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__algorithms_1_1DataSerializerAlgorithm/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__algorithms_1_1DataSerializerAlgorithm/#function-payload_to_bytes","text":"def payload_to_bytes( bits_string bits_string )","title":"function payload_to_bytes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__algorithms_1_1DataSerializerAlgorithm/#function-payload_to_bits","text":"def payload_to_bits( bytes_string bytes_string )","title":"function payload_to_bits"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__algorithms_1_1DataSerializerAlgorithm/#function-dec_to_bin","text":"def dec_to_bin( dec_value dec_value, low low, high high, bits bits, is_int is_int =False )","title":"function dec_to_bin"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__algorithms_1_1DataSerializerAlgorithm/#function-bin_to_dec","text":"def bin_to_dec( bin_value bin_value, low low, high high, bits bits, is_int is_int =False )","title":"function bin_to_dec"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__algorithms_1_1DataSerializerAlgorithm/#function-extract_field","text":"def extract_field( msg_data msg_data, field_address field_address )","title":"function extract_field"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__algorithms_1_1DataSerializerAlgorithm/#function-add_field_to_dict","text":"def add_field_to_dict( final_dict final_dict, field_address field_address, field_value field_value ) Updated on 2022-05-30 at 18:35:07 +0000","title":"function add_field_to_dict"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__ros/","text":"data_serializer_ros Namespaces Name data_serializer_ros::DataSerializerNode Updated on 2022-05-30 at 18:35:07 +0000","title":"data_serializer_ros"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__ros/#data_serializer_ros","text":"","title":"data_serializer_ros"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__ros/#namespaces","text":"Name data_serializer_ros::DataSerializerNode Updated on 2022-05-30 at 18:35:07 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__ros_1_1DataSerializerNode/","text":"data_serializer_ros::DataSerializerNode More... Classes Name class data_serializer_ros::DataSerializerNode::DataSerializerNode Functions Name def main () Detailed Description Developers: DSOR Team -> @irt.ist.pt Instituto Superior Tecnico Description: Please check the documentation of this package for more info. Functions Documentation function main def main() Updated on 2022-05-30 at 18:35:07 +0000","title":"data_serializer_ros::DataSerializerNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__ros_1_1DataSerializerNode/#data_serializer_rosdataserializernode","text":"More...","title":"data_serializer_ros::DataSerializerNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__ros_1_1DataSerializerNode/#classes","text":"Name class data_serializer_ros::DataSerializerNode::DataSerializerNode","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__ros_1_1DataSerializerNode/#functions","text":"Name def main ()","title":"Functions"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__ros_1_1DataSerializerNode/#detailed-description","text":"Developers: DSOR Team -> @irt.ist.pt Instituto Superior Tecnico Description: Please check the documentation of this package for more info.","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__ros_1_1DataSerializerNode/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__ros_1_1DataSerializerNode/#function-main","text":"def main() Updated on 2022-05-30 at 18:35:07 +0000","title":"function main"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacesetup/","text":"setup Attributes Name d Attributes Documentation variable d d = generate_distutils_setup( packages=['data_serializer_algorithms', 'data_serializer_ros'], package_dir={'data_serializer_algorithms': 'src/data_serializer_algorithms', 'data_serializer_ros': 'src/data_serializer_ros'} ); Updated on 2022-05-30 at 18:35:07 +0000","title":"setup"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacesetup/#setup","text":"","title":"setup"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacesetup/#attributes","text":"Name d","title":"Attributes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacesetup/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacesetup/#variable-d","text":"d = generate_distutils_setup( packages=['data_serializer_algorithms', 'data_serializer_ros'], package_dir={'data_serializer_algorithms': 'src/data_serializer_algorithms', 'data_serializer_ros': 'src/data_serializer_ros'} ); Updated on 2022-05-30 at 18:35:07 +0000","title":"variable d"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/","text":"Classes class DmacToMedusaNode namespace pos2simmodem class Pos2SimModem Updated on 2022-05-30 at 18:35:08 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/#classes","text":"class DmacToMedusaNode namespace pos2simmodem class Pos2SimModem Updated on 2022-05-30 at 18:35:08 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classDmacToMedusaNode/","text":"DmacToMedusaNode Public Functions Name DmacToMedusaNode (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~DmacToMedusaNode () Public Functions Documentation function DmacToMedusaNode DmacToMedusaNode( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private ) function ~DmacToMedusaNode ~DmacToMedusaNode() Updated on 2022-05-30 at 18:35:08 +0000","title":"DmacToMedusaNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classDmacToMedusaNode/#dmactomedusanode","text":"","title":"DmacToMedusaNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classDmacToMedusaNode/#public-functions","text":"Name DmacToMedusaNode (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~DmacToMedusaNode ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classDmacToMedusaNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classDmacToMedusaNode/#function-dmactomedusanode","text":"DmacToMedusaNode( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private )","title":"function DmacToMedusaNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classDmacToMedusaNode/#function-dmactomedusanode_1","text":"~DmacToMedusaNode() Updated on 2022-05-30 at 18:35:08 +0000","title":"function ~DmacToMedusaNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classpos2simmodem_1_1Pos2SimModem/","text":"pos2simmodem::Pos2SimModem More... Inherits from object Public Functions Name def init (self self) def position_callback (self self, msg msg) Public Attributes Name address sock time sub_odom Detailed Description class pos2simmodem::Pos2SimModem; Class to hold the read of Odometry messages and send position to the simulated modem. Public Functions Documentation function init def __init__( self self ) Initializing the necessary variables. function position_callback def position_callback( self self, msg msg ) Reads Odometry and sends position. Public Attributes Documentation variable address address; variable sock sock; variable time time; variable sub_odom sub_odom; Updated on 2022-05-30 at 18:35:08 +0000","title":"pos2simmodem::Pos2SimModem"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classpos2simmodem_1_1Pos2SimModem/#pos2simmodempos2simmodem","text":"More... Inherits from object","title":"pos2simmodem::Pos2SimModem"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classpos2simmodem_1_1Pos2SimModem/#public-functions","text":"Name def init (self self) def position_callback (self self, msg msg)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classpos2simmodem_1_1Pos2SimModem/#public-attributes","text":"Name address sock time sub_odom","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classpos2simmodem_1_1Pos2SimModem/#detailed-description","text":"class pos2simmodem::Pos2SimModem; Class to hold the read of Odometry messages and send position to the simulated modem.","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classpos2simmodem_1_1Pos2SimModem/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classpos2simmodem_1_1Pos2SimModem/#function-init","text":"def __init__( self self ) Initializing the necessary variables.","title":"function init"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classpos2simmodem_1_1Pos2SimModem/#function-position_callback","text":"def position_callback( self self, msg msg ) Reads Odometry and sends position.","title":"function position_callback"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classpos2simmodem_1_1Pos2SimModem/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classpos2simmodem_1_1Pos2SimModem/#variable-address","text":"address;","title":"variable address"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classpos2simmodem_1_1Pos2SimModem/#variable-sock","text":"sock;","title":"variable sock"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classpos2simmodem_1_1Pos2SimModem/#variable-time","text":"time;","title":"variable time"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classpos2simmodem_1_1Pos2SimModem/#variable-sub_odom","text":"sub_odom; Updated on 2022-05-30 at 18:35:08 +0000","title":"variable sub_odom"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:08 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:08 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:08 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:08 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Namespaces/","text":"Namespaces namespace pos2simmodem Updated on 2022-05-30 at 18:35:08 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Namespaces/#namespaces","text":"namespace pos2simmodem Updated on 2022-05-30 at 18:35:08 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Namespaces/namespacepos2simmodem/","text":"pos2simmodem Classes Name class pos2simmodem::Pos2SimModem Attributes Name node Attributes Documentation variable node node = Pos2SimModem(); Updated on 2022-05-30 at 18:35:08 +0000","title":"pos2simmodem"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Namespaces/namespacepos2simmodem/#pos2simmodem","text":"","title":"pos2simmodem"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Namespaces/namespacepos2simmodem/#classes","text":"Name class pos2simmodem::Pos2SimModem","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Namespaces/namespacepos2simmodem/#attributes","text":"Name node","title":"Attributes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Namespaces/namespacepos2simmodem/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Namespaces/namespacepos2simmodem/#variable-node","text":"node = Pos2SimModem(); Updated on 2022-05-30 at 18:35:08 +0000","title":"variable node"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/","text":"Classes class AcousticPinger class ReplierNode Updated on 2022-05-30 at 18:35:09 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/#classes","text":"class AcousticPinger class ReplierNode Updated on 2022-05-30 at 18:35:09 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/","text":"AcousticPinger Public Functions Name AcousticPinger (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~AcousticPinger () void updateClock (unsigned long int tmodem, ros::Time tros) unsigned long int getModemClockNow () void triggerSerialization () void pingNextNode () void serializerCallback (const std_msgs::String & msg) void EnableCallback (const std_msgs::Bool & msg) void RECVIMSCallback (const dmac::DMACPayload & msg) void Timer (const ros::TimerEvent & e) Public Attributes Name ros::NodeHandle nh Public Functions Documentation function AcousticPinger AcousticPinger( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private ) function ~AcousticPinger ~AcousticPinger() function updateClock void updateClock( unsigned long int tmodem, ros::Time tros ) function getModemClockNow unsigned long int getModemClockNow() function triggerSerialization void triggerSerialization() function pingNextNode void pingNextNode() function serializerCallback void serializerCallback( const std_msgs::String & msg ) function EnableCallback void EnableCallback( const std_msgs::Bool & msg ) function RECVIMSCallback void RECVIMSCallback( const dmac::DMACPayload & msg ) function Timer void Timer( const ros::TimerEvent & e ) Public Attributes Documentation variable nh ros::NodeHandle nh; Updated on 2022-05-30 at 18:35:09 +0000","title":"AcousticPinger"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/#acousticpinger","text":"","title":"AcousticPinger"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/#public-functions","text":"Name AcousticPinger (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~AcousticPinger () void updateClock (unsigned long int tmodem, ros::Time tros) unsigned long int getModemClockNow () void triggerSerialization () void pingNextNode () void serializerCallback (const std_msgs::String & msg) void EnableCallback (const std_msgs::Bool & msg) void RECVIMSCallback (const dmac::DMACPayload & msg) void Timer (const ros::TimerEvent & e)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/#public-attributes","text":"Name ros::NodeHandle nh","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/#function-acousticpinger","text":"AcousticPinger( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private )","title":"function AcousticPinger"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/#function-acousticpinger_1","text":"~AcousticPinger()","title":"function ~AcousticPinger"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/#function-updateclock","text":"void updateClock( unsigned long int tmodem, ros::Time tros )","title":"function updateClock"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/#function-getmodemclocknow","text":"unsigned long int getModemClockNow()","title":"function getModemClockNow"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/#function-triggerserialization","text":"void triggerSerialization()","title":"function triggerSerialization"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/#function-pingnextnode","text":"void pingNextNode()","title":"function pingNextNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/#function-serializercallback","text":"void serializerCallback( const std_msgs::String & msg )","title":"function serializerCallback"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/#function-enablecallback","text":"void EnableCallback( const std_msgs::Bool & msg )","title":"function EnableCallback"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/#function-recvimscallback","text":"void RECVIMSCallback( const dmac::DMACPayload & msg )","title":"function RECVIMSCallback"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/#function-timer","text":"void Timer( const ros::TimerEvent & e )","title":"function Timer"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/#variable-nh","text":"ros::NodeHandle nh; Updated on 2022-05-30 at 18:35:09 +0000","title":"variable nh"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classReplierNode/","text":"ReplierNode Public Functions Name ReplierNode (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~ReplierNode () Public Functions Documentation function ReplierNode ReplierNode( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private ) function ~ReplierNode ~ReplierNode() Updated on 2022-05-30 at 18:35:09 +0000","title":"ReplierNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classReplierNode/#repliernode","text":"","title":"ReplierNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classReplierNode/#public-functions","text":"Name ReplierNode (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~ReplierNode ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classReplierNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classReplierNode/#function-repliernode","text":"ReplierNode( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private )","title":"function ReplierNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classReplierNode/#function-repliernode_1","text":"~ReplierNode() Updated on 2022-05-30 at 18:35:09 +0000","title":"function ~ReplierNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:09 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:09 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:09 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:09 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Namespaces/","text":"Namespaces Updated on 2022-05-30 at 18:35:09 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Namespaces/#namespaces","text":"Updated on 2022-05-30 at 18:35:09 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/","text":"Classes namespace cpf_gamma_ros namespace CpfGammaClientNode class CpfGammaClientNode namespace CpfGammaServerNode class CpfGammaServerNode namespace setup Updated on 2022-05-30 at 18:35:07 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/#classes","text":"namespace cpf_gamma_ros namespace CpfGammaClientNode class CpfGammaClientNode namespace CpfGammaServerNode class CpfGammaServerNode namespace setup Updated on 2022-05-30 at 18:35:07 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaClientNode_1_1CpfGammaClientNode/","text":"cpf_gamma_ros::CpfGammaClientNode::CpfGammaClientNode Public Functions Name def init (self self) def initializeSubscribers (self self) def loadParams (self self) def broadcastGammaCallback (self self, msg msg) Public Attributes Name address sock node_frequency port addr Public Functions Documentation function init def __init__( self self ) Constructor for ros node ########################################################################################### @.@ Init node ########################################################################################### function initializeSubscribers def initializeSubscribers( self self ) function loadParams def loadParams( self self ) function broadcastGammaCallback def broadcastGammaCallback( self self, msg msg ) Public Attributes Documentation variable address address; variable sock sock; variable node_frequency node_frequency; variable port port; variable addr addr; Updated on 2022-05-30 at 18:35:07 +0000","title":"cpf_gamma_ros::CpfGammaClientNode::CpfGammaClientNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaClientNode_1_1CpfGammaClientNode/#cpf_gamma_roscpfgammaclientnodecpfgammaclientnode","text":"","title":"cpf_gamma_ros::CpfGammaClientNode::CpfGammaClientNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaClientNode_1_1CpfGammaClientNode/#public-functions","text":"Name def init (self self) def initializeSubscribers (self self) def loadParams (self self) def broadcastGammaCallback (self self, msg msg)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaClientNode_1_1CpfGammaClientNode/#public-attributes","text":"Name address sock node_frequency port addr","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaClientNode_1_1CpfGammaClientNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaClientNode_1_1CpfGammaClientNode/#function-init","text":"def __init__( self self ) Constructor for ros node ########################################################################################### @.@ Init node ###########################################################################################","title":"function init"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaClientNode_1_1CpfGammaClientNode/#function-initializesubscribers","text":"def initializeSubscribers( self self )","title":"function initializeSubscribers"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaClientNode_1_1CpfGammaClientNode/#function-loadparams","text":"def loadParams( self self )","title":"function loadParams"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaClientNode_1_1CpfGammaClientNode/#function-broadcastgammacallback","text":"def broadcastGammaCallback( self self, msg msg )","title":"function broadcastGammaCallback"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaClientNode_1_1CpfGammaClientNode/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaClientNode_1_1CpfGammaClientNode/#variable-address","text":"address;","title":"variable address"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaClientNode_1_1CpfGammaClientNode/#variable-sock","text":"sock;","title":"variable sock"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaClientNode_1_1CpfGammaClientNode/#variable-node_frequency","text":"node_frequency;","title":"variable node_frequency"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaClientNode_1_1CpfGammaClientNode/#variable-port","text":"port;","title":"variable port"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaClientNode_1_1CpfGammaClientNode/#variable-addr","text":"addr; Updated on 2022-05-30 at 18:35:07 +0000","title":"variable addr"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/","text":"cpf_gamma_ros::CpfGammaServerNode::CpfGammaServerNode Public Functions Name def init (self self) def initializePublishers (self self) def loadParams (self self) def serverEnable (self self) def parseData (self self, data data) def cpfGammaMessage (self self, parsed_data parsed_data) def etcpfGammaMessage (parsed_data parsed_data) def etcpfAckMessage (parsed_data parsed_data) Public Attributes Name messages_type data_populate sock pubs node_frequency id port Public Functions Documentation function init def __init__( self self ) Constructor for ros node ########################################################################################### @.@ Init node ########################################################################################### function initializePublishers def initializePublishers( self self ) function loadParams def loadParams( self self ) function serverEnable def serverEnable( self self ) function parseData def parseData( self self, data data ) function cpfGammaMessage def cpfGammaMessage( self self, parsed_data parsed_data ) function etcpfGammaMessage static def etcpfGammaMessage( parsed_data parsed_data ) function etcpfAckMessage static def etcpfAckMessage( parsed_data parsed_data ) Public Attributes Documentation variable messages_type messages_type; variable data_populate data_populate; variable sock sock; variable pubs pubs; variable node_frequency node_frequency; variable id id; variable port port; Updated on 2022-05-30 at 18:35:07 +0000","title":"cpf_gamma_ros::CpfGammaServerNode::CpfGammaServerNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#cpf_gamma_roscpfgammaservernodecpfgammaservernode","text":"","title":"cpf_gamma_ros::CpfGammaServerNode::CpfGammaServerNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#public-functions","text":"Name def init (self self) def initializePublishers (self self) def loadParams (self self) def serverEnable (self self) def parseData (self self, data data) def cpfGammaMessage (self self, parsed_data parsed_data) def etcpfGammaMessage (parsed_data parsed_data) def etcpfAckMessage (parsed_data parsed_data)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#public-attributes","text":"Name messages_type data_populate sock pubs node_frequency id port","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#function-init","text":"def __init__( self self ) Constructor for ros node ########################################################################################### @.@ Init node ###########################################################################################","title":"function init"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#function-initializepublishers","text":"def initializePublishers( self self )","title":"function initializePublishers"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#function-loadparams","text":"def loadParams( self self )","title":"function loadParams"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#function-serverenable","text":"def serverEnable( self self )","title":"function serverEnable"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#function-parsedata","text":"def parseData( self self, data data )","title":"function parseData"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#function-cpfgammamessage","text":"def cpfGammaMessage( self self, parsed_data parsed_data )","title":"function cpfGammaMessage"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#function-etcpfgammamessage","text":"static def etcpfGammaMessage( parsed_data parsed_data )","title":"function etcpfGammaMessage"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#function-etcpfackmessage","text":"static def etcpfAckMessage( parsed_data parsed_data )","title":"function etcpfAckMessage"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#variable-messages_type","text":"messages_type;","title":"variable messages_type"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#variable-data_populate","text":"data_populate;","title":"variable data_populate"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#variable-sock","text":"sock;","title":"variable sock"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#variable-pubs","text":"pubs;","title":"variable pubs"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#variable-node_frequency","text":"node_frequency;","title":"variable node_frequency"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#variable-id","text":"id;","title":"variable id"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#variable-port","text":"port; Updated on 2022-05-30 at 18:35:07 +0000","title":"variable port"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:07 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:07 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:07 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:07 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/","text":"Namespaces namespace cpf_gamma_ros namespace CpfGammaClientNode namespace CpfGammaServerNode namespace setup Updated on 2022-05-30 at 18:35:07 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/#namespaces","text":"namespace cpf_gamma_ros namespace CpfGammaClientNode namespace CpfGammaServerNode namespace setup Updated on 2022-05-30 at 18:35:07 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros/","text":"cpf_gamma_ros Namespaces Name cpf_gamma_ros::CpfGammaClientNode cpf_gamma_ros::CpfGammaServerNode Updated on 2022-05-30 at 18:35:07 +0000","title":"cpf_gamma_ros"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros/#cpf_gamma_ros","text":"","title":"cpf_gamma_ros"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros/#namespaces","text":"Name cpf_gamma_ros::CpfGammaClientNode cpf_gamma_ros::CpfGammaServerNode Updated on 2022-05-30 at 18:35:07 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros_1_1CpfGammaClientNode/","text":"cpf_gamma_ros::CpfGammaClientNode More... Classes Name class cpf_gamma_ros::CpfGammaClientNode::CpfGammaClientNode Functions Name def main () Detailed Description Developers: DSOR Team -> @isr.ist.pt Instituto Superior Tecnico Description: Please check the documentation of this package for more info. Functions Documentation function main def main() Updated on 2022-05-30 at 18:35:07 +0000","title":"cpf_gamma_ros::CpfGammaClientNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros_1_1CpfGammaClientNode/#cpf_gamma_roscpfgammaclientnode","text":"More...","title":"cpf_gamma_ros::CpfGammaClientNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros_1_1CpfGammaClientNode/#classes","text":"Name class cpf_gamma_ros::CpfGammaClientNode::CpfGammaClientNode","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros_1_1CpfGammaClientNode/#functions","text":"Name def main ()","title":"Functions"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros_1_1CpfGammaClientNode/#detailed-description","text":"Developers: DSOR Team -> @isr.ist.pt Instituto Superior Tecnico Description: Please check the documentation of this package for more info.","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros_1_1CpfGammaClientNode/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros_1_1CpfGammaClientNode/#function-main","text":"def main() Updated on 2022-05-30 at 18:35:07 +0000","title":"function main"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros_1_1CpfGammaServerNode/","text":"cpf_gamma_ros::CpfGammaServerNode More... Classes Name class cpf_gamma_ros::CpfGammaServerNode::CpfGammaServerNode Functions Name def main () Detailed Description Developers: DSOR Team -> @isr.ist.pt Instituto Superior Tecnico Description: Please check the documentation of this package for more info. Functions Documentation function main def main() Updated on 2022-05-30 at 18:35:07 +0000","title":"cpf_gamma_ros::CpfGammaServerNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros_1_1CpfGammaServerNode/#cpf_gamma_roscpfgammaservernode","text":"More...","title":"cpf_gamma_ros::CpfGammaServerNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros_1_1CpfGammaServerNode/#classes","text":"Name class cpf_gamma_ros::CpfGammaServerNode::CpfGammaServerNode","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros_1_1CpfGammaServerNode/#functions","text":"Name def main ()","title":"Functions"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros_1_1CpfGammaServerNode/#detailed-description","text":"Developers: DSOR Team -> @isr.ist.pt Instituto Superior Tecnico Description: Please check the documentation of this package for more info.","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros_1_1CpfGammaServerNode/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros_1_1CpfGammaServerNode/#function-main","text":"def main() Updated on 2022-05-30 at 18:35:07 +0000","title":"function main"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacesetup/","text":"setup Attributes Name d Attributes Documentation variable d d = generate_distutils_setup( packages=['cpf_gamma_algorithms', 'cpf_gamma_ros'], package_dir={'cpf_gamma_algorithms': 'src/cpf_gamma_algorithms', 'cpf_gamma_ros': 'src/cpf_gamma_ros'} ); Updated on 2022-05-30 at 18:35:07 +0000","title":"setup"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacesetup/#setup","text":"","title":"setup"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacesetup/#attributes","text":"Name d","title":"Attributes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacesetup/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacesetup/#variable-d","text":"d = generate_distutils_setup( packages=['cpf_gamma_algorithms', 'cpf_gamma_ros'], package_dir={'cpf_gamma_algorithms': 'src/cpf_gamma_algorithms', 'cpf_gamma_ros': 'src/cpf_gamma_ros'} ); Updated on 2022-05-30 at 18:35:07 +0000","title":"variable d"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/","text":"Classes class Innerloops Implementation of the inner loops. Computes the forces and torques (tau) to be applied on the vehicle based on desired reference values. class PID_Controller Implementation of a PID with anti windup. class RosController ROS implementation of the innerloops controllers. Based on a desired reference computes the force or torque to be applied. class Safeties Updated on 2022-05-30 at 18:35:08 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/#classes","text":"class Innerloops Implementation of the inner loops. Computes the forces and torques (tau) to be applied on the vehicle based on desired reference values. class PID_Controller Implementation of a PID with anti windup. class RosController ROS implementation of the innerloops controllers. Based on a desired reference computes the force or torque to be applied. class Safeties Updated on 2022-05-30 at 18:35:08 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classInnerloops/","text":"Innerloops Implementation of the inner loops. Computes the forces and torques (tau) to be applied on the vehicle based on desired reference values. #include <innerloops.h> Public Functions Name Innerloops (ros::NodeHandle & nh) Contructor of the innerloops class. ~Innerloops () Destructor of the innerloops class. Public Functions Documentation function Innerloops Innerloops( ros::NodeHandle & nh ) Contructor of the innerloops class. Parameters : nh ROS nodehandle to subscribe, publish and read parameters. function ~Innerloops ~Innerloops() Destructor of the innerloops class. Updated on 2022-05-30 at 18:35:08 +0000","title":"Innerloops"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classInnerloops/#innerloops","text":"Implementation of the inner loops. Computes the forces and torques (tau) to be applied on the vehicle based on desired reference values. #include <innerloops.h>","title":"Innerloops"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classInnerloops/#public-functions","text":"Name Innerloops (ros::NodeHandle & nh) Contructor of the innerloops class. ~Innerloops () Destructor of the innerloops class.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classInnerloops/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classInnerloops/#function-innerloops","text":"Innerloops( ros::NodeHandle & nh ) Contructor of the innerloops class. Parameters : nh ROS nodehandle to subscribe, publish and read parameters.","title":"function Innerloops"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classInnerloops/#function-innerloops_1","text":"~Innerloops() Destructor of the innerloops class. Updated on 2022-05-30 at 18:35:08 +0000","title":"function ~Innerloops"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/","text":"PID_Controller Implementation of a PID with anti windup. #include <pid_controller.h> Public Functions Name PID_Controller () Constructor of a pid controller with kp, ki and kd equal to 0. PID_Controller (float Kp, float Ki, float Kd, float max_error, float max_out) Constructor of a PID controller. Initially enabled. PID_Controller (float Kp, float Ki, float Kd, float max_error, float max_out, float min_error, float min_out) Constructor of a PID controller. Initially enabled. PID_Controller (float Kp, float Ki, float Kd, float Kff, float Kff_d, float Kff_lin_drag, float Kff_quad_drag, float max_error, float max_out, float min_error, float min_out) Constructor of a PID controller (without low pass filter). Initially enabled. PID_Controller (float Kp, float Ki, float Kd, float Kff, float Kff_d, float Kff_lin_drag, float Kff_quad_drag, float max_error, float max_out, float min_error, float min_out, double lpf_dt, double lpf_fc) Constructor of a PID controller (with low pass filter). Initially enabled. float computeCommand (float error_p, float ref_value, float duration, bool debug) Core function. Computes the output of the PID. void reset () Reset function. Sets the integral error term to 0. void setFFGains (const float & ff_gain, const float & ff_d_gain, const float & ff_lin_drag_gain, const float & ff_quad_drag_gain) Set the feedfoward Gains object. void setGains (const float & kp, const float & ki, const float & kd) Set the Gains object. void setLimitBounds (const float & max_out, const float & min_out) Set the Limit Bounds object. std::vector< double > getGains () const Get the Gains object. std::vector< double > getLimitBounds () const Get the Limit Bounds object. medusa_msgs::mPidDebug getDebugInfo () const Get debug info from the PID controller internal variables. Public Attributes Name bool disable Protected Attributes Name float p_gain_ float i_gain_ float d_gain_ float ff_gain_ float ff_d_gain_ float ff_lin_drag_gain_ float ff_quad_drag_gain_ float max_error_ float max_out_ float min_error_ float min_out_ float integral_ float pre_error_ float prev_ref_value_ bool has_lpf_ std::unique_ptr< LowPassFilter > lpf_ medusa_msgs::mPidDebug msg_debug_ Public Functions Documentation function PID_Controller PID_Controller() Constructor of a pid controller with kp, ki and kd equal to 0. function PID_Controller PID_Controller( float Kp, float Ki, float Kd, float max_error, float max_out ) Constructor of a PID controller. Initially enabled. Parameters : Kp Proporcional gain Ki Integral gain Kd Derivative gain max_error maximum reference error allowed max_out minimum reference error allowed function PID_Controller PID_Controller( float Kp, float Ki, float Kd, float max_error, float max_out, float min_error, float min_out ) Constructor of a PID controller. Initially enabled. Parameters : Kp Proporcional gain Ki Integral gain Kd Derivative gain max_error maximum reference error allowed max_out maximum output allowed min_error minimum refrence error allowed min_out minimum output allowed function PID_Controller PID_Controller( float Kp, float Ki, float Kd, float Kff, float Kff_d, float Kff_lin_drag, float Kff_quad_drag, float max_error, float max_out, float min_error, float min_out ) Constructor of a PID controller (without low pass filter). Initially enabled. Parameters : Kp Proporcional gain Ki Integral gain Kd Derivative gain Kff Feedforward gain Kff_d Feedforward gain (linear drag) [] Kff_dd Feedforward gain (quadratic drag) max_error maximum reference error allowed max_out maximum output allowed min_error minimum refrence error allowed min_out minimum output allowed function PID_Controller PID_Controller( float Kp, float Ki, float Kd, float Kff, float Kff_d, float Kff_lin_drag, float Kff_quad_drag, float max_error, float max_out, float min_error, float min_out, double lpf_dt, double lpf_fc ) Constructor of a PID controller (with low pass filter). Initially enabled. Parameters : Kp Proporcional gain Ki Integral gain Kd Derivative gain Kff Feedforward gain Kff_d Feedforward gain (linear drag) [] Kff_dd Feedforward gain (quadratic drag) max_error maximum reference error allowed max_out maximum output allowed min_error minimum refrence error allowed min_out minimum output allowed lpf_dt Low pass filter sampling time lpf_fc Low pass filter cutoff param function computeCommand float computeCommand( float error_p, float ref_value, float duration, bool debug ) Core function. Computes the output of the PID. Parameters : error_p Error between the reference and the estimated variable ref_value Reference value to compute the feedforward term duration Sample time debug Check if we want to generate a debugging message to later publish Return : function reset void reset() Reset function. Sets the integral error term to 0. function setFFGains void setFFGains( const float & ff_gain, const float & ff_d_gain, const float & ff_lin_drag_gain, const float & ff_quad_drag_gain ) Set the feedfoward Gains object. Parameters : ff_gain Feefoward gain of reference ff_d_gain Feedoforward gain of reference derivative ff_lin_drag_gain Feefoward gain (for linear drag) ff_quad_drag_gain Feefoward gain (for quadratic drag) function setGains void setGains( const float & kp, const float & ki, const float & kd ) Set the Gains object. Parameters : kp Proportional gain ki Integral gain kd Derivative gain function setLimitBounds void setLimitBounds( const float & max_out, const float & min_out ) Set the Limit Bounds object. Parameters : max_out maximum output allowed min_out minimum output allowed function getGains std::vector< double > getGains() const Get the Gains object. Return : std::vector const function getLimitBounds std::vector< double > getLimitBounds() const Get the Limit Bounds object. Return : std::vector const function getDebugInfo medusa_msgs::mPidDebug getDebugInfo() const Get debug info from the PID controller internal variables. Return : std::vector const Public Attributes Documentation variable disable bool disable; Protected Attributes Documentation variable p_gain_ float p_gain_; variable i_gain_ float i_gain_; variable d_gain_ float d_gain_; variable ff_gain_ float ff_gain_; variable ff_d_gain_ float ff_d_gain_; variable ff_lin_drag_gain_ float ff_lin_drag_gain_; variable ff_quad_drag_gain_ float ff_quad_drag_gain_; variable max_error_ float max_error_; variable max_out_ float max_out_; variable min_error_ float min_error_; variable min_out_ float min_out_; variable integral_ float integral_; variable pre_error_ float pre_error_; variable prev_ref_value_ float prev_ref_value_; variable has_lpf_ bool has_lpf_ {false}; variable lpf_ std::unique_ptr< LowPassFilter > lpf_; variable msg_debug_ medusa_msgs::mPidDebug msg_debug_; Updated on 2022-05-30 at 18:35:08 +0000","title":"PID_Controller"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#pid_controller","text":"Implementation of a PID with anti windup. #include <pid_controller.h>","title":"PID_Controller"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#public-functions","text":"Name PID_Controller () Constructor of a pid controller with kp, ki and kd equal to 0. PID_Controller (float Kp, float Ki, float Kd, float max_error, float max_out) Constructor of a PID controller. Initially enabled. PID_Controller (float Kp, float Ki, float Kd, float max_error, float max_out, float min_error, float min_out) Constructor of a PID controller. Initially enabled. PID_Controller (float Kp, float Ki, float Kd, float Kff, float Kff_d, float Kff_lin_drag, float Kff_quad_drag, float max_error, float max_out, float min_error, float min_out) Constructor of a PID controller (without low pass filter). Initially enabled. PID_Controller (float Kp, float Ki, float Kd, float Kff, float Kff_d, float Kff_lin_drag, float Kff_quad_drag, float max_error, float max_out, float min_error, float min_out, double lpf_dt, double lpf_fc) Constructor of a PID controller (with low pass filter). Initially enabled. float computeCommand (float error_p, float ref_value, float duration, bool debug) Core function. Computes the output of the PID. void reset () Reset function. Sets the integral error term to 0. void setFFGains (const float & ff_gain, const float & ff_d_gain, const float & ff_lin_drag_gain, const float & ff_quad_drag_gain) Set the feedfoward Gains object. void setGains (const float & kp, const float & ki, const float & kd) Set the Gains object. void setLimitBounds (const float & max_out, const float & min_out) Set the Limit Bounds object. std::vector< double > getGains () const Get the Gains object. std::vector< double > getLimitBounds () const Get the Limit Bounds object. medusa_msgs::mPidDebug getDebugInfo () const Get debug info from the PID controller internal variables.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#public-attributes","text":"Name bool disable","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#protected-attributes","text":"Name float p_gain_ float i_gain_ float d_gain_ float ff_gain_ float ff_d_gain_ float ff_lin_drag_gain_ float ff_quad_drag_gain_ float max_error_ float max_out_ float min_error_ float min_out_ float integral_ float pre_error_ float prev_ref_value_ bool has_lpf_ std::unique_ptr< LowPassFilter > lpf_ medusa_msgs::mPidDebug msg_debug_","title":"Protected Attributes"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#function-pid_controller","text":"PID_Controller() Constructor of a pid controller with kp, ki and kd equal to 0.","title":"function PID_Controller"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#function-pid_controller_1","text":"PID_Controller( float Kp, float Ki, float Kd, float max_error, float max_out ) Constructor of a PID controller. Initially enabled. Parameters : Kp Proporcional gain Ki Integral gain Kd Derivative gain max_error maximum reference error allowed max_out minimum reference error allowed","title":"function PID_Controller"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#function-pid_controller_2","text":"PID_Controller( float Kp, float Ki, float Kd, float max_error, float max_out, float min_error, float min_out ) Constructor of a PID controller. Initially enabled. Parameters : Kp Proporcional gain Ki Integral gain Kd Derivative gain max_error maximum reference error allowed max_out maximum output allowed min_error minimum refrence error allowed min_out minimum output allowed","title":"function PID_Controller"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#function-pid_controller_3","text":"PID_Controller( float Kp, float Ki, float Kd, float Kff, float Kff_d, float Kff_lin_drag, float Kff_quad_drag, float max_error, float max_out, float min_error, float min_out ) Constructor of a PID controller (without low pass filter). Initially enabled. Parameters : Kp Proporcional gain Ki Integral gain Kd Derivative gain Kff Feedforward gain Kff_d Feedforward gain (linear drag) [] Kff_dd Feedforward gain (quadratic drag) max_error maximum reference error allowed max_out maximum output allowed min_error minimum refrence error allowed min_out minimum output allowed","title":"function PID_Controller"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#function-pid_controller_4","text":"PID_Controller( float Kp, float Ki, float Kd, float Kff, float Kff_d, float Kff_lin_drag, float Kff_quad_drag, float max_error, float max_out, float min_error, float min_out, double lpf_dt, double lpf_fc ) Constructor of a PID controller (with low pass filter). Initially enabled. Parameters : Kp Proporcional gain Ki Integral gain Kd Derivative gain Kff Feedforward gain Kff_d Feedforward gain (linear drag) [] Kff_dd Feedforward gain (quadratic drag) max_error maximum reference error allowed max_out maximum output allowed min_error minimum refrence error allowed min_out minimum output allowed lpf_dt Low pass filter sampling time lpf_fc Low pass filter cutoff param","title":"function PID_Controller"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#function-computecommand","text":"float computeCommand( float error_p, float ref_value, float duration, bool debug ) Core function. Computes the output of the PID. Parameters : error_p Error between the reference and the estimated variable ref_value Reference value to compute the feedforward term duration Sample time debug Check if we want to generate a debugging message to later publish Return :","title":"function computeCommand"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#function-reset","text":"void reset() Reset function. Sets the integral error term to 0.","title":"function reset"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#function-setffgains","text":"void setFFGains( const float & ff_gain, const float & ff_d_gain, const float & ff_lin_drag_gain, const float & ff_quad_drag_gain ) Set the feedfoward Gains object. Parameters : ff_gain Feefoward gain of reference ff_d_gain Feedoforward gain of reference derivative ff_lin_drag_gain Feefoward gain (for linear drag) ff_quad_drag_gain Feefoward gain (for quadratic drag)","title":"function setFFGains"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#function-setgains","text":"void setGains( const float & kp, const float & ki, const float & kd ) Set the Gains object. Parameters : kp Proportional gain ki Integral gain kd Derivative gain","title":"function setGains"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#function-setlimitbounds","text":"void setLimitBounds( const float & max_out, const float & min_out ) Set the Limit Bounds object. Parameters : max_out maximum output allowed min_out minimum output allowed","title":"function setLimitBounds"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#function-getgains","text":"std::vector< double > getGains() const Get the Gains object. Return : std::vector const","title":"function getGains"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#function-getlimitbounds","text":"std::vector< double > getLimitBounds() const Get the Limit Bounds object. Return : std::vector const","title":"function getLimitBounds"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#function-getdebuginfo","text":"medusa_msgs::mPidDebug getDebugInfo() const Get debug info from the PID controller internal variables. Return : std::vector const","title":"function getDebugInfo"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-disable","text":"bool disable;","title":"variable disable"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-p_gain_","text":"float p_gain_;","title":"variable p_gain_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-i_gain_","text":"float i_gain_;","title":"variable i_gain_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-d_gain_","text":"float d_gain_;","title":"variable d_gain_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-ff_gain_","text":"float ff_gain_;","title":"variable ff_gain_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-ff_d_gain_","text":"float ff_d_gain_;","title":"variable ff_d_gain_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-ff_lin_drag_gain_","text":"float ff_lin_drag_gain_;","title":"variable ff_lin_drag_gain_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-ff_quad_drag_gain_","text":"float ff_quad_drag_gain_;","title":"variable ff_quad_drag_gain_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-max_error_","text":"float max_error_;","title":"variable max_error_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-max_out_","text":"float max_out_;","title":"variable max_out_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-min_error_","text":"float min_error_;","title":"variable min_error_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-min_out_","text":"float min_out_;","title":"variable min_out_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-integral_","text":"float integral_;","title":"variable integral_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-pre_error_","text":"float pre_error_;","title":"variable pre_error_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-prev_ref_value_","text":"float prev_ref_value_;","title":"variable prev_ref_value_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-has_lpf_","text":"bool has_lpf_ {false};","title":"variable has_lpf_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-lpf_","text":"std::unique_ptr< LowPassFilter > lpf_;","title":"variable lpf_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-msg_debug_","text":"medusa_msgs::mPidDebug msg_debug_; Updated on 2022-05-30 at 18:35:08 +0000","title":"variable msg_debug_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/","text":"RosController ROS implementation of the innerloops controllers. Based on a desired reference computes the force or torque to be applied. #include <ros_controller.h> Public Functions Name RosController (ros::NodeHandle & nh, std::string controller_name, std::string refCallback_topic, double * state, double * force_or_torque, double frequency) Constructor of a innerloop controller. RosController (ros::NodeHandle & nh, std::string controller_name, std::string refCallback_topic, double * state, double * state_dot, double * force_or_torque, double frequency) Constructor of a innerloop controller. virtual double computeCommand () Core function. Computes the PID output. void setCircularUnits (const bool & flag) Setter function for the circular units flag. void setPositiveOutput (const bool & flag) Set the Positive Output object. std::string getControllerName () const Get the Controller Name object. void setFFGainsPID (const float & kff, const float & kff_d, const float & kff_lin_drag, const float kff_quad_drag) Set the Feedforwar gains P I D object. void setGainsPID (const float & kp, const float & ki, const float & kd) Set the Gains P I D object. void setLimitBoundsPID (const float & max_out, const float & min_out) Protected Functions Name void refCallback (const std_msgs::Float64 & ptr) Callback function. Saturates the value if boundaries exist. void init (ros::NodeHandle & nh, std::string controller_name, std::string refCallback_topic) Initialize function. Reads the parameters, creates a pid controller if any gain is different from zero and subscribes to the relevant topic. virtual bool validRef () Check if the reference is new. Protected Attributes Name ros::Duration timeout_ref_ std::string controller_name_ double ref_value_ double max_ref_value_ double min_ref_value_ ros::Time ref_time_ ros::Time last_cmd_ bool debug_ medusa_msgs::mPidDebug debug_msg_ double * state_ptr_ double * force_or_torque_ptr_ double frequency_ bool circular_units_ bool positive_output_ PID_Controller * pid_c_ ros::Subscriber ros_sub_ ros::Publisher debug_pub_ Public Functions Documentation function RosController RosController( ros::NodeHandle & nh, std::string controller_name, std::string refCallback_topic, double * state, double * force_or_torque, double frequency ) Constructor of a innerloop controller. Parameters : nh ROS nodehandle to read parameters and subscribe to relevant topics controller_name Controller name (variable being controlled) refCallback_topic Topic name state Pointer to state variable being controlled force_or_torque Pointer to force or torque output frequency Frequency of controller sampling rate function RosController RosController( ros::NodeHandle & nh, std::string controller_name, std::string refCallback_topic, double * state, double * state_dot, double * force_or_torque, double frequency ) Constructor of a innerloop controller. Parameters : nh ROS nodehandle to read parameters and subscribe to relevant topics controller_name Controller name (variable being controlled) refCallback_topic Topic name state Pointer to state variable being controlled state_dot Pointer to the derivative of the state variable being controlled force_or_torque Pointer to force or torque output frequency Frequency of controller sampling rate function computeCommand virtual double computeCommand() Core function. Computes the PID output. Return : The force or torque that result from the PID computation function setCircularUnits inline void setCircularUnits( const bool & flag ) Setter function for the circular units flag. Parameters : flag true for controllers using angles, false otherwise function setPositiveOutput inline void setPositiveOutput( const bool & flag ) Set the Positive Output object. Parameters : flag function getControllerName inline std::string getControllerName() const Get the Controller Name object. function setFFGainsPID inline void setFFGainsPID( const float & kff, const float & kff_d, const float & kff_lin_drag, const float kff_quad_drag ) Set the Feedforwar gains P I D object. Parameters : kff Feedforward gain (quadratic) kff_d Feedforwad derivative gain kff_lin_drag Feedforward linear drag gain kff_quad_drag Feedforwad quadratic drag gain function setGainsPID inline void setGainsPID( const float & kp, const float & ki, const float & kd ) Set the Gains P I D object. Parameters : kp Proportional gain ki Integral gain kd Derivative gain function setLimitBoundsPID inline void setLimitBoundsPID( const float & max_out, const float & min_out ) Protected Functions Documentation function refCallback void refCallback( const std_msgs::Float64 & ptr ) Callback function. Saturates the value if boundaries exist. Parameters : msg Float64 value of the variable being controlled function init void init( ros::NodeHandle & nh, std::string controller_name, std::string refCallback_topic ) Initialize function. Reads the parameters, creates a pid controller if any gain is different from zero and subscribes to the relevant topic. Parameters : nh Nodehandle to read parameters and subscribe to relevant topics controller_name Controller name (variable being controlled) refCallback_topic Topic name function validRef virtual bool validRef() Check if the reference is new. Return : True if valid, false otherwise Protected Attributes Documentation variable timeout_ref_ ros::Duration timeout_ref_; variable controller_name_ std::string controller_name_; variable ref_value_ double ref_value_; variable max_ref_value_ double max_ref_value_; variable min_ref_value_ double min_ref_value_; variable ref_time_ ros::Time ref_time_; variable last_cmd_ ros::Time last_cmd_; variable debug_ bool debug_; variable debug_msg_ medusa_msgs::mPidDebug debug_msg_; variable state_ptr_ double * state_ptr_; variable force_or_torque_ptr_ double * force_or_torque_ptr_; variable frequency_ double frequency_; variable circular_units_ bool circular_units_; variable positive_output_ bool positive_output_; variable pid_c_ PID_Controller * pid_c_; variable ros_sub_ ros::Subscriber ros_sub_; variable debug_pub_ ros::Publisher debug_pub_; Updated on 2022-05-30 at 18:35:08 +0000","title":"RosController"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#roscontroller","text":"ROS implementation of the innerloops controllers. Based on a desired reference computes the force or torque to be applied. #include <ros_controller.h>","title":"RosController"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#public-functions","text":"Name RosController (ros::NodeHandle & nh, std::string controller_name, std::string refCallback_topic, double * state, double * force_or_torque, double frequency) Constructor of a innerloop controller. RosController (ros::NodeHandle & nh, std::string controller_name, std::string refCallback_topic, double * state, double * state_dot, double * force_or_torque, double frequency) Constructor of a innerloop controller. virtual double computeCommand () Core function. Computes the PID output. void setCircularUnits (const bool & flag) Setter function for the circular units flag. void setPositiveOutput (const bool & flag) Set the Positive Output object. std::string getControllerName () const Get the Controller Name object. void setFFGainsPID (const float & kff, const float & kff_d, const float & kff_lin_drag, const float kff_quad_drag) Set the Feedforwar gains P I D object. void setGainsPID (const float & kp, const float & ki, const float & kd) Set the Gains P I D object. void setLimitBoundsPID (const float & max_out, const float & min_out)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#protected-functions","text":"Name void refCallback (const std_msgs::Float64 & ptr) Callback function. Saturates the value if boundaries exist. void init (ros::NodeHandle & nh, std::string controller_name, std::string refCallback_topic) Initialize function. Reads the parameters, creates a pid controller if any gain is different from zero and subscribes to the relevant topic. virtual bool validRef () Check if the reference is new.","title":"Protected Functions"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#protected-attributes","text":"Name ros::Duration timeout_ref_ std::string controller_name_ double ref_value_ double max_ref_value_ double min_ref_value_ ros::Time ref_time_ ros::Time last_cmd_ bool debug_ medusa_msgs::mPidDebug debug_msg_ double * state_ptr_ double * force_or_torque_ptr_ double frequency_ bool circular_units_ bool positive_output_ PID_Controller * pid_c_ ros::Subscriber ros_sub_ ros::Publisher debug_pub_","title":"Protected Attributes"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#function-roscontroller","text":"RosController( ros::NodeHandle & nh, std::string controller_name, std::string refCallback_topic, double * state, double * force_or_torque, double frequency ) Constructor of a innerloop controller. Parameters : nh ROS nodehandle to read parameters and subscribe to relevant topics controller_name Controller name (variable being controlled) refCallback_topic Topic name state Pointer to state variable being controlled force_or_torque Pointer to force or torque output frequency Frequency of controller sampling rate","title":"function RosController"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#function-roscontroller_1","text":"RosController( ros::NodeHandle & nh, std::string controller_name, std::string refCallback_topic, double * state, double * state_dot, double * force_or_torque, double frequency ) Constructor of a innerloop controller. Parameters : nh ROS nodehandle to read parameters and subscribe to relevant topics controller_name Controller name (variable being controlled) refCallback_topic Topic name state Pointer to state variable being controlled state_dot Pointer to the derivative of the state variable being controlled force_or_torque Pointer to force or torque output frequency Frequency of controller sampling rate","title":"function RosController"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#function-computecommand","text":"virtual double computeCommand() Core function. Computes the PID output. Return : The force or torque that result from the PID computation","title":"function computeCommand"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#function-setcircularunits","text":"inline void setCircularUnits( const bool & flag ) Setter function for the circular units flag. Parameters : flag true for controllers using angles, false otherwise","title":"function setCircularUnits"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#function-setpositiveoutput","text":"inline void setPositiveOutput( const bool & flag ) Set the Positive Output object. Parameters : flag","title":"function setPositiveOutput"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#function-getcontrollername","text":"inline std::string getControllerName() const Get the Controller Name object.","title":"function getControllerName"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#function-setffgainspid","text":"inline void setFFGainsPID( const float & kff, const float & kff_d, const float & kff_lin_drag, const float kff_quad_drag ) Set the Feedforwar gains P I D object. Parameters : kff Feedforward gain (quadratic) kff_d Feedforwad derivative gain kff_lin_drag Feedforward linear drag gain kff_quad_drag Feedforwad quadratic drag gain","title":"function setFFGainsPID"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#function-setgainspid","text":"inline void setGainsPID( const float & kp, const float & ki, const float & kd ) Set the Gains P I D object. Parameters : kp Proportional gain ki Integral gain kd Derivative gain","title":"function setGainsPID"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#function-setlimitboundspid","text":"inline void setLimitBoundsPID( const float & max_out, const float & min_out )","title":"function setLimitBoundsPID"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#function-refcallback","text":"void refCallback( const std_msgs::Float64 & ptr ) Callback function. Saturates the value if boundaries exist. Parameters : msg Float64 value of the variable being controlled","title":"function refCallback"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#function-init","text":"void init( ros::NodeHandle & nh, std::string controller_name, std::string refCallback_topic ) Initialize function. Reads the parameters, creates a pid controller if any gain is different from zero and subscribes to the relevant topic. Parameters : nh Nodehandle to read parameters and subscribe to relevant topics controller_name Controller name (variable being controlled) refCallback_topic Topic name","title":"function init"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#function-validref","text":"virtual bool validRef() Check if the reference is new. Return : True if valid, false otherwise","title":"function validRef"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-timeout_ref_","text":"ros::Duration timeout_ref_;","title":"variable timeout_ref_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-controller_name_","text":"std::string controller_name_;","title":"variable controller_name_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-ref_value_","text":"double ref_value_;","title":"variable ref_value_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-max_ref_value_","text":"double max_ref_value_;","title":"variable max_ref_value_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-min_ref_value_","text":"double min_ref_value_;","title":"variable min_ref_value_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-ref_time_","text":"ros::Time ref_time_;","title":"variable ref_time_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-last_cmd_","text":"ros::Time last_cmd_;","title":"variable last_cmd_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-debug_","text":"bool debug_;","title":"variable debug_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-debug_msg_","text":"medusa_msgs::mPidDebug debug_msg_;","title":"variable debug_msg_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-state_ptr_","text":"double * state_ptr_;","title":"variable state_ptr_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-force_or_torque_ptr_","text":"double * force_or_torque_ptr_;","title":"variable force_or_torque_ptr_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-frequency_","text":"double frequency_;","title":"variable frequency_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-circular_units_","text":"bool circular_units_;","title":"variable circular_units_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-positive_output_","text":"bool positive_output_;","title":"variable positive_output_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-pid_c_","text":"PID_Controller * pid_c_;","title":"variable pid_c_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-ros_sub_","text":"ros::Subscriber ros_sub_;","title":"variable ros_sub_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-debug_pub_","text":"ros::Publisher debug_pub_; Updated on 2022-05-30 at 18:35:08 +0000","title":"variable debug_pub_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classSafeties/","text":"Safeties Public Functions Name Safeties (ros::NodeHandle & nh) Innerloops safeties constructor. virtual ~Safeties () Innerloops safeties Destructor. void loadParams (ros::NodeHandle & nh) Method to read parameters from yaml files. void initializeSubscribers (ros::NodeHandle & nh) Method to initialize subscribers. void initializePublishers (ros::NodeHandle & nh) Method to initialize publishers. void depthSafetyCallback (const std_msgs::Float64 & msg) Method called when a depth reference is received. Will check safeties regarding altitude: if valid will publish in the depth controller topic the desired reference, otherwise will publish the minimum altitude in the altitude controller. void altitudeSafetyCallback (const std_msgs::Float64 & msg) Method called when a altitude reference is received. Will check safeties regarding altitude: if above the minimum altitude will publish the desired reference, otherwise will publish the minimum altitude. void stateCallback (const auv_msgs::NavigationStatus & msg) Method called when a state msg is received. Updates depth and altitude values to calculate the water collumn needed for depth safeties. Public Functions Documentation function Safeties Safeties( ros::NodeHandle & nh ) Innerloops safeties constructor. Parameters : nh ros nodehandle to subscribe and publish topics function ~Safeties virtual ~Safeties() Innerloops safeties Destructor. function loadParams void loadParams( ros::NodeHandle & nh ) Method to read parameters from yaml files. Parameters : nh ros nodehandle to subscribe and publish topics function initializeSubscribers void initializeSubscribers( ros::NodeHandle & nh ) Method to initialize subscribers. Parameters : nh ros nodehandle to subscribe and publish topics function initializePublishers void initializePublishers( ros::NodeHandle & nh ) Method to initialize publishers. Parameters : nh ros nodehandle to subscribe and publish topics function depthSafetyCallback void depthSafetyCallback( const std_msgs::Float64 & msg ) Method called when a depth reference is received. Will check safeties regarding altitude: if valid will publish in the depth controller topic the desired reference, otherwise will publish the minimum altitude in the altitude controller. Parameters : msg Desired depth function altitudeSafetyCallback void altitudeSafetyCallback( const std_msgs::Float64 & msg ) Method called when a altitude reference is received. Will check safeties regarding altitude: if above the minimum altitude will publish the desired reference, otherwise will publish the minimum altitude. Parameters : msg Desired altitude function stateCallback void stateCallback( const auv_msgs::NavigationStatus & msg ) Method called when a state msg is received. Updates depth and altitude values to calculate the water collumn needed for depth safeties. Parameters : msg Vehicles state Updated on 2022-05-30 at 18:35:08 +0000","title":"Safeties"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classSafeties/#safeties","text":"","title":"Safeties"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classSafeties/#public-functions","text":"Name Safeties (ros::NodeHandle & nh) Innerloops safeties constructor. virtual ~Safeties () Innerloops safeties Destructor. void loadParams (ros::NodeHandle & nh) Method to read parameters from yaml files. void initializeSubscribers (ros::NodeHandle & nh) Method to initialize subscribers. void initializePublishers (ros::NodeHandle & nh) Method to initialize publishers. void depthSafetyCallback (const std_msgs::Float64 & msg) Method called when a depth reference is received. Will check safeties regarding altitude: if valid will publish in the depth controller topic the desired reference, otherwise will publish the minimum altitude in the altitude controller. void altitudeSafetyCallback (const std_msgs::Float64 & msg) Method called when a altitude reference is received. Will check safeties regarding altitude: if above the minimum altitude will publish the desired reference, otherwise will publish the minimum altitude. void stateCallback (const auv_msgs::NavigationStatus & msg) Method called when a state msg is received. Updates depth and altitude values to calculate the water collumn needed for depth safeties.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classSafeties/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classSafeties/#function-safeties","text":"Safeties( ros::NodeHandle & nh ) Innerloops safeties constructor. Parameters : nh ros nodehandle to subscribe and publish topics","title":"function Safeties"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classSafeties/#function-safeties_1","text":"virtual ~Safeties() Innerloops safeties Destructor.","title":"function ~Safeties"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classSafeties/#function-loadparams","text":"void loadParams( ros::NodeHandle & nh ) Method to read parameters from yaml files. Parameters : nh ros nodehandle to subscribe and publish topics","title":"function loadParams"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classSafeties/#function-initializesubscribers","text":"void initializeSubscribers( ros::NodeHandle & nh ) Method to initialize subscribers. Parameters : nh ros nodehandle to subscribe and publish topics","title":"function initializeSubscribers"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classSafeties/#function-initializepublishers","text":"void initializePublishers( ros::NodeHandle & nh ) Method to initialize publishers. Parameters : nh ros nodehandle to subscribe and publish topics","title":"function initializePublishers"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classSafeties/#function-depthsafetycallback","text":"void depthSafetyCallback( const std_msgs::Float64 & msg ) Method called when a depth reference is received. Will check safeties regarding altitude: if valid will publish in the depth controller topic the desired reference, otherwise will publish the minimum altitude in the altitude controller. Parameters : msg Desired depth","title":"function depthSafetyCallback"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classSafeties/#function-altitudesafetycallback","text":"void altitudeSafetyCallback( const std_msgs::Float64 & msg ) Method called when a altitude reference is received. Will check safeties regarding altitude: if above the minimum altitude will publish the desired reference, otherwise will publish the minimum altitude. Parameters : msg Desired altitude","title":"function altitudeSafetyCallback"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classSafeties/#function-statecallback","text":"void stateCallback( const auv_msgs::NavigationStatus & msg ) Method called when a state msg is received. Updates depth and altitude values to calculate the water collumn needed for depth safeties. Parameters : msg Vehicles state Updated on 2022-05-30 at 18:35:08 +0000","title":"function stateCallback"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:08 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:08 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:08 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:08 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Namespaces/","text":"Namespaces Updated on 2022-05-30 at 18:35:08 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Namespaces/#namespaces","text":"Updated on 2022-05-30 at 18:35:08 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/","text":"Classes namespace setup namespace src namespace open_loop_controller namespace OpenLoopNode class OpenLoopNode Updated on 2022-05-30 at 18:35:10 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/#classes","text":"namespace setup namespace src namespace open_loop_controller namespace OpenLoopNode class OpenLoopNode Updated on 2022-05-30 at 18:35:10 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/","text":"src::open_loop_controller::OpenLoopNode::OpenLoopNode More... Public Functions Name def init (self self) def load_params (self self) def initializeSubscribers (self self) def initializePublishers (self self) def timerCallback (self self, event event) def surgeCallback (self self, Float64 msg) def swayCallback (self self, Float64 msg) def heaveCallback (self self, Float64 msg) def yawRateCallback (self self, Float64 msg) def initializeTimer (self self) Public Attributes Name h_timerActivate surge_desired sway_desired heave_desired yaw_rate_desired last_update node_frequency gain_Fx gain_Fy gain_Fz gain_Tz surge_sub sway_sub heave_sub yaw_rate_sub force_pub timer Detailed Description class src::open_loop_controller::OpenLoopNode::OpenLoopNode; Remote controller ROS node class. Receives from a joystick (using pygame) the desired controls for the inner-loops and publishes these periodically (at a pre-defined frequency) to the inner-loops of the vehicle Public Functions Documentation function init def __init__( self self ) Class constructor. Initializes the ros node, loads the parameters from the ros parameter server, creates the inner-loops publishers and initializes the timer that publishes the desired inputs to the inner-loops function load_params def load_params( self self ) function initializeSubscribers def initializeSubscribers( self self ) function initializePublishers def initializePublishers( self self ) function timerCallback def timerCallback( self self, event event ) Callback used to publish to the inner-loops the desired control inputs :param event: A timer event - unused but required by the ROS API function surgeCallback def surgeCallback( self self, Float64 msg ) function swayCallback def swayCallback( self self, Float64 msg ) function heaveCallback def heaveCallback( self self, Float64 msg ) function yawRateCallback def yawRateCallback( self self, Float64 msg ) function initializeTimer def initializeTimer( self self ) Method that starts the system timer that periodically calls a callback Public Attributes Documentation variable h_timerActivate h_timerActivate; variable surge_desired surge_desired; variable sway_desired sway_desired; variable heave_desired heave_desired; variable yaw_rate_desired yaw_rate_desired; variable last_update last_update; variable node_frequency node_frequency; variable gain_Fx gain_Fx; variable gain_Fy gain_Fy; variable gain_Fz gain_Fz; variable gain_Tz gain_Tz; variable surge_sub surge_sub; variable sway_sub sway_sub; variable heave_sub heave_sub; variable yaw_rate_sub yaw_rate_sub; variable force_pub force_pub; variable timer timer; Updated on 2022-05-30 at 18:35:10 +0000","title":"src::open_loop_controller::OpenLoopNode::OpenLoopNode"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#srcopen_loop_controlleropenloopnodeopenloopnode","text":"More...","title":"src::open_loop_controller::OpenLoopNode::OpenLoopNode"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#public-functions","text":"Name def init (self self) def load_params (self self) def initializeSubscribers (self self) def initializePublishers (self self) def timerCallback (self self, event event) def surgeCallback (self self, Float64 msg) def swayCallback (self self, Float64 msg) def heaveCallback (self self, Float64 msg) def yawRateCallback (self self, Float64 msg) def initializeTimer (self self)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#public-attributes","text":"Name h_timerActivate surge_desired sway_desired heave_desired yaw_rate_desired last_update node_frequency gain_Fx gain_Fy gain_Fz gain_Tz surge_sub sway_sub heave_sub yaw_rate_sub force_pub timer","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#detailed-description","text":"class src::open_loop_controller::OpenLoopNode::OpenLoopNode; Remote controller ROS node class. Receives from a joystick (using pygame) the desired controls for the inner-loops and publishes these periodically (at a pre-defined frequency) to the inner-loops of the vehicle","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#function-init","text":"def __init__( self self ) Class constructor. Initializes the ros node, loads the parameters from the ros parameter server, creates the inner-loops publishers and initializes the timer that publishes the desired inputs to the inner-loops","title":"function init"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#function-load_params","text":"def load_params( self self )","title":"function load_params"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#function-initializesubscribers","text":"def initializeSubscribers( self self )","title":"function initializeSubscribers"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#function-initializepublishers","text":"def initializePublishers( self self )","title":"function initializePublishers"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#function-timercallback","text":"def timerCallback( self self, event event ) Callback used to publish to the inner-loops the desired control inputs :param event: A timer event - unused but required by the ROS API","title":"function timerCallback"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#function-surgecallback","text":"def surgeCallback( self self, Float64 msg )","title":"function surgeCallback"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#function-swaycallback","text":"def swayCallback( self self, Float64 msg )","title":"function swayCallback"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#function-heavecallback","text":"def heaveCallback( self self, Float64 msg )","title":"function heaveCallback"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#function-yawratecallback","text":"def yawRateCallback( self self, Float64 msg )","title":"function yawRateCallback"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#function-initializetimer","text":"def initializeTimer( self self ) Method that starts the system timer that periodically calls a callback","title":"function initializeTimer"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-h_timeractivate","text":"h_timerActivate;","title":"variable h_timerActivate"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-surge_desired","text":"surge_desired;","title":"variable surge_desired"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-sway_desired","text":"sway_desired;","title":"variable sway_desired"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-heave_desired","text":"heave_desired;","title":"variable heave_desired"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-yaw_rate_desired","text":"yaw_rate_desired;","title":"variable yaw_rate_desired"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-last_update","text":"last_update;","title":"variable last_update"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-node_frequency","text":"node_frequency;","title":"variable node_frequency"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-gain_fx","text":"gain_Fx;","title":"variable gain_Fx"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-gain_fy","text":"gain_Fy;","title":"variable gain_Fy"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-gain_fz","text":"gain_Fz;","title":"variable gain_Fz"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-gain_tz","text":"gain_Tz;","title":"variable gain_Tz"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-surge_sub","text":"surge_sub;","title":"variable surge_sub"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-sway_sub","text":"sway_sub;","title":"variable sway_sub"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-heave_sub","text":"heave_sub;","title":"variable heave_sub"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-yaw_rate_sub","text":"yaw_rate_sub;","title":"variable yaw_rate_sub"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-force_pub","text":"force_pub;","title":"variable force_pub"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-timer","text":"timer; Updated on 2022-05-30 at 18:35:10 +0000","title":"variable timer"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:10 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:10 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:10 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:10 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/","text":"Namespaces namespace setup namespace src namespace open_loop_controller namespace OpenLoopNode Updated on 2022-05-30 at 18:35:10 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/#namespaces","text":"namespace setup namespace src namespace open_loop_controller namespace OpenLoopNode Updated on 2022-05-30 at 18:35:10 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesetup/","text":"setup Attributes Name d Attributes Documentation variable d d = generate_distutils_setup( packages=['open_loop_controller'], package_dir={'open_loop_controller': 'src/open_loop_controller'} ); Updated on 2022-05-30 at 18:35:10 +0000","title":"setup"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesetup/#setup","text":"","title":"setup"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesetup/#attributes","text":"Name d","title":"Attributes"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesetup/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesetup/#variable-d","text":"d = generate_distutils_setup( packages=['open_loop_controller'], package_dir={'open_loop_controller': 'src/open_loop_controller'} ); Updated on 2022-05-30 at 18:35:10 +0000","title":"variable d"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesrc/","text":"src Namespaces Name src::open_loop_controller Updated on 2022-05-30 at 18:35:10 +0000","title":"src"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesrc/#src","text":"","title":"src"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesrc/#namespaces","text":"Name src::open_loop_controller Updated on 2022-05-30 at 18:35:10 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesrc_1_1open__loop__controller/","text":"src::open_loop_controller Namespaces Name src::open_loop_controller::OpenLoopNode Updated on 2022-05-30 at 18:35:10 +0000","title":"src::open_loop_controller"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesrc_1_1open__loop__controller/#srcopen_loop_controller","text":"","title":"src::open_loop_controller"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesrc_1_1open__loop__controller/#namespaces","text":"Name src::open_loop_controller::OpenLoopNode Updated on 2022-05-30 at 18:35:10 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesrc_1_1open__loop__controller_1_1OpenLoopNode/","text":"src::open_loop_controller::OpenLoopNode More... Classes Name class src::open_loop_controller::OpenLoopNode::OpenLoopNode Functions Name def main () Detailed Description @author: Marcelo Fialho Jacinto @email: marcelo.jacinto@tecnico.ulisboa.pt @date: 30/03/2022 @licence: MIT Functions Documentation function main def main() Initialize the RemoteControllerNode and let the timer callback do all the work Updated on 2022-05-30 at 18:35:10 +0000","title":"src::open_loop_controller::OpenLoopNode"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesrc_1_1open__loop__controller_1_1OpenLoopNode/#srcopen_loop_controlleropenloopnode","text":"More...","title":"src::open_loop_controller::OpenLoopNode"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesrc_1_1open__loop__controller_1_1OpenLoopNode/#classes","text":"Name class src::open_loop_controller::OpenLoopNode::OpenLoopNode","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesrc_1_1open__loop__controller_1_1OpenLoopNode/#functions","text":"Name def main ()","title":"Functions"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesrc_1_1open__loop__controller_1_1OpenLoopNode/#detailed-description","text":"@author: Marcelo Fialho Jacinto @email: marcelo.jacinto@tecnico.ulisboa.pt @date: 30/03/2022 @licence: MIT","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesrc_1_1open__loop__controller_1_1OpenLoopNode/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesrc_1_1open__loop__controller_1_1OpenLoopNode/#function-main","text":"def main() Initialize the RemoteControllerNode and let the timer callback do all the work Updated on 2022-05-30 at 18:35:10 +0000","title":"function main"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/","text":"Classes class CPFControl Abstract class to implement the cooperative path following synchronization controller. class CpfNode ROS node to actually do the Cooperative Control. class EventTriggered Implements a CPF controller using Event triggered communications. struct VehicleInfo Auxiliar structure to hold information regarding one vehicle. Updated on 2022-05-30 at 18:35:08 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/#classes","text":"class CPFControl Abstract class to implement the cooperative path following synchronization controller. class CpfNode ROS node to actually do the Cooperative Control. class EventTriggered Implements a CPF controller using Event triggered communications. struct VehicleInfo Auxiliar structure to hold information regarding one vehicle. Updated on 2022-05-30 at 18:35:08 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/","text":"CPFControl Abstract class to implement the cooperative path following synchronization controller. More... #include <CPFControl.h> Inherited by EventTriggered Public Functions Name virtual double coordinationController (double time) =0 Method to that updated the coordination control law and returns the correction speed vc to be used by the virtual target. virtual bool updateVehiclesInformation (double time, unsigned int ID, double gamma, double vd) =0 Method to update each individual vehicle information given an int with the ID of the vehicle and the new virtual target value. virtual bool publishCurrentGamma (double time) =0 Method to inform the user if the current gamma should be published or not. virtual bool reset () =0 Method to reset the current CPF controller. Eigen::MatrixXi getAdjencyMatrix () Method to get the Adjency Matrix that represents the network topology. Eigen::VectorXi getNeighbors () Method to get a vector with the neighbors of the current vehicle. bool updateAdjencyMatrix (Eigen::Matrix< int, Eigen::Dynamic, Eigen::Dynamic > & adjency_matrix) Method to update the Adjency Matrix that represents the network topology. unsigned int getNetworkSize () Method to get the number of vehicles used in the network. unsigned int getCurrentVehicleID () Method to get the current vehicle ID in the network. virtual ~CPFControl () Virtual destructor for the abstract class. Protected Functions Name CPFControl (Eigen::Matrix< int, Eigen::Dynamic, Eigen::Dynamic > & adjency_matrix, unsigned int vehicle_ID) Constructor for the abstract class. Receive the adjency matrix as a parameter. Detailed Description class CPFControl; Abstract class to implement the cooperative path following synchronization controller. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT In this class it is assumed that each vehicle has an ID which corresponds to each position in the adjency matrix that describes the topology of the network. The first ID is assumed to be 0. Public Functions Documentation function coordinationController virtual double coordinationController( double time ) =0 Method to that updated the coordination control law and returns the correction speed vc to be used by the virtual target. Parameters : time An int with the current time expressed in seconds Return : A double with the speed correction term vc Reimplemented by : EventTriggered::coordinationController function updateVehiclesInformation virtual bool updateVehiclesInformation( double time, unsigned int ID, double gamma, double vd ) =0 Method to update each individual vehicle information given an int with the ID of the vehicle and the new virtual target value. Parameters : time An int with the current time expressed in seconds ID An int with the ID of the vehicle which to update information gamma A double with the new information of the virtual target position vd A double with the desired velocity of the virtual target of that particular vehicle Return : A boolean with the information whether the information was used with success or not Reimplemented by : EventTriggered::updateVehiclesInformation function publishCurrentGamma virtual bool publishCurrentGamma( double time ) =0 Method to inform the user if the current gamma should be published or not. Parameters : time The current time expressed in seconds Return : A boolean that is true if the current gamma should be published Reimplemented by : EventTriggered::publishCurrentGamma function reset virtual bool reset() =0 Method to reset the current CPF controller. Return : A boolean whether it was reset correctly or not Reimplemented by : EventTriggered::reset function getAdjencyMatrix Eigen::MatrixXi getAdjencyMatrix() Method to get the Adjency Matrix that represents the network topology. Return : An eigen adjecy matrix of ints An eigen adjecy matrix of doubles function getNeighbors Eigen::VectorXi getNeighbors() Method to get a vector with the neighbors of the current vehicle. Return : An eigen vector with ints function updateAdjencyMatrix bool updateAdjencyMatrix( Eigen::Matrix< int, Eigen::Dynamic, Eigen::Dynamic > & adjency_matrix ) Method to update the Adjency Matrix that represents the network topology. Return : A boolean informing if update was done successfully or not function getNetworkSize unsigned int getNetworkSize() Method to get the number of vehicles used in the network. Return : An int with the number of vehicles in the network function getCurrentVehicleID unsigned int getCurrentVehicleID() Method to get the current vehicle ID in the network. Return : An int with the current vehicle ID function ~CPFControl virtual ~CPFControl() Virtual destructor for the abstract class. Protected Functions Documentation function CPFControl CPFControl( Eigen::Matrix< int, Eigen::Dynamic, Eigen::Dynamic > & adjency_matrix, unsigned int vehicle_ID ) Constructor for the abstract class. Receive the adjency matrix as a parameter. Parameters : adjency_matrix An Eigen adjency matrix vehicle_ID The current vehicle ID Updated on 2022-05-30 at 18:35:08 +0000","title":"CPFControl"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#cpfcontrol","text":"Abstract class to implement the cooperative path following synchronization controller. More... #include <CPFControl.h> Inherited by EventTriggered","title":"CPFControl"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#public-functions","text":"Name virtual double coordinationController (double time) =0 Method to that updated the coordination control law and returns the correction speed vc to be used by the virtual target. virtual bool updateVehiclesInformation (double time, unsigned int ID, double gamma, double vd) =0 Method to update each individual vehicle information given an int with the ID of the vehicle and the new virtual target value. virtual bool publishCurrentGamma (double time) =0 Method to inform the user if the current gamma should be published or not. virtual bool reset () =0 Method to reset the current CPF controller. Eigen::MatrixXi getAdjencyMatrix () Method to get the Adjency Matrix that represents the network topology. Eigen::VectorXi getNeighbors () Method to get a vector with the neighbors of the current vehicle. bool updateAdjencyMatrix (Eigen::Matrix< int, Eigen::Dynamic, Eigen::Dynamic > & adjency_matrix) Method to update the Adjency Matrix that represents the network topology. unsigned int getNetworkSize () Method to get the number of vehicles used in the network. unsigned int getCurrentVehicleID () Method to get the current vehicle ID in the network. virtual ~CPFControl () Virtual destructor for the abstract class.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#protected-functions","text":"Name CPFControl (Eigen::Matrix< int, Eigen::Dynamic, Eigen::Dynamic > & adjency_matrix, unsigned int vehicle_ID) Constructor for the abstract class. Receive the adjency matrix as a parameter.","title":"Protected Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#detailed-description","text":"class CPFControl; Abstract class to implement the cooperative path following synchronization controller. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT In this class it is assumed that each vehicle has an ID which corresponds to each position in the adjency matrix that describes the topology of the network. The first ID is assumed to be 0.","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#function-coordinationcontroller","text":"virtual double coordinationController( double time ) =0 Method to that updated the coordination control law and returns the correction speed vc to be used by the virtual target. Parameters : time An int with the current time expressed in seconds Return : A double with the speed correction term vc Reimplemented by : EventTriggered::coordinationController","title":"function coordinationController"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#function-updatevehiclesinformation","text":"virtual bool updateVehiclesInformation( double time, unsigned int ID, double gamma, double vd ) =0 Method to update each individual vehicle information given an int with the ID of the vehicle and the new virtual target value. Parameters : time An int with the current time expressed in seconds ID An int with the ID of the vehicle which to update information gamma A double with the new information of the virtual target position vd A double with the desired velocity of the virtual target of that particular vehicle Return : A boolean with the information whether the information was used with success or not Reimplemented by : EventTriggered::updateVehiclesInformation","title":"function updateVehiclesInformation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#function-publishcurrentgamma","text":"virtual bool publishCurrentGamma( double time ) =0 Method to inform the user if the current gamma should be published or not. Parameters : time The current time expressed in seconds Return : A boolean that is true if the current gamma should be published Reimplemented by : EventTriggered::publishCurrentGamma","title":"function publishCurrentGamma"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#function-reset","text":"virtual bool reset() =0 Method to reset the current CPF controller. Return : A boolean whether it was reset correctly or not Reimplemented by : EventTriggered::reset","title":"function reset"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#function-getadjencymatrix","text":"Eigen::MatrixXi getAdjencyMatrix() Method to get the Adjency Matrix that represents the network topology. Return : An eigen adjecy matrix of ints An eigen adjecy matrix of doubles","title":"function getAdjencyMatrix"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#function-getneighbors","text":"Eigen::VectorXi getNeighbors() Method to get a vector with the neighbors of the current vehicle. Return : An eigen vector with ints","title":"function getNeighbors"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#function-updateadjencymatrix","text":"bool updateAdjencyMatrix( Eigen::Matrix< int, Eigen::Dynamic, Eigen::Dynamic > & adjency_matrix ) Method to update the Adjency Matrix that represents the network topology. Return : A boolean informing if update was done successfully or not","title":"function updateAdjencyMatrix"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#function-getnetworksize","text":"unsigned int getNetworkSize() Method to get the number of vehicles used in the network. Return : An int with the number of vehicles in the network","title":"function getNetworkSize"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#function-getcurrentvehicleid","text":"unsigned int getCurrentVehicleID() Method to get the current vehicle ID in the network. Return : An int with the current vehicle ID","title":"function getCurrentVehicleID"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#function-cpfcontrol","text":"virtual ~CPFControl() Virtual destructor for the abstract class.","title":"function ~CPFControl"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#function-cpfcontrol_1","text":"CPFControl( Eigen::Matrix< int, Eigen::Dynamic, Eigen::Dynamic > & adjency_matrix, unsigned int vehicle_ID ) Constructor for the abstract class. Receive the adjency matrix as a parameter. Parameters : adjency_matrix An Eigen adjency matrix vehicle_ID The current vehicle ID Updated on 2022-05-30 at 18:35:08 +0000","title":"function CPFControl"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCpfNode/","text":"CpfNode ROS node to actually do the Cooperative Control. More... #include <CpfNode.h> Public Functions Name CpfNode (ros::NodeHandle * nh, ros::NodeHandle * nh_p) The constructor for the Cooperative control law. ~CpfNode () Destructor for the CPF Node. Here all the subscribers, publishers and timers are shutdown. Detailed Description class CpfNode; ROS node to actually do the Cooperative Control. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT Public Functions Documentation function CpfNode CpfNode( ros::NodeHandle * nh, ros::NodeHandle * nh_p ) The constructor for the Cooperative control law. Parameters : nh The public nodehandle nh_p The private nodehandle nh Pointer to the public nodehandle nh Pointer to the private nodehandle Constructor for the CpfNode . function ~CpfNode ~CpfNode() Destructor for the CPF Node. Here all the subscribers, publishers and timers are shutdown. Destructor for the CpfNode . Updated on 2022-05-30 at 18:35:08 +0000","title":"CpfNode"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCpfNode/#cpfnode","text":"ROS node to actually do the Cooperative Control. More... #include <CpfNode.h>","title":"CpfNode"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCpfNode/#public-functions","text":"Name CpfNode (ros::NodeHandle * nh, ros::NodeHandle * nh_p) The constructor for the Cooperative control law. ~CpfNode () Destructor for the CPF Node. Here all the subscribers, publishers and timers are shutdown.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCpfNode/#detailed-description","text":"class CpfNode; ROS node to actually do the Cooperative Control. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCpfNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCpfNode/#function-cpfnode","text":"CpfNode( ros::NodeHandle * nh, ros::NodeHandle * nh_p ) The constructor for the Cooperative control law. Parameters : nh The public nodehandle nh_p The private nodehandle nh Pointer to the public nodehandle nh Pointer to the private nodehandle Constructor for the CpfNode .","title":"function CpfNode"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCpfNode/#function-cpfnode_1","text":"~CpfNode() Destructor for the CPF Node. Here all the subscribers, publishers and timers are shutdown. Destructor for the CpfNode . Updated on 2022-05-30 at 18:35:08 +0000","title":"function ~CpfNode"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classEventTriggered/","text":"EventTriggered Implements a CPF controller using Event triggered communications. More... #include <EventTriggered.h> Inherits from CPFControl Public Functions Name EventTriggered (Eigen::Matrix< int, Eigen::Dynamic, Eigen::Dynamic > & adjency_matrix, unsigned int vehicle_ID, double k_epsilon, double c0, double c1, double alpha) Constructor for the EventTriggered CPF class. Receive the adjency matrix as a parameter. ~EventTriggered () The destructor for the EventTriggered class. virtual double coordinationController (double time) override Method to that updated the coordination control law and returns the correction speed vc to be used by the virtual target. virtual bool updateVehiclesInformation (double time, unsigned int ID, double gamma, double vd) override Method to update each individual vehicle information given an int with the ID of the vehicle and the new virtual target value. virtual bool publishCurrentGamma (double time) override Method to inform the user if the current gamma should be published or not This method will update the value of gamma last sent to the network when this method returns true. virtual bool reset () override Method to reset the current CPF controller. Protected Functions Name void predictVehicleEstimator (unsigned int ID, double time) Method to estimate the current gamma of a vehicle represented by ID. Additional inherited members Public Functions inherited from CPFControl Name Eigen::MatrixXi getAdjencyMatrix () Method to get the Adjency Matrix that represents the network topology. Eigen::VectorXi getNeighbors () Method to get a vector with the neighbors of the current vehicle. bool updateAdjencyMatrix (Eigen::Matrix< int, Eigen::Dynamic, Eigen::Dynamic > & adjency_matrix) Method to update the Adjency Matrix that represents the network topology. unsigned int getNetworkSize () Method to get the number of vehicles used in the network. unsigned int getCurrentVehicleID () Method to get the current vehicle ID in the network. virtual ~CPFControl () Virtual destructor for the abstract class. Protected Functions inherited from CPFControl Name CPFControl (Eigen::Matrix< int, Eigen::Dynamic, Eigen::Dynamic > & adjency_matrix, unsigned int vehicle_ID) Constructor for the abstract class. Receive the adjency matrix as a parameter. Detailed Description class EventTriggered; Implements a CPF controller using Event triggered communications. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : GPLv3 Public Functions Documentation function EventTriggered EventTriggered( Eigen::Matrix< int, Eigen::Dynamic, Eigen::Dynamic > & adjency_matrix, unsigned int vehicle_ID, double k_epsilon, double c0, double c1, double alpha ) Constructor for the EventTriggered CPF class. Receive the adjency matrix as a parameter. Parameters : adjency_matrix An Eigen adjency matrix vehicle_ID An unsigned int with the ID of this particular vehicle k_epsilon The gain for the correction control law c0 The gain for the event trigger threshold c1 The gain for the event trigger threshold alpha The gian for the event trigger threshold function ~EventTriggered ~EventTriggered() The destructor for the EventTriggered class. Destructor for the EventTriggered class. function coordinationController virtual double coordinationController( double time ) override Method to that updated the coordination control law and returns the correction speed vc to be used by the virtual target. Parameters : time An int with the current time expressed in seconds Return : A double with the speed correction term vc Reimplements : CPFControl::coordinationController function updateVehiclesInformation virtual bool updateVehiclesInformation( double time, unsigned int ID, double gamma, double vd ) override Method to update each individual vehicle information given an int with the ID of the vehicle and the new virtual target value. Parameters : time An int with the current time expressed in seconds ID An int with the ID of the vehicle which to update information gamma A double with the new information of the virtual target position vd A double with the desired velocity of the virtual target of that particular vehicle Return : A boolean with the information whether the information was used with success or not Reimplements : CPFControl::updateVehiclesInformation function publishCurrentGamma virtual bool publishCurrentGamma( double time ) override Method to inform the user if the current gamma should be published or not This method will update the value of gamma last sent to the network when this method returns true. Parameters : time The current time expressed in seconds Return : A boolean that is true if the current gamma should be published Reimplements : CPFControl::publishCurrentGamma Method to inform the user if the current gamma should be published or not. function reset virtual bool reset() override Method to reset the current CPF controller. Return : A boolean whether it was reset correctly or not Reimplements : CPFControl::reset Protected Functions Documentation function predictVehicleEstimator void predictVehicleEstimator( unsigned int ID, double time ) Method to estimate the current gamma of a vehicle represented by ID. Parameters : ID The ID of the vehicle to update the prediction time The current time expressed in seconds Updated on 2022-05-30 at 18:35:08 +0000","title":"EventTriggered"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classEventTriggered/#eventtriggered","text":"Implements a CPF controller using Event triggered communications. More... #include <EventTriggered.h> Inherits from CPFControl","title":"EventTriggered"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classEventTriggered/#public-functions","text":"Name EventTriggered (Eigen::Matrix< int, Eigen::Dynamic, Eigen::Dynamic > & adjency_matrix, unsigned int vehicle_ID, double k_epsilon, double c0, double c1, double alpha) Constructor for the EventTriggered CPF class. Receive the adjency matrix as a parameter. ~EventTriggered () The destructor for the EventTriggered class. virtual double coordinationController (double time) override Method to that updated the coordination control law and returns the correction speed vc to be used by the virtual target. virtual bool updateVehiclesInformation (double time, unsigned int ID, double gamma, double vd) override Method to update each individual vehicle information given an int with the ID of the vehicle and the new virtual target value. virtual bool publishCurrentGamma (double time) override Method to inform the user if the current gamma should be published or not This method will update the value of gamma last sent to the network when this method returns true. virtual bool reset () override Method to reset the current CPF controller.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classEventTriggered/#protected-functions","text":"Name void predictVehicleEstimator (unsigned int ID, double time) Method to estimate the current gamma of a vehicle represented by ID.","title":"Protected Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classEventTriggered/#additional-inherited-members","text":"Public Functions inherited from CPFControl Name Eigen::MatrixXi getAdjencyMatrix () Method to get the Adjency Matrix that represents the network topology. Eigen::VectorXi getNeighbors () Method to get a vector with the neighbors of the current vehicle. bool updateAdjencyMatrix (Eigen::Matrix< int, Eigen::Dynamic, Eigen::Dynamic > & adjency_matrix) Method to update the Adjency Matrix that represents the network topology. unsigned int getNetworkSize () Method to get the number of vehicles used in the network. unsigned int getCurrentVehicleID () Method to get the current vehicle ID in the network. virtual ~CPFControl () Virtual destructor for the abstract class. Protected Functions inherited from CPFControl Name CPFControl (Eigen::Matrix< int, Eigen::Dynamic, Eigen::Dynamic > & adjency_matrix, unsigned int vehicle_ID) Constructor for the abstract class. Receive the adjency matrix as a parameter.","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classEventTriggered/#detailed-description","text":"class EventTriggered; Implements a CPF controller using Event triggered communications. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : GPLv3","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classEventTriggered/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classEventTriggered/#function-eventtriggered","text":"EventTriggered( Eigen::Matrix< int, Eigen::Dynamic, Eigen::Dynamic > & adjency_matrix, unsigned int vehicle_ID, double k_epsilon, double c0, double c1, double alpha ) Constructor for the EventTriggered CPF class. Receive the adjency matrix as a parameter. Parameters : adjency_matrix An Eigen adjency matrix vehicle_ID An unsigned int with the ID of this particular vehicle k_epsilon The gain for the correction control law c0 The gain for the event trigger threshold c1 The gain for the event trigger threshold alpha The gian for the event trigger threshold","title":"function EventTriggered"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classEventTriggered/#function-eventtriggered_1","text":"~EventTriggered() The destructor for the EventTriggered class. Destructor for the EventTriggered class.","title":"function ~EventTriggered"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classEventTriggered/#function-coordinationcontroller","text":"virtual double coordinationController( double time ) override Method to that updated the coordination control law and returns the correction speed vc to be used by the virtual target. Parameters : time An int with the current time expressed in seconds Return : A double with the speed correction term vc Reimplements : CPFControl::coordinationController","title":"function coordinationController"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classEventTriggered/#function-updatevehiclesinformation","text":"virtual bool updateVehiclesInformation( double time, unsigned int ID, double gamma, double vd ) override Method to update each individual vehicle information given an int with the ID of the vehicle and the new virtual target value. Parameters : time An int with the current time expressed in seconds ID An int with the ID of the vehicle which to update information gamma A double with the new information of the virtual target position vd A double with the desired velocity of the virtual target of that particular vehicle Return : A boolean with the information whether the information was used with success or not Reimplements : CPFControl::updateVehiclesInformation","title":"function updateVehiclesInformation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classEventTriggered/#function-publishcurrentgamma","text":"virtual bool publishCurrentGamma( double time ) override Method to inform the user if the current gamma should be published or not This method will update the value of gamma last sent to the network when this method returns true. Parameters : time The current time expressed in seconds Return : A boolean that is true if the current gamma should be published Reimplements : CPFControl::publishCurrentGamma Method to inform the user if the current gamma should be published or not.","title":"function publishCurrentGamma"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classEventTriggered/#function-reset","text":"virtual bool reset() override Method to reset the current CPF controller. Return : A boolean whether it was reset correctly or not Reimplements : CPFControl::reset","title":"function reset"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classEventTriggered/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classEventTriggered/#function-predictvehicleestimator","text":"void predictVehicleEstimator( unsigned int ID, double time ) Method to estimate the current gamma of a vehicle represented by ID. Parameters : ID The ID of the vehicle to update the prediction time The current time expressed in seconds Updated on 2022-05-30 at 18:35:08 +0000","title":"function predictVehicleEstimator"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/structVehicleInfo/","text":"VehicleInfo Auxiliar structure to hold information regarding one vehicle. More... #include <EventTriggered.h> Public Attributes Name double gamma The real value of gamma received by the network and the corresponding time at which this value was received by the network. double time The time instant expressed in seconds corresponding to the instant when gamma was received. double gamma_hat The estimated value of gamma. double vd The desired speed for that gamma. bool is_active Flag that will become true when the first value is received from the network for this vehicle. Detailed Description struct VehicleInfo; Auxiliar structure to hold information regarding one vehicle. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT Public Attributes Documentation variable gamma double gamma {0.0}; The real value of gamma received by the network and the corresponding time at which this value was received by the network. variable time double time {0.0}; The time instant expressed in seconds corresponding to the instant when gamma was received. variable gamma_hat double gamma_hat {0.0}; The estimated value of gamma. variable vd double vd {0.0}; The desired speed for that gamma. variable is_active bool is_active {false}; Flag that will become true when the first value is received from the network for this vehicle. Updated on 2022-05-30 at 18:35:08 +0000","title":"VehicleInfo"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/structVehicleInfo/#vehicleinfo","text":"Auxiliar structure to hold information regarding one vehicle. More... #include <EventTriggered.h>","title":"VehicleInfo"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/structVehicleInfo/#public-attributes","text":"Name double gamma The real value of gamma received by the network and the corresponding time at which this value was received by the network. double time The time instant expressed in seconds corresponding to the instant when gamma was received. double gamma_hat The estimated value of gamma. double vd The desired speed for that gamma. bool is_active Flag that will become true when the first value is received from the network for this vehicle.","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/structVehicleInfo/#detailed-description","text":"struct VehicleInfo; Auxiliar structure to hold information regarding one vehicle. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/structVehicleInfo/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/structVehicleInfo/#variable-gamma","text":"double gamma {0.0}; The real value of gamma received by the network and the corresponding time at which this value was received by the network.","title":"variable gamma"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/structVehicleInfo/#variable-time","text":"double time {0.0}; The time instant expressed in seconds corresponding to the instant when gamma was received.","title":"variable time"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/structVehicleInfo/#variable-gamma_hat","text":"double gamma_hat {0.0}; The estimated value of gamma.","title":"variable gamma_hat"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/structVehicleInfo/#variable-vd","text":"double vd {0.0}; The desired speed for that gamma.","title":"variable vd"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/structVehicleInfo/#variable-is_active","text":"bool is_active {false}; Flag that will become true when the first value is received from the network for this vehicle. Updated on 2022-05-30 at 18:35:08 +0000","title":"variable is_active"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:08 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:08 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:08 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:08 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Namespaces/","text":"Namespaces Updated on 2022-05-30 at 18:35:08 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Namespaces/#namespaces","text":"Updated on 2022-05-30 at 18:35:08 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/","text":"Classes class Aguiar Path following using Aguiar 's algorithm for path following Method6: based on the work of Aguiar and Hespanha (2007) This algorithm support: Controls: class Brevik Path following using Brevik 's algorithm for path following Method4: based on the work of Brevik and Fossen (2005) This algorithm support: Controls: class Fossen Path following using Fossen 's algorithm for path following Method3: based on the work of Fossen(2015) class Lapierre Path following using Lapierre 's algorithm for path following Method2: developed from the work of Lionel Lapierre and Antonio(2003) class Marcelo Path following using Aguiar 's algorithm for path following Method6: based on the work of Aguiar and Hespanha (2007) This algorithm support: Controls: struct PFollowingDebug class PathFollowing A Base class to update the path following law. class PathFollowingNode Path Following Node, where the magic happens. struct PathState A structure to hold the data of the path. class Pramod Path following using Pramod 's algorithm for path following*. class RelativeHeading Path following using RelativeHeading 's algorithm for path following*. class Romulo Path following using Aguiar 's algorithm modified to also control sway instead of yaw_rate (by Romulo ) class Samson Path following using Lapierre 's algorithm for path following Method1: based on the work of Samson (1993) struct VehicleState A structure to hold the state of the vehicle. Updated on 2022-05-30 at 18:35:15 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/#classes","text":"class Aguiar Path following using Aguiar 's algorithm for path following Method6: based on the work of Aguiar and Hespanha (2007) This algorithm support: Controls: class Brevik Path following using Brevik 's algorithm for path following Method4: based on the work of Brevik and Fossen (2005) This algorithm support: Controls: class Fossen Path following using Fossen 's algorithm for path following Method3: based on the work of Fossen(2015) class Lapierre Path following using Lapierre 's algorithm for path following Method2: developed from the work of Lionel Lapierre and Antonio(2003) class Marcelo Path following using Aguiar 's algorithm for path following Method6: based on the work of Aguiar and Hespanha (2007) This algorithm support: Controls: struct PFollowingDebug class PathFollowing A Base class to update the path following law. class PathFollowingNode Path Following Node, where the magic happens. struct PathState A structure to hold the data of the path. class Pramod Path following using Pramod 's algorithm for path following*. class RelativeHeading Path following using RelativeHeading 's algorithm for path following*. class Romulo Path following using Aguiar 's algorithm modified to also control sway instead of yaw_rate (by Romulo ) class Samson Path following using Lapierre 's algorithm for path following Method1: based on the work of Samson (1993) struct VehicleState A structure to hold the state of the vehicle. Updated on 2022-05-30 at 18:35:15 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classAguiar/","text":"title: Aguiar summary: Path following using Aguiar's algorithm for path following Method6: based on the work of Aguiar and Hespanha (2007) This algorithm support: Controls: Aguiar Path following using Aguiar 's algorithm for path following Method6: based on the work of Aguiar and Hespanha (2007) This algorithm support: Controls: More... #include <Aguiar.h> Inherits from PathFollowing Public Functions Name Aguiar (double delta, double kk[2], double kz, double k_pos, double k_currents, ros::Publisher surge_pub, ros::Publisher yaw_rate_pub, ros::Publisher rabbit_pub) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method to update the gains, given a vector of doubles. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish_private the data from the path following. virtual void start () override Method used in the first run to do initial setup. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once. virtual bool resetVirtualTarget (float value) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Additional inherited members Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_ Detailed Description class Aguiar; Path following using Aguiar 's algorithm for path following Method6: based on the work of Aguiar and Hespanha (2007) This algorithm support: Controls: Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT yaw-rate surge virtual-target (gamma) Supports Cooperative Path Following - True Contains Currents Observers - True Public Functions Documentation function Aguiar Aguiar( double delta, double kk[2], double kz, double k_pos, double k_currents, ros::Publisher surge_pub, ros::Publisher yaw_rate_pub, ros::Publisher rabbit_pub ) Constructor method for the Path Following class. Parameters : delta Control gain kk Control gains kz Control gain k_pos Observer gain k_currents Observer gain surge_pub The ROS surge publisher yaw_rate_pub The ROS yaw rate publisher rabbit_pub The ROS rabbit publisher function setPFGains virtual bool setPFGains( std::vector< double > gains ) override Method to update the gains, given a vector of doubles. Parameters : gains A vector of gains to update in the controller The default order is: delta, kk[0], kk[1], kz, k_pos, k_currents Return : a boolean which represents the success of the operation Reimplements : PathFollowing::setPFGains function callPFController virtual void callPFController( double dt ) override Method that implements the path following control law. Parameters : dt The time step between last call and current call (in seconds) Reimplements : PathFollowing::callPFController function publish_private virtual void publish_private() override Method to publish_private the data from the path following. Reimplements : PathFollowing::publish_private function start virtual void start() override Method used in the first run to do initial setup. Reimplements : PathFollowing::start function stop virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : The success of the operation Reimplements : PathFollowing::stop Check if the gamma is greater then the gamma max of the path If so, we have reached the end function reset virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset function resetVirtualTarget virtual bool resetVirtualTarget( float value ) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Return : Whether the reset was made successfully or not Reimplements : PathFollowing::resetVirtualTarget Updated on 2022-05-30 at 18:35:15 +0000","title":"classAguiar"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classAguiar/#aguiar","text":"Path following using Aguiar 's algorithm for path following Method6: based on the work of Aguiar and Hespanha (2007) This algorithm support: Controls: More... #include <Aguiar.h> Inherits from PathFollowing","title":"Aguiar"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classAguiar/#public-functions","text":"Name Aguiar (double delta, double kk[2], double kz, double k_pos, double k_currents, ros::Publisher surge_pub, ros::Publisher yaw_rate_pub, ros::Publisher rabbit_pub) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method to update the gains, given a vector of doubles. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish_private the data from the path following. virtual void start () override Method used in the first run to do initial setup. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once. virtual bool resetVirtualTarget (float value) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classAguiar/#additional-inherited-members","text":"Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classAguiar/#detailed-description","text":"class Aguiar; Path following using Aguiar 's algorithm for path following Method6: based on the work of Aguiar and Hespanha (2007) This algorithm support: Controls: Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT yaw-rate surge virtual-target (gamma) Supports Cooperative Path Following - True Contains Currents Observers - True","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classAguiar/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classAguiar/#function-aguiar","text":"Aguiar( double delta, double kk[2], double kz, double k_pos, double k_currents, ros::Publisher surge_pub, ros::Publisher yaw_rate_pub, ros::Publisher rabbit_pub ) Constructor method for the Path Following class. Parameters : delta Control gain kk Control gains kz Control gain k_pos Observer gain k_currents Observer gain surge_pub The ROS surge publisher yaw_rate_pub The ROS yaw rate publisher rabbit_pub The ROS rabbit publisher","title":"function Aguiar"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classAguiar/#function-setpfgains","text":"virtual bool setPFGains( std::vector< double > gains ) override Method to update the gains, given a vector of doubles. Parameters : gains A vector of gains to update in the controller The default order is: delta, kk[0], kk[1], kz, k_pos, k_currents Return : a boolean which represents the success of the operation Reimplements : PathFollowing::setPFGains","title":"function setPFGains"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classAguiar/#function-callpfcontroller","text":"virtual void callPFController( double dt ) override Method that implements the path following control law. Parameters : dt The time step between last call and current call (in seconds) Reimplements : PathFollowing::callPFController","title":"function callPFController"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classAguiar/#function-publish_private","text":"virtual void publish_private() override Method to publish_private the data from the path following. Reimplements : PathFollowing::publish_private","title":"function publish_private"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classAguiar/#function-start","text":"virtual void start() override Method used in the first run to do initial setup. Reimplements : PathFollowing::start","title":"function start"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classAguiar/#function-stop","text":"virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : The success of the operation Reimplements : PathFollowing::stop Check if the gamma is greater then the gamma max of the path If so, we have reached the end","title":"function stop"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classAguiar/#function-reset","text":"virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset","title":"function reset"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classAguiar/#function-resetvirtualtarget","text":"virtual bool resetVirtualTarget( float value ) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Return : Whether the reset was made successfully or not Reimplements : PathFollowing::resetVirtualTarget Updated on 2022-05-30 at 18:35:15 +0000","title":"function resetVirtualTarget"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classBrevik/","text":"title: Brevik summary: Path following using Brevik's algorithm for path following Method4: based on the work of Brevik and Fossen (2005) This algorithm support: Controls: Brevik Path following using Brevik 's algorithm for path following Method4: based on the work of Brevik and Fossen (2005) This algorithm support: Controls: More... #include <Brevik.h> Inherits from PathFollowing Public Functions Name Brevik (ros::Publisher surge_pub, ros::Publisher yaw_pub, ros::Publisher rabbit_pub) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method to update the gains, given a vector of doubles. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish the data from the path following. virtual void start () override Method used in the first run to do initial setup. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once. virtual bool resetVirtualTarget (float value) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Additional inherited members Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_ Detailed Description class Brevik; Path following using Brevik 's algorithm for path following Method4: based on the work of Brevik and Fossen (2005) This algorithm support: Controls: Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT yaw surge virtual-target (gamma) Supports Cooperative Path Following - True Contains Currents Observers - False Public Functions Documentation function Brevik Brevik( ros::Publisher surge_pub, ros::Publisher yaw_pub, ros::Publisher rabbit_pub ) Constructor method for the Path Following class. Parameters : surge_pub The ROS surge publisher yaw_pub The ROS yaw publisher rabbit_pub The ROS rabbit publisher function setPFGains virtual bool setPFGains( std::vector< double > gains ) override Method to update the gains, given a vector of doubles. Parameters : gains The gains for the controller Return : By default just returns false for this algorithm Reimplements : PathFollowing::setPFGains NOTE: In this class the setPFGains method does nothing to the controller as all the gains are fixed function callPFController virtual void callPFController( double dt ) override Method that implements the path following control law. Parameters : dt The time difference between last call and current call (in seconds) Reimplements : PathFollowing::callPFController function publish_private virtual void publish_private() override Method to publish the data from the path following. Reimplements : PathFollowing::publish_private function start virtual void start() override Method used in the first run to do initial setup. Reimplements : PathFollowing::start function stop virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : The success of the operation Reimplements : PathFollowing::stop Check if the gamma is greater then the gamma max of the path If so, we have reached the end function reset virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset function resetVirtualTarget virtual bool resetVirtualTarget( float value ) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Return : Whether the reset was made successfully or not Reimplements : PathFollowing::resetVirtualTarget Updated on 2022-05-30 at 18:35:15 +0000","title":"classBrevik"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classBrevik/#brevik","text":"Path following using Brevik 's algorithm for path following Method4: based on the work of Brevik and Fossen (2005) This algorithm support: Controls: More... #include <Brevik.h> Inherits from PathFollowing","title":"Brevik"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classBrevik/#public-functions","text":"Name Brevik (ros::Publisher surge_pub, ros::Publisher yaw_pub, ros::Publisher rabbit_pub) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method to update the gains, given a vector of doubles. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish the data from the path following. virtual void start () override Method used in the first run to do initial setup. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once. virtual bool resetVirtualTarget (float value) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classBrevik/#additional-inherited-members","text":"Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classBrevik/#detailed-description","text":"class Brevik; Path following using Brevik 's algorithm for path following Method4: based on the work of Brevik and Fossen (2005) This algorithm support: Controls: Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT yaw surge virtual-target (gamma) Supports Cooperative Path Following - True Contains Currents Observers - False","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classBrevik/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classBrevik/#function-brevik","text":"Brevik( ros::Publisher surge_pub, ros::Publisher yaw_pub, ros::Publisher rabbit_pub ) Constructor method for the Path Following class. Parameters : surge_pub The ROS surge publisher yaw_pub The ROS yaw publisher rabbit_pub The ROS rabbit publisher","title":"function Brevik"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classBrevik/#function-setpfgains","text":"virtual bool setPFGains( std::vector< double > gains ) override Method to update the gains, given a vector of doubles. Parameters : gains The gains for the controller Return : By default just returns false for this algorithm Reimplements : PathFollowing::setPFGains NOTE: In this class the setPFGains method does nothing to the controller as all the gains are fixed","title":"function setPFGains"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classBrevik/#function-callpfcontroller","text":"virtual void callPFController( double dt ) override Method that implements the path following control law. Parameters : dt The time difference between last call and current call (in seconds) Reimplements : PathFollowing::callPFController","title":"function callPFController"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classBrevik/#function-publish_private","text":"virtual void publish_private() override Method to publish the data from the path following. Reimplements : PathFollowing::publish_private","title":"function publish_private"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classBrevik/#function-start","text":"virtual void start() override Method used in the first run to do initial setup. Reimplements : PathFollowing::start","title":"function start"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classBrevik/#function-stop","text":"virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : The success of the operation Reimplements : PathFollowing::stop Check if the gamma is greater then the gamma max of the path If so, we have reached the end","title":"function stop"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classBrevik/#function-reset","text":"virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset","title":"function reset"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classBrevik/#function-resetvirtualtarget","text":"virtual bool resetVirtualTarget( float value ) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Return : Whether the reset was made successfully or not Reimplements : PathFollowing::resetVirtualTarget Updated on 2022-05-30 at 18:35:15 +0000","title":"function resetVirtualTarget"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classFossen/","text":"title: Fossen summary: Path following using Fossen's algorithm for path following Method3: based on the work of Fossen(2015) Fossen Path following using Fossen 's algorithm for path following Method3: based on the work of Fossen(2015) More... #include <Fossen.h> Inherits from PathFollowing Public Functions Name Fossen (ros::Publisher surge_pub, ros::Publisher yaw_pub, ros::ServiceClient mode_client) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method that given an array of doubles, updates the gains of the controller. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish the data from the path following. virtual void start () override Method used to start the algorithm in the first run. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once. Additional inherited members Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. virtual bool resetVirtualTarget (float value) Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) bool resetVirtualTarget () Method to reset the virtual target of the vehicle (gamma) to zero. Not all controllers need this (example: Samson , Fossen which use the closest point) void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_ Detailed Description class Fossen; Path following using Fossen 's algorithm for path following Method3: based on the work of Fossen(2015) Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This algorithm support: Controls: yaw surge Supports Cooperative Path Following - True Contains Currents Observers - False Public Functions Documentation function Fossen Fossen( ros::Publisher surge_pub, ros::Publisher yaw_pub, ros::ServiceClient mode_client ) Constructor method for the Path Following class. Parameters : surge_pub The ROS surge publisher yaw_pub The ROS yaw publisher mode_client The ROS client for the path (to change the mode of operation to closest point) function setPFGains virtual bool setPFGains( std::vector< double > gains ) override Method that given an array of doubles, updates the gains of the controller. Parameters : gains The gains of the controller Return : By default just returns false for this algorithm Reimplements : PathFollowing::setPFGains NOTE: In this controller this method does nothing, as there are no gains to tweak. They are all fixed function callPFController virtual void callPFController( double dt ) override Method that implements the path following control law. Parameters : dt The time diference between last call and current call (in seconds) dt The time difference in seconds Reimplements : PathFollowing::callPFController Method that implements the path Following algorihtm. function publish_private virtual void publish_private() override Method to publish the data from the path following. Reimplements : PathFollowing::publish_private function start virtual void start() override Method used to start the algorithm in the first run. Return : the success of the operation Reimplements : PathFollowing::start function stop virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : the success of the operation Reimplements : PathFollowing::stop function reset virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset Updated on 2022-05-30 at 18:35:15 +0000","title":"classFossen"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classFossen/#fossen","text":"Path following using Fossen 's algorithm for path following Method3: based on the work of Fossen(2015) More... #include <Fossen.h> Inherits from PathFollowing","title":"Fossen"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classFossen/#public-functions","text":"Name Fossen (ros::Publisher surge_pub, ros::Publisher yaw_pub, ros::ServiceClient mode_client) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method that given an array of doubles, updates the gains of the controller. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish the data from the path following. virtual void start () override Method used to start the algorithm in the first run. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classFossen/#additional-inherited-members","text":"Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. virtual bool resetVirtualTarget (float value) Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) bool resetVirtualTarget () Method to reset the virtual target of the vehicle (gamma) to zero. Not all controllers need this (example: Samson , Fossen which use the closest point) void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classFossen/#detailed-description","text":"class Fossen; Path following using Fossen 's algorithm for path following Method3: based on the work of Fossen(2015) Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This algorithm support: Controls: yaw surge Supports Cooperative Path Following - True Contains Currents Observers - False","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classFossen/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classFossen/#function-fossen","text":"Fossen( ros::Publisher surge_pub, ros::Publisher yaw_pub, ros::ServiceClient mode_client ) Constructor method for the Path Following class. Parameters : surge_pub The ROS surge publisher yaw_pub The ROS yaw publisher mode_client The ROS client for the path (to change the mode of operation to closest point)","title":"function Fossen"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classFossen/#function-setpfgains","text":"virtual bool setPFGains( std::vector< double > gains ) override Method that given an array of doubles, updates the gains of the controller. Parameters : gains The gains of the controller Return : By default just returns false for this algorithm Reimplements : PathFollowing::setPFGains NOTE: In this controller this method does nothing, as there are no gains to tweak. They are all fixed","title":"function setPFGains"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classFossen/#function-callpfcontroller","text":"virtual void callPFController( double dt ) override Method that implements the path following control law. Parameters : dt The time diference between last call and current call (in seconds) dt The time difference in seconds Reimplements : PathFollowing::callPFController Method that implements the path Following algorihtm.","title":"function callPFController"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classFossen/#function-publish_private","text":"virtual void publish_private() override Method to publish the data from the path following. Reimplements : PathFollowing::publish_private","title":"function publish_private"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classFossen/#function-start","text":"virtual void start() override Method used to start the algorithm in the first run. Return : the success of the operation Reimplements : PathFollowing::start","title":"function start"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classFossen/#function-stop","text":"virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : the success of the operation Reimplements : PathFollowing::stop","title":"function stop"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classFossen/#function-reset","text":"virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset Updated on 2022-05-30 at 18:35:15 +0000","title":"function reset"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classLapierre/","text":"title: Lapierre summary: Path following using Lapierre's algorithm for path following Method2: developed from the work of Lionel Lapierre and Antonio(2003) Lapierre Path following using Lapierre 's algorithm for path following Method2: developed from the work of Lionel Lapierre and Antonio(2003) More... #include <Lapierre.h> Inherits from PathFollowing Public Functions Name Lapierre (double k1, double k2, double k3, double theta, double k_delta, ros::Publisher surge_pub, ros::Publisher yaw_rate_pub, ros::Publisher rabbit_pub) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method that given a vector of doubles, updates the gains of the controller. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish the data from the path following. virtual void start () override Method to run in the first iteration of the path following algorithm. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once. virtual bool resetVirtualTarget (float value) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Additional inherited members Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_ Detailed Description class Lapierre; Path following using Lapierre 's algorithm for path following Method2: developed from the work of Lionel Lapierre and Antonio(2003) Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This algorithm support: Controls: yaw-rate surge virtual-target (gamma) Supports Cooperative Path Following - True Contains Currents Observers - False Public Functions Documentation function Lapierre Lapierre( double k1, double k2, double k3, double theta, double k_delta, ros::Publisher surge_pub, ros::Publisher yaw_rate_pub, ros::Publisher rabbit_pub ) Constructor method for the Path Following class. Parameters : k1 Controller gain k2 Controller gain k3 Controller gain theta Controller gain k_delta Controller gain surge_pub The ROS surge publisher yaw_rate_pub The ROS yaw rate publisher rabbit_pub The ROS rabbit publisher function setPFGains virtual bool setPFGains( std::vector< double > gains ) override Method that given a vector of doubles, updates the gains of the controller. Parameters : gains A vector of gains Return : a boolean which represents the success of the operation Reimplements : PathFollowing::setPFGains NOTE: The default order of the gains is k1, k2, k3, theta, k_delta function callPFController virtual void callPFController( double dt ) override Method that implements the path following control law. Parameters : dt The time diference between the last and current call (in seconds) Reimplements : PathFollowing::callPFController function publish_private virtual void publish_private() override Method to publish the data from the path following. Reimplements : PathFollowing::publish_private function start virtual void start() override Method to run in the first iteration of the path following algorithm. Reimplements : PathFollowing::start function stop virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : the success of the operation Reimplements : PathFollowing::stop Check if the gamma is greater then the gamma max of the path If so, we have reached the end function reset virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset function resetVirtualTarget virtual bool resetVirtualTarget( float value ) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Return : Whether the reset was made successfully or not Reimplements : PathFollowing::resetVirtualTarget Updated on 2022-05-30 at 18:35:15 +0000","title":"classLapierre"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classLapierre/#lapierre","text":"Path following using Lapierre 's algorithm for path following Method2: developed from the work of Lionel Lapierre and Antonio(2003) More... #include <Lapierre.h> Inherits from PathFollowing","title":"Lapierre"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classLapierre/#public-functions","text":"Name Lapierre (double k1, double k2, double k3, double theta, double k_delta, ros::Publisher surge_pub, ros::Publisher yaw_rate_pub, ros::Publisher rabbit_pub) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method that given a vector of doubles, updates the gains of the controller. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish the data from the path following. virtual void start () override Method to run in the first iteration of the path following algorithm. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once. virtual bool resetVirtualTarget (float value) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classLapierre/#additional-inherited-members","text":"Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classLapierre/#detailed-description","text":"class Lapierre; Path following using Lapierre 's algorithm for path following Method2: developed from the work of Lionel Lapierre and Antonio(2003) Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This algorithm support: Controls: yaw-rate surge virtual-target (gamma) Supports Cooperative Path Following - True Contains Currents Observers - False","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classLapierre/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classLapierre/#function-lapierre","text":"Lapierre( double k1, double k2, double k3, double theta, double k_delta, ros::Publisher surge_pub, ros::Publisher yaw_rate_pub, ros::Publisher rabbit_pub ) Constructor method for the Path Following class. Parameters : k1 Controller gain k2 Controller gain k3 Controller gain theta Controller gain k_delta Controller gain surge_pub The ROS surge publisher yaw_rate_pub The ROS yaw rate publisher rabbit_pub The ROS rabbit publisher","title":"function Lapierre"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classLapierre/#function-setpfgains","text":"virtual bool setPFGains( std::vector< double > gains ) override Method that given a vector of doubles, updates the gains of the controller. Parameters : gains A vector of gains Return : a boolean which represents the success of the operation Reimplements : PathFollowing::setPFGains NOTE: The default order of the gains is k1, k2, k3, theta, k_delta","title":"function setPFGains"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classLapierre/#function-callpfcontroller","text":"virtual void callPFController( double dt ) override Method that implements the path following control law. Parameters : dt The time diference between the last and current call (in seconds) Reimplements : PathFollowing::callPFController","title":"function callPFController"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classLapierre/#function-publish_private","text":"virtual void publish_private() override Method to publish the data from the path following. Reimplements : PathFollowing::publish_private","title":"function publish_private"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classLapierre/#function-start","text":"virtual void start() override Method to run in the first iteration of the path following algorithm. Reimplements : PathFollowing::start","title":"function start"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classLapierre/#function-stop","text":"virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : the success of the operation Reimplements : PathFollowing::stop Check if the gamma is greater then the gamma max of the path If so, we have reached the end","title":"function stop"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classLapierre/#function-reset","text":"virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset","title":"function reset"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classLapierre/#function-resetvirtualtarget","text":"virtual bool resetVirtualTarget( float value ) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Return : Whether the reset was made successfully or not Reimplements : PathFollowing::resetVirtualTarget Updated on 2022-05-30 at 18:35:15 +0000","title":"function resetVirtualTarget"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classMarcelo/","text":"title: Marcelo summary: Path following using Aguiar's algorithm for path following Method6: based on the work of Aguiar and Hespanha (2007) This algorithm support: Controls: Marcelo Path following using Aguiar 's algorithm for path following Method6: based on the work of Aguiar and Hespanha (2007) This algorithm support: Controls: More... #include <Marcelo.h> Inherits from PathFollowing Public Functions Name Marcelo (double delta, double kk[2], double kz, double k_pos, double k_currents, double rd[3], double d[3], ros::Publisher surge_pub, ros::Publisher yaw_rate_pub, ros::Publisher rabbit_pub, ros::Publisher currents_estimation_x_pub, ros::Publisher currents_estimation_y_pub) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method to update the gains, given a vector of doubles. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish_private the data from the path following. virtual void start () override Method used in the first run to do initial setup. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once. virtual bool resetVirtualTarget (float value) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Additional inherited members Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_ Detailed Description class Marcelo; Path following using Aguiar 's algorithm for path following Method6: based on the work of Aguiar and Hespanha (2007) This algorithm support: Controls: Author : Marcelo Jacinto Version : 1.0a Date : 2021 Copyright : MIT yaw-rate surge virtual-target (gamma) Supports Cooperative Path Following - True Contains Currents Observers - True Public Functions Documentation function Marcelo Marcelo( double delta, double kk[2], double kz, double k_pos, double k_currents, double rd[3], double d[3], ros::Publisher surge_pub, ros::Publisher yaw_rate_pub, ros::Publisher rabbit_pub, ros::Publisher currents_estimation_x_pub, ros::Publisher currents_estimation_y_pub ) Constructor method for the Path Following class. Parameters : delta Control gain kk Control gains kz Control gain k_pos Observer gain k_currents Observer gain surge_pub The ROS surge publisher yaw_rate_pub The ROS yaw rate publisher rabbit_pub The ROS rabbit publisher function setPFGains virtual bool setPFGains( std::vector< double > gains ) override Method to update the gains, given a vector of doubles. Parameters : gains A vector of gains to update in the controller The default order is: delta, kk[0], kk[1], kz, k_pos, k_currents Return : a boolean which represents the success of the operation Reimplements : PathFollowing::setPFGains function callPFController virtual void callPFController( double dt ) override Method that implements the path following control law. Parameters : dt The time step between last call and current call (in seconds) Reimplements : PathFollowing::callPFController function publish_private virtual void publish_private() override Method to publish_private the data from the path following. Reimplements : PathFollowing::publish_private function start virtual void start() override Method used in the first run to do initial setup. Reimplements : PathFollowing::start function stop virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : The success of the operation Reimplements : PathFollowing::stop Check if the gamma is greater then the gamma max of the path If so, we have reached the end function reset virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset function resetVirtualTarget virtual bool resetVirtualTarget( float value ) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Return : Whether the reset was made successfully or not Reimplements : PathFollowing::resetVirtualTarget Updated on 2022-05-30 at 18:35:15 +0000","title":"classMarcelo"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classMarcelo/#marcelo","text":"Path following using Aguiar 's algorithm for path following Method6: based on the work of Aguiar and Hespanha (2007) This algorithm support: Controls: More... #include <Marcelo.h> Inherits from PathFollowing","title":"Marcelo"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classMarcelo/#public-functions","text":"Name Marcelo (double delta, double kk[2], double kz, double k_pos, double k_currents, double rd[3], double d[3], ros::Publisher surge_pub, ros::Publisher yaw_rate_pub, ros::Publisher rabbit_pub, ros::Publisher currents_estimation_x_pub, ros::Publisher currents_estimation_y_pub) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method to update the gains, given a vector of doubles. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish_private the data from the path following. virtual void start () override Method used in the first run to do initial setup. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once. virtual bool resetVirtualTarget (float value) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classMarcelo/#additional-inherited-members","text":"Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classMarcelo/#detailed-description","text":"class Marcelo; Path following using Aguiar 's algorithm for path following Method6: based on the work of Aguiar and Hespanha (2007) This algorithm support: Controls: Author : Marcelo Jacinto Version : 1.0a Date : 2021 Copyright : MIT yaw-rate surge virtual-target (gamma) Supports Cooperative Path Following - True Contains Currents Observers - True","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classMarcelo/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classMarcelo/#function-marcelo","text":"Marcelo( double delta, double kk[2], double kz, double k_pos, double k_currents, double rd[3], double d[3], ros::Publisher surge_pub, ros::Publisher yaw_rate_pub, ros::Publisher rabbit_pub, ros::Publisher currents_estimation_x_pub, ros::Publisher currents_estimation_y_pub ) Constructor method for the Path Following class. Parameters : delta Control gain kk Control gains kz Control gain k_pos Observer gain k_currents Observer gain surge_pub The ROS surge publisher yaw_rate_pub The ROS yaw rate publisher rabbit_pub The ROS rabbit publisher","title":"function Marcelo"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classMarcelo/#function-setpfgains","text":"virtual bool setPFGains( std::vector< double > gains ) override Method to update the gains, given a vector of doubles. Parameters : gains A vector of gains to update in the controller The default order is: delta, kk[0], kk[1], kz, k_pos, k_currents Return : a boolean which represents the success of the operation Reimplements : PathFollowing::setPFGains","title":"function setPFGains"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classMarcelo/#function-callpfcontroller","text":"virtual void callPFController( double dt ) override Method that implements the path following control law. Parameters : dt The time step between last call and current call (in seconds) Reimplements : PathFollowing::callPFController","title":"function callPFController"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classMarcelo/#function-publish_private","text":"virtual void publish_private() override Method to publish_private the data from the path following. Reimplements : PathFollowing::publish_private","title":"function publish_private"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classMarcelo/#function-start","text":"virtual void start() override Method used in the first run to do initial setup. Reimplements : PathFollowing::start","title":"function start"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classMarcelo/#function-stop","text":"virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : The success of the operation Reimplements : PathFollowing::stop Check if the gamma is greater then the gamma max of the path If so, we have reached the end","title":"function stop"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classMarcelo/#function-reset","text":"virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset","title":"function reset"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classMarcelo/#function-resetvirtualtarget","text":"virtual bool resetVirtualTarget( float value ) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Return : Whether the reset was made successfully or not Reimplements : PathFollowing::resetVirtualTarget Updated on 2022-05-30 at 18:35:15 +0000","title":"function resetVirtualTarget"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/","text":"PathFollowing A Base class to update the path following law. More... #include <PathFollowing.h> Inherited by Aguiar , Brevik , Fossen , Lapierre , Marcelo , Pramod , RelativeHeading , Romulo , Samson Public Functions Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. virtual void callPFController (double dt) =0 Method to update the path following control law. void publish () Method to publish the data given by the algorithm. virtual void publish_private () =0 virtual void start () =0 Method used to setup the algorithm in the first iteration. virtual bool stop () =0 Method used to check whether we have reached the end of the path following algorithm or not. This method will be called in every iteration of the algorithm, and when it return true, the algorithm will stop. virtual bool reset () =0 Method used to reset the algorithm control parameters when running the algorithm more than once. virtual bool resetVirtualTarget (float value) Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) bool resetVirtualTarget () Method to reset the virtual target of the vehicle (gamma) to zero. Not all controllers need this (example: Samson , Fossen which use the closest point) virtual bool setPFGains (std::vector< double > gains) =0 Receives a vector of gains that should be mapped to the specific controller gains. void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_ Detailed Description class PathFollowing; A Base class to update the path following law. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT Public Functions Documentation function ~PathFollowing virtual ~PathFollowing() Virtual destructor for the abstract pathfollowing class. function callPFController virtual void callPFController( double dt ) =0 Method to update the path following control law. Parameters : dt The time diference between the current and previous call (in seconds) Reimplemented by : Pramod::callPFController , RelativeHeading::callPFController , Romulo::callPFController , Fossen::callPFController , Brevik::callPFController , Marcelo::callPFController , Samson::callPFController , Lapierre::callPFController , Aguiar::callPFController function publish void publish() Method to publish the data given by the algorithm. function publish_private virtual void publish_private() =0 Reimplemented by : Pramod::publish_private , RelativeHeading::publish_private , Romulo::publish_private , Fossen::publish_private , Brevik::publish_private , Marcelo::publish_private , Samson::publish_private , Lapierre::publish_private , Aguiar::publish_private function start virtual void start() =0 Method used to setup the algorithm in the first iteration. Reimplemented by : Pramod::start , RelativeHeading::start , Romulo::start , Brevik::start , Marcelo::start , Samson::start , Fossen::start , Lapierre::start , Aguiar::start function stop virtual bool stop() =0 Method used to check whether we have reached the end of the path following algorithm or not. This method will be called in every iteration of the algorithm, and when it return true, the algorithm will stop. Return : A boolean that represents whether we have reached the end Reimplemented by : Pramod::stop , RelativeHeading::stop , Romulo::stop , Brevik::stop , Marcelo::stop , Samson::stop , Fossen::stop , Lapierre::stop , Aguiar::stop function reset virtual bool reset() =0 Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplemented by : Pramod::reset , RelativeHeading::reset , Romulo::reset , Brevik::reset , Marcelo::reset , Samson::reset , Fossen::reset , Lapierre::reset , Aguiar::reset function resetVirtualTarget virtual bool resetVirtualTarget( float value ) Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Return : Whether the reset was made successfully or not Reimplemented by : RelativeHeading::resetVirtualTarget , Romulo::resetVirtualTarget , Brevik::resetVirtualTarget , Marcelo::resetVirtualTarget , Lapierre::resetVirtualTarget , Aguiar::resetVirtualTarget function resetVirtualTarget bool resetVirtualTarget() Method to reset the virtual target of the vehicle (gamma) to zero. Not all controllers need this (example: Samson , Fossen which use the closest point) Return : Whether the reset was made successfully or not This method calls the resetVirtualTarget(float value) method which can be overriden by each pf controller function setPFGains virtual bool setPFGains( std::vector< double > gains ) =0 Receives a vector of gains that should be mapped to the specific controller gains. Parameters : gains A vector of gains for the controller Reimplemented by : Pramod::setPFGains , RelativeHeading::setPFGains , Romulo::setPFGains , Fossen::setPFGains , Brevik::setPFGains , Marcelo::setPFGains , Samson::setPFGains , Lapierre::setPFGains , Aguiar::setPFGains This method must be implemented by each Path Following class function UpdateVehicleState void UpdateVehicleState( const VehicleState & vehicle_state ) Method to update the vehicle state used by the controller. Parameters : vehicle_state A structure with the current state of the vehicle function UpdatePathState void UpdatePathState( const PathState & path_state ) Method to update the path state used by the controller. Parameters : path_state A structure with the current state of the path function setPFollowingDebugPublisher inline void setPFollowingDebugPublisher( const ros::Publisher & pfollowing_debug_pub ) Method to set common publishers. Protected Functions Documentation function algConvert double algConvert( double alg_new, double alg_old, double alg_out_old ) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes Documentation variable vehicle_state_ VehicleState vehicle_state_; Variable to store the state of the vehicle. variable path_state_ PathState path_state_; Variable to store the state of the path. variable pfollowing_debug_ PFollowingDebug pfollowing_debug_; Variable to store the state of the path. variable pfollowing_debug_pub_ ros::Publisher pfollowing_debug_pub_; Updated on 2022-05-30 at 18:35:15 +0000","title":"PathFollowing"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#pathfollowing","text":"A Base class to update the path following law. More... #include <PathFollowing.h> Inherited by Aguiar , Brevik , Fossen , Lapierre , Marcelo , Pramod , RelativeHeading , Romulo , Samson","title":"PathFollowing"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#public-functions","text":"Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. virtual void callPFController (double dt) =0 Method to update the path following control law. void publish () Method to publish the data given by the algorithm. virtual void publish_private () =0 virtual void start () =0 Method used to setup the algorithm in the first iteration. virtual bool stop () =0 Method used to check whether we have reached the end of the path following algorithm or not. This method will be called in every iteration of the algorithm, and when it return true, the algorithm will stop. virtual bool reset () =0 Method used to reset the algorithm control parameters when running the algorithm more than once. virtual bool resetVirtualTarget (float value) Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) bool resetVirtualTarget () Method to reset the virtual target of the vehicle (gamma) to zero. Not all controllers need this (example: Samson , Fossen which use the closest point) virtual bool setPFGains (std::vector< double > gains) =0 Receives a vector of gains that should be mapped to the specific controller gains. void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#protected-functions","text":"Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms.","title":"Protected Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#protected-attributes","text":"Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_","title":"Protected Attributes"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#detailed-description","text":"class PathFollowing; A Base class to update the path following law. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#function-pathfollowing","text":"virtual ~PathFollowing() Virtual destructor for the abstract pathfollowing class.","title":"function ~PathFollowing"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#function-callpfcontroller","text":"virtual void callPFController( double dt ) =0 Method to update the path following control law. Parameters : dt The time diference between the current and previous call (in seconds) Reimplemented by : Pramod::callPFController , RelativeHeading::callPFController , Romulo::callPFController , Fossen::callPFController , Brevik::callPFController , Marcelo::callPFController , Samson::callPFController , Lapierre::callPFController , Aguiar::callPFController","title":"function callPFController"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#function-publish","text":"void publish() Method to publish the data given by the algorithm.","title":"function publish"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#function-publish_private","text":"virtual void publish_private() =0 Reimplemented by : Pramod::publish_private , RelativeHeading::publish_private , Romulo::publish_private , Fossen::publish_private , Brevik::publish_private , Marcelo::publish_private , Samson::publish_private , Lapierre::publish_private , Aguiar::publish_private","title":"function publish_private"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#function-start","text":"virtual void start() =0 Method used to setup the algorithm in the first iteration. Reimplemented by : Pramod::start , RelativeHeading::start , Romulo::start , Brevik::start , Marcelo::start , Samson::start , Fossen::start , Lapierre::start , Aguiar::start","title":"function start"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#function-stop","text":"virtual bool stop() =0 Method used to check whether we have reached the end of the path following algorithm or not. This method will be called in every iteration of the algorithm, and when it return true, the algorithm will stop. Return : A boolean that represents whether we have reached the end Reimplemented by : Pramod::stop , RelativeHeading::stop , Romulo::stop , Brevik::stop , Marcelo::stop , Samson::stop , Fossen::stop , Lapierre::stop , Aguiar::stop","title":"function stop"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#function-reset","text":"virtual bool reset() =0 Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplemented by : Pramod::reset , RelativeHeading::reset , Romulo::reset , Brevik::reset , Marcelo::reset , Samson::reset , Fossen::reset , Lapierre::reset , Aguiar::reset","title":"function reset"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#function-resetvirtualtarget","text":"virtual bool resetVirtualTarget( float value ) Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Return : Whether the reset was made successfully or not Reimplemented by : RelativeHeading::resetVirtualTarget , Romulo::resetVirtualTarget , Brevik::resetVirtualTarget , Marcelo::resetVirtualTarget , Lapierre::resetVirtualTarget , Aguiar::resetVirtualTarget","title":"function resetVirtualTarget"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#function-resetvirtualtarget_1","text":"bool resetVirtualTarget() Method to reset the virtual target of the vehicle (gamma) to zero. Not all controllers need this (example: Samson , Fossen which use the closest point) Return : Whether the reset was made successfully or not This method calls the resetVirtualTarget(float value) method which can be overriden by each pf controller","title":"function resetVirtualTarget"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#function-setpfgains","text":"virtual bool setPFGains( std::vector< double > gains ) =0 Receives a vector of gains that should be mapped to the specific controller gains. Parameters : gains A vector of gains for the controller Reimplemented by : Pramod::setPFGains , RelativeHeading::setPFGains , Romulo::setPFGains , Fossen::setPFGains , Brevik::setPFGains , Marcelo::setPFGains , Samson::setPFGains , Lapierre::setPFGains , Aguiar::setPFGains This method must be implemented by each Path Following class","title":"function setPFGains"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#function-updatevehiclestate","text":"void UpdateVehicleState( const VehicleState & vehicle_state ) Method to update the vehicle state used by the controller. Parameters : vehicle_state A structure with the current state of the vehicle","title":"function UpdateVehicleState"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#function-updatepathstate","text":"void UpdatePathState( const PathState & path_state ) Method to update the path state used by the controller. Parameters : path_state A structure with the current state of the path","title":"function UpdatePathState"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#function-setpfollowingdebugpublisher","text":"inline void setPFollowingDebugPublisher( const ros::Publisher & pfollowing_debug_pub ) Method to set common publishers.","title":"function setPFollowingDebugPublisher"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#function-algconvert","text":"double algConvert( double alg_new, double alg_old, double alg_out_old ) Auxiliar method to smooth out the angle to be used by path following algorithms.","title":"function algConvert"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#variable-vehicle_state_","text":"VehicleState vehicle_state_; Variable to store the state of the vehicle.","title":"variable vehicle_state_"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#variable-path_state_","text":"PathState path_state_; Variable to store the state of the path.","title":"variable path_state_"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#variable-pfollowing_debug_","text":"PFollowingDebug pfollowing_debug_; Variable to store the state of the path.","title":"variable pfollowing_debug_"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#variable-pfollowing_debug_pub_","text":"ros::Publisher pfollowing_debug_pub_; Updated on 2022-05-30 at 18:35:15 +0000","title":"variable pfollowing_debug_pub_"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowingNode/","text":"PathFollowingNode Path Following Node, where the magic happens. More... #include <PathFollowingNode.h> Public Functions Name PathFollowingNode (ros::NodeHandle * nh, ros::NodeHandle * nh_p) The constructor of the path following node. ~PathFollowingNode () The destructor of the path following node (where the subscribers, publishers and services are terminated) Detailed Description class PathFollowingNode; Path Following Node, where the magic happens. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT Public Functions Documentation function PathFollowingNode PathFollowingNode( ros::NodeHandle * nh, ros::NodeHandle * nh_p ) The constructor of the path following node. Parameters : nh The public ROS node handle nh_p The private ROS node handle nh Public ros node handle nh_p Private ros node handle The Path Following Node constructor. function ~PathFollowingNode ~PathFollowingNode() The destructor of the path following node (where the subscribers, publishers and services are terminated) Node class destructor. Updated on 2022-05-30 at 18:35:15 +0000","title":"PathFollowingNode"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowingNode/#pathfollowingnode","text":"Path Following Node, where the magic happens. More... #include <PathFollowingNode.h>","title":"PathFollowingNode"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowingNode/#public-functions","text":"Name PathFollowingNode (ros::NodeHandle * nh, ros::NodeHandle * nh_p) The constructor of the path following node. ~PathFollowingNode () The destructor of the path following node (where the subscribers, publishers and services are terminated)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowingNode/#detailed-description","text":"class PathFollowingNode; Path Following Node, where the magic happens. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowingNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowingNode/#function-pathfollowingnode","text":"PathFollowingNode( ros::NodeHandle * nh, ros::NodeHandle * nh_p ) The constructor of the path following node. Parameters : nh The public ROS node handle nh_p The private ROS node handle nh Public ros node handle nh_p Private ros node handle The Path Following Node constructor.","title":"function PathFollowingNode"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowingNode/#function-pathfollowingnode_1","text":"~PathFollowingNode() The destructor of the path following node (where the subscribers, publishers and services are terminated) Node class destructor. Updated on 2022-05-30 at 18:35:15 +0000","title":"function ~PathFollowingNode"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPramod/","text":"Pramod Path following using Pramod 's algorithm for path following*. More... #include <Pramod.h> Inherits from PathFollowing Public Functions Name Pramod (std::vector< double > gains, ros::Publisher surge_pub, ros::Publisher yaw_pub, ros::ServiceClient mode_client) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method that given an array of doubles, updates the gains of the controller. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish the data from the path following. virtual void start () override Method used to start the algorithm in the first run. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once. Additional inherited members Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. virtual bool resetVirtualTarget (float value) Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) bool resetVirtualTarget () Method to reset the virtual target of the vehicle (gamma) to zero. Not all controllers need this (example: Samson , Fossen which use the closest point) void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_ Detailed Description class Pramod; Path following using Pramod 's algorithm for path following*. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This algorithm support: Controls: yaw surge Supports Cooperative Path Following - True Contains Currents Observers - False Public Functions Documentation function Pramod Pramod( std::vector< double > gains, ros::Publisher surge_pub, ros::Publisher yaw_pub, ros::ServiceClient mode_client ) Constructor method for the Path Following class. Parameters : gains A vector with the gains of the controller (2 gains only - Kp and Kd) surge_pub The ROS surge publisher yaw_pub The ROS yaw publisher mode_client The ROS service client to change the mode of operation of the path (to the closest point) function setPFGains virtual bool setPFGains( std::vector< double > gains ) override Method that given an array of doubles, updates the gains of the controller. Parameters : gains A vector of gains of the controller (only 2 gains Kp and Kd) Return : a boolean which represents the success of the operation Reimplements : PathFollowing::setPFGains function callPFController virtual void callPFController( double dt ) override Method that implements the path following control law. Parameters : dt The time diference between the previous and current call (in seconds) Reimplements : PathFollowing::callPFController function publish_private virtual void publish_private() override Method to publish the data from the path following. Reimplements : PathFollowing::publish_private function start virtual void start() override Method used to start the algorithm in the first run. Reimplements : PathFollowing::start function stop virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : The success of the operation Reimplements : PathFollowing::stop function reset virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset Updated on 2022-05-30 at 18:35:15 +0000","title":"Pramod"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPramod/#pramod","text":"Path following using Pramod 's algorithm for path following*. More... #include <Pramod.h> Inherits from PathFollowing","title":"Pramod"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPramod/#public-functions","text":"Name Pramod (std::vector< double > gains, ros::Publisher surge_pub, ros::Publisher yaw_pub, ros::ServiceClient mode_client) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method that given an array of doubles, updates the gains of the controller. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish the data from the path following. virtual void start () override Method used to start the algorithm in the first run. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPramod/#additional-inherited-members","text":"Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. virtual bool resetVirtualTarget (float value) Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) bool resetVirtualTarget () Method to reset the virtual target of the vehicle (gamma) to zero. Not all controllers need this (example: Samson , Fossen which use the closest point) void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPramod/#detailed-description","text":"class Pramod; Path following using Pramod 's algorithm for path following*. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This algorithm support: Controls: yaw surge Supports Cooperative Path Following - True Contains Currents Observers - False","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPramod/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPramod/#function-pramod","text":"Pramod( std::vector< double > gains, ros::Publisher surge_pub, ros::Publisher yaw_pub, ros::ServiceClient mode_client ) Constructor method for the Path Following class. Parameters : gains A vector with the gains of the controller (2 gains only - Kp and Kd) surge_pub The ROS surge publisher yaw_pub The ROS yaw publisher mode_client The ROS service client to change the mode of operation of the path (to the closest point)","title":"function Pramod"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPramod/#function-setpfgains","text":"virtual bool setPFGains( std::vector< double > gains ) override Method that given an array of doubles, updates the gains of the controller. Parameters : gains A vector of gains of the controller (only 2 gains Kp and Kd) Return : a boolean which represents the success of the operation Reimplements : PathFollowing::setPFGains","title":"function setPFGains"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPramod/#function-callpfcontroller","text":"virtual void callPFController( double dt ) override Method that implements the path following control law. Parameters : dt The time diference between the previous and current call (in seconds) Reimplements : PathFollowing::callPFController","title":"function callPFController"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPramod/#function-publish_private","text":"virtual void publish_private() override Method to publish the data from the path following. Reimplements : PathFollowing::publish_private","title":"function publish_private"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPramod/#function-start","text":"virtual void start() override Method used to start the algorithm in the first run. Reimplements : PathFollowing::start","title":"function start"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPramod/#function-stop","text":"virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : The success of the operation Reimplements : PathFollowing::stop","title":"function stop"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPramod/#function-reset","text":"virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset Updated on 2022-05-30 at 18:35:15 +0000","title":"function reset"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRelativeHeading/","text":"RelativeHeading Path following using RelativeHeading 's algorithm for path following*. More... #include <RelativeHeading.h> Inherits from PathFollowing Public Functions Name RelativeHeading (double kx, double ky, double kz, const Eigen::Vector2d & p_sat, double yaw_offset, ros::Publisher surge_pub, ros::Publisher sway_pub, ros::Publisher yaw_pub, ros::Publisher rabbit_pub) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method to update the gains, given a vector of doubles. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish_private the data from the path following. virtual void start () override Method used in the first run to do initial setup. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once. virtual bool resetVirtualTarget (float value) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Additional inherited members Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_ Detailed Description class RelativeHeading; Path following using RelativeHeading 's algorithm for path following*. Author : Francisco Rego Andre Potes Marcelo Jacinto Version : 1.0a Date : 2021 Copyright : MIT This algorithm support: Controls: yaw surge sway Supports Cooperative Path Following - True Contains Currents Observers - False Public Functions Documentation function RelativeHeading RelativeHeading( double kx, double ky, double kz, const Eigen::Vector2d & p_sat, double yaw_offset, ros::Publisher surge_pub, ros::Publisher sway_pub, ros::Publisher yaw_pub, ros::Publisher rabbit_pub ) Constructor method for the Path Following class. Parameters : surge_pub The ROS surge publisher sway_pub The ROS sway publisher yaw_pub The ROS yaw publisher rabbit_pub The ROS rabbit publisher function setPFGains virtual bool setPFGains( std::vector< double > gains ) override Method to update the gains, given a vector of doubles. Parameters : gains A vector of gains to update in the controller The default order is: TODO Return : a boolean which represents the success of the operation Reimplements : PathFollowing::setPFGains function callPFController virtual void callPFController( double dt ) override Method that implements the path following control law. Parameters : dt The time step between last call and current call (in seconds) Reimplements : PathFollowing::callPFController function publish_private virtual void publish_private() override Method to publish_private the data from the path following. Reimplements : PathFollowing::publish_private function start virtual void start() override Method used in the first run to do initial setup. Reimplements : PathFollowing::start function stop virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : The success of the operation Reimplements : PathFollowing::stop Check if the gamma is greater then the gamma max of the path If so, we have reached the end function reset virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset function resetVirtualTarget virtual bool resetVirtualTarget( float value ) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Return : Whether the reset was made successfully or not Reimplements : PathFollowing::resetVirtualTarget Updated on 2022-05-30 at 18:35:15 +0000","title":"RelativeHeading"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRelativeHeading/#relativeheading","text":"Path following using RelativeHeading 's algorithm for path following*. More... #include <RelativeHeading.h> Inherits from PathFollowing","title":"RelativeHeading"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRelativeHeading/#public-functions","text":"Name RelativeHeading (double kx, double ky, double kz, const Eigen::Vector2d & p_sat, double yaw_offset, ros::Publisher surge_pub, ros::Publisher sway_pub, ros::Publisher yaw_pub, ros::Publisher rabbit_pub) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method to update the gains, given a vector of doubles. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish_private the data from the path following. virtual void start () override Method used in the first run to do initial setup. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once. virtual bool resetVirtualTarget (float value) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRelativeHeading/#additional-inherited-members","text":"Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRelativeHeading/#detailed-description","text":"class RelativeHeading; Path following using RelativeHeading 's algorithm for path following*. Author : Francisco Rego Andre Potes Marcelo Jacinto Version : 1.0a Date : 2021 Copyright : MIT This algorithm support: Controls: yaw surge sway Supports Cooperative Path Following - True Contains Currents Observers - False","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRelativeHeading/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRelativeHeading/#function-relativeheading","text":"RelativeHeading( double kx, double ky, double kz, const Eigen::Vector2d & p_sat, double yaw_offset, ros::Publisher surge_pub, ros::Publisher sway_pub, ros::Publisher yaw_pub, ros::Publisher rabbit_pub ) Constructor method for the Path Following class. Parameters : surge_pub The ROS surge publisher sway_pub The ROS sway publisher yaw_pub The ROS yaw publisher rabbit_pub The ROS rabbit publisher","title":"function RelativeHeading"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRelativeHeading/#function-setpfgains","text":"virtual bool setPFGains( std::vector< double > gains ) override Method to update the gains, given a vector of doubles. Parameters : gains A vector of gains to update in the controller The default order is: TODO Return : a boolean which represents the success of the operation Reimplements : PathFollowing::setPFGains","title":"function setPFGains"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRelativeHeading/#function-callpfcontroller","text":"virtual void callPFController( double dt ) override Method that implements the path following control law. Parameters : dt The time step between last call and current call (in seconds) Reimplements : PathFollowing::callPFController","title":"function callPFController"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRelativeHeading/#function-publish_private","text":"virtual void publish_private() override Method to publish_private the data from the path following. Reimplements : PathFollowing::publish_private","title":"function publish_private"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRelativeHeading/#function-start","text":"virtual void start() override Method used in the first run to do initial setup. Reimplements : PathFollowing::start","title":"function start"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRelativeHeading/#function-stop","text":"virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : The success of the operation Reimplements : PathFollowing::stop Check if the gamma is greater then the gamma max of the path If so, we have reached the end","title":"function stop"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRelativeHeading/#function-reset","text":"virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset","title":"function reset"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRelativeHeading/#function-resetvirtualtarget","text":"virtual bool resetVirtualTarget( float value ) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Return : Whether the reset was made successfully or not Reimplements : PathFollowing::resetVirtualTarget Updated on 2022-05-30 at 18:35:15 +0000","title":"function resetVirtualTarget"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRomulo/","text":"Romulo Path following using Aguiar 's algorithm modified to also control sway instead of yaw_rate (by Romulo ) More... #include <Romulo.h> Inherits from PathFollowing Public Functions Name Romulo (std::vector< double > gains, ros::Publisher surge_pub, ros::Publisher sway_pub, ros::Publisher rabbit_pub) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method that given an array of doubles, updates the gains of the controller. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish the data from the path following. virtual void start () override Method to do initial setup for the first run. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once. virtual bool resetVirtualTarget (float value) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Additional inherited members Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_ Detailed Description class Romulo; Path following using Aguiar 's algorithm modified to also control sway instead of yaw_rate (by Romulo ) Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This algorithm support: Controls: surge sway virtual-target (gamma) Supports Cooperative Path Following - True Contains Currents Observers - False Public Functions Documentation function Romulo Romulo( std::vector< double > gains, ros::Publisher surge_pub, ros::Publisher sway_pub, ros::Publisher rabbit_pub ) Constructor method for the Path Following class. Parameters : gains The gains of the controller surge_pub The ROS publisher of surge sway_pub The ROS publisher of sway rabbit_pub The ROS publisher of the virtual rabbit function setPFGains virtual bool setPFGains( std::vector< double > gains ) override Method that given an array of doubles, updates the gains of the controller. Parameters : gains The gains of the controller Return : a boolean which represents the success of the operation Reimplements : PathFollowing::setPFGains function callPFController virtual void callPFController( double dt ) override Method that implements the path following control law. Parameters : dt The time difference between the current and previous call (in seconds) Reimplements : PathFollowing::callPFController function publish_private virtual void publish_private() override Method to publish the data from the path following. Reimplements : PathFollowing::publish_private function start virtual void start() override Method to do initial setup for the first run. Reimplements : PathFollowing::start function stop virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : The success of the operation Reimplements : PathFollowing::stop Check if the gamma is greater then the gamma max of the path If so, we have reached the end function reset virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset function resetVirtualTarget virtual bool resetVirtualTarget( float value ) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Return : Whether the reset was made successfully or not Reimplements : PathFollowing::resetVirtualTarget Updated on 2022-05-30 at 18:35:15 +0000","title":"Romulo"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRomulo/#romulo","text":"Path following using Aguiar 's algorithm modified to also control sway instead of yaw_rate (by Romulo ) More... #include <Romulo.h> Inherits from PathFollowing","title":"Romulo"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRomulo/#public-functions","text":"Name Romulo (std::vector< double > gains, ros::Publisher surge_pub, ros::Publisher sway_pub, ros::Publisher rabbit_pub) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method that given an array of doubles, updates the gains of the controller. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish the data from the path following. virtual void start () override Method to do initial setup for the first run. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once. virtual bool resetVirtualTarget (float value) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRomulo/#additional-inherited-members","text":"Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRomulo/#detailed-description","text":"class Romulo; Path following using Aguiar 's algorithm modified to also control sway instead of yaw_rate (by Romulo ) Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This algorithm support: Controls: surge sway virtual-target (gamma) Supports Cooperative Path Following - True Contains Currents Observers - False","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRomulo/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRomulo/#function-romulo","text":"Romulo( std::vector< double > gains, ros::Publisher surge_pub, ros::Publisher sway_pub, ros::Publisher rabbit_pub ) Constructor method for the Path Following class. Parameters : gains The gains of the controller surge_pub The ROS publisher of surge sway_pub The ROS publisher of sway rabbit_pub The ROS publisher of the virtual rabbit","title":"function Romulo"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRomulo/#function-setpfgains","text":"virtual bool setPFGains( std::vector< double > gains ) override Method that given an array of doubles, updates the gains of the controller. Parameters : gains The gains of the controller Return : a boolean which represents the success of the operation Reimplements : PathFollowing::setPFGains","title":"function setPFGains"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRomulo/#function-callpfcontroller","text":"virtual void callPFController( double dt ) override Method that implements the path following control law. Parameters : dt The time difference between the current and previous call (in seconds) Reimplements : PathFollowing::callPFController","title":"function callPFController"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRomulo/#function-publish_private","text":"virtual void publish_private() override Method to publish the data from the path following. Reimplements : PathFollowing::publish_private","title":"function publish_private"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRomulo/#function-start","text":"virtual void start() override Method to do initial setup for the first run. Reimplements : PathFollowing::start","title":"function start"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRomulo/#function-stop","text":"virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : The success of the operation Reimplements : PathFollowing::stop Check if the gamma is greater then the gamma max of the path If so, we have reached the end","title":"function stop"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRomulo/#function-reset","text":"virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset","title":"function reset"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRomulo/#function-resetvirtualtarget","text":"virtual bool resetVirtualTarget( float value ) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Return : Whether the reset was made successfully or not Reimplements : PathFollowing::resetVirtualTarget Updated on 2022-05-30 at 18:35:15 +0000","title":"function resetVirtualTarget"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classSamson/","text":"title: Samson summary: Path following using Lapierre's algorithm for path following Method1: based on the work of Samson (1993) Samson Path following using Lapierre 's algorithm for path following Method1: based on the work of Samson (1993) More... #include <Samson.h> Inherits from PathFollowing Public Functions Name Samson (double k1, double k2, double k3, double theta, double k_delta, ros::Publisher surge_pub, ros::Publisher yaw_rate_pub, ros::ServiceClient mode_client) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method that given a vector of doubles, updates the gains of the controller. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish the data from the path following. virtual void start () override Method to run in the first iteration of the path following algorithm. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once. Additional inherited members Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. virtual bool resetVirtualTarget (float value) Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) bool resetVirtualTarget () Method to reset the virtual target of the vehicle (gamma) to zero. Not all controllers need this (example: Samson , Fossen which use the closest point) void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_ Detailed Description class Samson; Path following using Lapierre 's algorithm for path following Method1: based on the work of Samson (1993) Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This algorithm support: Controls: yaw-rate surge Supports Cooperative Path Following - True Contains Currents Observers - False Public Functions Documentation function Samson Samson( double k1, double k2, double k3, double theta, double k_delta, ros::Publisher surge_pub, ros::Publisher yaw_rate_pub, ros::ServiceClient mode_client ) Constructor method for the Path Following class. Parameters : k1 The controller gain k2 The controller gain k3 The controller gain theta The controller gain k_delta The controller gain surge_pub The ROS surge publisher yaw_rate_pub The ROS yaw rate publisher mode_client The ROS service client to change the mode of operation of the path to be the closest point function setPFGains virtual bool setPFGains( std::vector< double > gains ) override Method that given a vector of doubles, updates the gains of the controller. Parameters : gains A vector of gains Return : a boolean which represents the success of the operation Reimplements : PathFollowing::setPFGains NOTE: The default order of the gains is k1, k2, k3, theta, k_delta function callPFController virtual void callPFController( double dt ) override Method that implements the path following control law. Reimplements : PathFollowing::callPFController function publish_private virtual void publish_private() override Method to publish the data from the path following. Reimplements : PathFollowing::publish_private function start virtual void start() override Method to run in the first iteration of the path following algorithm. Reimplements : PathFollowing::start function stop virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : The success of the operation Reimplements : PathFollowing::stop function reset virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset Updated on 2022-05-30 at 18:35:15 +0000","title":"classSamson"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classSamson/#samson","text":"Path following using Lapierre 's algorithm for path following Method1: based on the work of Samson (1993) More... #include <Samson.h> Inherits from PathFollowing","title":"Samson"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classSamson/#public-functions","text":"Name Samson (double k1, double k2, double k3, double theta, double k_delta, ros::Publisher surge_pub, ros::Publisher yaw_rate_pub, ros::ServiceClient mode_client) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method that given a vector of doubles, updates the gains of the controller. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish the data from the path following. virtual void start () override Method to run in the first iteration of the path following algorithm. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classSamson/#additional-inherited-members","text":"Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. virtual bool resetVirtualTarget (float value) Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) bool resetVirtualTarget () Method to reset the virtual target of the vehicle (gamma) to zero. Not all controllers need this (example: Samson , Fossen which use the closest point) void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classSamson/#detailed-description","text":"class Samson; Path following using Lapierre 's algorithm for path following Method1: based on the work of Samson (1993) Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This algorithm support: Controls: yaw-rate surge Supports Cooperative Path Following - True Contains Currents Observers - False","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classSamson/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classSamson/#function-samson","text":"Samson( double k1, double k2, double k3, double theta, double k_delta, ros::Publisher surge_pub, ros::Publisher yaw_rate_pub, ros::ServiceClient mode_client ) Constructor method for the Path Following class. Parameters : k1 The controller gain k2 The controller gain k3 The controller gain theta The controller gain k_delta The controller gain surge_pub The ROS surge publisher yaw_rate_pub The ROS yaw rate publisher mode_client The ROS service client to change the mode of operation of the path to be the closest point","title":"function Samson"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classSamson/#function-setpfgains","text":"virtual bool setPFGains( std::vector< double > gains ) override Method that given a vector of doubles, updates the gains of the controller. Parameters : gains A vector of gains Return : a boolean which represents the success of the operation Reimplements : PathFollowing::setPFGains NOTE: The default order of the gains is k1, k2, k3, theta, k_delta","title":"function setPFGains"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classSamson/#function-callpfcontroller","text":"virtual void callPFController( double dt ) override Method that implements the path following control law. Reimplements : PathFollowing::callPFController","title":"function callPFController"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classSamson/#function-publish_private","text":"virtual void publish_private() override Method to publish the data from the path following. Reimplements : PathFollowing::publish_private","title":"function publish_private"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classSamson/#function-start","text":"virtual void start() override Method to run in the first iteration of the path following algorithm. Reimplements : PathFollowing::start","title":"function start"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classSamson/#function-stop","text":"virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : The success of the operation Reimplements : PathFollowing::stop","title":"function stop"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classSamson/#function-reset","text":"virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset Updated on 2022-05-30 at 18:35:15 +0000","title":"function reset"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPFollowingDebug/","text":"PFollowingDebug Public Attributes Name std::string algorithm double cross_track_error double along_track_error double yaw double psi double gamma Public Attributes Documentation variable algorithm std::string algorithm; variable cross_track_error double cross_track_error {0.0}; variable along_track_error double along_track_error {0.0}; variable yaw double yaw {0.0}; variable psi double psi {0.0}; variable gamma double gamma {0.0}; Updated on 2022-05-30 at 18:35:15 +0000","title":"PFollowingDebug"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPFollowingDebug/#pfollowingdebug","text":"","title":"PFollowingDebug"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPFollowingDebug/#public-attributes","text":"Name std::string algorithm double cross_track_error double along_track_error double yaw double psi double gamma","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPFollowingDebug/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPFollowingDebug/#variable-algorithm","text":"std::string algorithm;","title":"variable algorithm"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPFollowingDebug/#variable-cross_track_error","text":"double cross_track_error {0.0};","title":"variable cross_track_error"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPFollowingDebug/#variable-along_track_error","text":"double along_track_error {0.0};","title":"variable along_track_error"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPFollowingDebug/#variable-yaw","text":"double yaw {0.0};","title":"variable yaw"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPFollowingDebug/#variable-psi","text":"double psi {0.0};","title":"variable psi"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPFollowingDebug/#variable-gamma","text":"double gamma {0.0}; Updated on 2022-05-30 at 18:35:15 +0000","title":"variable gamma"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/","text":"PathState A structure to hold the data of the path. More... #include <States.h> Public Attributes Name double gamma The value of gamma used in the computations for this values. Eigen::Vector3d pd Desired position and its derivatives. Eigen::Vector3d d_pd Eigen::Vector3d dd_pd double psi Other properties of the path such as the psi, curvature and tangent_norm. double curvature double tangent_norm double vd The desired speed for a given gamma. double d_vd double vehicle_speed double vc The correction speed for gamma (when cooperating with other vehicles. double gamma_min Properties related to the boundaries of the parameterization of the path. double gamma_max Detailed Description struct PathState; A structure to hold the data of the path. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT Public Attributes Documentation variable gamma double gamma {0.0}; The value of gamma used in the computations for this values. variable pd Eigen::Vector3d pd {0.0, 0.0, 0.0}; Desired position and its derivatives. variable d_pd Eigen::Vector3d d_pd {0.0, 0.0, 0.0}; variable dd_pd Eigen::Vector3d dd_pd {0.0, 0.0, 0.0}; variable psi double psi {0.0}; Other properties of the path such as the psi, curvature and tangent_norm. variable curvature double curvature {0.0}; variable tangent_norm double tangent_norm {0.0}; variable vd double vd {0.0}; The desired speed for a given gamma. variable d_vd double d_vd {0.0}; variable vehicle_speed double vehicle_speed {0.0}; variable vc double vc {0.0}; The correction speed for gamma (when cooperating with other vehicles. variable gamma_min double gamma_min {std::numeric_limits<double>::lowest()}; Properties related to the boundaries of the parameterization of the path. variable gamma_max double gamma_max {std::numeric_limits<double>::max()}; Updated on 2022-05-30 at 18:35:15 +0000","title":"PathState"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#pathstate","text":"A structure to hold the data of the path. More... #include <States.h>","title":"PathState"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#public-attributes","text":"Name double gamma The value of gamma used in the computations for this values. Eigen::Vector3d pd Desired position and its derivatives. Eigen::Vector3d d_pd Eigen::Vector3d dd_pd double psi Other properties of the path such as the psi, curvature and tangent_norm. double curvature double tangent_norm double vd The desired speed for a given gamma. double d_vd double vehicle_speed double vc The correction speed for gamma (when cooperating with other vehicles. double gamma_min Properties related to the boundaries of the parameterization of the path. double gamma_max","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#detailed-description","text":"struct PathState; A structure to hold the data of the path. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#variable-gamma","text":"double gamma {0.0}; The value of gamma used in the computations for this values.","title":"variable gamma"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#variable-pd","text":"Eigen::Vector3d pd {0.0, 0.0, 0.0}; Desired position and its derivatives.","title":"variable pd"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#variable-d_pd","text":"Eigen::Vector3d d_pd {0.0, 0.0, 0.0};","title":"variable d_pd"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#variable-dd_pd","text":"Eigen::Vector3d dd_pd {0.0, 0.0, 0.0};","title":"variable dd_pd"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#variable-psi","text":"double psi {0.0}; Other properties of the path such as the psi, curvature and tangent_norm.","title":"variable psi"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#variable-curvature","text":"double curvature {0.0};","title":"variable curvature"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#variable-tangent_norm","text":"double tangent_norm {0.0};","title":"variable tangent_norm"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#variable-vd","text":"double vd {0.0}; The desired speed for a given gamma.","title":"variable vd"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#variable-d_vd","text":"double d_vd {0.0};","title":"variable d_vd"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#variable-vehicle_speed","text":"double vehicle_speed {0.0};","title":"variable vehicle_speed"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#variable-vc","text":"double vc {0.0}; The correction speed for gamma (when cooperating with other vehicles.","title":"variable vc"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#variable-gamma_min","text":"double gamma_min {std::numeric_limits<double>::lowest()}; Properties related to the boundaries of the parameterization of the path.","title":"variable gamma_min"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#variable-gamma_max","text":"double gamma_max {std::numeric_limits<double>::max()}; Updated on 2022-05-30 at 18:35:15 +0000","title":"variable gamma_max"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structVehicleState/","text":"VehicleState A structure to hold the state of the vehicle. More... #include <States.h> Public Attributes Name Eigen::Vector3d v1 Velocities in the body frame. Eigen::Vector3d v2 Eigen::Vector3d eta1 Positions and orientations in inertial frame. Eigen::Vector3d eta2 Detailed Description struct VehicleState; A structure to hold the state of the vehicle. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT Public Attributes Documentation variable v1 Eigen::Vector3d v1 {0.0, 0.0, 0.0}; Velocities in the body frame. variable v2 Eigen::Vector3d v2 {0.0, 0.0, 0.0}; variable eta1 Eigen::Vector3d eta1 {0.0, 0.0, 0.0}; Positions and orientations in inertial frame. variable eta2 Eigen::Vector3d eta2 {0.0, 0.0, 0.0}; Updated on 2022-05-30 at 18:35:15 +0000","title":"VehicleState"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structVehicleState/#vehiclestate","text":"A structure to hold the state of the vehicle. More... #include <States.h>","title":"VehicleState"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structVehicleState/#public-attributes","text":"Name Eigen::Vector3d v1 Velocities in the body frame. Eigen::Vector3d v2 Eigen::Vector3d eta1 Positions and orientations in inertial frame. Eigen::Vector3d eta2","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structVehicleState/#detailed-description","text":"struct VehicleState; A structure to hold the state of the vehicle. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structVehicleState/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structVehicleState/#variable-v1","text":"Eigen::Vector3d v1 {0.0, 0.0, 0.0}; Velocities in the body frame.","title":"variable v1"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structVehicleState/#variable-v2","text":"Eigen::Vector3d v2 {0.0, 0.0, 0.0};","title":"variable v2"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structVehicleState/#variable-eta1","text":"Eigen::Vector3d eta1 {0.0, 0.0, 0.0}; Positions and orientations in inertial frame.","title":"variable eta1"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structVehicleState/#variable-eta2","text":"Eigen::Vector3d eta2 {0.0, 0.0, 0.0}; Updated on 2022-05-30 at 18:35:15 +0000","title":"variable eta2"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:15 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:15 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:15 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:15 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Namespaces/","text":"Namespaces Updated on 2022-05-30 at 18:35:15 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Namespaces/#namespaces","text":"Updated on 2022-05-30 at 18:35:15 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/","text":"Classes struct Output_t Waypoint output struct. Contains orientation and linear and angular velocities. Not everything needs to be used. struct Vehicle_t Vehicle state struct. Contains position, orientation and linear and angular velocities. struct WPref_t Waypoint reference struct. Contains references for poistion and orientations. Not everything needs to be used. class WaypointController Abstract class of a waypoint controller. class WaypointNode ROS node class. class WpHeading Waypoint controller using surge, surge and yaw rate. Not only can go to waypoint and hold its position but can also maintain heading. class WpLoose Waypoint controller similar to standard, using surge and yaw (nose of the vehicle points to the desired position). The difference is that this one limits the rate of yaw reference. class WpStandard Waypoint controller using surge and yaw, where the nose of the vehicle points to the desired position. Updated on 2022-05-30 at 18:35:14 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/#classes","text":"struct Output_t Waypoint output struct. Contains orientation and linear and angular velocities. Not everything needs to be used. struct Vehicle_t Vehicle state struct. Contains position, orientation and linear and angular velocities. struct WPref_t Waypoint reference struct. Contains references for poistion and orientations. Not everything needs to be used. class WaypointController Abstract class of a waypoint controller. class WaypointNode ROS node class. class WpHeading Waypoint controller using surge, surge and yaw rate. Not only can go to waypoint and hold its position but can also maintain heading. class WpLoose Waypoint controller similar to standard, using surge and yaw (nose of the vehicle points to the desired position). The difference is that this one limits the rate of yaw reference. class WpStandard Waypoint controller using surge and yaw, where the nose of the vehicle points to the desired position. Updated on 2022-05-30 at 18:35:14 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/","text":"WaypointController Abstract class of a waypoint controller. #include <wp_controller.h> Inherited by WpHeading , WpLoose , WpStandard Public Functions Name WaypointController () virtual ~WaypointController () void setFrequency (const double & f) Mutator for setting the controller period. void setGains (const std::vector< double > & gains) Mutator for updating the gains. void compute ( Vehicle_t state, WPref_t wp_ref) Computes and publishes the output of the controller. Protected Functions Name virtual void publish () =0 Virtual function to publish the output of the controller. virtual void calculateRef ( Vehicle_t state, WPref_t wp_ref) =0 Virtual function to compute the waypoint controller. double getYawOut () Getter of the yaw reference (output of controller) double getYawrateOut () Getter of the yaw rate reference (output of controller) double getSurgeOut () Getter of the surge reference (output of controller) double getSwayOut () Getter of the sway reference (output of controller) void setYawOut (const double & value) Yaw reference setter (output of controller) void setYawrateOut (const double & value) Yaw rate reference setter (output of controller) void setSurgeOut (const double & value) Surge reference setter (output of controller) void setSwayOut (const double & value) Sway reference setter (output of controller) Protected Attributes Name double ts_ std::vector< double > gains_ Public Functions Documentation function WaypointController inline WaypointController() function ~WaypointController inline virtual ~WaypointController() function setFrequency inline void setFrequency( const double & f ) Mutator for setting the controller period. Parameters : f frequency of the main loop function setGains inline void setGains( const std::vector< double > & gains ) Mutator for updating the gains. Parameters : gains parameters of the waypoiny controller function compute inline void compute( Vehicle_t state, WPref_t wp_ref ) Computes and publishes the output of the controller. Parameters : state wp_ref Protected Functions Documentation function publish virtual void publish() =0 Virtual function to publish the output of the controller. Reimplemented by : WpLoose::publish , WpHeading::publish , WpStandard::publish function calculateRef virtual void calculateRef( Vehicle_t state, WPref_t wp_ref ) =0 Virtual function to compute the waypoint controller. Parameters : state wp_ref Reimplemented by : WpLoose::calculateRef , WpHeading::calculateRef , WpStandard::calculateRef function getYawOut inline double getYawOut() Getter of the yaw reference (output of controller) Return : yaw ref function getYawrateOut inline double getYawrateOut() Getter of the yaw rate reference (output of controller) Return : yaw rate ref function getSurgeOut inline double getSurgeOut() Getter of the surge reference (output of controller) Return : surge ref function getSwayOut inline double getSwayOut() Getter of the sway reference (output of controller) Return : sway ref function setYawOut inline void setYawOut( const double & value ) Yaw reference setter (output of controller) Parameters : value yaw ref function setYawrateOut inline void setYawrateOut( const double & value ) Yaw rate reference setter (output of controller) Parameters : value yaw rate ref function setSurgeOut inline void setSurgeOut( const double & value ) Surge reference setter (output of controller) Parameters : value surge ref function setSwayOut inline void setSwayOut( const double & value ) Sway reference setter (output of controller) Parameters : value sway ref Protected Attributes Documentation variable ts_ double ts_ {0.0}; variable gains_ std::vector< double > gains_; Updated on 2022-05-30 at 18:35:14 +0000","title":"WaypointController"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#waypointcontroller","text":"Abstract class of a waypoint controller. #include <wp_controller.h> Inherited by WpHeading , WpLoose , WpStandard","title":"WaypointController"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#public-functions","text":"Name WaypointController () virtual ~WaypointController () void setFrequency (const double & f) Mutator for setting the controller period. void setGains (const std::vector< double > & gains) Mutator for updating the gains. void compute ( Vehicle_t state, WPref_t wp_ref) Computes and publishes the output of the controller.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#protected-functions","text":"Name virtual void publish () =0 Virtual function to publish the output of the controller. virtual void calculateRef ( Vehicle_t state, WPref_t wp_ref) =0 Virtual function to compute the waypoint controller. double getYawOut () Getter of the yaw reference (output of controller) double getYawrateOut () Getter of the yaw rate reference (output of controller) double getSurgeOut () Getter of the surge reference (output of controller) double getSwayOut () Getter of the sway reference (output of controller) void setYawOut (const double & value) Yaw reference setter (output of controller) void setYawrateOut (const double & value) Yaw rate reference setter (output of controller) void setSurgeOut (const double & value) Surge reference setter (output of controller) void setSwayOut (const double & value) Sway reference setter (output of controller)","title":"Protected Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#protected-attributes","text":"Name double ts_ std::vector< double > gains_","title":"Protected Attributes"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#function-waypointcontroller","text":"inline WaypointController()","title":"function WaypointController"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#function-waypointcontroller_1","text":"inline virtual ~WaypointController()","title":"function ~WaypointController"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#function-setfrequency","text":"inline void setFrequency( const double & f ) Mutator for setting the controller period. Parameters : f frequency of the main loop","title":"function setFrequency"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#function-setgains","text":"inline void setGains( const std::vector< double > & gains ) Mutator for updating the gains. Parameters : gains parameters of the waypoiny controller","title":"function setGains"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#function-compute","text":"inline void compute( Vehicle_t state, WPref_t wp_ref ) Computes and publishes the output of the controller. Parameters : state wp_ref","title":"function compute"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#function-publish","text":"virtual void publish() =0 Virtual function to publish the output of the controller. Reimplemented by : WpLoose::publish , WpHeading::publish , WpStandard::publish","title":"function publish"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#function-calculateref","text":"virtual void calculateRef( Vehicle_t state, WPref_t wp_ref ) =0 Virtual function to compute the waypoint controller. Parameters : state wp_ref Reimplemented by : WpLoose::calculateRef , WpHeading::calculateRef , WpStandard::calculateRef","title":"function calculateRef"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#function-getyawout","text":"inline double getYawOut() Getter of the yaw reference (output of controller) Return : yaw ref","title":"function getYawOut"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#function-getyawrateout","text":"inline double getYawrateOut() Getter of the yaw rate reference (output of controller) Return : yaw rate ref","title":"function getYawrateOut"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#function-getsurgeout","text":"inline double getSurgeOut() Getter of the surge reference (output of controller) Return : surge ref","title":"function getSurgeOut"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#function-getswayout","text":"inline double getSwayOut() Getter of the sway reference (output of controller) Return : sway ref","title":"function getSwayOut"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#function-setyawout","text":"inline void setYawOut( const double & value ) Yaw reference setter (output of controller) Parameters : value yaw ref","title":"function setYawOut"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#function-setyawrateout","text":"inline void setYawrateOut( const double & value ) Yaw rate reference setter (output of controller) Parameters : value yaw rate ref","title":"function setYawrateOut"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#function-setsurgeout","text":"inline void setSurgeOut( const double & value ) Surge reference setter (output of controller) Parameters : value surge ref","title":"function setSurgeOut"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#function-setswayout","text":"inline void setSwayOut( const double & value ) Sway reference setter (output of controller) Parameters : value sway ref","title":"function setSwayOut"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#variable-ts_","text":"double ts_ {0.0};","title":"variable ts_"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#variable-gains_","text":"std::vector< double > gains_; Updated on 2022-05-30 at 18:35:14 +0000","title":"variable gains_"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointNode/","text":"WaypointNode ROS node class. #include <waypoint.h> Public Functions Name WaypointNode (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehanle_private) ~WaypointNode () Public Functions Documentation function WaypointNode WaypointNode( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehanle_private ) function ~WaypointNode ~WaypointNode() Updated on 2022-05-30 at 18:35:14 +0000","title":"WaypointNode"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointNode/#waypointnode","text":"ROS node class. #include <waypoint.h>","title":"WaypointNode"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointNode/#public-functions","text":"Name WaypointNode (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehanle_private) ~WaypointNode ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointNode/#function-waypointnode","text":"WaypointNode( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehanle_private )","title":"function WaypointNode"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointNode/#function-waypointnode_1","text":"~WaypointNode() Updated on 2022-05-30 at 18:35:14 +0000","title":"function ~WaypointNode"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpHeading/","text":"WpHeading Waypoint controller using surge, surge and yaw rate. Not only can go to waypoint and hold its position but can also maintain heading. #include <wp_heading.h> Inherits from WaypointController Public Functions Name WpHeading (ros::Publisher surge_pub, ros::Publisher sway_pub, ros::Publisher yaw_rate_pub) virtual ~WpHeading () Additional inherited members Public Functions inherited from WaypointController Name WaypointController () virtual ~WaypointController () void setFrequency (const double & f) Mutator for setting the controller period. void setGains (const std::vector< double > & gains) Mutator for updating the gains. void compute ( Vehicle_t state, WPref_t wp_ref) Computes and publishes the output of the controller. Protected Functions inherited from WaypointController Name double getYawOut () Getter of the yaw reference (output of controller) double getYawrateOut () Getter of the yaw rate reference (output of controller) double getSurgeOut () Getter of the surge reference (output of controller) double getSwayOut () Getter of the sway reference (output of controller) void setYawOut (const double & value) Yaw reference setter (output of controller) void setYawrateOut (const double & value) Yaw rate reference setter (output of controller) void setSurgeOut (const double & value) Surge reference setter (output of controller) void setSwayOut (const double & value) Sway reference setter (output of controller) Protected Attributes inherited from WaypointController Name double ts_ std::vector< double > gains_ Public Functions Documentation function WpHeading WpHeading( ros::Publisher surge_pub, ros::Publisher sway_pub, ros::Publisher yaw_rate_pub ) function ~WpHeading inline virtual ~WpHeading() Updated on 2022-05-30 at 18:35:14 +0000","title":"WpHeading"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpHeading/#wpheading","text":"Waypoint controller using surge, surge and yaw rate. Not only can go to waypoint and hold its position but can also maintain heading. #include <wp_heading.h> Inherits from WaypointController","title":"WpHeading"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpHeading/#public-functions","text":"Name WpHeading (ros::Publisher surge_pub, ros::Publisher sway_pub, ros::Publisher yaw_rate_pub) virtual ~WpHeading ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpHeading/#additional-inherited-members","text":"Public Functions inherited from WaypointController Name WaypointController () virtual ~WaypointController () void setFrequency (const double & f) Mutator for setting the controller period. void setGains (const std::vector< double > & gains) Mutator for updating the gains. void compute ( Vehicle_t state, WPref_t wp_ref) Computes and publishes the output of the controller. Protected Functions inherited from WaypointController Name double getYawOut () Getter of the yaw reference (output of controller) double getYawrateOut () Getter of the yaw rate reference (output of controller) double getSurgeOut () Getter of the surge reference (output of controller) double getSwayOut () Getter of the sway reference (output of controller) void setYawOut (const double & value) Yaw reference setter (output of controller) void setYawrateOut (const double & value) Yaw rate reference setter (output of controller) void setSurgeOut (const double & value) Surge reference setter (output of controller) void setSwayOut (const double & value) Sway reference setter (output of controller) Protected Attributes inherited from WaypointController Name double ts_ std::vector< double > gains_","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpHeading/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpHeading/#function-wpheading","text":"WpHeading( ros::Publisher surge_pub, ros::Publisher sway_pub, ros::Publisher yaw_rate_pub )","title":"function WpHeading"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpHeading/#function-wpheading_1","text":"inline virtual ~WpHeading() Updated on 2022-05-30 at 18:35:14 +0000","title":"function ~WpHeading"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpLoose/","text":"WpLoose Waypoint controller similar to standard, using surge and yaw (nose of the vehicle points to the desired position). The difference is that this one limits the rate of yaw reference. #include <wp_loose.h> Inherits from WaypointController Public Functions Name WpLoose (ros::Publisher surge_pub, ros::Publisher yaw_pub) virtual ~WpLoose () Additional inherited members Public Functions inherited from WaypointController Name WaypointController () virtual ~WaypointController () void setFrequency (const double & f) Mutator for setting the controller period. void setGains (const std::vector< double > & gains) Mutator for updating the gains. void compute ( Vehicle_t state, WPref_t wp_ref) Computes and publishes the output of the controller. Protected Functions inherited from WaypointController Name double getYawOut () Getter of the yaw reference (output of controller) double getYawrateOut () Getter of the yaw rate reference (output of controller) double getSurgeOut () Getter of the surge reference (output of controller) double getSwayOut () Getter of the sway reference (output of controller) void setYawOut (const double & value) Yaw reference setter (output of controller) void setYawrateOut (const double & value) Yaw rate reference setter (output of controller) void setSurgeOut (const double & value) Surge reference setter (output of controller) void setSwayOut (const double & value) Sway reference setter (output of controller) Protected Attributes inherited from WaypointController Name double ts_ std::vector< double > gains_ Public Functions Documentation function WpLoose WpLoose( ros::Publisher surge_pub, ros::Publisher yaw_pub ) function ~WpLoose inline virtual ~WpLoose() Updated on 2022-05-30 at 18:35:14 +0000","title":"WpLoose"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpLoose/#wploose","text":"Waypoint controller similar to standard, using surge and yaw (nose of the vehicle points to the desired position). The difference is that this one limits the rate of yaw reference. #include <wp_loose.h> Inherits from WaypointController","title":"WpLoose"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpLoose/#public-functions","text":"Name WpLoose (ros::Publisher surge_pub, ros::Publisher yaw_pub) virtual ~WpLoose ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpLoose/#additional-inherited-members","text":"Public Functions inherited from WaypointController Name WaypointController () virtual ~WaypointController () void setFrequency (const double & f) Mutator for setting the controller period. void setGains (const std::vector< double > & gains) Mutator for updating the gains. void compute ( Vehicle_t state, WPref_t wp_ref) Computes and publishes the output of the controller. Protected Functions inherited from WaypointController Name double getYawOut () Getter of the yaw reference (output of controller) double getYawrateOut () Getter of the yaw rate reference (output of controller) double getSurgeOut () Getter of the surge reference (output of controller) double getSwayOut () Getter of the sway reference (output of controller) void setYawOut (const double & value) Yaw reference setter (output of controller) void setYawrateOut (const double & value) Yaw rate reference setter (output of controller) void setSurgeOut (const double & value) Surge reference setter (output of controller) void setSwayOut (const double & value) Sway reference setter (output of controller) Protected Attributes inherited from WaypointController Name double ts_ std::vector< double > gains_","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpLoose/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpLoose/#function-wploose","text":"WpLoose( ros::Publisher surge_pub, ros::Publisher yaw_pub )","title":"function WpLoose"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpLoose/#function-wploose_1","text":"inline virtual ~WpLoose() Updated on 2022-05-30 at 18:35:14 +0000","title":"function ~WpLoose"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpStandard/","text":"WpStandard Waypoint controller using surge and yaw, where the nose of the vehicle points to the desired position. #include <wp_standard.h> Inherits from WaypointController Public Functions Name WpStandard (ros::Publisher surge_pub, ros::Publisher yaw_pub) virtual ~WpStandard () Additional inherited members Public Functions inherited from WaypointController Name WaypointController () virtual ~WaypointController () void setFrequency (const double & f) Mutator for setting the controller period. void setGains (const std::vector< double > & gains) Mutator for updating the gains. void compute ( Vehicle_t state, WPref_t wp_ref) Computes and publishes the output of the controller. Protected Functions inherited from WaypointController Name double getYawOut () Getter of the yaw reference (output of controller) double getYawrateOut () Getter of the yaw rate reference (output of controller) double getSurgeOut () Getter of the surge reference (output of controller) double getSwayOut () Getter of the sway reference (output of controller) void setYawOut (const double & value) Yaw reference setter (output of controller) void setYawrateOut (const double & value) Yaw rate reference setter (output of controller) void setSurgeOut (const double & value) Surge reference setter (output of controller) void setSwayOut (const double & value) Sway reference setter (output of controller) Protected Attributes inherited from WaypointController Name double ts_ std::vector< double > gains_ Public Functions Documentation function WpStandard WpStandard( ros::Publisher surge_pub, ros::Publisher yaw_pub ) function ~WpStandard inline virtual ~WpStandard() Updated on 2022-05-30 at 18:35:14 +0000","title":"WpStandard"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpStandard/#wpstandard","text":"Waypoint controller using surge and yaw, where the nose of the vehicle points to the desired position. #include <wp_standard.h> Inherits from WaypointController","title":"WpStandard"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpStandard/#public-functions","text":"Name WpStandard (ros::Publisher surge_pub, ros::Publisher yaw_pub) virtual ~WpStandard ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpStandard/#additional-inherited-members","text":"Public Functions inherited from WaypointController Name WaypointController () virtual ~WaypointController () void setFrequency (const double & f) Mutator for setting the controller period. void setGains (const std::vector< double > & gains) Mutator for updating the gains. void compute ( Vehicle_t state, WPref_t wp_ref) Computes and publishes the output of the controller. Protected Functions inherited from WaypointController Name double getYawOut () Getter of the yaw reference (output of controller) double getYawrateOut () Getter of the yaw rate reference (output of controller) double getSurgeOut () Getter of the surge reference (output of controller) double getSwayOut () Getter of the sway reference (output of controller) void setYawOut (const double & value) Yaw reference setter (output of controller) void setYawrateOut (const double & value) Yaw rate reference setter (output of controller) void setSurgeOut (const double & value) Surge reference setter (output of controller) void setSwayOut (const double & value) Sway reference setter (output of controller) Protected Attributes inherited from WaypointController Name double ts_ std::vector< double > gains_","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpStandard/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpStandard/#function-wpstandard","text":"WpStandard( ros::Publisher surge_pub, ros::Publisher yaw_pub )","title":"function WpStandard"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpStandard/#function-wpstandard_1","text":"inline virtual ~WpStandard() Updated on 2022-05-30 at 18:35:14 +0000","title":"function ~WpStandard"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structOutput__t/","text":"Output_t Waypoint output struct. Contains orientation and linear and angular velocities. Not everything needs to be used. #include <wp_controller.h> Public Attributes Name Eigen::Vector3d eta2 Eigen::Vector3d v1 Eigen::Vector3d v2 Public Attributes Documentation variable eta2 Eigen::Vector3d eta2 {0.0, 0.0, 0.0}; variable v1 Eigen::Vector3d v1 {0.0, 0.0, 0.0}; variable v2 Eigen::Vector3d v2 {0.0, 0.0, 0.0}; Updated on 2022-05-30 at 18:35:14 +0000","title":"Output_t"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structOutput__t/#output_t","text":"Waypoint output struct. Contains orientation and linear and angular velocities. Not everything needs to be used. #include <wp_controller.h>","title":"Output_t"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structOutput__t/#public-attributes","text":"Name Eigen::Vector3d eta2 Eigen::Vector3d v1 Eigen::Vector3d v2","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structOutput__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structOutput__t/#variable-eta2","text":"Eigen::Vector3d eta2 {0.0, 0.0, 0.0};","title":"variable eta2"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structOutput__t/#variable-v1","text":"Eigen::Vector3d v1 {0.0, 0.0, 0.0};","title":"variable v1"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structOutput__t/#variable-v2","text":"Eigen::Vector3d v2 {0.0, 0.0, 0.0}; Updated on 2022-05-30 at 18:35:14 +0000","title":"variable v2"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structVehicle__t/","text":"Vehicle_t Vehicle state struct. Contains position, orientation and linear and angular velocities. #include <wp_controller.h> Public Attributes Name Eigen::Vector3d eta1 Eigen::Vector3d eta2 Eigen::Vector3d v1 Eigen::Vector3d v2 Public Attributes Documentation variable eta1 Eigen::Vector3d eta1 {0.0, 0.0, 0.0}; variable eta2 Eigen::Vector3d eta2 {0.0, 0.0, 0.0}; variable v1 Eigen::Vector3d v1 {0.0, 0.0, 0.0}; variable v2 Eigen::Vector3d v2 {0.0, 0.0, 0.0}; Updated on 2022-05-30 at 18:35:14 +0000","title":"Vehicle_t"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structVehicle__t/#vehicle_t","text":"Vehicle state struct. Contains position, orientation and linear and angular velocities. #include <wp_controller.h>","title":"Vehicle_t"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structVehicle__t/#public-attributes","text":"Name Eigen::Vector3d eta1 Eigen::Vector3d eta2 Eigen::Vector3d v1 Eigen::Vector3d v2","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structVehicle__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structVehicle__t/#variable-eta1","text":"Eigen::Vector3d eta1 {0.0, 0.0, 0.0};","title":"variable eta1"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structVehicle__t/#variable-eta2","text":"Eigen::Vector3d eta2 {0.0, 0.0, 0.0};","title":"variable eta2"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structVehicle__t/#variable-v1","text":"Eigen::Vector3d v1 {0.0, 0.0, 0.0};","title":"variable v1"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structVehicle__t/#variable-v2","text":"Eigen::Vector3d v2 {0.0, 0.0, 0.0}; Updated on 2022-05-30 at 18:35:14 +0000","title":"variable v2"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structWPref__t/","text":"WPref_t Waypoint reference struct. Contains references for poistion and orientations. Not everything needs to be used. #include <wp_controller.h> Public Attributes Name Eigen::Vector3d eta1 Eigen::Vector3d eta2 Public Attributes Documentation variable eta1 Eigen::Vector3d eta1 {0.0, 0.0, 0.0}; variable eta2 Eigen::Vector3d eta2 {0.0, 0.0, 0.0}; Updated on 2022-05-30 at 18:35:14 +0000","title":"WPref_t"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structWPref__t/#wpref_t","text":"Waypoint reference struct. Contains references for poistion and orientations. Not everything needs to be used. #include <wp_controller.h>","title":"WPref_t"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structWPref__t/#public-attributes","text":"Name Eigen::Vector3d eta1 Eigen::Vector3d eta2","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structWPref__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structWPref__t/#variable-eta1","text":"Eigen::Vector3d eta1 {0.0, 0.0, 0.0};","title":"variable eta1"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structWPref__t/#variable-eta2","text":"Eigen::Vector3d eta2 {0.0, 0.0, 0.0}; Updated on 2022-05-30 at 18:35:14 +0000","title":"variable eta2"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:14 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:14 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:14 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:14 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Namespaces/","text":"Namespaces Updated on 2022-05-30 at 18:35:14 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Namespaces/#namespaces","text":"Updated on 2022-05-30 at 18:35:14 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Classes/","text":"Classes class ThrustAllocation ROS implementation of the thrust allocation. Receives forces applied to the vehicle and calculates the desired forces to each thruster based on the pseudo inverse of the thrust allocation matrix. Updated on 2022-05-30 at 18:35:11 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Classes/#classes","text":"class ThrustAllocation ROS implementation of the thrust allocation. Receives forces applied to the vehicle and calculates the desired forces to each thruster based on the pseudo inverse of the thrust allocation matrix. Updated on 2022-05-30 at 18:35:11 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Classes/classThrustAllocation/","text":"ThrustAllocation ROS implementation of the thrust allocation. Receives forces applied to the vehicle and calculates the desired forces to each thruster based on the pseudo inverse of the thrust allocation matrix. #include <thruster_allocation.h> Public Functions Name ThrustAllocation (ros::NodeHandle & nh) Thrust Allocation class constructor. void initializeSubscribers (ros::NodeHandle & nh) Function to initialize subscribers. void initializePublishers (ros::NodeHandle & nh) Function to initialize publishers. void loadParams (ros::NodeHandle & nh) Function to read parameters. Reads the thruster allocation matrix and computes its pseudo inverse. void saturateVector (Eigen::VectorXd & thr_thrust) Given a force vector for each thruster, saturate the norm of the vector based on the maximum force of the thruster. void readTAM (ros::NodeHandle & nh) Function to read a thruster allocation matrix and compute its pseudo inverse. void readCT (ros::NodeHandle & nh) Function to read the ct parameters (conversion from thrust to RPM and vice versa) void readRPMGain (ros::NodeHandle & nh) Function to read the actuators gain (RPM max value / 100). void thrusterAllocation (const auv_msgs::BodyForceRequest & msg) Callback function of the topic with the tau (force request) Public Functions Documentation function ThrustAllocation ThrustAllocation( ros::NodeHandle & nh ) Thrust Allocation class constructor. Parameters : nh ROS nodehandle to publish, subscribe and read relevant parameters function initializeSubscribers void initializeSubscribers( ros::NodeHandle & nh ) Function to initialize subscribers. Parameters : nh ROS nodehandle to publish, subscribe and read relevant function initializePublishers void initializePublishers( ros::NodeHandle & nh ) Function to initialize publishers. Parameters : nh ROS nodehandle to publish, subscribe and read relevant function loadParams void loadParams( ros::NodeHandle & nh ) Function to read parameters. Reads the thruster allocation matrix and computes its pseudo inverse. Parameters : nh ROS nodehandle to publish, subscribe and read relevant function saturateVector void saturateVector( Eigen::VectorXd & thr_thrust ) Given a force vector for each thruster, saturate the norm of the vector based on the maximum force of the thruster. function readTAM void readTAM( ros::NodeHandle & nh ) Function to read a thruster allocation matrix and compute its pseudo inverse. Parameters : nh function readCT void readCT( ros::NodeHandle & nh ) Function to read the ct parameters (conversion from thrust to RPM and vice versa) Parameters : nh function readRPMGain void readRPMGain( ros::NodeHandle & nh ) Function to read the actuators gain (RPM max value / 100). Parameters : nh function thrusterAllocation void thrusterAllocation( const auv_msgs::BodyForceRequest & msg ) Callback function of the topic with the tau (force request) Parameters : msg Variable containing the force request Updated on 2022-05-30 at 18:35:11 +0000","title":"ThrustAllocation"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Classes/classThrustAllocation/#thrustallocation","text":"ROS implementation of the thrust allocation. Receives forces applied to the vehicle and calculates the desired forces to each thruster based on the pseudo inverse of the thrust allocation matrix. #include <thruster_allocation.h>","title":"ThrustAllocation"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Classes/classThrustAllocation/#public-functions","text":"Name ThrustAllocation (ros::NodeHandle & nh) Thrust Allocation class constructor. void initializeSubscribers (ros::NodeHandle & nh) Function to initialize subscribers. void initializePublishers (ros::NodeHandle & nh) Function to initialize publishers. void loadParams (ros::NodeHandle & nh) Function to read parameters. Reads the thruster allocation matrix and computes its pseudo inverse. void saturateVector (Eigen::VectorXd & thr_thrust) Given a force vector for each thruster, saturate the norm of the vector based on the maximum force of the thruster. void readTAM (ros::NodeHandle & nh) Function to read a thruster allocation matrix and compute its pseudo inverse. void readCT (ros::NodeHandle & nh) Function to read the ct parameters (conversion from thrust to RPM and vice versa) void readRPMGain (ros::NodeHandle & nh) Function to read the actuators gain (RPM max value / 100). void thrusterAllocation (const auv_msgs::BodyForceRequest & msg) Callback function of the topic with the tau (force request)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Classes/classThrustAllocation/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Classes/classThrustAllocation/#function-thrustallocation","text":"ThrustAllocation( ros::NodeHandle & nh ) Thrust Allocation class constructor. Parameters : nh ROS nodehandle to publish, subscribe and read relevant parameters","title":"function ThrustAllocation"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Classes/classThrustAllocation/#function-initializesubscribers","text":"void initializeSubscribers( ros::NodeHandle & nh ) Function to initialize subscribers. Parameters : nh ROS nodehandle to publish, subscribe and read relevant","title":"function initializeSubscribers"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Classes/classThrustAllocation/#function-initializepublishers","text":"void initializePublishers( ros::NodeHandle & nh ) Function to initialize publishers. Parameters : nh ROS nodehandle to publish, subscribe and read relevant","title":"function initializePublishers"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Classes/classThrustAllocation/#function-loadparams","text":"void loadParams( ros::NodeHandle & nh ) Function to read parameters. Reads the thruster allocation matrix and computes its pseudo inverse. Parameters : nh ROS nodehandle to publish, subscribe and read relevant","title":"function loadParams"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Classes/classThrustAllocation/#function-saturatevector","text":"void saturateVector( Eigen::VectorXd & thr_thrust ) Given a force vector for each thruster, saturate the norm of the vector based on the maximum force of the thruster.","title":"function saturateVector"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Classes/classThrustAllocation/#function-readtam","text":"void readTAM( ros::NodeHandle & nh ) Function to read a thruster allocation matrix and compute its pseudo inverse. Parameters : nh","title":"function readTAM"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Classes/classThrustAllocation/#function-readct","text":"void readCT( ros::NodeHandle & nh ) Function to read the ct parameters (conversion from thrust to RPM and vice versa) Parameters : nh","title":"function readCT"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Classes/classThrustAllocation/#function-readrpmgain","text":"void readRPMGain( ros::NodeHandle & nh ) Function to read the actuators gain (RPM max value / 100). Parameters : nh","title":"function readRPMGain"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Classes/classThrustAllocation/#function-thrusterallocation","text":"void thrusterAllocation( const auv_msgs::BodyForceRequest & msg ) Callback function of the topic with the tau (force request) Parameters : msg Variable containing the force request Updated on 2022-05-30 at 18:35:11 +0000","title":"function thrusterAllocation"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:11 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:11 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:11 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:11 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Namespaces/","text":"Namespaces Updated on 2022-05-30 at 18:35:11 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Namespaces/#namespaces","text":"Updated on 2022-05-30 at 18:35:11 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_control/vehicle_stabilizer/Classes/","text":"Classes class VehicleStabilizerNode Updated on 2022-05-30 at 18:35:14 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_control/vehicle_stabilizer/Classes/#classes","text":"class VehicleStabilizerNode Updated on 2022-05-30 at 18:35:14 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_control/vehicle_stabilizer/Classes/classVehicleStabilizerNode/","text":"VehicleStabilizerNode Public Functions Name VehicleStabilizerNode (ros::NodeHandle * nh, ros::NodeHandle * nh_p) ~VehicleStabilizerNode () Public Functions Documentation function VehicleStabilizerNode VehicleStabilizerNode( ros::NodeHandle * nh, ros::NodeHandle * nh_p ) Parameters : nh The public ROS nodehandle nh_p The private ROS nodehandle function ~VehicleStabilizerNode ~VehicleStabilizerNode() Destructor of the VehicleStabilizerNode class Updated on 2022-05-30 at 18:35:14 +0000","title":"VehicleStabilizerNode"},{"location":"api/markdown/medusa_base/medusa_control/vehicle_stabilizer/Classes/classVehicleStabilizerNode/#vehiclestabilizernode","text":"","title":"VehicleStabilizerNode"},{"location":"api/markdown/medusa_base/medusa_control/vehicle_stabilizer/Classes/classVehicleStabilizerNode/#public-functions","text":"Name VehicleStabilizerNode (ros::NodeHandle * nh, ros::NodeHandle * nh_p) ~VehicleStabilizerNode ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/vehicle_stabilizer/Classes/classVehicleStabilizerNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/vehicle_stabilizer/Classes/classVehicleStabilizerNode/#function-vehiclestabilizernode","text":"VehicleStabilizerNode( ros::NodeHandle * nh, ros::NodeHandle * nh_p ) Parameters : nh The public ROS nodehandle nh_p The private ROS nodehandle","title":"function VehicleStabilizerNode"},{"location":"api/markdown/medusa_base/medusa_control/vehicle_stabilizer/Classes/classVehicleStabilizerNode/#function-vehiclestabilizernode_1","text":"~VehicleStabilizerNode() Destructor of the VehicleStabilizerNode class Updated on 2022-05-30 at 18:35:14 +0000","title":"function ~VehicleStabilizerNode"},{"location":"api/markdown/medusa_base/medusa_control/vehicle_stabilizer/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:14 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_control/vehicle_stabilizer/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:14 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_control/vehicle_stabilizer/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:14 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_control/vehicle_stabilizer/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:14 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_control/vehicle_stabilizer/Namespaces/","text":"Namespaces Updated on 2022-05-30 at 18:35:14 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_control/vehicle_stabilizer/Namespaces/#namespaces","text":"Updated on 2022-05-30 at 18:35:14 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/","text":"Classes class AuvState2mState class Gnss2Utm class Gnss2UtmOutlier class LowPassFilter class SmoothState class UsblFix2Pos Updated on 2022-05-30 at 18:35:09 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/#classes","text":"class AuvState2mState class Gnss2Utm class Gnss2UtmOutlier class LowPassFilter class SmoothState class UsblFix2Pos Updated on 2022-05-30 at 18:35:09 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classAuvState2mState/","text":"AuvState2mState Public Functions Name AuvState2mState (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~AuvState2mState () Public Functions Documentation function AuvState2mState AuvState2mState( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private ) function ~AuvState2mState ~AuvState2mState() Updated on 2022-05-30 at 18:35:09 +0000","title":"AuvState2mState"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classAuvState2mState/#auvstate2mstate","text":"","title":"AuvState2mState"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classAuvState2mState/#public-functions","text":"Name AuvState2mState (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~AuvState2mState ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classAuvState2mState/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classAuvState2mState/#function-auvstate2mstate","text":"AuvState2mState( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private )","title":"function AuvState2mState"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classAuvState2mState/#function-auvstate2mstate_1","text":"~AuvState2mState() Updated on 2022-05-30 at 18:35:09 +0000","title":"function ~AuvState2mState"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classGnss2Utm/","text":"Gnss2Utm Public Functions Name Gnss2Utm (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~Gnss2Utm () Public Functions Documentation function Gnss2Utm Gnss2Utm( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private ) function ~Gnss2Utm ~Gnss2Utm() Updated on 2022-05-30 at 18:35:09 +0000","title":"Gnss2Utm"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classGnss2Utm/#gnss2utm","text":"","title":"Gnss2Utm"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classGnss2Utm/#public-functions","text":"Name Gnss2Utm (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~Gnss2Utm ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classGnss2Utm/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classGnss2Utm/#function-gnss2utm","text":"Gnss2Utm( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private )","title":"function Gnss2Utm"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classGnss2Utm/#function-gnss2utm_1","text":"~Gnss2Utm() Updated on 2022-05-30 at 18:35:09 +0000","title":"function ~Gnss2Utm"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classGnss2UtmOutlier/","text":"Gnss2UtmOutlier Public Functions Name Gnss2UtmOutlier (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~Gnss2UtmOutlier () Public Functions Documentation function Gnss2UtmOutlier Gnss2UtmOutlier( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private ) function ~Gnss2UtmOutlier ~Gnss2UtmOutlier() Updated on 2022-05-30 at 18:35:09 +0000","title":"Gnss2UtmOutlier"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classGnss2UtmOutlier/#gnss2utmoutlier","text":"","title":"Gnss2UtmOutlier"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classGnss2UtmOutlier/#public-functions","text":"Name Gnss2UtmOutlier (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~Gnss2UtmOutlier ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classGnss2UtmOutlier/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classGnss2UtmOutlier/#function-gnss2utmoutlier","text":"Gnss2UtmOutlier( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private )","title":"function Gnss2UtmOutlier"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classGnss2UtmOutlier/#function-gnss2utmoutlier_1","text":"~Gnss2UtmOutlier() Updated on 2022-05-30 at 18:35:09 +0000","title":"function ~Gnss2UtmOutlier"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/","text":"LowPassFilter Public Functions Name LowPassFilter () LowPassFilter (double wn, double qsi) LowPassFilter (double wn, double qsi, bool initialize_on_first) LowPassFilter (double wn, double qsi, double var_init, double var_dot_init) ~LowPassFilter () std::pair< double, double > update (double measurement) std::pair< double, double > predict () Public Attributes Name bool initialized Protected Attributes Name double wn double qsi double K1 double K2 std::pair< double, double > estimate ros::Time last_Update Public Functions Documentation function LowPassFilter inline LowPassFilter() function LowPassFilter inline LowPassFilter( double wn, double qsi ) function LowPassFilter inline LowPassFilter( double wn, double qsi, bool initialize_on_first ) function LowPassFilter inline LowPassFilter( double wn, double qsi, double var_init, double var_dot_init ) function ~LowPassFilter inline ~LowPassFilter() function update inline std::pair< double, double > update( double measurement ) function predict inline std::pair< double, double > predict() Public Attributes Documentation variable initialized bool initialized; Protected Attributes Documentation variable wn double wn; variable qsi double qsi; variable K1 double K1; variable K2 double K2; variable estimate std::pair< double, double > estimate; variable last_Update ros::Time last_Update; Updated on 2022-05-30 at 18:35:09 +0000","title":"LowPassFilter"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#lowpassfilter","text":"","title":"LowPassFilter"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#public-functions","text":"Name LowPassFilter () LowPassFilter (double wn, double qsi) LowPassFilter (double wn, double qsi, bool initialize_on_first) LowPassFilter (double wn, double qsi, double var_init, double var_dot_init) ~LowPassFilter () std::pair< double, double > update (double measurement) std::pair< double, double > predict ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#public-attributes","text":"Name bool initialized","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#protected-attributes","text":"Name double wn double qsi double K1 double K2 std::pair< double, double > estimate ros::Time last_Update","title":"Protected Attributes"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#function-lowpassfilter","text":"inline LowPassFilter()","title":"function LowPassFilter"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#function-lowpassfilter_1","text":"inline LowPassFilter( double wn, double qsi )","title":"function LowPassFilter"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#function-lowpassfilter_2","text":"inline LowPassFilter( double wn, double qsi, bool initialize_on_first )","title":"function LowPassFilter"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#function-lowpassfilter_3","text":"inline LowPassFilter( double wn, double qsi, double var_init, double var_dot_init )","title":"function LowPassFilter"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#function-lowpassfilter_4","text":"inline ~LowPassFilter()","title":"function ~LowPassFilter"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#function-update","text":"inline std::pair< double, double > update( double measurement )","title":"function update"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#function-predict","text":"inline std::pair< double, double > predict()","title":"function predict"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#variable-initialized","text":"bool initialized;","title":"variable initialized"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#variable-wn","text":"double wn;","title":"variable wn"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#variable-qsi","text":"double qsi;","title":"variable qsi"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#variable-k1","text":"double K1;","title":"variable K1"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#variable-k2","text":"double K2;","title":"variable K2"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#variable-estimate","text":"std::pair< double, double > estimate;","title":"variable estimate"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#variable-last_update","text":"ros::Time last_Update; Updated on 2022-05-30 at 18:35:09 +0000","title":"variable last_Update"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classSmoothState/","text":"SmoothState Public Functions Name SmoothState (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~SmoothState () Public Functions Documentation function SmoothState SmoothState( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private ) function ~SmoothState ~SmoothState() Updated on 2022-05-30 at 18:35:09 +0000","title":"SmoothState"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classSmoothState/#smoothstate","text":"","title":"SmoothState"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classSmoothState/#public-functions","text":"Name SmoothState (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~SmoothState ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classSmoothState/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classSmoothState/#function-smoothstate","text":"SmoothState( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private )","title":"function SmoothState"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classSmoothState/#function-smoothstate_1","text":"~SmoothState() Updated on 2022-05-30 at 18:35:09 +0000","title":"function ~SmoothState"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classUsblFix2Pos/","text":"UsblFix2Pos Public Functions Name UsblFix2Pos (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~UsblFix2Pos () Public Functions Documentation function UsblFix2Pos UsblFix2Pos( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private ) function ~UsblFix2Pos ~UsblFix2Pos() Updated on 2022-05-30 at 18:35:09 +0000","title":"UsblFix2Pos"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classUsblFix2Pos/#usblfix2pos","text":"","title":"UsblFix2Pos"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classUsblFix2Pos/#public-functions","text":"Name UsblFix2Pos (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~UsblFix2Pos ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classUsblFix2Pos/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classUsblFix2Pos/#function-usblfix2pos","text":"UsblFix2Pos( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private )","title":"function UsblFix2Pos"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classUsblFix2Pos/#function-usblfix2pos_1","text":"~UsblFix2Pos() Updated on 2022-05-30 at 18:35:09 +0000","title":"function ~UsblFix2Pos"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:09 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:09 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:09 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:09 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Namespaces/","text":"Namespaces Updated on 2022-05-30 at 18:35:09 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Namespaces/#namespaces","text":"Updated on 2022-05-30 at 18:35:09 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/","text":"Classes class DeadReckoning DeadReckoning class. namespace FilterGimmicks FilterGimmicks namespace. struct measurement Define a measurement object. struct predicate_frame_id Predicate to find a giver frame_id among a list of frame_id. class FiltersNode FiltersNode class. class HorizontalFilter Horizontal Filter class. struct config class RotationalFilter This Class estimates the state of the vehicle in the rotational frame. The state includes orientation and angular velocity. The latest state estimate of the filter is obtained using the function computePredict() . Measurement updates to the filter is done using newMeasurement() . struct config class VerticalFilter This Class estimates the state of the vehicle in the horizontal frame. The state includes depth, velocity, altitude, and bouyancy. The latest state estimate of the filter is obtained using the exposed function getEstimate(). Measurement updates to the filter is done either using measCallback(). struct config Updated on 2022-05-30 at 18:35:10 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/#classes","text":"class DeadReckoning DeadReckoning class. namespace FilterGimmicks FilterGimmicks namespace. struct measurement Define a measurement object. struct predicate_frame_id Predicate to find a giver frame_id among a list of frame_id. class FiltersNode FiltersNode class. class HorizontalFilter Horizontal Filter class. struct config class RotationalFilter This Class estimates the state of the vehicle in the rotational frame. The state includes orientation and angular velocity. The latest state estimate of the filter is obtained using the function computePredict() . Measurement updates to the filter is done using newMeasurement() . struct config class VerticalFilter This Class estimates the state of the vehicle in the horizontal frame. The state includes depth, velocity, altitude, and bouyancy. The latest state estimate of the filter is obtained using the exposed function getEstimate(). Measurement updates to the filter is done either using measCallback(). struct config Updated on 2022-05-30 at 18:35:10 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classDeadReckoning/","text":"DeadReckoning DeadReckoning class. More... #include <DeadReckoning.h> Public Functions Name DeadReckoning (ros::NodeHandle * nh, ros::NodeHandle * nh_private) Contructor DeadReckoning . ~DeadReckoning () Desctructor DeadReckoning . void computePredict () Propagate the state to the current time. Detailed Description class DeadReckoning; DeadReckoning class. Note : This node only outputs useful information when dvl is present Every time a new mission is deployed (FLAG=6), the DR is reseted to the current navigation state(x,y) Public Functions Documentation function DeadReckoning DeadReckoning( ros::NodeHandle * nh, ros::NodeHandle * nh_private ) Contructor DeadReckoning . function ~DeadReckoning ~DeadReckoning() Desctructor DeadReckoning . function computePredict void computePredict() Propagate the state to the current time. Return : Success or Failure Updated on 2022-05-30 at 18:35:10 +0000","title":"DeadReckoning"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classDeadReckoning/#deadreckoning","text":"DeadReckoning class. More... #include <DeadReckoning.h>","title":"DeadReckoning"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classDeadReckoning/#public-functions","text":"Name DeadReckoning (ros::NodeHandle * nh, ros::NodeHandle * nh_private) Contructor DeadReckoning . ~DeadReckoning () Desctructor DeadReckoning . void computePredict () Propagate the state to the current time.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classDeadReckoning/#detailed-description","text":"class DeadReckoning; DeadReckoning class. Note : This node only outputs useful information when dvl is present Every time a new mission is deployed (FLAG=6), the DR is reseted to the current navigation state(x,y)","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classDeadReckoning/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classDeadReckoning/#function-deadreckoning","text":"DeadReckoning( ros::NodeHandle * nh, ros::NodeHandle * nh_private ) Contructor DeadReckoning .","title":"function DeadReckoning"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classDeadReckoning/#function-deadreckoning_1","text":"~DeadReckoning() Desctructor DeadReckoning .","title":"function ~DeadReckoning"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classDeadReckoning/#function-computepredict","text":"void computePredict() Propagate the state to the current time. Return : Success or Failure Updated on 2022-05-30 at 18:35:10 +0000","title":"function computePredict"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classFiltersNode/","text":"FiltersNode FiltersNode class. More... #include <FiltersNode.h> Public Functions Name FiltersNode (ros::NodeHandle * nh, ros::NodeHandle * nh_private) Constructor. ~FiltersNode () Destructor. double nodeFrequency () Defines the node frequency. Detailed Description class FiltersNode; FiltersNode class. Note : Read all the parameters for each filter(Horicontal, Rotations, Vertical), and configures them. Takes care of the iteration using timer. Also responsible for controlling the measurement buffer of the horizontal filter. Public Functions Documentation function FiltersNode FiltersNode( ros::NodeHandle * nh, ros::NodeHandle * nh_private ) Constructor. Parameters : nh node handle nh_private node handle private function ~FiltersNode ~FiltersNode() Destructor. function nodeFrequency double nodeFrequency() Defines the node frequency. Return : Node frequency Updated on 2022-05-30 at 18:35:10 +0000","title":"FiltersNode"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classFiltersNode/#filtersnode","text":"FiltersNode class. More... #include <FiltersNode.h>","title":"FiltersNode"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classFiltersNode/#public-functions","text":"Name FiltersNode (ros::NodeHandle * nh, ros::NodeHandle * nh_private) Constructor. ~FiltersNode () Destructor. double nodeFrequency () Defines the node frequency.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classFiltersNode/#detailed-description","text":"class FiltersNode; FiltersNode class. Note : Read all the parameters for each filter(Horicontal, Rotations, Vertical), and configures them. Takes care of the iteration using timer. Also responsible for controlling the measurement buffer of the horizontal filter.","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classFiltersNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classFiltersNode/#function-filtersnode","text":"FiltersNode( ros::NodeHandle * nh, ros::NodeHandle * nh_private ) Constructor. Parameters : nh node handle nh_private node handle private","title":"function FiltersNode"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classFiltersNode/#function-filtersnode_1","text":"~FiltersNode() Destructor.","title":"function ~FiltersNode"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classFiltersNode/#function-nodefrequency","text":"double nodeFrequency() Defines the node frequency. Return : Node frequency Updated on 2022-05-30 at 18:35:10 +0000","title":"function nodeFrequency"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/","text":"HorizontalFilter Horizontal Filter class. More... #include <HorizontalFilter.h> Public Classes Name struct config Public Functions Name HorizontalFilter () Contructor Horizontal Filter. virtual ~HorizontalFilter () =default Desctructor Horizontal Filter. bool computePredict (auv_msgs::NavigationStatus & state, const ros::Time & t_request) Propagate the state to the current time. void configure ( HorizontalFilter::config & configurations) Configure filter variables and set initialization conditions. void newMeasurement ( FilterGimmicks::measurement & m) Tranforms the measurement from the sensor frame to the filter world frame. Calls addMeasurement and forwardPropagation methods. void deleteMeasurementsInBuffer () Clears all measurements older than a timer period defined in save_meas_interval. std::vector< double > getExtimateCurrents () Returns the currents. void resetFilter () Reset horizontal filter. Public Attributes Name const static int MEAS_LEN const static int STATE_LEN Detailed Description class HorizontalFilter; Horizontal Filter class. Note : This Class estimates the state of the vehicle in the horizontal frame. The state includes position, velocity, acceleration and currents. The latest state estimate of the filter is obtained using the exposed function getEstimate(). Measurement updates to the filter is done either using measCallback() and the latest state estimate is accessed using getEstimate(). Water currents are estimated but the output is not exposed to the user. Public Functions Documentation function HorizontalFilter HorizontalFilter() Contructor Horizontal Filter. function ~HorizontalFilter virtual ~HorizontalFilter() =default Desctructor Horizontal Filter. function computePredict bool computePredict( auv_msgs::NavigationStatus & state, const ros::Time & t_request ) Propagate the state to the current time. Parameters : state State vector t_request current time Return : Success or Failure function configure void configure( HorizontalFilter::config & configurations ) Configure filter variables and set initialization conditions. Parameters : configurations function newMeasurement void newMeasurement( FilterGimmicks::measurement & m ) Tranforms the measurement from the sensor frame to the filter world frame. Calls addMeasurement and forwardPropagation methods. Parameters : msg New measurement function deleteMeasurementsInBuffer void deleteMeasurementsInBuffer() Clears all measurements older than a timer period defined in save_meas_interval. function getExtimateCurrents std::vector< double > getExtimateCurrents() Returns the currents. Return : x_current, y_current function resetFilter void resetFilter() Reset horizontal filter. Public Attributes Documentation variable MEAS_LEN static const static int MEAS_LEN = 6; variable STATE_LEN static const static int STATE_LEN = 8; Updated on 2022-05-30 at 18:35:10 +0000","title":"HorizontalFilter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#horizontalfilter","text":"Horizontal Filter class. More... #include <HorizontalFilter.h>","title":"HorizontalFilter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#public-classes","text":"Name struct config","title":"Public Classes"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#public-functions","text":"Name HorizontalFilter () Contructor Horizontal Filter. virtual ~HorizontalFilter () =default Desctructor Horizontal Filter. bool computePredict (auv_msgs::NavigationStatus & state, const ros::Time & t_request) Propagate the state to the current time. void configure ( HorizontalFilter::config & configurations) Configure filter variables and set initialization conditions. void newMeasurement ( FilterGimmicks::measurement & m) Tranforms the measurement from the sensor frame to the filter world frame. Calls addMeasurement and forwardPropagation methods. void deleteMeasurementsInBuffer () Clears all measurements older than a timer period defined in save_meas_interval. std::vector< double > getExtimateCurrents () Returns the currents. void resetFilter () Reset horizontal filter.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#public-attributes","text":"Name const static int MEAS_LEN const static int STATE_LEN","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#detailed-description","text":"class HorizontalFilter; Horizontal Filter class. Note : This Class estimates the state of the vehicle in the horizontal frame. The state includes position, velocity, acceleration and currents. The latest state estimate of the filter is obtained using the exposed function getEstimate(). Measurement updates to the filter is done either using measCallback() and the latest state estimate is accessed using getEstimate(). Water currents are estimated but the output is not exposed to the user.","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#function-horizontalfilter","text":"HorizontalFilter() Contructor Horizontal Filter.","title":"function HorizontalFilter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#function-horizontalfilter_1","text":"virtual ~HorizontalFilter() =default Desctructor Horizontal Filter.","title":"function ~HorizontalFilter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#function-computepredict","text":"bool computePredict( auv_msgs::NavigationStatus & state, const ros::Time & t_request ) Propagate the state to the current time. Parameters : state State vector t_request current time Return : Success or Failure","title":"function computePredict"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#function-configure","text":"void configure( HorizontalFilter::config & configurations ) Configure filter variables and set initialization conditions. Parameters : configurations","title":"function configure"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#function-newmeasurement","text":"void newMeasurement( FilterGimmicks::measurement & m ) Tranforms the measurement from the sensor frame to the filter world frame. Calls addMeasurement and forwardPropagation methods. Parameters : msg New measurement","title":"function newMeasurement"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#function-deletemeasurementsinbuffer","text":"void deleteMeasurementsInBuffer() Clears all measurements older than a timer period defined in save_meas_interval.","title":"function deleteMeasurementsInBuffer"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#function-getextimatecurrents","text":"std::vector< double > getExtimateCurrents() Returns the currents. Return : x_current, y_current","title":"function getExtimateCurrents"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#function-resetfilter","text":"void resetFilter() Reset horizontal filter.","title":"function resetFilter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#variable-meas_len","text":"static const static int MEAS_LEN = 6;","title":"variable MEAS_LEN"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#variable-state_len","text":"static const static int STATE_LEN = 8; Updated on 2022-05-30 at 18:35:10 +0000","title":"variable STATE_LEN"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classRotationalFilter/","text":"RotationalFilter This Class estimates the state of the vehicle in the rotational frame. The state includes orientation and angular velocity. The latest state estimate of the filter is obtained using the function computePredict() . Measurement updates to the filter is done using newMeasurement() . #include <RotationalFilter.h> Public Classes Name struct config Public Functions Name RotationalFilter () Rotational Filter Constructor. virtual ~RotationalFilter () =default Rotational Filter Destructor. void computePredict (auv_msgs::NavigationStatus & state, const ros::Time & t_request) Progate the state to the time t_request. void configure (const config configurations) configure filter program variables and may initializes the filter void newMeasurement (const FilterGimmicks::measurement & m) Checks and processes a new measurement. void resetFilter () Reset the horizontal filter. Public Attributes Name const int STATE_LEN double PI Public Functions Documentation function RotationalFilter RotationalFilter() Rotational Filter Constructor. function ~RotationalFilter virtual ~RotationalFilter() =default Rotational Filter Destructor. function computePredict void computePredict( auv_msgs::NavigationStatus & state, const ros::Time & t_request ) Progate the state to the time t_request. Parameters : state t_request Note : Why have we used TF here? We want: Rotation of base_link wrt world, i.e. header = world, child = base_link (TFwb). I have: 1. static_tf - Rotation of imu wrt base_link, i.e. header = base_link, child = imu (TFbi); 2. sensor output - Rotation of imu wrt world, i.e. header = world, child = imu (TFwi). Solution: TFwb = TFwi * (TFbi)^-1 function configure void configure( const config configurations ) configure filter program variables and may initializes the filter Parameters : configurations struct to store configurations from yaml file function newMeasurement void newMeasurement( const FilterGimmicks::measurement & m ) Checks and processes a new measurement. Parameters : m measurement function resetFilter void resetFilter() Reset the horizontal filter. Public Attributes Documentation variable STATE_LEN static const int STATE_LEN = 6; variable PI double PI = 3.1415926; Updated on 2022-05-30 at 18:35:10 +0000","title":"RotationalFilter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classRotationalFilter/#rotationalfilter","text":"This Class estimates the state of the vehicle in the rotational frame. The state includes orientation and angular velocity. The latest state estimate of the filter is obtained using the function computePredict() . Measurement updates to the filter is done using newMeasurement() . #include <RotationalFilter.h>","title":"RotationalFilter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classRotationalFilter/#public-classes","text":"Name struct config","title":"Public Classes"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classRotationalFilter/#public-functions","text":"Name RotationalFilter () Rotational Filter Constructor. virtual ~RotationalFilter () =default Rotational Filter Destructor. void computePredict (auv_msgs::NavigationStatus & state, const ros::Time & t_request) Progate the state to the time t_request. void configure (const config configurations) configure filter program variables and may initializes the filter void newMeasurement (const FilterGimmicks::measurement & m) Checks and processes a new measurement. void resetFilter () Reset the horizontal filter.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classRotationalFilter/#public-attributes","text":"Name const int STATE_LEN double PI","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classRotationalFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classRotationalFilter/#function-rotationalfilter","text":"RotationalFilter() Rotational Filter Constructor.","title":"function RotationalFilter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classRotationalFilter/#function-rotationalfilter_1","text":"virtual ~RotationalFilter() =default Rotational Filter Destructor.","title":"function ~RotationalFilter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classRotationalFilter/#function-computepredict","text":"void computePredict( auv_msgs::NavigationStatus & state, const ros::Time & t_request ) Progate the state to the time t_request. Parameters : state t_request Note : Why have we used TF here? We want: Rotation of base_link wrt world, i.e. header = world, child = base_link (TFwb). I have: 1. static_tf - Rotation of imu wrt base_link, i.e. header = base_link, child = imu (TFbi); 2. sensor output - Rotation of imu wrt world, i.e. header = world, child = imu (TFwi). Solution: TFwb = TFwi * (TFbi)^-1","title":"function computePredict"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classRotationalFilter/#function-configure","text":"void configure( const config configurations ) configure filter program variables and may initializes the filter Parameters : configurations struct to store configurations from yaml file","title":"function configure"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classRotationalFilter/#function-newmeasurement","text":"void newMeasurement( const FilterGimmicks::measurement & m ) Checks and processes a new measurement. Parameters : m measurement","title":"function newMeasurement"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classRotationalFilter/#function-resetfilter","text":"void resetFilter() Reset the horizontal filter.","title":"function resetFilter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classRotationalFilter/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classRotationalFilter/#variable-state_len","text":"static const int STATE_LEN = 6;","title":"variable STATE_LEN"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classRotationalFilter/#variable-pi","text":"double PI = 3.1415926; Updated on 2022-05-30 at 18:35:10 +0000","title":"variable PI"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classVerticalFilter/","text":"VerticalFilter This Class estimates the state of the vehicle in the horizontal frame. The state includes depth, velocity, altitude, and bouyancy. The latest state estimate of the filter is obtained using the exposed function getEstimate(). Measurement updates to the filter is done either using measCallback(). More... #include <VerticalFilter.h> Public Classes Name struct config Public Functions Name VerticalFilter () Constructor. virtual ~VerticalFilter () =default Destructor. void configure (const VerticalFilter::config configurations) Configure filter program variables and set initialization conditions. void computePredict (auv_msgs::NavigationStatus & state, ros::Time t_request) Propagate the state to the current time. void newMeasurement (const FilterGimmicks::measurement & m) Checks and processes a new measurement. void resetFilter () Resets the filter, will require re-initialization to start back update again. Public Attributes Name const int MEAS_LEN Measurement length. Detailed Description class VerticalFilter; This Class estimates the state of the vehicle in the horizontal frame. The state includes depth, velocity, altitude, and bouyancy. The latest state estimate of the filter is obtained using the exposed function getEstimate(). Measurement updates to the filter is done either using measCallback(). @Note Bouyancy is estimated but the output is not exposed to the user. Public Functions Documentation function VerticalFilter VerticalFilter() Constructor. function ~VerticalFilter virtual ~VerticalFilter() =default Destructor. function configure void configure( const VerticalFilter::config configurations ) Configure filter program variables and set initialization conditions. Parameters : config_ structure with configurations function computePredict void computePredict( auv_msgs::NavigationStatus & state, ros::Time t_request ) Propagate the state to the current time. Parameters : state State vector t_request current time function newMeasurement void newMeasurement( const FilterGimmicks::measurement & m ) Checks and processes a new measurement. Parameters : m Measurement Return : true if measurement is processed successfully function resetFilter void resetFilter() Resets the filter, will require re-initialization to start back update again. Public Attributes Documentation variable MEAS_LEN static const int MEAS_LEN = 3; Measurement length. Updated on 2022-05-30 at 18:35:10 +0000","title":"VerticalFilter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classVerticalFilter/#verticalfilter","text":"This Class estimates the state of the vehicle in the horizontal frame. The state includes depth, velocity, altitude, and bouyancy. The latest state estimate of the filter is obtained using the exposed function getEstimate(). Measurement updates to the filter is done either using measCallback(). More... #include <VerticalFilter.h>","title":"VerticalFilter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classVerticalFilter/#public-classes","text":"Name struct config","title":"Public Classes"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classVerticalFilter/#public-functions","text":"Name VerticalFilter () Constructor. virtual ~VerticalFilter () =default Destructor. void configure (const VerticalFilter::config configurations) Configure filter program variables and set initialization conditions. void computePredict (auv_msgs::NavigationStatus & state, ros::Time t_request) Propagate the state to the current time. void newMeasurement (const FilterGimmicks::measurement & m) Checks and processes a new measurement. void resetFilter () Resets the filter, will require re-initialization to start back update again.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classVerticalFilter/#public-attributes","text":"Name const int MEAS_LEN Measurement length.","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classVerticalFilter/#detailed-description","text":"class VerticalFilter; This Class estimates the state of the vehicle in the horizontal frame. The state includes depth, velocity, altitude, and bouyancy. The latest state estimate of the filter is obtained using the exposed function getEstimate(). Measurement updates to the filter is done either using measCallback(). @Note Bouyancy is estimated but the output is not exposed to the user.","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classVerticalFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classVerticalFilter/#function-verticalfilter","text":"VerticalFilter() Constructor.","title":"function VerticalFilter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classVerticalFilter/#function-verticalfilter_1","text":"virtual ~VerticalFilter() =default Destructor.","title":"function ~VerticalFilter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classVerticalFilter/#function-configure","text":"void configure( const VerticalFilter::config configurations ) Configure filter program variables and set initialization conditions. Parameters : config_ structure with configurations","title":"function configure"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classVerticalFilter/#function-computepredict","text":"void computePredict( auv_msgs::NavigationStatus & state, ros::Time t_request ) Propagate the state to the current time. Parameters : state State vector t_request current time","title":"function computePredict"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classVerticalFilter/#function-newmeasurement","text":"void newMeasurement( const FilterGimmicks::measurement & m ) Checks and processes a new measurement. Parameters : m Measurement Return : true if measurement is processed successfully","title":"function newMeasurement"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classVerticalFilter/#function-resetfilter","text":"void resetFilter() Resets the filter, will require re-initialization to start back update again.","title":"function resetFilter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classVerticalFilter/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classVerticalFilter/#variable-meas_len","text":"static const int MEAS_LEN = 3; Measurement length. Updated on 2022-05-30 at 18:35:10 +0000","title":"variable MEAS_LEN"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/","text":"FilterGimmicks::measurement Define a measurement object. More... #include <FilterGimmicks.h> Public Types Name enum measurement_type { Null = 1, CONFIG, VALUE} Public Functions Name void setLength (int length) measurement () measurement (int length) measurement (std::string header_) measurement (std::string frame_id, std::string config_, std::vector< double > noise_, double rejection_threshold_, int reject_counter_, double outlier_increase_) measurement (std::string frame_id, std::vector< double > value_, std::vector< double > noise_) measurement (const dsor_msgs::Measurement & m_) Public Attributes Name bool base_frame std_msgs::Header header Eigen::VectorXd value Eigen::VectorXd noise Eigen::VectorXd config Eigen::VectorXd state_copy Eigen::MatrixXd state_cov_copy std::string sensor_config double outlier_tolerance double time_of_previous_meas double outlier_increase int reject_counter Detailed Description struct FilterGimmicks::measurement; Define a measurement object. Note : measurement struct temporary placed here. To be moved later somewhere Public Types Documentation enum measurement_type Enumerator Value Description Null 1 CONFIG VALUE Public Functions Documentation function setLength inline void setLength( int length ) function measurement inline measurement() function measurement inline measurement( int length ) function measurement inline measurement( std::string header_ ) function measurement inline measurement( std::string frame_id, std::string config_, std::vector< double > noise_, double rejection_threshold_, int reject_counter_, double outlier_increase_ ) function measurement inline measurement( std::string frame_id, std::vector< double > value_, std::vector< double > noise_ ) function measurement inline measurement( const dsor_msgs::Measurement & m_ ) Public Attributes Documentation variable base_frame bool base_frame; variable header std_msgs::Header header; variable value Eigen::VectorXd value; variable noise Eigen::VectorXd noise; variable config Eigen::VectorXd config; variable state_copy Eigen::VectorXd state_copy; variable state_cov_copy Eigen::MatrixXd state_cov_copy; variable sensor_config std::string sensor_config; variable outlier_tolerance double outlier_tolerance; variable time_of_previous_meas double time_of_previous_meas; variable outlier_increase double outlier_increase; variable reject_counter int reject_counter; Updated on 2022-05-30 at 18:35:10 +0000","title":"FilterGimmicks::measurement"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#filtergimmicksmeasurement","text":"Define a measurement object. More... #include <FilterGimmicks.h>","title":"FilterGimmicks::measurement"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#public-types","text":"Name enum measurement_type { Null = 1, CONFIG, VALUE}","title":"Public Types"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#public-functions","text":"Name void setLength (int length) measurement () measurement (int length) measurement (std::string header_) measurement (std::string frame_id, std::string config_, std::vector< double > noise_, double rejection_threshold_, int reject_counter_, double outlier_increase_) measurement (std::string frame_id, std::vector< double > value_, std::vector< double > noise_) measurement (const dsor_msgs::Measurement & m_)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#public-attributes","text":"Name bool base_frame std_msgs::Header header Eigen::VectorXd value Eigen::VectorXd noise Eigen::VectorXd config Eigen::VectorXd state_copy Eigen::MatrixXd state_cov_copy std::string sensor_config double outlier_tolerance double time_of_previous_meas double outlier_increase int reject_counter","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#detailed-description","text":"struct FilterGimmicks::measurement; Define a measurement object. Note : measurement struct temporary placed here. To be moved later somewhere","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#enum-measurement_type","text":"Enumerator Value Description Null 1 CONFIG VALUE","title":"enum measurement_type"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#function-setlength","text":"inline void setLength( int length )","title":"function setLength"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#function-measurement","text":"inline measurement()","title":"function measurement"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#function-measurement_1","text":"inline measurement( int length )","title":"function measurement"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#function-measurement_2","text":"inline measurement( std::string header_ )","title":"function measurement"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#function-measurement_3","text":"inline measurement( std::string frame_id, std::string config_, std::vector< double > noise_, double rejection_threshold_, int reject_counter_, double outlier_increase_ )","title":"function measurement"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#function-measurement_4","text":"inline measurement( std::string frame_id, std::vector< double > value_, std::vector< double > noise_ )","title":"function measurement"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#function-measurement_5","text":"inline measurement( const dsor_msgs::Measurement & m_ )","title":"function measurement"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#variable-base_frame","text":"bool base_frame;","title":"variable base_frame"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#variable-header","text":"std_msgs::Header header;","title":"variable header"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#variable-value","text":"Eigen::VectorXd value;","title":"variable value"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#variable-noise","text":"Eigen::VectorXd noise;","title":"variable noise"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#variable-config","text":"Eigen::VectorXd config;","title":"variable config"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#variable-state_copy","text":"Eigen::VectorXd state_copy;","title":"variable state_copy"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#variable-state_cov_copy","text":"Eigen::MatrixXd state_cov_copy;","title":"variable state_cov_copy"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#variable-sensor_config","text":"std::string sensor_config;","title":"variable sensor_config"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#variable-outlier_tolerance","text":"double outlier_tolerance;","title":"variable outlier_tolerance"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#variable-time_of_previous_meas","text":"double time_of_previous_meas;","title":"variable time_of_previous_meas"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#variable-outlier_increase","text":"double outlier_increase;","title":"variable outlier_increase"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#variable-reject_counter","text":"int reject_counter; Updated on 2022-05-30 at 18:35:10 +0000","title":"variable reject_counter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1predicate__frame__id/","text":"FilterGimmicks::predicate_frame_id Predicate to find a giver frame_id among a list of frame_id. #include <FilterGimmicks.h> Public Functions Name predicate_frame_id (std::string target_) bool operator() ( measurement & sensor) Public Attributes Name std::string target Public Functions Documentation function predicate_frame_id inline predicate_frame_id( std::string target_ ) function operator() inline bool operator()( measurement & sensor ) Public Attributes Documentation variable target std::string target; Updated on 2022-05-30 at 18:35:10 +0000","title":"FilterGimmicks::predicate_frame_id"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1predicate__frame__id/#filtergimmickspredicate_frame_id","text":"Predicate to find a giver frame_id among a list of frame_id. #include <FilterGimmicks.h>","title":"FilterGimmicks::predicate_frame_id"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1predicate__frame__id/#public-functions","text":"Name predicate_frame_id (std::string target_) bool operator() ( measurement & sensor)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1predicate__frame__id/#public-attributes","text":"Name std::string target","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1predicate__frame__id/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1predicate__frame__id/#function-predicate_frame_id","text":"inline predicate_frame_id( std::string target_ )","title":"function predicate_frame_id"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1predicate__frame__id/#function-operator","text":"inline bool operator()( measurement & sensor )","title":"function operator()"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1predicate__frame__id/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1predicate__frame__id/#variable-target","text":"std::string target; Updated on 2022-05-30 at 18:35:10 +0000","title":"variable target"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structHorizontalFilter_1_1config/","text":"HorizontalFilter::config Public Attributes Name bool initialized bool broadcast_tf double reject_counter double init_cov double process_noise double kalman_config std::vector< std::string > frames FilterGimmicks::measurement meas_init std::vector< FilterGimmicks::measurement > sensors tf2_ros::TransformBroadcaster * br_node Public Attributes Documentation variable initialized bool initialized {false}; variable broadcast_tf bool broadcast_tf; variable reject_counter double reject_counter; variable init_cov double init_cov; variable process_noise double process_noise; variable kalman_config double kalman_config; variable frames std::vector< std::string > frames; variable meas_init FilterGimmicks::measurement meas_init; variable sensors std::vector< FilterGimmicks::measurement > sensors; variable br_node tf2_ros::TransformBroadcaster * br_node; Updated on 2022-05-30 at 18:35:10 +0000","title":"HorizontalFilter::config"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structHorizontalFilter_1_1config/#horizontalfilterconfig","text":"","title":"HorizontalFilter::config"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structHorizontalFilter_1_1config/#public-attributes","text":"Name bool initialized bool broadcast_tf double reject_counter double init_cov double process_noise double kalman_config std::vector< std::string > frames FilterGimmicks::measurement meas_init std::vector< FilterGimmicks::measurement > sensors tf2_ros::TransformBroadcaster * br_node","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structHorizontalFilter_1_1config/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structHorizontalFilter_1_1config/#variable-initialized","text":"bool initialized {false};","title":"variable initialized"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structHorizontalFilter_1_1config/#variable-broadcast_tf","text":"bool broadcast_tf;","title":"variable broadcast_tf"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structHorizontalFilter_1_1config/#variable-reject_counter","text":"double reject_counter;","title":"variable reject_counter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structHorizontalFilter_1_1config/#variable-init_cov","text":"double init_cov;","title":"variable init_cov"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structHorizontalFilter_1_1config/#variable-process_noise","text":"double process_noise;","title":"variable process_noise"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structHorizontalFilter_1_1config/#variable-kalman_config","text":"double kalman_config;","title":"variable kalman_config"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structHorizontalFilter_1_1config/#variable-frames","text":"std::vector< std::string > frames;","title":"variable frames"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structHorizontalFilter_1_1config/#variable-meas_init","text":"FilterGimmicks::measurement meas_init;","title":"variable meas_init"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structHorizontalFilter_1_1config/#variable-sensors","text":"std::vector< FilterGimmicks::measurement > sensors;","title":"variable sensors"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structHorizontalFilter_1_1config/#variable-br_node","text":"tf2_ros::TransformBroadcaster * br_node; Updated on 2022-05-30 at 18:35:10 +0000","title":"variable br_node"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structRotationalFilter_1_1config/","text":"RotationalFilter::config Public Attributes Name bool initialized bool bypass_ahrs double reject_counter double init_cov double process_noise double kalman_config std::vector< std::string > frames FilterGimmicks::measurement meas_init std::vector< FilterGimmicks::measurement > sensors tf2_ros::TransformBroadcaster * br_node Public Attributes Documentation variable initialized bool initialized {false}; variable bypass_ahrs bool bypass_ahrs; variable reject_counter double reject_counter; variable init_cov double init_cov; variable process_noise double process_noise; variable kalman_config double kalman_config; variable frames std::vector< std::string > frames; variable meas_init FilterGimmicks::measurement meas_init; variable sensors std::vector< FilterGimmicks::measurement > sensors; variable br_node tf2_ros::TransformBroadcaster * br_node; Updated on 2022-05-30 at 18:35:10 +0000","title":"RotationalFilter::config"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structRotationalFilter_1_1config/#rotationalfilterconfig","text":"","title":"RotationalFilter::config"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structRotationalFilter_1_1config/#public-attributes","text":"Name bool initialized bool bypass_ahrs double reject_counter double init_cov double process_noise double kalman_config std::vector< std::string > frames FilterGimmicks::measurement meas_init std::vector< FilterGimmicks::measurement > sensors tf2_ros::TransformBroadcaster * br_node","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structRotationalFilter_1_1config/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structRotationalFilter_1_1config/#variable-initialized","text":"bool initialized {false};","title":"variable initialized"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structRotationalFilter_1_1config/#variable-bypass_ahrs","text":"bool bypass_ahrs;","title":"variable bypass_ahrs"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structRotationalFilter_1_1config/#variable-reject_counter","text":"double reject_counter;","title":"variable reject_counter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structRotationalFilter_1_1config/#variable-init_cov","text":"double init_cov;","title":"variable init_cov"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structRotationalFilter_1_1config/#variable-process_noise","text":"double process_noise;","title":"variable process_noise"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structRotationalFilter_1_1config/#variable-kalman_config","text":"double kalman_config;","title":"variable kalman_config"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structRotationalFilter_1_1config/#variable-frames","text":"std::vector< std::string > frames;","title":"variable frames"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structRotationalFilter_1_1config/#variable-meas_init","text":"FilterGimmicks::measurement meas_init;","title":"variable meas_init"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structRotationalFilter_1_1config/#variable-sensors","text":"std::vector< FilterGimmicks::measurement > sensors;","title":"variable sensors"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structRotationalFilter_1_1config/#variable-br_node","text":"tf2_ros::TransformBroadcaster * br_node; Updated on 2022-05-30 at 18:35:10 +0000","title":"variable br_node"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structVerticalFilter_1_1config/","text":"VerticalFilter::config Public Attributes Name bool initialized bool broadcast_tf double vertical_drag alpha, beta, bouyancy double reject_counter double init_cov double process_noise double kalman_config std::vector< std::string > frames base_frame, odom_frame, map_frame, world_frame FilterGimmicks::measurement meas_init std::vector< FilterGimmicks::measurement > sensors tf2_ros::TransformBroadcaster * br_node Public Attributes Documentation variable initialized bool initialized {false}; variable broadcast_tf bool broadcast_tf; variable vertical_drag double vertical_drag; alpha, beta, bouyancy variable reject_counter double reject_counter; variable init_cov double init_cov; variable process_noise double process_noise; variable kalman_config double kalman_config; variable frames std::vector< std::string > frames; base_frame, odom_frame, map_frame, world_frame variable meas_init FilterGimmicks::measurement meas_init; variable sensors std::vector< FilterGimmicks::measurement > sensors; variable br_node tf2_ros::TransformBroadcaster * br_node; Updated on 2022-05-30 at 18:35:10 +0000","title":"VerticalFilter::config"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structVerticalFilter_1_1config/#verticalfilterconfig","text":"","title":"VerticalFilter::config"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structVerticalFilter_1_1config/#public-attributes","text":"Name bool initialized bool broadcast_tf double vertical_drag alpha, beta, bouyancy double reject_counter double init_cov double process_noise double kalman_config std::vector< std::string > frames base_frame, odom_frame, map_frame, world_frame FilterGimmicks::measurement meas_init std::vector< FilterGimmicks::measurement > sensors tf2_ros::TransformBroadcaster * br_node","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structVerticalFilter_1_1config/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structVerticalFilter_1_1config/#variable-initialized","text":"bool initialized {false};","title":"variable initialized"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structVerticalFilter_1_1config/#variable-broadcast_tf","text":"bool broadcast_tf;","title":"variable broadcast_tf"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structVerticalFilter_1_1config/#variable-vertical_drag","text":"double vertical_drag; alpha, beta, bouyancy","title":"variable vertical_drag"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structVerticalFilter_1_1config/#variable-reject_counter","text":"double reject_counter;","title":"variable reject_counter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structVerticalFilter_1_1config/#variable-init_cov","text":"double init_cov;","title":"variable init_cov"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structVerticalFilter_1_1config/#variable-process_noise","text":"double process_noise;","title":"variable process_noise"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structVerticalFilter_1_1config/#variable-kalman_config","text":"double kalman_config;","title":"variable kalman_config"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structVerticalFilter_1_1config/#variable-frames","text":"std::vector< std::string > frames; base_frame, odom_frame, map_frame, world_frame","title":"variable frames"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structVerticalFilter_1_1config/#variable-meas_init","text":"FilterGimmicks::measurement meas_init;","title":"variable meas_init"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structVerticalFilter_1_1config/#variable-sensors","text":"std::vector< FilterGimmicks::measurement > sensors;","title":"variable sensors"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structVerticalFilter_1_1config/#variable-br_node","text":"tf2_ros::TransformBroadcaster * br_node; Updated on 2022-05-30 at 18:35:10 +0000","title":"variable br_node"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:10 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:10 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:10 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:10 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Namespaces/","text":"Namespaces namespace FilterGimmicks FilterGimmicks namespace. Updated on 2022-05-30 at 18:35:10 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Namespaces/#namespaces","text":"namespace FilterGimmicks FilterGimmicks namespace. Updated on 2022-05-30 at 18:35:10 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Namespaces/namespaceFilterGimmicks/","text":"FilterGimmicks FilterGimmicks namespace. More... Classes Name struct FilterGimmicks::measurement Define a measurement object. struct FilterGimmicks::predicate_frame_id Predicate to find a giver frame_id among a list of frame_id. Types Name typedef struct FilterGimmicks::measurement measurement Define a measurement object. Functions Name bool isinvalid (const measurement & m, double time) Validates a measurement if time is not negative, measurement or covariance are not nan. Detailed Description FilterGimmicks namespace. Note : gimmicks methods for navigation filters Types Documentation typedef measurement typedef struct FilterGimmicks::measurement FilterGimmicks::measurement; Define a measurement object. Note : measurement struct temporary placed here. To be moved later somewhere Functions Documentation function isinvalid static bool isinvalid( const measurement & m, double time ) Validates a measurement if time is not negative, measurement or covariance are not nan. Parameters : val measurement time Return : true if measurement is invalid false if measurement is valid Updated on 2022-05-30 at 18:35:10 +0000","title":"FilterGimmicks"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Namespaces/namespaceFilterGimmicks/#filtergimmicks","text":"FilterGimmicks namespace. More...","title":"FilterGimmicks"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Namespaces/namespaceFilterGimmicks/#classes","text":"Name struct FilterGimmicks::measurement Define a measurement object. struct FilterGimmicks::predicate_frame_id Predicate to find a giver frame_id among a list of frame_id.","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Namespaces/namespaceFilterGimmicks/#types","text":"Name typedef struct FilterGimmicks::measurement measurement Define a measurement object.","title":"Types"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Namespaces/namespaceFilterGimmicks/#functions","text":"Name bool isinvalid (const measurement & m, double time) Validates a measurement if time is not negative, measurement or covariance are not nan.","title":"Functions"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Namespaces/namespaceFilterGimmicks/#detailed-description","text":"FilterGimmicks namespace. Note : gimmicks methods for navigation filters","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Namespaces/namespaceFilterGimmicks/#types-documentation","text":"","title":"Types Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Namespaces/namespaceFilterGimmicks/#typedef-measurement","text":"typedef struct FilterGimmicks::measurement FilterGimmicks::measurement; Define a measurement object. Note : measurement struct temporary placed here. To be moved later somewhere","title":"typedef measurement"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Namespaces/namespaceFilterGimmicks/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Namespaces/namespaceFilterGimmicks/#function-isinvalid","text":"static bool isinvalid( const measurement & m, double time ) Validates a measurement if time is not negative, measurement or covariance are not nan. Parameters : val measurement time Return : true if measurement is invalid false if measurement is valid Updated on 2022-05-30 at 18:35:10 +0000","title":"function isinvalid"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/","text":"Classes class Arc2D Class that implements a 2D arc section. class Bernoulli Class that implements a 2D Lemniscate of Bernoulli section. class Circle2D Class that implements a 2D Circle section. class ConstRabbitSpeed Class that implements a constant speed value requirement. This class will receive in its constructor the desired velocity for the speed in the path frame. class ConstVehicleSpeed Class that implements a constant speed value requirement. This class will receive in its constructor the desired velocity for the speed in the inertial frame and will implement the corresponding speed in the path frame. class Line Class that implements a 3D line section. class Path The Path class! This class implements all the meethod to get the desired position, derivative, second derivatives, tangent, curvature and derivative norm. class PathNode Implementation of the PathNode . Creates a Path , adds elements to the path and publishes the path data when listening to the path parameter gamma. class PathSection An abstract class that is used as a template for Path Sections. class Polinomial5 Class that implements a 5th order polinomial section. class Polynomial5 Class that implements a 5th order polynomial section. class Sinusoid2D Class that implements a 2D sinusoid section. class Speed Abstract class to serve as the base for speed as a function of gamma. Updated on 2022-05-30 at 18:35:08 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/#classes","text":"class Arc2D Class that implements a 2D arc section. class Bernoulli Class that implements a 2D Lemniscate of Bernoulli section. class Circle2D Class that implements a 2D Circle section. class ConstRabbitSpeed Class that implements a constant speed value requirement. This class will receive in its constructor the desired velocity for the speed in the path frame. class ConstVehicleSpeed Class that implements a constant speed value requirement. This class will receive in its constructor the desired velocity for the speed in the inertial frame and will implement the corresponding speed in the path frame. class Line Class that implements a 3D line section. class Path The Path class! This class implements all the meethod to get the desired position, derivative, second derivatives, tangent, curvature and derivative norm. class PathNode Implementation of the PathNode . Creates a Path , adds elements to the path and publishes the path data when listening to the path parameter gamma. class PathSection An abstract class that is used as a template for Path Sections. class Polinomial5 Class that implements a 5th order polinomial section. class Polynomial5 Class that implements a 5th order polynomial section. class Sinusoid2D Class that implements a 2D sinusoid section. class Speed Abstract class to serve as the base for speed as a function of gamma. Updated on 2022-05-30 at 18:35:08 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classArc2D/","text":"Arc2D Class that implements a 2D arc section. More... #include <Arc2D.h> Inherits from PathSection Public Functions Name Arc2D (Eigen::Vector2d start_point, Eigen::Vector2d end_point, Eigen::Vector2d center_point, int direction, double z) Constructor for the Arc2D class, that receives the desired plane for the arc. Arc2D (Eigen::Vector2d start_point, Eigen::Vector2d end_point, Eigen::Vector2d center_point, int direction) Constructor for the Arc2D class, that receives the desired plane for the arc. Assumes the plane is placed at z=0.0 m. virtual Eigen::Vector3d eq_pd (double t) override The Path section equation. virtual Eigen::Vector3d eq_d_pd (double t) override First derivative of the path section equation with respect to the path parameter t. virtual Eigen::Vector3d eq_dd_pd (double t) override Second derivative of the path section equation with respect to the path parameter t. virtual double curvature (double t) override Compute the curvature in a simple manner. Computed as 1/Radius. virtual double getClosestPointGamma (Eigen::Vector3d & coordinate) override Method for getting the gamma of the closes point to the path in a more efficient manner For an arc it uses a closed form equation to solve this problem. Additional inherited members Public Functions inherited from PathSection Name virtual double tangent (double t) Default method for computing the tangent to the path section. virtual double derivative_norm (double t) Default method for computing the norm of the derivative. bool can_be_composed () Method to return whether a pathSection can be composed with other path sections or not. double limitGamma (double t) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. double getMaxGammaValue () Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. double getMinGammaValue () Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. virtual ~PathSection () Virtual destructor for the abstract class. Protected Functions inherited from PathSection Name PathSection (bool can_be_composed) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . bool setMaxGammaValue (double gamma_max) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. bool setMinGammaValue (double gamma_min) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. double GradientDescent (double gamma_o, Eigen::Vector3d & x_pos, double tolerance) Method that implements the gradient descent to minimize the error of double getInitialGammaEstimate (Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. double bisection (Eigen::Vector3d & x_pos, double a, double b) Method to implement bisection method Detailed Description class Arc2D; Class that implements a 2D arc section. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the sections library Public Functions Documentation function Arc2D Arc2D( Eigen::Vector2d start_point, Eigen::Vector2d end_point, Eigen::Vector2d center_point, int direction, double z ) Constructor for the Arc2D class, that receives the desired plane for the arc. Parameters : start_point The 2D start point of the arc end_point The 2D end point of the arc center_point The 2D coordinate with the center of the arc direction An int (-1 or 1) that represents the direction of the arc z The altitude at which to place the arc Constructor for the Arc2D path. Using this constructor we can specify the plane in which to put the arc function Arc2D Arc2D( Eigen::Vector2d start_point, Eigen::Vector2d end_point, Eigen::Vector2d center_point, int direction ) Constructor for the Arc2D class, that receives the desired plane for the arc. Assumes the plane is placed at z=0.0 m. Parameters : start_point The 2D start point of the arc end_point The 2D end point of the arc center_point The 2D coordinate with the center of the arc direction An int (-1 or 1) that represents the direction of the arc The constructors for the Arc2D paths Using this constructor we assume the path is place in the plane z = 0 function eq_pd virtual Eigen::Vector3d eq_pd( double t ) override The Path section equation. Parameters : t The path parameter Return : An Eigen::Vector3d with the equation of the path with respect to the path parameter Reimplements : PathSection::eq_pd function eq_d_pd virtual Eigen::Vector3d eq_d_pd( double t ) override First derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter t Return : An Eigen::Vector3d with the equation of the partial derivative with respect to the path parameter Reimplements : PathSection::eq_d_pd function eq_dd_pd virtual Eigen::Vector3d eq_dd_pd( double t ) override Second derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter t Return : An Eigen::Vector3d with the equation of the second order partial derivative with respect to the path parameter Reimplements : PathSection::eq_dd_pd function curvature virtual double curvature( double t ) override Compute the curvature in a simple manner. Computed as 1/Radius. Parameters : t The path parameter t Return : A double with the curvature in of that section (1/radius) Reimplements : PathSection::curvature function getClosestPointGamma virtual double getClosestPointGamma( Eigen::Vector3d & coordinate ) override Method for getting the gamma of the closes point to the path in a more efficient manner For an arc it uses a closed form equation to solve this problem. Parameters : coordinate The coordinate of the vehicle in the 3D space Return : A double with the gamma corresponding to the closest point in the path Reimplements : PathSection::getClosestPointGamma Updated on 2022-05-30 at 18:35:08 +0000","title":"Arc2D"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classArc2D/#arc2d","text":"Class that implements a 2D arc section. More... #include <Arc2D.h> Inherits from PathSection","title":"Arc2D"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classArc2D/#public-functions","text":"Name Arc2D (Eigen::Vector2d start_point, Eigen::Vector2d end_point, Eigen::Vector2d center_point, int direction, double z) Constructor for the Arc2D class, that receives the desired plane for the arc. Arc2D (Eigen::Vector2d start_point, Eigen::Vector2d end_point, Eigen::Vector2d center_point, int direction) Constructor for the Arc2D class, that receives the desired plane for the arc. Assumes the plane is placed at z=0.0 m. virtual Eigen::Vector3d eq_pd (double t) override The Path section equation. virtual Eigen::Vector3d eq_d_pd (double t) override First derivative of the path section equation with respect to the path parameter t. virtual Eigen::Vector3d eq_dd_pd (double t) override Second derivative of the path section equation with respect to the path parameter t. virtual double curvature (double t) override Compute the curvature in a simple manner. Computed as 1/Radius. virtual double getClosestPointGamma (Eigen::Vector3d & coordinate) override Method for getting the gamma of the closes point to the path in a more efficient manner For an arc it uses a closed form equation to solve this problem.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classArc2D/#additional-inherited-members","text":"Public Functions inherited from PathSection Name virtual double tangent (double t) Default method for computing the tangent to the path section. virtual double derivative_norm (double t) Default method for computing the norm of the derivative. bool can_be_composed () Method to return whether a pathSection can be composed with other path sections or not. double limitGamma (double t) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. double getMaxGammaValue () Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. double getMinGammaValue () Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. virtual ~PathSection () Virtual destructor for the abstract class. Protected Functions inherited from PathSection Name PathSection (bool can_be_composed) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . bool setMaxGammaValue (double gamma_max) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. bool setMinGammaValue (double gamma_min) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. double GradientDescent (double gamma_o, Eigen::Vector3d & x_pos, double tolerance) Method that implements the gradient descent to minimize the error of double getInitialGammaEstimate (Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. double bisection (Eigen::Vector3d & x_pos, double a, double b) Method to implement bisection method","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classArc2D/#detailed-description","text":"class Arc2D; Class that implements a 2D arc section. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the sections library","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classArc2D/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classArc2D/#function-arc2d","text":"Arc2D( Eigen::Vector2d start_point, Eigen::Vector2d end_point, Eigen::Vector2d center_point, int direction, double z ) Constructor for the Arc2D class, that receives the desired plane for the arc. Parameters : start_point The 2D start point of the arc end_point The 2D end point of the arc center_point The 2D coordinate with the center of the arc direction An int (-1 or 1) that represents the direction of the arc z The altitude at which to place the arc Constructor for the Arc2D path. Using this constructor we can specify the plane in which to put the arc","title":"function Arc2D"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classArc2D/#function-arc2d_1","text":"Arc2D( Eigen::Vector2d start_point, Eigen::Vector2d end_point, Eigen::Vector2d center_point, int direction ) Constructor for the Arc2D class, that receives the desired plane for the arc. Assumes the plane is placed at z=0.0 m. Parameters : start_point The 2D start point of the arc end_point The 2D end point of the arc center_point The 2D coordinate with the center of the arc direction An int (-1 or 1) that represents the direction of the arc The constructors for the Arc2D paths Using this constructor we assume the path is place in the plane z = 0","title":"function Arc2D"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classArc2D/#function-eq_pd","text":"virtual Eigen::Vector3d eq_pd( double t ) override The Path section equation. Parameters : t The path parameter Return : An Eigen::Vector3d with the equation of the path with respect to the path parameter Reimplements : PathSection::eq_pd","title":"function eq_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classArc2D/#function-eq_d_pd","text":"virtual Eigen::Vector3d eq_d_pd( double t ) override First derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter t Return : An Eigen::Vector3d with the equation of the partial derivative with respect to the path parameter Reimplements : PathSection::eq_d_pd","title":"function eq_d_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classArc2D/#function-eq_dd_pd","text":"virtual Eigen::Vector3d eq_dd_pd( double t ) override Second derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter t Return : An Eigen::Vector3d with the equation of the second order partial derivative with respect to the path parameter Reimplements : PathSection::eq_dd_pd","title":"function eq_dd_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classArc2D/#function-curvature","text":"virtual double curvature( double t ) override Compute the curvature in a simple manner. Computed as 1/Radius. Parameters : t The path parameter t Return : A double with the curvature in of that section (1/radius) Reimplements : PathSection::curvature","title":"function curvature"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classArc2D/#function-getclosestpointgamma","text":"virtual double getClosestPointGamma( Eigen::Vector3d & coordinate ) override Method for getting the gamma of the closes point to the path in a more efficient manner For an arc it uses a closed form equation to solve this problem. Parameters : coordinate The coordinate of the vehicle in the 3D space Return : A double with the gamma corresponding to the closest point in the path Reimplements : PathSection::getClosestPointGamma Updated on 2022-05-30 at 18:35:08 +0000","title":"function getClosestPointGamma"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classBernoulli/","text":"Bernoulli Class that implements a 2D Lemniscate of Bernoulli section. More... #include <Bernoulli.h> Inherits from PathSection Public Functions Name Bernoulli (double radius, double center_x, double center_y) Constructor for the path section that assumes the plane in which the path is placed is z=0. Bernoulli (double radius, double center_x, double center_y, double z) Constructor for the path section. virtual Eigen::Vector3d eq_pd (double t) override Path section equation. virtual Eigen::Vector3d eq_d_pd (double t) override First derivative of the path section equation with respect to the path parameter t. virtual Eigen::Vector3d eq_dd_pd (double t) override Second derivative of the path section equation with respect to the path parameter t. virtual double curvature (double t) override Compute the curvature using the direct formula. virtual double getClosestPointGamma (Eigen::Vector3d & coordinate) override Method for getting the gamma of the closest point. In this implementation the closest point is computed iteratively using Gradient Descent Method. For the first iteration, to get a good initialization, the section is divided into N partitions between [0, 2*PI] and the minimum is computed for each partition. The gamma with the minimum distance will be used to initialize the algorithm. Additional inherited members Public Functions inherited from PathSection Name virtual double tangent (double t) Default method for computing the tangent to the path section. virtual double derivative_norm (double t) Default method for computing the norm of the derivative. bool can_be_composed () Method to return whether a pathSection can be composed with other path sections or not. double limitGamma (double t) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. double getMaxGammaValue () Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. double getMinGammaValue () Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. virtual ~PathSection () Virtual destructor for the abstract class. Protected Functions inherited from PathSection Name PathSection (bool can_be_composed) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . bool setMaxGammaValue (double gamma_max) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. bool setMinGammaValue (double gamma_min) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. double GradientDescent (double gamma_o, Eigen::Vector3d & x_pos, double tolerance) Method that implements the gradient descent to minimize the error of double getInitialGammaEstimate (Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. double bisection (Eigen::Vector3d & x_pos, double a, double b) Method to implement bisection method Detailed Description class Bernoulli; Class that implements a 2D Lemniscate of Bernoulli section. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the sections library Public Functions Documentation function Bernoulli Bernoulli( double radius, double center_x, double center_y ) Constructor for the path section that assumes the plane in which the path is placed is z=0. Parameters : radius The radius of the bernoulli lamniscaste section center_x The x coordinate of the center of the bernoulli center_y The y coordinate of the center of the bernoulli function Bernoulli Bernoulli( double radius, double center_x, double center_y, double z ) Constructor for the path section. Parameters : radius The radius of the bernoulli lamniscaste section center_x The x coordinate of the center of the bernoulli center_y The y coordinate of the center of the bernoulli z The altitude in m in which to place the bernoulli function eq_pd virtual Eigen::Vector3d eq_pd( double t ) override Path section equation. Parameters : t The path parameter Return : An Eigen::Vector3d with the value of the equation of the path Reimplements : PathSection::eq_pd function eq_d_pd virtual Eigen::Vector3d eq_d_pd( double t ) override First derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter Return : An Eigen::Vector3d with the value of the derivate of the equation of the path Reimplements : PathSection::eq_d_pd function eq_dd_pd virtual Eigen::Vector3d eq_dd_pd( double t ) override Second derivative of the path section equation with respect to the path parameter t. Parameters : t The path paramter Return : An Eigen::Vector3d with the value of the derivative of the equation of the path Reimplements : PathSection::eq_dd_pd function curvature virtual double curvature( double t ) override Compute the curvature using the direct formula. Parameters : t The path parameter Return : a double with the curvature of the section Reimplements : PathSection::curvature function getClosestPointGamma virtual double getClosestPointGamma( Eigen::Vector3d & coordinate ) override Method for getting the gamma of the closest point. In this implementation the closest point is computed iteratively using Gradient Descent Method. For the first iteration, to get a good initialization, the section is divided into N partitions between [0, 2*PI] and the minimum is computed for each partition. The gamma with the minimum distance will be used to initialize the algorithm. Parameters : coordinate An Eigen::Vector3d with the coordinate of the vehicle Return : a double with the gamma corresponding to the closest point Reimplements : PathSection::getClosestPointGamma Method to return the closest point to the path By default just calls the Gradient Descent algorithm Updated on 2022-05-30 at 18:35:08 +0000","title":"Bernoulli"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classBernoulli/#bernoulli","text":"Class that implements a 2D Lemniscate of Bernoulli section. More... #include <Bernoulli.h> Inherits from PathSection","title":"Bernoulli"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classBernoulli/#public-functions","text":"Name Bernoulli (double radius, double center_x, double center_y) Constructor for the path section that assumes the plane in which the path is placed is z=0. Bernoulli (double radius, double center_x, double center_y, double z) Constructor for the path section. virtual Eigen::Vector3d eq_pd (double t) override Path section equation. virtual Eigen::Vector3d eq_d_pd (double t) override First derivative of the path section equation with respect to the path parameter t. virtual Eigen::Vector3d eq_dd_pd (double t) override Second derivative of the path section equation with respect to the path parameter t. virtual double curvature (double t) override Compute the curvature using the direct formula. virtual double getClosestPointGamma (Eigen::Vector3d & coordinate) override Method for getting the gamma of the closest point. In this implementation the closest point is computed iteratively using Gradient Descent Method. For the first iteration, to get a good initialization, the section is divided into N partitions between [0, 2*PI] and the minimum is computed for each partition. The gamma with the minimum distance will be used to initialize the algorithm.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classBernoulli/#additional-inherited-members","text":"Public Functions inherited from PathSection Name virtual double tangent (double t) Default method for computing the tangent to the path section. virtual double derivative_norm (double t) Default method for computing the norm of the derivative. bool can_be_composed () Method to return whether a pathSection can be composed with other path sections or not. double limitGamma (double t) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. double getMaxGammaValue () Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. double getMinGammaValue () Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. virtual ~PathSection () Virtual destructor for the abstract class. Protected Functions inherited from PathSection Name PathSection (bool can_be_composed) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . bool setMaxGammaValue (double gamma_max) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. bool setMinGammaValue (double gamma_min) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. double GradientDescent (double gamma_o, Eigen::Vector3d & x_pos, double tolerance) Method that implements the gradient descent to minimize the error of double getInitialGammaEstimate (Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. double bisection (Eigen::Vector3d & x_pos, double a, double b) Method to implement bisection method","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classBernoulli/#detailed-description","text":"class Bernoulli; Class that implements a 2D Lemniscate of Bernoulli section. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the sections library","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classBernoulli/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classBernoulli/#function-bernoulli","text":"Bernoulli( double radius, double center_x, double center_y ) Constructor for the path section that assumes the plane in which the path is placed is z=0. Parameters : radius The radius of the bernoulli lamniscaste section center_x The x coordinate of the center of the bernoulli center_y The y coordinate of the center of the bernoulli","title":"function Bernoulli"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classBernoulli/#function-bernoulli_1","text":"Bernoulli( double radius, double center_x, double center_y, double z ) Constructor for the path section. Parameters : radius The radius of the bernoulli lamniscaste section center_x The x coordinate of the center of the bernoulli center_y The y coordinate of the center of the bernoulli z The altitude in m in which to place the bernoulli","title":"function Bernoulli"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classBernoulli/#function-eq_pd","text":"virtual Eigen::Vector3d eq_pd( double t ) override Path section equation. Parameters : t The path parameter Return : An Eigen::Vector3d with the value of the equation of the path Reimplements : PathSection::eq_pd","title":"function eq_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classBernoulli/#function-eq_d_pd","text":"virtual Eigen::Vector3d eq_d_pd( double t ) override First derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter Return : An Eigen::Vector3d with the value of the derivate of the equation of the path Reimplements : PathSection::eq_d_pd","title":"function eq_d_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classBernoulli/#function-eq_dd_pd","text":"virtual Eigen::Vector3d eq_dd_pd( double t ) override Second derivative of the path section equation with respect to the path parameter t. Parameters : t The path paramter Return : An Eigen::Vector3d with the value of the derivative of the equation of the path Reimplements : PathSection::eq_dd_pd","title":"function eq_dd_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classBernoulli/#function-curvature","text":"virtual double curvature( double t ) override Compute the curvature using the direct formula. Parameters : t The path parameter Return : a double with the curvature of the section Reimplements : PathSection::curvature","title":"function curvature"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classBernoulli/#function-getclosestpointgamma","text":"virtual double getClosestPointGamma( Eigen::Vector3d & coordinate ) override Method for getting the gamma of the closest point. In this implementation the closest point is computed iteratively using Gradient Descent Method. For the first iteration, to get a good initialization, the section is divided into N partitions between [0, 2*PI] and the minimum is computed for each partition. The gamma with the minimum distance will be used to initialize the algorithm. Parameters : coordinate An Eigen::Vector3d with the coordinate of the vehicle Return : a double with the gamma corresponding to the closest point Reimplements : PathSection::getClosestPointGamma Method to return the closest point to the path By default just calls the Gradient Descent algorithm Updated on 2022-05-30 at 18:35:08 +0000","title":"function getClosestPointGamma"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classCircle2D/","text":"Circle2D Class that implements a 2D Circle section. More... #include <Circle2D.h> Inherits from PathSection Public Functions Name Circle2D (double radius, double center_x, double center_y) Constructor for the path section that assumes the plane in which the path is placed is z=0. Circle2D (double radius, double center_x, double center_y, double z) Constructor for the path section. virtual Eigen::Vector3d eq_pd (double t) override Path Section equation. virtual Eigen::Vector3d eq_d_pd (double t) override First derivative of the path section equation with respect to the path parameter. virtual Eigen::Vector3d eq_dd_pd (double t) override Second derivative of the path section equation with respect to the path parameter t. virtual double curvature (double t) override Compute the curvature using only the radius. Computed as 1/Radius. virtual double getClosestPointGamma (Eigen::Vector3d & coordinate) override Method for getting the gamma of the closest point. Additional inherited members Public Functions inherited from PathSection Name virtual double tangent (double t) Default method for computing the tangent to the path section. virtual double derivative_norm (double t) Default method for computing the norm of the derivative. bool can_be_composed () Method to return whether a pathSection can be composed with other path sections or not. double limitGamma (double t) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. double getMaxGammaValue () Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. double getMinGammaValue () Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. virtual ~PathSection () Virtual destructor for the abstract class. Protected Functions inherited from PathSection Name PathSection (bool can_be_composed) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . bool setMaxGammaValue (double gamma_max) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. bool setMinGammaValue (double gamma_min) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. double GradientDescent (double gamma_o, Eigen::Vector3d & x_pos, double tolerance) Method that implements the gradient descent to minimize the error of double getInitialGammaEstimate (Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. double bisection (Eigen::Vector3d & x_pos, double a, double b) Method to implement bisection method Detailed Description class Circle2D; Class that implements a 2D Circle section. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the sections library Public Functions Documentation function Circle2D Circle2D( double radius, double center_x, double center_y ) Constructor for the path section that assumes the plane in which the path is placed is z=0. Parameters : radius The radius in m of the Circle center_x The x coordinate of the center of the circle center_y The y coordinate of the center of the circle function Circle2D Circle2D( double radius, double center_x, double center_y, double z ) Constructor for the path section. Parameters : radius The radius in m of the Circle center_x The x coordinate of the center of the circle center_y The y coordinate of the center of the circle z The z axis where to place the circle function eq_pd virtual Eigen::Vector3d eq_pd( double t ) override Path Section equation. Parameters : t The path parameter Return : An Eigen::Vector3d with the values from the equation of the path Reimplements : PathSection::eq_pd function eq_d_pd virtual Eigen::Vector3d eq_d_pd( double t ) override First derivative of the path section equation with respect to the path parameter. Parameters : t The path parameter Return : An Eigen::Vector3d with the values from the derivative of the equation Reimplements : PathSection::eq_d_pd function eq_dd_pd virtual Eigen::Vector3d eq_dd_pd( double t ) override Second derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter Return : An Eigen::Vector3d with the values from the second derivative of the equation Reimplements : PathSection::eq_dd_pd function curvature virtual double curvature( double t ) override Compute the curvature using only the radius. Computed as 1/Radius. Parameters : t The path paramter Return : A double with the curvature of that section (1/radius) Reimplements : PathSection::curvature function getClosestPointGamma virtual double getClosestPointGamma( Eigen::Vector3d & coordinate ) override Method for getting the gamma of the closest point. Parameters : coordinate The vehicle position Return : A double with the gamma corresponding to the closest point in the path Reimplements : PathSection::getClosestPointGamma Method to return the closest point to the path By default just calls the Gradient Descent algorithm Updated on 2022-05-30 at 18:35:08 +0000","title":"Circle2D"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classCircle2D/#circle2d","text":"Class that implements a 2D Circle section. More... #include <Circle2D.h> Inherits from PathSection","title":"Circle2D"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classCircle2D/#public-functions","text":"Name Circle2D (double radius, double center_x, double center_y) Constructor for the path section that assumes the plane in which the path is placed is z=0. Circle2D (double radius, double center_x, double center_y, double z) Constructor for the path section. virtual Eigen::Vector3d eq_pd (double t) override Path Section equation. virtual Eigen::Vector3d eq_d_pd (double t) override First derivative of the path section equation with respect to the path parameter. virtual Eigen::Vector3d eq_dd_pd (double t) override Second derivative of the path section equation with respect to the path parameter t. virtual double curvature (double t) override Compute the curvature using only the radius. Computed as 1/Radius. virtual double getClosestPointGamma (Eigen::Vector3d & coordinate) override Method for getting the gamma of the closest point.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classCircle2D/#additional-inherited-members","text":"Public Functions inherited from PathSection Name virtual double tangent (double t) Default method for computing the tangent to the path section. virtual double derivative_norm (double t) Default method for computing the norm of the derivative. bool can_be_composed () Method to return whether a pathSection can be composed with other path sections or not. double limitGamma (double t) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. double getMaxGammaValue () Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. double getMinGammaValue () Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. virtual ~PathSection () Virtual destructor for the abstract class. Protected Functions inherited from PathSection Name PathSection (bool can_be_composed) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . bool setMaxGammaValue (double gamma_max) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. bool setMinGammaValue (double gamma_min) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. double GradientDescent (double gamma_o, Eigen::Vector3d & x_pos, double tolerance) Method that implements the gradient descent to minimize the error of double getInitialGammaEstimate (Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. double bisection (Eigen::Vector3d & x_pos, double a, double b) Method to implement bisection method","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classCircle2D/#detailed-description","text":"class Circle2D; Class that implements a 2D Circle section. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the sections library","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classCircle2D/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classCircle2D/#function-circle2d","text":"Circle2D( double radius, double center_x, double center_y ) Constructor for the path section that assumes the plane in which the path is placed is z=0. Parameters : radius The radius in m of the Circle center_x The x coordinate of the center of the circle center_y The y coordinate of the center of the circle","title":"function Circle2D"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classCircle2D/#function-circle2d_1","text":"Circle2D( double radius, double center_x, double center_y, double z ) Constructor for the path section. Parameters : radius The radius in m of the Circle center_x The x coordinate of the center of the circle center_y The y coordinate of the center of the circle z The z axis where to place the circle","title":"function Circle2D"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classCircle2D/#function-eq_pd","text":"virtual Eigen::Vector3d eq_pd( double t ) override Path Section equation. Parameters : t The path parameter Return : An Eigen::Vector3d with the values from the equation of the path Reimplements : PathSection::eq_pd","title":"function eq_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classCircle2D/#function-eq_d_pd","text":"virtual Eigen::Vector3d eq_d_pd( double t ) override First derivative of the path section equation with respect to the path parameter. Parameters : t The path parameter Return : An Eigen::Vector3d with the values from the derivative of the equation Reimplements : PathSection::eq_d_pd","title":"function eq_d_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classCircle2D/#function-eq_dd_pd","text":"virtual Eigen::Vector3d eq_dd_pd( double t ) override Second derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter Return : An Eigen::Vector3d with the values from the second derivative of the equation Reimplements : PathSection::eq_dd_pd","title":"function eq_dd_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classCircle2D/#function-curvature","text":"virtual double curvature( double t ) override Compute the curvature using only the radius. Computed as 1/Radius. Parameters : t The path paramter Return : A double with the curvature of that section (1/radius) Reimplements : PathSection::curvature","title":"function curvature"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classCircle2D/#function-getclosestpointgamma","text":"virtual double getClosestPointGamma( Eigen::Vector3d & coordinate ) override Method for getting the gamma of the closest point. Parameters : coordinate The vehicle position Return : A double with the gamma corresponding to the closest point in the path Reimplements : PathSection::getClosestPointGamma Method to return the closest point to the path By default just calls the Gradient Descent algorithm Updated on 2022-05-30 at 18:35:08 +0000","title":"function getClosestPointGamma"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstRabbitSpeed/","text":"ConstRabbitSpeed Class that implements a constant speed value requirement. This class will receive in its constructor the desired velocity for the speed in the path frame. More... #include <ConstRabbitSpeed.h> Inherits from Speed Public Functions Name ConstRabbitSpeed (double rabbit_speed, double default_val) Constructor for the ConstVehicleSpeed class. Receives as a parameter a double which represents the desired speed of the vehicle in the inertial frame. virtual double getVd (double gamma, double tangent_norm) override Method to get the desired velocity for the virtual target on the path given the path parameter (given by the value of gamma) virtual double get_d_Vd (double gamma, double tangent_norm) override Method to get the desired acceleration for the virtual target on the path given the path parameter (given by the value of gamma) virtual double getDefaultVd (double gamma, double tangent_norm) override Method to get the default desired velocity for safety when we are doing path following and want to have a backup value. Additional inherited members Public Functions inherited from Speed Name virtual ~Speed () Virtual destructor for the abstract class. Detailed Description class ConstRabbitSpeed; Class that implements a constant speed value requirement. This class will receive in its constructor the desired velocity for the speed in the path frame. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the speeds library Public Functions Documentation function ConstRabbitSpeed ConstRabbitSpeed( double rabbit_speed, double default_val ) Constructor for the ConstVehicleSpeed class. Receives as a parameter a double which represents the desired speed of the vehicle in the inertial frame. Parameters : rabbit_speed The speed of the path parameter (in the path frame) default_val The default value of the path parameter (if outside the parameterization bounds) function getVd virtual double getVd( double gamma, double tangent_norm ) override Method to get the desired velocity for the virtual target on the path given the path parameter (given by the value of gamma) Parameters : gamma The path parameter tangent_norm The norm of the tangent to the path Return : A double with the desired speed Reimplements : Speed::getVd function get_d_Vd virtual double get_d_Vd( double gamma, double tangent_norm ) override Method to get the desired acceleration for the virtual target on the path given the path parameter (given by the value of gamma) Parameters : gamma The value of the path parameter tangent_norm The norm of the tangent to the path Return : A double with the desired acceleration Reimplements : Speed::get_d_Vd function getDefaultVd virtual double getDefaultVd( double gamma, double tangent_norm ) override Method to get the default desired velocity for safety when we are doing path following and want to have a backup value. Parameters : gamma The value of the path parameter tangent_norm The norm of the tangent to the path in gamma Return : A double with the default desired speed Reimplements : Speed::getDefaultVd Updated on 2022-05-30 at 18:35:08 +0000","title":"ConstRabbitSpeed"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstRabbitSpeed/#constrabbitspeed","text":"Class that implements a constant speed value requirement. This class will receive in its constructor the desired velocity for the speed in the path frame. More... #include <ConstRabbitSpeed.h> Inherits from Speed","title":"ConstRabbitSpeed"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstRabbitSpeed/#public-functions","text":"Name ConstRabbitSpeed (double rabbit_speed, double default_val) Constructor for the ConstVehicleSpeed class. Receives as a parameter a double which represents the desired speed of the vehicle in the inertial frame. virtual double getVd (double gamma, double tangent_norm) override Method to get the desired velocity for the virtual target on the path given the path parameter (given by the value of gamma) virtual double get_d_Vd (double gamma, double tangent_norm) override Method to get the desired acceleration for the virtual target on the path given the path parameter (given by the value of gamma) virtual double getDefaultVd (double gamma, double tangent_norm) override Method to get the default desired velocity for safety when we are doing path following and want to have a backup value.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstRabbitSpeed/#additional-inherited-members","text":"Public Functions inherited from Speed Name virtual ~Speed () Virtual destructor for the abstract class.","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstRabbitSpeed/#detailed-description","text":"class ConstRabbitSpeed; Class that implements a constant speed value requirement. This class will receive in its constructor the desired velocity for the speed in the path frame. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the speeds library","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstRabbitSpeed/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstRabbitSpeed/#function-constrabbitspeed","text":"ConstRabbitSpeed( double rabbit_speed, double default_val ) Constructor for the ConstVehicleSpeed class. Receives as a parameter a double which represents the desired speed of the vehicle in the inertial frame. Parameters : rabbit_speed The speed of the path parameter (in the path frame) default_val The default value of the path parameter (if outside the parameterization bounds)","title":"function ConstRabbitSpeed"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstRabbitSpeed/#function-getvd","text":"virtual double getVd( double gamma, double tangent_norm ) override Method to get the desired velocity for the virtual target on the path given the path parameter (given by the value of gamma) Parameters : gamma The path parameter tangent_norm The norm of the tangent to the path Return : A double with the desired speed Reimplements : Speed::getVd","title":"function getVd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstRabbitSpeed/#function-get_d_vd","text":"virtual double get_d_Vd( double gamma, double tangent_norm ) override Method to get the desired acceleration for the virtual target on the path given the path parameter (given by the value of gamma) Parameters : gamma The value of the path parameter tangent_norm The norm of the tangent to the path Return : A double with the desired acceleration Reimplements : Speed::get_d_Vd","title":"function get_d_Vd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstRabbitSpeed/#function-getdefaultvd","text":"virtual double getDefaultVd( double gamma, double tangent_norm ) override Method to get the default desired velocity for safety when we are doing path following and want to have a backup value. Parameters : gamma The value of the path parameter tangent_norm The norm of the tangent to the path in gamma Return : A double with the default desired speed Reimplements : Speed::getDefaultVd Updated on 2022-05-30 at 18:35:08 +0000","title":"function getDefaultVd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstVehicleSpeed/","text":"ConstVehicleSpeed Class that implements a constant speed value requirement. This class will receive in its constructor the desired velocity for the speed in the inertial frame and will implement the corresponding speed in the path frame. More... #include <ConstVehicleSpeed.h> Inherits from Speed Public Functions Name ConstVehicleSpeed (double vehicle_speed, double default_val) Constructor for the ConstVehicleSpeed class. Receives as a parameter a double which represents the desired speed of the vehicle in the inertial frame. virtual double getVd (double gamma, double tangent_norm) override Method to get the desired velocity for the virtual target on the path given the path parameter (given by the value of gamma) virtual double get_d_Vd (double gamma, double tangent_norm) override Method to get the desired acceleration for the virtual target on the path given the path parameter (given by the value of gamma) virtual double getDefaultVd (double gamma, double tangent_norm) override Method to get the default desired velocity for safety when we are doing path following and want to have a backup value. Additional inherited members Public Functions inherited from Speed Name virtual ~Speed () Virtual destructor for the abstract class. Detailed Description class ConstVehicleSpeed; Class that implements a constant speed value requirement. This class will receive in its constructor the desired velocity for the speed in the inertial frame and will implement the corresponding speed in the path frame. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the speeds library Public Functions Documentation function ConstVehicleSpeed ConstVehicleSpeed( double vehicle_speed, double default_val ) Constructor for the ConstVehicleSpeed class. Receives as a parameter a double which represents the desired speed of the vehicle in the inertial frame. Parameters : vehicle_speed The desired speed for the vehicle in m/s default_val The desired default_value when the vehicle is outside the gamma range function getVd virtual double getVd( double gamma, double tangent_norm ) override Method to get the desired velocity for the virtual target on the path given the path parameter (given by the value of gamma) Parameters : gamma The path parameter tangent_norm The norm of the tangent to the path Return : A double with the desired speed Reimplements : Speed::getVd function get_d_Vd virtual double get_d_Vd( double gamma, double tangent_norm ) override Method to get the desired acceleration for the virtual target on the path given the path parameter (given by the value of gamma) Parameters : gamma The value of the path parameter tangent_norm The norm of the tangent to the path Return : A double with the desired acceleration Reimplements : Speed::get_d_Vd function getDefaultVd virtual double getDefaultVd( double gamma, double tangent_norm ) override Method to get the default desired velocity for safety when we are doing path following and want to have a backup value. Parameters : gamma The value of the path parameter tangent_norm The norm of the tangent to the path in gamma Return : A double with the default desired speed Reimplements : Speed::getDefaultVd Updated on 2022-05-30 at 18:35:08 +0000","title":"ConstVehicleSpeed"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstVehicleSpeed/#constvehiclespeed","text":"Class that implements a constant speed value requirement. This class will receive in its constructor the desired velocity for the speed in the inertial frame and will implement the corresponding speed in the path frame. More... #include <ConstVehicleSpeed.h> Inherits from Speed","title":"ConstVehicleSpeed"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstVehicleSpeed/#public-functions","text":"Name ConstVehicleSpeed (double vehicle_speed, double default_val) Constructor for the ConstVehicleSpeed class. Receives as a parameter a double which represents the desired speed of the vehicle in the inertial frame. virtual double getVd (double gamma, double tangent_norm) override Method to get the desired velocity for the virtual target on the path given the path parameter (given by the value of gamma) virtual double get_d_Vd (double gamma, double tangent_norm) override Method to get the desired acceleration for the virtual target on the path given the path parameter (given by the value of gamma) virtual double getDefaultVd (double gamma, double tangent_norm) override Method to get the default desired velocity for safety when we are doing path following and want to have a backup value.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstVehicleSpeed/#additional-inherited-members","text":"Public Functions inherited from Speed Name virtual ~Speed () Virtual destructor for the abstract class.","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstVehicleSpeed/#detailed-description","text":"class ConstVehicleSpeed; Class that implements a constant speed value requirement. This class will receive in its constructor the desired velocity for the speed in the inertial frame and will implement the corresponding speed in the path frame. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the speeds library","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstVehicleSpeed/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstVehicleSpeed/#function-constvehiclespeed","text":"ConstVehicleSpeed( double vehicle_speed, double default_val ) Constructor for the ConstVehicleSpeed class. Receives as a parameter a double which represents the desired speed of the vehicle in the inertial frame. Parameters : vehicle_speed The desired speed for the vehicle in m/s default_val The desired default_value when the vehicle is outside the gamma range","title":"function ConstVehicleSpeed"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstVehicleSpeed/#function-getvd","text":"virtual double getVd( double gamma, double tangent_norm ) override Method to get the desired velocity for the virtual target on the path given the path parameter (given by the value of gamma) Parameters : gamma The path parameter tangent_norm The norm of the tangent to the path Return : A double with the desired speed Reimplements : Speed::getVd","title":"function getVd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstVehicleSpeed/#function-get_d_vd","text":"virtual double get_d_Vd( double gamma, double tangent_norm ) override Method to get the desired acceleration for the virtual target on the path given the path parameter (given by the value of gamma) Parameters : gamma The value of the path parameter tangent_norm The norm of the tangent to the path Return : A double with the desired acceleration Reimplements : Speed::get_d_Vd","title":"function get_d_Vd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstVehicleSpeed/#function-getdefaultvd","text":"virtual double getDefaultVd( double gamma, double tangent_norm ) override Method to get the default desired velocity for safety when we are doing path following and want to have a backup value. Parameters : gamma The value of the path parameter tangent_norm The norm of the tangent to the path in gamma Return : A double with the default desired speed Reimplements : Speed::getDefaultVd Updated on 2022-05-30 at 18:35:08 +0000","title":"function getDefaultVd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classLine/","text":"Line Class that implements a 3D line section. More... #include <Line.h> Inherits from PathSection Public Functions Name Line (Eigen::Vector3d start_point, Eigen::Vector3d end_point) Constructor for the 3DLine class. It assumes that the reference for the frame is (0, 0, 0) Line (Eigen::Vector3d start_point, Eigen::Vector3d end_point, Eigen::Vector3d ref_point) Constructor for the 3DLine class. virtual Eigen::Vector3d eq_pd (double t) override Path section equation. virtual Eigen::Vector3d eq_d_pd (double t) override First derivative of the path section equation with respect to the path parameter t. virtual Eigen::Vector3d eq_dd_pd (double t) override Second derivative of the path section equation with respect to the path parameter t. virtual double curvature (double t) override The curvature of a line is constant, therefore we can make the computation really efficient. virtual double getClosestPointGamma (Eigen::Vector3d & coordinate) override Method for getting the gamma of the closes point to the path in a more efficient manner For a line it uses a closed form equation to solve this problem. Additional inherited members Public Functions inherited from PathSection Name virtual double tangent (double t) Default method for computing the tangent to the path section. virtual double derivative_norm (double t) Default method for computing the norm of the derivative. bool can_be_composed () Method to return whether a pathSection can be composed with other path sections or not. double limitGamma (double t) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. double getMaxGammaValue () Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. double getMinGammaValue () Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. virtual ~PathSection () Virtual destructor for the abstract class. Protected Functions inherited from PathSection Name PathSection (bool can_be_composed) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . bool setMaxGammaValue (double gamma_max) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. bool setMinGammaValue (double gamma_min) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. double GradientDescent (double gamma_o, Eigen::Vector3d & x_pos, double tolerance) Method that implements the gradient descent to minimize the error of double getInitialGammaEstimate (Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. double bisection (Eigen::Vector3d & x_pos, double a, double b) Method to implement bisection method Detailed Description class Line; Class that implements a 3D line section. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the sections library Public Functions Documentation function Line Line( Eigen::Vector3d start_point, Eigen::Vector3d end_point ) Constructor for the 3DLine class. It assumes that the reference for the frame is (0, 0, 0) Parameters : start_point The starting point in the 3D space end_point The end point in the 3D space function Line Line( Eigen::Vector3d start_point, Eigen::Vector3d end_point, Eigen::Vector3d ref_point ) Constructor for the 3DLine class. Parameters : start_point The starting point in the 3D space end_point The end point in the 3D space ref_point The ref_point in the 3D to draw the line relative to this reference function eq_pd virtual Eigen::Vector3d eq_pd( double t ) override Path section equation. Parameters : t The path parameter Return : An Eigen::Vector3d with the value of the equation of the path Reimplements : PathSection::eq_pd function eq_d_pd virtual Eigen::Vector3d eq_d_pd( double t ) override First derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter Return : An Eigen::Vector3d with the value of the derivative of the path equation Reimplements : PathSection::eq_d_pd function eq_dd_pd virtual Eigen::Vector3d eq_dd_pd( double t ) override Second derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter Return : An Eigen::Vector3d with the value of the second derivative of the path equation Reimplements : PathSection::eq_dd_pd function curvature virtual double curvature( double t ) override The curvature of a line is constant, therefore we can make the computation really efficient. Parameters : t The path parameter Return : A double = 0 (since a line has no curvature) Reimplements : PathSection::curvature function getClosestPointGamma virtual double getClosestPointGamma( Eigen::Vector3d & coordinate ) override Method for getting the gamma of the closes point to the path in a more efficient manner For a line it uses a closed form equation to solve this problem. Parameters : coordinate The vehicle coordinate Return : A double with the gamma corresponding to the cloest point in the path. Reimplements : PathSection::getClosestPointGamma Updated on 2022-05-30 at 18:35:08 +0000","title":"Line"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classLine/#line","text":"Class that implements a 3D line section. More... #include <Line.h> Inherits from PathSection","title":"Line"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classLine/#public-functions","text":"Name Line (Eigen::Vector3d start_point, Eigen::Vector3d end_point) Constructor for the 3DLine class. It assumes that the reference for the frame is (0, 0, 0) Line (Eigen::Vector3d start_point, Eigen::Vector3d end_point, Eigen::Vector3d ref_point) Constructor for the 3DLine class. virtual Eigen::Vector3d eq_pd (double t) override Path section equation. virtual Eigen::Vector3d eq_d_pd (double t) override First derivative of the path section equation with respect to the path parameter t. virtual Eigen::Vector3d eq_dd_pd (double t) override Second derivative of the path section equation with respect to the path parameter t. virtual double curvature (double t) override The curvature of a line is constant, therefore we can make the computation really efficient. virtual double getClosestPointGamma (Eigen::Vector3d & coordinate) override Method for getting the gamma of the closes point to the path in a more efficient manner For a line it uses a closed form equation to solve this problem.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classLine/#additional-inherited-members","text":"Public Functions inherited from PathSection Name virtual double tangent (double t) Default method for computing the tangent to the path section. virtual double derivative_norm (double t) Default method for computing the norm of the derivative. bool can_be_composed () Method to return whether a pathSection can be composed with other path sections or not. double limitGamma (double t) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. double getMaxGammaValue () Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. double getMinGammaValue () Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. virtual ~PathSection () Virtual destructor for the abstract class. Protected Functions inherited from PathSection Name PathSection (bool can_be_composed) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . bool setMaxGammaValue (double gamma_max) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. bool setMinGammaValue (double gamma_min) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. double GradientDescent (double gamma_o, Eigen::Vector3d & x_pos, double tolerance) Method that implements the gradient descent to minimize the error of double getInitialGammaEstimate (Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. double bisection (Eigen::Vector3d & x_pos, double a, double b) Method to implement bisection method","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classLine/#detailed-description","text":"class Line; Class that implements a 3D line section. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the sections library","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classLine/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classLine/#function-line","text":"Line( Eigen::Vector3d start_point, Eigen::Vector3d end_point ) Constructor for the 3DLine class. It assumes that the reference for the frame is (0, 0, 0) Parameters : start_point The starting point in the 3D space end_point The end point in the 3D space","title":"function Line"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classLine/#function-line_1","text":"Line( Eigen::Vector3d start_point, Eigen::Vector3d end_point, Eigen::Vector3d ref_point ) Constructor for the 3DLine class. Parameters : start_point The starting point in the 3D space end_point The end point in the 3D space ref_point The ref_point in the 3D to draw the line relative to this reference","title":"function Line"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classLine/#function-eq_pd","text":"virtual Eigen::Vector3d eq_pd( double t ) override Path section equation. Parameters : t The path parameter Return : An Eigen::Vector3d with the value of the equation of the path Reimplements : PathSection::eq_pd","title":"function eq_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classLine/#function-eq_d_pd","text":"virtual Eigen::Vector3d eq_d_pd( double t ) override First derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter Return : An Eigen::Vector3d with the value of the derivative of the path equation Reimplements : PathSection::eq_d_pd","title":"function eq_d_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classLine/#function-eq_dd_pd","text":"virtual Eigen::Vector3d eq_dd_pd( double t ) override Second derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter Return : An Eigen::Vector3d with the value of the second derivative of the path equation Reimplements : PathSection::eq_dd_pd","title":"function eq_dd_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classLine/#function-curvature","text":"virtual double curvature( double t ) override The curvature of a line is constant, therefore we can make the computation really efficient. Parameters : t The path parameter Return : A double = 0 (since a line has no curvature) Reimplements : PathSection::curvature","title":"function curvature"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classLine/#function-getclosestpointgamma","text":"virtual double getClosestPointGamma( Eigen::Vector3d & coordinate ) override Method for getting the gamma of the closes point to the path in a more efficient manner For a line it uses a closed form equation to solve this problem. Parameters : coordinate The vehicle coordinate Return : A double with the gamma corresponding to the cloest point in the path. Reimplements : PathSection::getClosestPointGamma Updated on 2022-05-30 at 18:35:08 +0000","title":"function getClosestPointGamma"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/","text":"Path The Path class! This class implements all the meethod to get the desired position, derivative, second derivatives, tangent, curvature and derivative norm. More... #include <Path.h> Public Functions Name Path () The constructor for the path class. ~Path () The destructor for the path class. Frees all the memory allocated for each path section inside the vector of section. bool isEmpty () Method to check wether the path contains path sections or not. bool addPathSection ( PathSection * path_section) Method to add a path section to the path. bool addSpeedSection ( Speed * speed_section) * Method to add a speed section to the path std::tuple< PathSection *, double > getPathSection (double gamma) Method to get the path section corresponding to a given gamma. std::optional< Eigen::Vector3d > eq_pd (double gamma) * Method to retrieve the position in the path given the path parameter gamma std::optional< Eigen::Vector3d > eq_d_pd (double gamma) * Method to retrieve the derivative of the position in the path given the path parameter gamma std::optional< Eigen::Vector3d > eq_dd_pd (double gamma) * Method to retrieve the second derivative of the position in the path given the path parameter gamma std::optional< double > tangent (double gamma) * Get the tangent to the path, given the gamma parameter std::optional< double > curvature (double gamma) * The curvature of the path, given the gamma parameter std::optional< double > derivative_norm (double gamma) * The norm of the derivative of the path std::optional< double > eq_vd (double gamma) Method to get the desired speed profile for a particular part of the path given the path parameter gamma. std::optional< double > eq_d_vd (double gamma) Method to get the desired acceleration profile for a paritcular part of the path given the path parameter. std::pair< double, double > getMinMaxGamma () Method to retrieve the minimum and maximum gamma values allowed for the current path. std::optional< double > getClosestGamma (Eigen::Vector3d & coordinate) Method to get the gamma corresponding to the closest point on the path, relative to the coordinate passed as argument. Public Attributes Name std::vector< PathSection * > sections_ List of PathSections to follow. Detailed Description class Path; The Path class! This class implements all the meethod to get the desired position, derivative, second derivatives, tangent, curvature and derivative norm. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class stores a list of sections, and switches between sections based on the gamma value passed to the functions This class has the option to have a single section (for example, appropriate for a Bernoulli ) and the option to have multiple section (for example, lines and arcs to make lawnmowers) Public Functions Documentation function Path Path() The constructor for the path class. function ~Path ~Path() The destructor for the path class. Frees all the memory allocated for each path section inside the vector of section. Destructor for the Path object. Deletes the memory allocated for each path section inside the vector of sections. function isEmpty bool isEmpty() Method to check wether the path contains path sections or not. Return : A boolean true if the path contains path sections in the vector function addPathSection bool addPathSection( PathSection * path_section ) Method to add a path section to the path. Parameters : *path_section A Pointer to a PathSection object (can be Line , Arc2D , Bernoulli , etc...) Return : true if path was added with success or false if not function addSpeedSection bool addSpeedSection( Speed * speed_section ) Method to add a speed section to the path Parameters : speed_section A Pointer to a SpeedSection object (can be ConstRabbitSpeed , ConstVehicleSpeed , ...) Return : true if the speed was added with success or false if not function getPathSection std::tuple< PathSection *, double > getPathSection( double gamma ) Method to get the path section corresponding to a given gamma. Parameters : gamma - A double with the path parameter Return : The PathSection object corresponding to the given gamma and the internal gamma corresponding to that path section function eq_pd std::optional< Eigen::Vector3d > eq_pd( double gamma ) Method to retrieve the position in the path given the path parameter gamma Parameters : gamma - A double with the path parameter Return : A vector (3x1) with [x(gamma), y(gamma), z(gamma)] function eq_d_pd std::optional< Eigen::Vector3d > eq_d_pd( double gamma ) Method to retrieve the derivative of the position in the path given the path parameter gamma Parameters : gamma - A double with the path parameter Return : A vector (3x1) with [x_dot(gamma, y_dot(gamma), z_dot(gamma)] function eq_dd_pd std::optional< Eigen::Vector3d > eq_dd_pd( double gamma ) Method to retrieve the second derivative of the position in the path given the path parameter gamma Parameters : gamma - A double with the path parameter Return : A vector (3x1) with [x_ddot(gamma), y_ddot(gamma), z_ddot(gamma)] function tangent std::optional< double > tangent( double gamma ) Get the tangent to the path, given the gamma parameter Parameters : gamma - A double with the path parameter Return : A double with the tangent size function curvature std::optional< double > curvature( double gamma ) The curvature of the path, given the gamma parameter Parameters : gamma - A double with the path parameter Return : A double with the curvature of the path function derivative_norm std::optional< double > derivative_norm( double gamma ) The norm of the derivative of the path Parameters : gamma - A double with the path parameter Return : A double with the norm of the derivative of the path function eq_vd std::optional< double > eq_vd( double gamma ) Method to get the desired speed profile for a particular part of the path given the path parameter gamma. Parameters : gamma A double with the path parameter Return : A double with the value of vd function eq_d_vd std::optional< double > eq_d_vd( double gamma ) Method to get the desired acceleration profile for a paritcular part of the path given the path parameter. Parameters : gamma A double with the path parameter Return : A double with the valud of d_vd function getMinMaxGamma std::pair< double, double > getMinMaxGamma() Method to retrieve the minimum and maximum gamma values allowed for the current path. Return : A pair with 2 doubles with the first being the minimum value and the second the maximum value Method to return the minimum and maximum value that gamma can achive in the path. function getClosestGamma std::optional< double > getClosestGamma( Eigen::Vector3d & coordinate ) Method to get the gamma corresponding to the closest point on the path, relative to the coordinate passed as argument. Parameters : coordinate The coordinate of the vehicle Return : A double with the gamma of the path corresponding to the closest point on the path Public Attributes Documentation variable sections_ std::vector< PathSection * > sections_; List of PathSections to follow. Updated on 2022-05-30 at 18:35:08 +0000","title":"Path"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#path","text":"The Path class! This class implements all the meethod to get the desired position, derivative, second derivatives, tangent, curvature and derivative norm. More... #include <Path.h>","title":"Path"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#public-functions","text":"Name Path () The constructor for the path class. ~Path () The destructor for the path class. Frees all the memory allocated for each path section inside the vector of section. bool isEmpty () Method to check wether the path contains path sections or not. bool addPathSection ( PathSection * path_section) Method to add a path section to the path. bool addSpeedSection ( Speed * speed_section) * Method to add a speed section to the path std::tuple< PathSection *, double > getPathSection (double gamma) Method to get the path section corresponding to a given gamma. std::optional< Eigen::Vector3d > eq_pd (double gamma) * Method to retrieve the position in the path given the path parameter gamma std::optional< Eigen::Vector3d > eq_d_pd (double gamma) * Method to retrieve the derivative of the position in the path given the path parameter gamma std::optional< Eigen::Vector3d > eq_dd_pd (double gamma) * Method to retrieve the second derivative of the position in the path given the path parameter gamma std::optional< double > tangent (double gamma) * Get the tangent to the path, given the gamma parameter std::optional< double > curvature (double gamma) * The curvature of the path, given the gamma parameter std::optional< double > derivative_norm (double gamma) * The norm of the derivative of the path std::optional< double > eq_vd (double gamma) Method to get the desired speed profile for a particular part of the path given the path parameter gamma. std::optional< double > eq_d_vd (double gamma) Method to get the desired acceleration profile for a paritcular part of the path given the path parameter. std::pair< double, double > getMinMaxGamma () Method to retrieve the minimum and maximum gamma values allowed for the current path. std::optional< double > getClosestGamma (Eigen::Vector3d & coordinate) Method to get the gamma corresponding to the closest point on the path, relative to the coordinate passed as argument.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#public-attributes","text":"Name std::vector< PathSection * > sections_ List of PathSections to follow.","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#detailed-description","text":"class Path; The Path class! This class implements all the meethod to get the desired position, derivative, second derivatives, tangent, curvature and derivative norm. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class stores a list of sections, and switches between sections based on the gamma value passed to the functions This class has the option to have a single section (for example, appropriate for a Bernoulli ) and the option to have multiple section (for example, lines and arcs to make lawnmowers)","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#function-path","text":"Path() The constructor for the path class.","title":"function Path"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#function-path_1","text":"~Path() The destructor for the path class. Frees all the memory allocated for each path section inside the vector of section. Destructor for the Path object. Deletes the memory allocated for each path section inside the vector of sections.","title":"function ~Path"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#function-isempty","text":"bool isEmpty() Method to check wether the path contains path sections or not. Return : A boolean true if the path contains path sections in the vector","title":"function isEmpty"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#function-addpathsection","text":"bool addPathSection( PathSection * path_section ) Method to add a path section to the path. Parameters : *path_section A Pointer to a PathSection object (can be Line , Arc2D , Bernoulli , etc...) Return : true if path was added with success or false if not","title":"function addPathSection"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#function-addspeedsection","text":"bool addSpeedSection( Speed * speed_section ) Method to add a speed section to the path Parameters : speed_section A Pointer to a SpeedSection object (can be ConstRabbitSpeed , ConstVehicleSpeed , ...) Return : true if the speed was added with success or false if not","title":"function addSpeedSection"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#function-getpathsection","text":"std::tuple< PathSection *, double > getPathSection( double gamma ) Method to get the path section corresponding to a given gamma. Parameters : gamma - A double with the path parameter Return : The PathSection object corresponding to the given gamma and the internal gamma corresponding to that path section","title":"function getPathSection"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#function-eq_pd","text":"std::optional< Eigen::Vector3d > eq_pd( double gamma ) Method to retrieve the position in the path given the path parameter gamma Parameters : gamma - A double with the path parameter Return : A vector (3x1) with [x(gamma), y(gamma), z(gamma)]","title":"function eq_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#function-eq_d_pd","text":"std::optional< Eigen::Vector3d > eq_d_pd( double gamma ) Method to retrieve the derivative of the position in the path given the path parameter gamma Parameters : gamma - A double with the path parameter Return : A vector (3x1) with [x_dot(gamma, y_dot(gamma), z_dot(gamma)]","title":"function eq_d_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#function-eq_dd_pd","text":"std::optional< Eigen::Vector3d > eq_dd_pd( double gamma ) Method to retrieve the second derivative of the position in the path given the path parameter gamma Parameters : gamma - A double with the path parameter Return : A vector (3x1) with [x_ddot(gamma), y_ddot(gamma), z_ddot(gamma)]","title":"function eq_dd_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#function-tangent","text":"std::optional< double > tangent( double gamma ) Get the tangent to the path, given the gamma parameter Parameters : gamma - A double with the path parameter Return : A double with the tangent size","title":"function tangent"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#function-curvature","text":"std::optional< double > curvature( double gamma ) The curvature of the path, given the gamma parameter Parameters : gamma - A double with the path parameter Return : A double with the curvature of the path","title":"function curvature"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#function-derivative_norm","text":"std::optional< double > derivative_norm( double gamma ) The norm of the derivative of the path Parameters : gamma - A double with the path parameter Return : A double with the norm of the derivative of the path","title":"function derivative_norm"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#function-eq_vd","text":"std::optional< double > eq_vd( double gamma ) Method to get the desired speed profile for a particular part of the path given the path parameter gamma. Parameters : gamma A double with the path parameter Return : A double with the value of vd","title":"function eq_vd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#function-eq_d_vd","text":"std::optional< double > eq_d_vd( double gamma ) Method to get the desired acceleration profile for a paritcular part of the path given the path parameter. Parameters : gamma A double with the path parameter Return : A double with the valud of d_vd","title":"function eq_d_vd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#function-getminmaxgamma","text":"std::pair< double, double > getMinMaxGamma() Method to retrieve the minimum and maximum gamma values allowed for the current path. Return : A pair with 2 doubles with the first being the minimum value and the second the maximum value Method to return the minimum and maximum value that gamma can achive in the path.","title":"function getMinMaxGamma"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#function-getclosestgamma","text":"std::optional< double > getClosestGamma( Eigen::Vector3d & coordinate ) Method to get the gamma corresponding to the closest point on the path, relative to the coordinate passed as argument. Parameters : coordinate The coordinate of the vehicle Return : A double with the gamma of the path corresponding to the closest point on the path","title":"function getClosestGamma"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#variable-sections_","text":"std::vector< PathSection * > sections_; List of PathSections to follow. Updated on 2022-05-30 at 18:35:08 +0000","title":"variable sections_"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathNode/","text":"PathNode Implementation of the PathNode . Creates a Path , adds elements to the path and publishes the path data when listening to the path parameter gamma. More... #include <PathNode.h> Public Functions Name PathNode (ros::NodeHandle * nh, ros::NodeHandle * nh_p) Constructor of the PathNode class. ~PathNode () Destructor of the PathNode class. Detailed Description class PathNode; Implementation of the PathNode . Creates a Path , adds elements to the path and publishes the path data when listening to the path parameter gamma. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT Public Functions Documentation function PathNode PathNode( ros::NodeHandle * nh, ros::NodeHandle * nh_p ) Constructor of the PathNode class. Parameters : nh Pointer to a public ROS NodeHandle nh_p Pointer to a private ROS NodeHandle nh A pointer to the public ROS node handle nh_p A pointer to the private ROS node handle PathNode constructor. Receives the ROS node handles as inputs and initializes the subscribers, publishers, timers, parameters, etc... function ~PathNode ~PathNode() Destructor of the PathNode class. Class destructor. Called when deleting the class object. Updated on 2022-05-30 at 18:35:08 +0000","title":"PathNode"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathNode/#pathnode","text":"Implementation of the PathNode . Creates a Path , adds elements to the path and publishes the path data when listening to the path parameter gamma. More... #include <PathNode.h>","title":"PathNode"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathNode/#public-functions","text":"Name PathNode (ros::NodeHandle * nh, ros::NodeHandle * nh_p) Constructor of the PathNode class. ~PathNode () Destructor of the PathNode class.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathNode/#detailed-description","text":"class PathNode; Implementation of the PathNode . Creates a Path , adds elements to the path and publishes the path data when listening to the path parameter gamma. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathNode/#function-pathnode","text":"PathNode( ros::NodeHandle * nh, ros::NodeHandle * nh_p ) Constructor of the PathNode class. Parameters : nh Pointer to a public ROS NodeHandle nh_p Pointer to a private ROS NodeHandle nh A pointer to the public ROS node handle nh_p A pointer to the private ROS node handle PathNode constructor. Receives the ROS node handles as inputs and initializes the subscribers, publishers, timers, parameters, etc...","title":"function PathNode"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathNode/#function-pathnode_1","text":"~PathNode() Destructor of the PathNode class. Class destructor. Called when deleting the class object. Updated on 2022-05-30 at 18:35:08 +0000","title":"function ~PathNode"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/","text":"PathSection An abstract class that is used as a template for Path Sections. More... #include <PathSection.h> Inherited by Arc2D , Bernoulli , Circle2D , Line , Polinomial5 , Polynomial5 , Sinusoid2D Public Functions Name virtual Eigen::Vector3d eq_pd (double t) =0 The Path section equation. virtual Eigen::Vector3d eq_d_pd (double t) =0 First derivative of the path section equation with respect to path parameter t. virtual Eigen::Vector3d eq_dd_pd (double t) =0 Second derivative of the path section equation with respect to the path parameter t. virtual double tangent (double t) Default method for computing the tangent to the path section. virtual double curvature (double t) Default method for computing the curvature. The default implementation implements the general formula to compute the curvature based on the derivative equations of the path. virtual double derivative_norm (double t) Default method for computing the norm of the derivative. virtual double getClosestPointGamma (Eigen::Vector3d & coordinate) Default method for getting the gamma of the closed point to the path. By default this method uses gradient Descent algorithm to compute the closest point in the path with the initial guess of gamma=0.0. bool can_be_composed () Method to return whether a pathSection can be composed with other path sections or not. double limitGamma (double t) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. double getMaxGammaValue () Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. double getMinGammaValue () Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. virtual ~PathSection () Virtual destructor for the abstract class. Protected Functions Name PathSection (bool can_be_composed) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . bool setMaxGammaValue (double gamma_max) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. bool setMinGammaValue (double gamma_min) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. double GradientDescent (double gamma_o, Eigen::Vector3d & x_pos, double tolerance) Method that implements the gradient descent to minimize the error of double getInitialGammaEstimate (Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. double bisection (Eigen::Vector3d & x_pos, double a, double b) Method to implement bisection method Detailed Description class PathSection; An abstract class that is used as a template for Path Sections. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT For path sections that can_be_composed the minimum value of gamma will be defaulted to 0 (and cannot be changed) in order not to mess with the Path section switching algorithm. The maximum value can be any greater than 0. For path sections where can_be_composed = false, the minimum value for gamma if -inf an the maximum value if +inf (but these can be changed) Public Functions Documentation function eq_pd virtual Eigen::Vector3d eq_pd( double t ) =0 The Path section equation. Parameters : t The path parameter Return : An Eigen::Vector3d with the equation of the path with respect to the path parameter Reimplemented by : Polinomial5::eq_pd , Polynomial5::eq_pd , Line::eq_pd , Sinusoid2D::eq_pd , Circle2D::eq_pd , Bernoulli::eq_pd , Arc2D::eq_pd function eq_d_pd virtual Eigen::Vector3d eq_d_pd( double t ) =0 First derivative of the path section equation with respect to path parameter t. Parameters : t The path parameter Return : An Eigen::Vector3d with the first derivative of the path equation with respect to the path parameter Reimplemented by : Polinomial5::eq_d_pd , Polynomial5::eq_d_pd , Line::eq_d_pd , Sinusoid2D::eq_d_pd , Circle2D::eq_d_pd , Bernoulli::eq_d_pd , Arc2D::eq_d_pd function eq_dd_pd virtual Eigen::Vector3d eq_dd_pd( double t ) =0 Second derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter Return : An Eigen::Vector3d with the second derivative of the path equation with respect to the path paramter Reimplemented by : Polinomial5::eq_dd_pd , Polynomial5::eq_dd_pd , Line::eq_dd_pd , Circle2D::eq_dd_pd , Bernoulli::eq_dd_pd , Sinusoid2D::eq_dd_pd , Arc2D::eq_dd_pd function tangent virtual double tangent( double t ) Default method for computing the tangent to the path section. Parameters : t The path parameter Return : A double with the angle of the tangent to the path function curvature virtual double curvature( double t ) Default method for computing the curvature. The default implementation implements the general formula to compute the curvature based on the derivative equations of the path. Parameters : t The path parameter Return : A double with the path curvature Reimplemented by : Line::curvature , Circle2D::curvature , Bernoulli::curvature , Arc2D::curvature function derivative_norm virtual double derivative_norm( double t ) Default method for computing the norm of the derivative. Parameters : t The path parameter Return : A double with the norm of the derivative of the path position pd function getClosestPointGamma virtual double getClosestPointGamma( Eigen::Vector3d & coordinate ) Default method for getting the gamma of the closed point to the path. By default this method uses gradient Descent algorithm to compute the closest point in the path with the initial guess of gamma=0.0. Parameters : coordinate A Eigen::Vector3d with the coordinates of the vehicle Return : A double with the closest point in the path Reimplemented by : Polinomial5::getClosestPointGamma , Polynomial5::getClosestPointGamma , Sinusoid2D::getClosestPointGamma , Line::getClosestPointGamma , Circle2D::getClosestPointGamma , Bernoulli::getClosestPointGamma , Arc2D::getClosestPointGamma This is not the most efficient way to compute the closest point for several kinds of paths, but it is the most general, hence used as the default one Method to return the closest point to the path By default just calls the Gradient Descent algorithm function can_be_composed bool can_be_composed() Method to return whether a pathSection can be composed with other path sections or not. Return : A boolean indicating wether the pathsection can be composed with other sections or not function limitGamma double limitGamma( double t ) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. Parameters : t The path parameter also known as gamma Return : A double with the path parameter limited between the valid bounds function getMaxGammaValue double getMaxGammaValue() Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. Return : A double with the maximum value that can be achieved with gamma function getMinGammaValue double getMinGammaValue() Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. Return : A double with the minimum value the can be achieved with gamma function ~PathSection virtual ~PathSection() Virtual destructor for the abstract class. Protected Functions Documentation function PathSection PathSection( bool can_be_composed ) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . Parameters : can_be_composed A boolean that indicated that if this kind of path can be composed with other path sections or not function setMaxGammaValue bool setMaxGammaValue( double gamma_max ) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. Parameters : gamma_max The desired max value for gamma Return : True if new value was accepted function setMinGammaValue bool setMinGammaValue( double gamma_min ) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. Parameters : gamma_min The desired min value for gamma Return : True if the new value was accepted NOTE: for paths where can_be_composed == true, this function always returns false as it is required for those kinds of segments to start with 0 (but no limit is put on gamma max) function GradientDescent double GradientDescent( double gamma_o, Eigen::Vector3d & x_pos, double tolerance ) Method that implements the gradient descent to minimize the error of ||pd(gamma) - p_vehicle||. Parameters : gamma_o The initial guess for the path paramter x_pos The position of the vehicle tolerance A constant tweaking parameter Return : the estimated gamma value that minimizes the error function getInitialGammaEstimate double getInitialGammaEstimate( Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val ) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. Parameters : x_pos The position of the vehicle num_partitions The number of divisions to make on the path min_val The minimum boundary to search in gamma max_val The maximum boundary to search in gamma Return : A double with a good gamma to use as an initialization for the estimation Then grabs the gamma that minimizes the most from all sections function bisection double bisection( Eigen::Vector3d & x_pos, double a, double b ) Method to implement bisection method Parameters : x_pos The position of the vehicle a The left bound for the gamma value b The right bound for the gamma value Return : The most likely value of gamma Updated on 2022-05-30 at 18:35:08 +0000","title":"PathSection"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#pathsection","text":"An abstract class that is used as a template for Path Sections. More... #include <PathSection.h> Inherited by Arc2D , Bernoulli , Circle2D , Line , Polinomial5 , Polynomial5 , Sinusoid2D","title":"PathSection"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#public-functions","text":"Name virtual Eigen::Vector3d eq_pd (double t) =0 The Path section equation. virtual Eigen::Vector3d eq_d_pd (double t) =0 First derivative of the path section equation with respect to path parameter t. virtual Eigen::Vector3d eq_dd_pd (double t) =0 Second derivative of the path section equation with respect to the path parameter t. virtual double tangent (double t) Default method for computing the tangent to the path section. virtual double curvature (double t) Default method for computing the curvature. The default implementation implements the general formula to compute the curvature based on the derivative equations of the path. virtual double derivative_norm (double t) Default method for computing the norm of the derivative. virtual double getClosestPointGamma (Eigen::Vector3d & coordinate) Default method for getting the gamma of the closed point to the path. By default this method uses gradient Descent algorithm to compute the closest point in the path with the initial guess of gamma=0.0. bool can_be_composed () Method to return whether a pathSection can be composed with other path sections or not. double limitGamma (double t) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. double getMaxGammaValue () Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. double getMinGammaValue () Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. virtual ~PathSection () Virtual destructor for the abstract class.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#protected-functions","text":"Name PathSection (bool can_be_composed) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . bool setMaxGammaValue (double gamma_max) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. bool setMinGammaValue (double gamma_min) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. double GradientDescent (double gamma_o, Eigen::Vector3d & x_pos, double tolerance) Method that implements the gradient descent to minimize the error of double getInitialGammaEstimate (Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. double bisection (Eigen::Vector3d & x_pos, double a, double b) Method to implement bisection method","title":"Protected Functions"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#detailed-description","text":"class PathSection; An abstract class that is used as a template for Path Sections. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT For path sections that can_be_composed the minimum value of gamma will be defaulted to 0 (and cannot be changed) in order not to mess with the Path section switching algorithm. The maximum value can be any greater than 0. For path sections where can_be_composed = false, the minimum value for gamma if -inf an the maximum value if +inf (but these can be changed)","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-eq_pd","text":"virtual Eigen::Vector3d eq_pd( double t ) =0 The Path section equation. Parameters : t The path parameter Return : An Eigen::Vector3d with the equation of the path with respect to the path parameter Reimplemented by : Polinomial5::eq_pd , Polynomial5::eq_pd , Line::eq_pd , Sinusoid2D::eq_pd , Circle2D::eq_pd , Bernoulli::eq_pd , Arc2D::eq_pd","title":"function eq_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-eq_d_pd","text":"virtual Eigen::Vector3d eq_d_pd( double t ) =0 First derivative of the path section equation with respect to path parameter t. Parameters : t The path parameter Return : An Eigen::Vector3d with the first derivative of the path equation with respect to the path parameter Reimplemented by : Polinomial5::eq_d_pd , Polynomial5::eq_d_pd , Line::eq_d_pd , Sinusoid2D::eq_d_pd , Circle2D::eq_d_pd , Bernoulli::eq_d_pd , Arc2D::eq_d_pd","title":"function eq_d_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-eq_dd_pd","text":"virtual Eigen::Vector3d eq_dd_pd( double t ) =0 Second derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter Return : An Eigen::Vector3d with the second derivative of the path equation with respect to the path paramter Reimplemented by : Polinomial5::eq_dd_pd , Polynomial5::eq_dd_pd , Line::eq_dd_pd , Circle2D::eq_dd_pd , Bernoulli::eq_dd_pd , Sinusoid2D::eq_dd_pd , Arc2D::eq_dd_pd","title":"function eq_dd_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-tangent","text":"virtual double tangent( double t ) Default method for computing the tangent to the path section. Parameters : t The path parameter Return : A double with the angle of the tangent to the path","title":"function tangent"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-curvature","text":"virtual double curvature( double t ) Default method for computing the curvature. The default implementation implements the general formula to compute the curvature based on the derivative equations of the path. Parameters : t The path parameter Return : A double with the path curvature Reimplemented by : Line::curvature , Circle2D::curvature , Bernoulli::curvature , Arc2D::curvature","title":"function curvature"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-derivative_norm","text":"virtual double derivative_norm( double t ) Default method for computing the norm of the derivative. Parameters : t The path parameter Return : A double with the norm of the derivative of the path position pd","title":"function derivative_norm"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-getclosestpointgamma","text":"virtual double getClosestPointGamma( Eigen::Vector3d & coordinate ) Default method for getting the gamma of the closed point to the path. By default this method uses gradient Descent algorithm to compute the closest point in the path with the initial guess of gamma=0.0. Parameters : coordinate A Eigen::Vector3d with the coordinates of the vehicle Return : A double with the closest point in the path Reimplemented by : Polinomial5::getClosestPointGamma , Polynomial5::getClosestPointGamma , Sinusoid2D::getClosestPointGamma , Line::getClosestPointGamma , Circle2D::getClosestPointGamma , Bernoulli::getClosestPointGamma , Arc2D::getClosestPointGamma This is not the most efficient way to compute the closest point for several kinds of paths, but it is the most general, hence used as the default one Method to return the closest point to the path By default just calls the Gradient Descent algorithm","title":"function getClosestPointGamma"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-can_be_composed","text":"bool can_be_composed() Method to return whether a pathSection can be composed with other path sections or not. Return : A boolean indicating wether the pathsection can be composed with other sections or not","title":"function can_be_composed"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-limitgamma","text":"double limitGamma( double t ) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. Parameters : t The path parameter also known as gamma Return : A double with the path parameter limited between the valid bounds","title":"function limitGamma"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-getmaxgammavalue","text":"double getMaxGammaValue() Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. Return : A double with the maximum value that can be achieved with gamma","title":"function getMaxGammaValue"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-getmingammavalue","text":"double getMinGammaValue() Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. Return : A double with the minimum value the can be achieved with gamma","title":"function getMinGammaValue"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-pathsection","text":"virtual ~PathSection() Virtual destructor for the abstract class.","title":"function ~PathSection"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-pathsection_1","text":"PathSection( bool can_be_composed ) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . Parameters : can_be_composed A boolean that indicated that if this kind of path can be composed with other path sections or not","title":"function PathSection"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-setmaxgammavalue","text":"bool setMaxGammaValue( double gamma_max ) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. Parameters : gamma_max The desired max value for gamma Return : True if new value was accepted","title":"function setMaxGammaValue"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-setmingammavalue","text":"bool setMinGammaValue( double gamma_min ) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. Parameters : gamma_min The desired min value for gamma Return : True if the new value was accepted NOTE: for paths where can_be_composed == true, this function always returns false as it is required for those kinds of segments to start with 0 (but no limit is put on gamma max)","title":"function setMinGammaValue"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-gradientdescent","text":"double GradientDescent( double gamma_o, Eigen::Vector3d & x_pos, double tolerance ) Method that implements the gradient descent to minimize the error of ||pd(gamma) - p_vehicle||. Parameters : gamma_o The initial guess for the path paramter x_pos The position of the vehicle tolerance A constant tweaking parameter Return : the estimated gamma value that minimizes the error","title":"function GradientDescent"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-getinitialgammaestimate","text":"double getInitialGammaEstimate( Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val ) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. Parameters : x_pos The position of the vehicle num_partitions The number of divisions to make on the path min_val The minimum boundary to search in gamma max_val The maximum boundary to search in gamma Return : A double with a good gamma to use as an initialization for the estimation Then grabs the gamma that minimizes the most from all sections","title":"function getInitialGammaEstimate"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-bisection","text":"double bisection( Eigen::Vector3d & x_pos, double a, double b ) Method to implement bisection method Parameters : x_pos The position of the vehicle a The left bound for the gamma value b The right bound for the gamma value Return : The most likely value of gamma Updated on 2022-05-30 at 18:35:08 +0000","title":"function bisection"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolinomial5/","text":"Polinomial5 Class that implements a 5th order polinomial section. More... #include <Polinomial5.h> Inherits from PathSection Public Functions Name Polinomial5 (std::array< double, 5 > a, std::array< double, 5 > b, double c) Constructor for the Polinomial5 class, that receives the desired plane for the polinomial. virtual Eigen::Vector3d eq_pd (double t) override The Path section equation. virtual Eigen::Vector3d eq_d_pd (double t) override First derivative of the path section equation with respect to the path parameter t. virtual Eigen::Vector3d eq_dd_pd (double t) override Second derivative of the path section equation with respect to the path parameter t. virtual double getClosestPointGamma (Eigen::Vector3d & coordinate) override Method for getting the gamma of the closes point to the path. Additional inherited members Public Functions inherited from PathSection Name virtual double tangent (double t) Default method for computing the tangent to the path section. virtual double curvature (double t) Default method for computing the curvature. The default implementation implements the general formula to compute the curvature based on the derivative equations of the path. virtual double derivative_norm (double t) Default method for computing the norm of the derivative. bool can_be_composed () Method to return whether a pathSection can be composed with other path sections or not. double limitGamma (double t) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. double getMaxGammaValue () Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. double getMinGammaValue () Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. virtual ~PathSection () Virtual destructor for the abstract class. Protected Functions inherited from PathSection Name PathSection (bool can_be_composed) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . bool setMaxGammaValue (double gamma_max) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. bool setMinGammaValue (double gamma_min) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. double GradientDescent (double gamma_o, Eigen::Vector3d & x_pos, double tolerance) Method that implements the gradient descent to minimize the error of double getInitialGammaEstimate (Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. double bisection (Eigen::Vector3d & x_pos, double a, double b) Method to implement bisection method Detailed Description class Polinomial5; Class that implements a 5th order polinomial section. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the sections library Public Functions Documentation function Polinomial5 Polinomial5( std::array< double, 5 > a, std::array< double, 5 > b, double c ) Constructor for the Polinomial5 class, that receives the desired plane for the polinomial. Parameters : offset The 2D start point of the arc function eq_pd virtual Eigen::Vector3d eq_pd( double t ) override The Path section equation. Parameters : t The path parameter Return : An Eigen::Vector3d with the equation of the path with respect to the path parameter Reimplements : PathSection::eq_pd function eq_d_pd virtual Eigen::Vector3d eq_d_pd( double t ) override First derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter t Return : An Eigen::Vector3d with the equation of the partial derivative with respect to the path parameter Reimplements : PathSection::eq_d_pd function eq_dd_pd virtual Eigen::Vector3d eq_dd_pd( double t ) override Second derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter t Return : An Eigen::Vector3d with the equation of the second order partial derivative with respect to the path parameter Reimplements : PathSection::eq_dd_pd function getClosestPointGamma virtual double getClosestPointGamma( Eigen::Vector3d & coordinate ) override Method for getting the gamma of the closes point to the path. Parameters : The coordinate of the vehicle in the 3D space Return : A double with the gamma corresponding to the closest point in the path Reimplements : PathSection::getClosestPointGamma Updated on 2022-05-30 at 18:35:08 +0000","title":"Polinomial5"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolinomial5/#polinomial5","text":"Class that implements a 5th order polinomial section. More... #include <Polinomial5.h> Inherits from PathSection","title":"Polinomial5"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolinomial5/#public-functions","text":"Name Polinomial5 (std::array< double, 5 > a, std::array< double, 5 > b, double c) Constructor for the Polinomial5 class, that receives the desired plane for the polinomial. virtual Eigen::Vector3d eq_pd (double t) override The Path section equation. virtual Eigen::Vector3d eq_d_pd (double t) override First derivative of the path section equation with respect to the path parameter t. virtual Eigen::Vector3d eq_dd_pd (double t) override Second derivative of the path section equation with respect to the path parameter t. virtual double getClosestPointGamma (Eigen::Vector3d & coordinate) override Method for getting the gamma of the closes point to the path.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolinomial5/#additional-inherited-members","text":"Public Functions inherited from PathSection Name virtual double tangent (double t) Default method for computing the tangent to the path section. virtual double curvature (double t) Default method for computing the curvature. The default implementation implements the general formula to compute the curvature based on the derivative equations of the path. virtual double derivative_norm (double t) Default method for computing the norm of the derivative. bool can_be_composed () Method to return whether a pathSection can be composed with other path sections or not. double limitGamma (double t) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. double getMaxGammaValue () Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. double getMinGammaValue () Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. virtual ~PathSection () Virtual destructor for the abstract class. Protected Functions inherited from PathSection Name PathSection (bool can_be_composed) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . bool setMaxGammaValue (double gamma_max) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. bool setMinGammaValue (double gamma_min) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. double GradientDescent (double gamma_o, Eigen::Vector3d & x_pos, double tolerance) Method that implements the gradient descent to minimize the error of double getInitialGammaEstimate (Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. double bisection (Eigen::Vector3d & x_pos, double a, double b) Method to implement bisection method","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolinomial5/#detailed-description","text":"class Polinomial5; Class that implements a 5th order polinomial section. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the sections library","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolinomial5/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolinomial5/#function-polinomial5","text":"Polinomial5( std::array< double, 5 > a, std::array< double, 5 > b, double c ) Constructor for the Polinomial5 class, that receives the desired plane for the polinomial. Parameters : offset The 2D start point of the arc","title":"function Polinomial5"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolinomial5/#function-eq_pd","text":"virtual Eigen::Vector3d eq_pd( double t ) override The Path section equation. Parameters : t The path parameter Return : An Eigen::Vector3d with the equation of the path with respect to the path parameter Reimplements : PathSection::eq_pd","title":"function eq_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolinomial5/#function-eq_d_pd","text":"virtual Eigen::Vector3d eq_d_pd( double t ) override First derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter t Return : An Eigen::Vector3d with the equation of the partial derivative with respect to the path parameter Reimplements : PathSection::eq_d_pd","title":"function eq_d_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolinomial5/#function-eq_dd_pd","text":"virtual Eigen::Vector3d eq_dd_pd( double t ) override Second derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter t Return : An Eigen::Vector3d with the equation of the second order partial derivative with respect to the path parameter Reimplements : PathSection::eq_dd_pd","title":"function eq_dd_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolinomial5/#function-getclosestpointgamma","text":"virtual double getClosestPointGamma( Eigen::Vector3d & coordinate ) override Method for getting the gamma of the closes point to the path. Parameters : The coordinate of the vehicle in the 3D space Return : A double with the gamma corresponding to the closest point in the path Reimplements : PathSection::getClosestPointGamma Updated on 2022-05-30 at 18:35:08 +0000","title":"function getClosestPointGamma"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolynomial5/","text":"Polynomial5 Class that implements a 5th order polynomial section. More... #include <Polynomial5.h> Inherits from PathSection Public Functions Name Polynomial5 (Eigen::Matrix< double, 6, 1 > & a, Eigen::Matrix< double, 6, 1 > & b, double c, double offset_x, double offset_y) Constructor for the Polynomial5 class, that receives the desired plane for the polynomial. virtual Eigen::Vector3d eq_pd (double t) override The Path section equation. virtual Eigen::Vector3d eq_d_pd (double t) override First derivative of the path section equation with respect to the path parameter t. virtual Eigen::Vector3d eq_dd_pd (double t) override Second derivative of the path section equation with respect to the path parameter t. virtual double getClosestPointGamma (Eigen::Vector3d & coordinate) override Method for getting the gamma of the closes point to the path. Additional inherited members Public Functions inherited from PathSection Name virtual double tangent (double t) Default method for computing the tangent to the path section. virtual double curvature (double t) Default method for computing the curvature. The default implementation implements the general formula to compute the curvature based on the derivative equations of the path. virtual double derivative_norm (double t) Default method for computing the norm of the derivative. bool can_be_composed () Method to return whether a pathSection can be composed with other path sections or not. double limitGamma (double t) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. double getMaxGammaValue () Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. double getMinGammaValue () Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. virtual ~PathSection () Virtual destructor for the abstract class. Protected Functions inherited from PathSection Name PathSection (bool can_be_composed) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . bool setMaxGammaValue (double gamma_max) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. bool setMinGammaValue (double gamma_min) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. double GradientDescent (double gamma_o, Eigen::Vector3d & x_pos, double tolerance) Method that implements the gradient descent to minimize the error of double getInitialGammaEstimate (Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. double bisection (Eigen::Vector3d & x_pos, double a, double b) Method to implement bisection method Detailed Description class Polynomial5; Class that implements a 5th order polynomial section. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the sections library Public Functions Documentation function Polynomial5 Polynomial5( Eigen::Matrix< double, 6, 1 > & a, Eigen::Matrix< double, 6, 1 > & b, double c, double offset_x, double offset_y ) Constructor for the Polynomial5 class, that receives the desired plane for the polynomial. Parameters : a A vector with 6 elements for the polynomial equation b A vector with 6 elements for the polynomial equation c A double for the polynomial equation offset_x A double with the x_offset offset_y A double with the y_offset function eq_pd virtual Eigen::Vector3d eq_pd( double t ) override The Path section equation. Parameters : t The path parameter Return : An Eigen::Vector3d with the equation of the path with respect to the path parameter Reimplements : PathSection::eq_pd function eq_d_pd virtual Eigen::Vector3d eq_d_pd( double t ) override First derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter t Return : An Eigen::Vector3d with the equation of the partial derivative with respect to the path parameter Reimplements : PathSection::eq_d_pd function eq_dd_pd virtual Eigen::Vector3d eq_dd_pd( double t ) override Second derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter t Return : An Eigen::Vector3d with the equation of the second order partial derivative with respect to the path parameter Reimplements : PathSection::eq_dd_pd function getClosestPointGamma virtual double getClosestPointGamma( Eigen::Vector3d & coordinate ) override Method for getting the gamma of the closes point to the path. Parameters : The coordinate of the vehicle in the 3D space Return : A double with the gamma corresponding to the closest point in the path Reimplements : PathSection::getClosestPointGamma Updated on 2022-05-30 at 18:35:08 +0000","title":"Polynomial5"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolynomial5/#polynomial5","text":"Class that implements a 5th order polynomial section. More... #include <Polynomial5.h> Inherits from PathSection","title":"Polynomial5"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolynomial5/#public-functions","text":"Name Polynomial5 (Eigen::Matrix< double, 6, 1 > & a, Eigen::Matrix< double, 6, 1 > & b, double c, double offset_x, double offset_y) Constructor for the Polynomial5 class, that receives the desired plane for the polynomial. virtual Eigen::Vector3d eq_pd (double t) override The Path section equation. virtual Eigen::Vector3d eq_d_pd (double t) override First derivative of the path section equation with respect to the path parameter t. virtual Eigen::Vector3d eq_dd_pd (double t) override Second derivative of the path section equation with respect to the path parameter t. virtual double getClosestPointGamma (Eigen::Vector3d & coordinate) override Method for getting the gamma of the closes point to the path.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolynomial5/#additional-inherited-members","text":"Public Functions inherited from PathSection Name virtual double tangent (double t) Default method for computing the tangent to the path section. virtual double curvature (double t) Default method for computing the curvature. The default implementation implements the general formula to compute the curvature based on the derivative equations of the path. virtual double derivative_norm (double t) Default method for computing the norm of the derivative. bool can_be_composed () Method to return whether a pathSection can be composed with other path sections or not. double limitGamma (double t) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. double getMaxGammaValue () Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. double getMinGammaValue () Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. virtual ~PathSection () Virtual destructor for the abstract class. Protected Functions inherited from PathSection Name PathSection (bool can_be_composed) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . bool setMaxGammaValue (double gamma_max) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. bool setMinGammaValue (double gamma_min) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. double GradientDescent (double gamma_o, Eigen::Vector3d & x_pos, double tolerance) Method that implements the gradient descent to minimize the error of double getInitialGammaEstimate (Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. double bisection (Eigen::Vector3d & x_pos, double a, double b) Method to implement bisection method","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolynomial5/#detailed-description","text":"class Polynomial5; Class that implements a 5th order polynomial section. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the sections library","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolynomial5/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolynomial5/#function-polynomial5","text":"Polynomial5( Eigen::Matrix< double, 6, 1 > & a, Eigen::Matrix< double, 6, 1 > & b, double c, double offset_x, double offset_y ) Constructor for the Polynomial5 class, that receives the desired plane for the polynomial. Parameters : a A vector with 6 elements for the polynomial equation b A vector with 6 elements for the polynomial equation c A double for the polynomial equation offset_x A double with the x_offset offset_y A double with the y_offset","title":"function Polynomial5"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolynomial5/#function-eq_pd","text":"virtual Eigen::Vector3d eq_pd( double t ) override The Path section equation. Parameters : t The path parameter Return : An Eigen::Vector3d with the equation of the path with respect to the path parameter Reimplements : PathSection::eq_pd","title":"function eq_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolynomial5/#function-eq_d_pd","text":"virtual Eigen::Vector3d eq_d_pd( double t ) override First derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter t Return : An Eigen::Vector3d with the equation of the partial derivative with respect to the path parameter Reimplements : PathSection::eq_d_pd","title":"function eq_d_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolynomial5/#function-eq_dd_pd","text":"virtual Eigen::Vector3d eq_dd_pd( double t ) override Second derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter t Return : An Eigen::Vector3d with the equation of the second order partial derivative with respect to the path parameter Reimplements : PathSection::eq_dd_pd","title":"function eq_dd_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolynomial5/#function-getclosestpointgamma","text":"virtual double getClosestPointGamma( Eigen::Vector3d & coordinate ) override Method for getting the gamma of the closes point to the path. Parameters : The coordinate of the vehicle in the 3D space Return : A double with the gamma corresponding to the closest point in the path Reimplements : PathSection::getClosestPointGamma Updated on 2022-05-30 at 18:35:08 +0000","title":"function getClosestPointGamma"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSinusoid2D/","text":"Sinusoid2D Class that implements a 2D sinusoid section. More... #include <Sinusoid2D.h> Inherits from PathSection Public Functions Name Sinusoid2D (Eigen::Vector2d & offset, double z) Constructor for the Sinusoid2D class, that receives the desired plane for the sinudoid. Sinusoid2D (Eigen::Vector2d & offset) Constructor for the Sinudoid2D class, that receives the desired plane for the sinudoid. Assumes the plane is placed at z=0.0. virtual Eigen::Vector3d eq_pd (double t) override The Path section equation. virtual Eigen::Vector3d eq_d_pd (double t) override First derivative of the path section equation with respect to the path parameter t. virtual Eigen::Vector3d eq_dd_pd (double t) override Second derivative of the path section equation with respect to the path parameter t. virtual double getClosestPointGamma (Eigen::Vector3d & coordinate) override Method for getting the gamma of the closes point to the path. Additional inherited members Public Functions inherited from PathSection Name virtual double tangent (double t) Default method for computing the tangent to the path section. virtual double curvature (double t) Default method for computing the curvature. The default implementation implements the general formula to compute the curvature based on the derivative equations of the path. virtual double derivative_norm (double t) Default method for computing the norm of the derivative. bool can_be_composed () Method to return whether a pathSection can be composed with other path sections or not. double limitGamma (double t) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. double getMaxGammaValue () Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. double getMinGammaValue () Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. virtual ~PathSection () Virtual destructor for the abstract class. Protected Functions inherited from PathSection Name PathSection (bool can_be_composed) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . bool setMaxGammaValue (double gamma_max) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. bool setMinGammaValue (double gamma_min) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. double GradientDescent (double gamma_o, Eigen::Vector3d & x_pos, double tolerance) Method that implements the gradient descent to minimize the error of double getInitialGammaEstimate (Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. double bisection (Eigen::Vector3d & x_pos, double a, double b) Method to implement bisection method Detailed Description class Sinusoid2D; Class that implements a 2D sinusoid section. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the sections library Public Functions Documentation function Sinusoid2D Sinusoid2D( Eigen::Vector2d & offset, double z ) Constructor for the Sinusoid2D class, that receives the desired plane for the sinudoid. Parameters : offset The 2D start point of the arc z The altitude at which to place the arc function Sinusoid2D Sinusoid2D( Eigen::Vector2d & offset ) Constructor for the Sinudoid2D class, that receives the desired plane for the sinudoid. Assumes the plane is placed at z=0.0. Parameters : offset The 2D offset for the Sinudoid of the sinusoid function eq_pd virtual Eigen::Vector3d eq_pd( double t ) override The Path section equation. Parameters : t The path parameter Return : An Eigen::Vector3d with the equation of the path with respect to the path parameter Reimplements : PathSection::eq_pd function eq_d_pd virtual Eigen::Vector3d eq_d_pd( double t ) override First derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter t Return : An Eigen::Vector3d with the equation of the partial derivative with respect to the path parameter Reimplements : PathSection::eq_d_pd function eq_dd_pd virtual Eigen::Vector3d eq_dd_pd( double t ) override Second derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter t Return : An Eigen::Vector3d with the equation of the second order partial derivative with respect to the path parameter Reimplements : PathSection::eq_dd_pd function getClosestPointGamma virtual double getClosestPointGamma( Eigen::Vector3d & coordinate ) override Method for getting the gamma of the closes point to the path. Parameters : The coordinate of the vehicle in the 3D space Return : A double with the gamma corresponding to the closest point in the path Reimplements : PathSection::getClosestPointGamma Updated on 2022-05-30 at 18:35:08 +0000","title":"Sinusoid2D"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSinusoid2D/#sinusoid2d","text":"Class that implements a 2D sinusoid section. More... #include <Sinusoid2D.h> Inherits from PathSection","title":"Sinusoid2D"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSinusoid2D/#public-functions","text":"Name Sinusoid2D (Eigen::Vector2d & offset, double z) Constructor for the Sinusoid2D class, that receives the desired plane for the sinudoid. Sinusoid2D (Eigen::Vector2d & offset) Constructor for the Sinudoid2D class, that receives the desired plane for the sinudoid. Assumes the plane is placed at z=0.0. virtual Eigen::Vector3d eq_pd (double t) override The Path section equation. virtual Eigen::Vector3d eq_d_pd (double t) override First derivative of the path section equation with respect to the path parameter t. virtual Eigen::Vector3d eq_dd_pd (double t) override Second derivative of the path section equation with respect to the path parameter t. virtual double getClosestPointGamma (Eigen::Vector3d & coordinate) override Method for getting the gamma of the closes point to the path.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSinusoid2D/#additional-inherited-members","text":"Public Functions inherited from PathSection Name virtual double tangent (double t) Default method for computing the tangent to the path section. virtual double curvature (double t) Default method for computing the curvature. The default implementation implements the general formula to compute the curvature based on the derivative equations of the path. virtual double derivative_norm (double t) Default method for computing the norm of the derivative. bool can_be_composed () Method to return whether a pathSection can be composed with other path sections or not. double limitGamma (double t) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. double getMaxGammaValue () Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. double getMinGammaValue () Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. virtual ~PathSection () Virtual destructor for the abstract class. Protected Functions inherited from PathSection Name PathSection (bool can_be_composed) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . bool setMaxGammaValue (double gamma_max) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. bool setMinGammaValue (double gamma_min) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. double GradientDescent (double gamma_o, Eigen::Vector3d & x_pos, double tolerance) Method that implements the gradient descent to minimize the error of double getInitialGammaEstimate (Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. double bisection (Eigen::Vector3d & x_pos, double a, double b) Method to implement bisection method","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSinusoid2D/#detailed-description","text":"class Sinusoid2D; Class that implements a 2D sinusoid section. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the sections library","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSinusoid2D/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSinusoid2D/#function-sinusoid2d","text":"Sinusoid2D( Eigen::Vector2d & offset, double z ) Constructor for the Sinusoid2D class, that receives the desired plane for the sinudoid. Parameters : offset The 2D start point of the arc z The altitude at which to place the arc","title":"function Sinusoid2D"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSinusoid2D/#function-sinusoid2d_1","text":"Sinusoid2D( Eigen::Vector2d & offset ) Constructor for the Sinudoid2D class, that receives the desired plane for the sinudoid. Assumes the plane is placed at z=0.0. Parameters : offset The 2D offset for the Sinudoid of the sinusoid","title":"function Sinusoid2D"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSinusoid2D/#function-eq_pd","text":"virtual Eigen::Vector3d eq_pd( double t ) override The Path section equation. Parameters : t The path parameter Return : An Eigen::Vector3d with the equation of the path with respect to the path parameter Reimplements : PathSection::eq_pd","title":"function eq_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSinusoid2D/#function-eq_d_pd","text":"virtual Eigen::Vector3d eq_d_pd( double t ) override First derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter t Return : An Eigen::Vector3d with the equation of the partial derivative with respect to the path parameter Reimplements : PathSection::eq_d_pd","title":"function eq_d_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSinusoid2D/#function-eq_dd_pd","text":"virtual Eigen::Vector3d eq_dd_pd( double t ) override Second derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter t Return : An Eigen::Vector3d with the equation of the second order partial derivative with respect to the path parameter Reimplements : PathSection::eq_dd_pd","title":"function eq_dd_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSinusoid2D/#function-getclosestpointgamma","text":"virtual double getClosestPointGamma( Eigen::Vector3d & coordinate ) override Method for getting the gamma of the closes point to the path. Parameters : The coordinate of the vehicle in the 3D space Return : A double with the gamma corresponding to the closest point in the path Reimplements : PathSection::getClosestPointGamma Updated on 2022-05-30 at 18:35:08 +0000","title":"function getClosestPointGamma"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSpeed/","text":"Speed Abstract class to serve as the base for speed as a function of gamma. More... #include <Speed.h> Inherited by ConstRabbitSpeed , ConstVehicleSpeed Public Functions Name virtual double getVd (double gamma, double tangent_norm) =0 Method to get the desired velocity for the virtual target on the path given the path parameter (given by the value of gamma) virtual double get_d_Vd (double gamma, double tangent_norm) =0 Method to get the desired acceleration for the virtual target on the path given the path parameter (given by the value of gamma) virtual double getDefaultVd (double gamma, double tangent_norm) =0 Method to get the default desired velocity for safety when we are doing path following and want to have a backup value. virtual ~Speed () Virtual destructor for the abstract class. Detailed Description class Speed; Abstract class to serve as the base for speed as a function of gamma. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT Since this class is abstract it cannot be instantiated. It must be inherited. Public Functions Documentation function getVd virtual double getVd( double gamma, double tangent_norm ) =0 Method to get the desired velocity for the virtual target on the path given the path parameter (given by the value of gamma) Parameters : gamma The path parameter tangent_norm The norm of the tangent to the path in gamma Return : A double with the desired speed Reimplemented by : ConstRabbitSpeed::getVd , ConstVehicleSpeed::getVd NOTE: This method is pure virtual which means it must be implemented by a class that inherits Speed function get_d_Vd virtual double get_d_Vd( double gamma, double tangent_norm ) =0 Method to get the desired acceleration for the virtual target on the path given the path parameter (given by the value of gamma) Parameters : gamma The value of the path parameter tangent_norm The norm of the tangent to the path in gamma Return : A double with the desired acceleration Reimplemented by : ConstRabbitSpeed::get_d_Vd , ConstVehicleSpeed::get_d_Vd NOTE: This method is pure virtual which means it must be implemented by a class that inherits Speed function getDefaultVd virtual double getDefaultVd( double gamma, double tangent_norm ) =0 Method to get the default desired velocity for safety when we are doing path following and want to have a backup value. Parameters : gamma The value of the path parameter tangent_norm The norm of the tangent to the path in gamma Return : A double with the default desired speed Reimplemented by : ConstRabbitSpeed::getDefaultVd , ConstVehicleSpeed::getDefaultVd NOTE: THis method is pura virtual which means it must be implemented by a class that inherits Speed function ~Speed virtual ~Speed() Virtual destructor for the abstract class. Updated on 2022-05-30 at 18:35:08 +0000","title":"Speed"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSpeed/#speed","text":"Abstract class to serve as the base for speed as a function of gamma. More... #include <Speed.h> Inherited by ConstRabbitSpeed , ConstVehicleSpeed","title":"Speed"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSpeed/#public-functions","text":"Name virtual double getVd (double gamma, double tangent_norm) =0 Method to get the desired velocity for the virtual target on the path given the path parameter (given by the value of gamma) virtual double get_d_Vd (double gamma, double tangent_norm) =0 Method to get the desired acceleration for the virtual target on the path given the path parameter (given by the value of gamma) virtual double getDefaultVd (double gamma, double tangent_norm) =0 Method to get the default desired velocity for safety when we are doing path following and want to have a backup value. virtual ~Speed () Virtual destructor for the abstract class.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSpeed/#detailed-description","text":"class Speed; Abstract class to serve as the base for speed as a function of gamma. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT Since this class is abstract it cannot be instantiated. It must be inherited.","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSpeed/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSpeed/#function-getvd","text":"virtual double getVd( double gamma, double tangent_norm ) =0 Method to get the desired velocity for the virtual target on the path given the path parameter (given by the value of gamma) Parameters : gamma The path parameter tangent_norm The norm of the tangent to the path in gamma Return : A double with the desired speed Reimplemented by : ConstRabbitSpeed::getVd , ConstVehicleSpeed::getVd NOTE: This method is pure virtual which means it must be implemented by a class that inherits Speed","title":"function getVd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSpeed/#function-get_d_vd","text":"virtual double get_d_Vd( double gamma, double tangent_norm ) =0 Method to get the desired acceleration for the virtual target on the path given the path parameter (given by the value of gamma) Parameters : gamma The value of the path parameter tangent_norm The norm of the tangent to the path in gamma Return : A double with the desired acceleration Reimplemented by : ConstRabbitSpeed::get_d_Vd , ConstVehicleSpeed::get_d_Vd NOTE: This method is pure virtual which means it must be implemented by a class that inherits Speed","title":"function get_d_Vd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSpeed/#function-getdefaultvd","text":"virtual double getDefaultVd( double gamma, double tangent_norm ) =0 Method to get the default desired velocity for safety when we are doing path following and want to have a backup value. Parameters : gamma The value of the path parameter tangent_norm The norm of the tangent to the path in gamma Return : A double with the default desired speed Reimplemented by : ConstRabbitSpeed::getDefaultVd , ConstVehicleSpeed::getDefaultVd NOTE: THis method is pura virtual which means it must be implemented by a class that inherits Speed","title":"function getDefaultVd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSpeed/#function-speed","text":"virtual ~Speed() Virtual destructor for the abstract class. Updated on 2022-05-30 at 18:35:08 +0000","title":"function ~Speed"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:08 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:08 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:08 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:08 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Namespaces/","text":"Namespaces Updated on 2022-05-30 at 18:35:08 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Namespaces/#namespaces","text":"Updated on 2022-05-30 at 18:35:08 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/","text":"Classes class AUV AUV class - implements a Matlab-like simulation of an AUV in C++. class SimulationNode SimulationNode class - implements the ROS interface to actually perform an AUV simulation. struct State State class - used to save the state of a vehicle (using SNAME convention) Updated on 2022-05-30 at 18:35:05 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/#classes","text":"class AUV AUV class - implements a Matlab-like simulation of an AUV in C++. class SimulationNode SimulationNode class - implements the ROS interface to actually perform an AUV simulation. struct State State class - used to save the state of a vehicle (using SNAME convention) Updated on 2022-05-30 at 18:35:05 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classAUV/","text":"AUV AUV class - implements a Matlab-like simulation of an AUV in C++. More... #include <AUV.h> Public Functions Name AUV (double mass, double fluid_density, double zg, double vehicle_density, const Eigen::Vector3d & inertia_tensor, const Eigen::Matrix< double, 6, 1 > & linear_damping_tensor, const Eigen::Matrix< double, 6, 1 > & quadratic_damping_tensor, const Eigen::Matrix< double, 6, 1 > & added_mass_tensor, const Eigen::MatrixXd & allocation_matrix, const Eigen::Vector3d & lump_param_positive, const Eigen::Vector3d & lump_param_negative, const Eigen::Vector2d & min_max_thruster_input, double thrusters_gain, double thrusters_pole, double thrusters_delay, double sampling_period, const Eigen::Vector3d & disturbance_mean, const Eigen::Vector3d & disturbance_sigma, const Eigen::Vector3d & disturbance_minimum, const Eigen::Vector3d & disturbance_maximum) void update (double dt, const Eigen::VectorXd & thrust) State getState () void setState (const State & state) unsigned int getNumberThrusters () Detailed Description class AUV; AUV class - implements a Matlab-like simulation of an AUV in C++. Author : Marcelo Jacinto Version : 1.0.0 Date : 2021/11/12 Copyright : MIT Public Functions Documentation function AUV AUV( double mass, double fluid_density, double zg, double vehicle_density, const Eigen::Vector3d & inertia_tensor, const Eigen::Matrix< double, 6, 1 > & linear_damping_tensor, const Eigen::Matrix< double, 6, 1 > & quadratic_damping_tensor, const Eigen::Matrix< double, 6, 1 > & added_mass_tensor, const Eigen::MatrixXd & allocation_matrix, const Eigen::Vector3d & lump_param_positive, const Eigen::Vector3d & lump_param_negative, const Eigen::Vector2d & min_max_thruster_input, double thrusters_gain, double thrusters_pole, double thrusters_delay, double sampling_period, const Eigen::Vector3d & disturbance_mean, const Eigen::Vector3d & disturbance_sigma, const Eigen::Vector3d & disturbance_minimum, const Eigen::Vector3d & disturbance_maximum ) Parameters : mass The mass of the vehicle in Kg fluid_density The density of the fluid the vehicle is in (a.k.a water density) zg The center of gravity of the (sphere-like) vehicle vehicle_density The density of the vehicle (Kg/m^3) inertia_tensor A vector of 3 elements with the diagonal of the inertia matrix linear_damping_tensor A vector of 6 elements with the diagonal of the linear damping matrix quadratic_damping_tensor A vector of 6 elements with the diagonal of the quadratic damping matrix added_mass_tensor A vector of 6 elements with the diagonal of the added mass matrix allocation_matrix A matrix with the contributions of each thruster to the forces in X,Y and Z and the arms for computing the moments of inertia later [Fx, Fy, Fz, lx, ly, lz] (each line represents one thruster) lump_param_positive The thrust curve parameters for the right side of the curve lump_param_negative The thrust curve parameters for the left side of the curve min_max_thruster_input The minimum and maximum normalized thruster inputs [min_input, max_input]^T thrusters_gain thrusters_pole thrusters_delay sampling_period An approximated sampling period (s) at which the simulation will run (NOTE: this is needed to discretize the thrusters model only and the integration of the dynamics of the vehicle will use the dt variable provided through the update method) disturbance_mean A vector with the mean of the ocean disturbances (gaussian process) disturbance_sigma A vector with the standard deviation of the ocean disturbances (gaussian process) disturbance_minimum A vector with the minimum values for the ocean disturbances disturbance_maximum A vector with the maximum values for the ocean disturbances MedusaAUV class constructor function update void update( double dt, const Eigen::VectorXd & thrust ) Parameters : dt The time difference (in seconds) between the last function call and the disturbance function call thrust A vector of n elements with the thrust to apply to each of the n vehicle thursters (normalized between 0 and 1) Method to update the state of the vehicle given the thrust applied to each individual thruster. This method verifies if (dt >= 0) and the size of thrust vector is the same as the number of thrusters of the model. If some of these conditions does not verify, a std::invalid_argument exception is thrown function getState inline State getState() Return : A state object with the state of the vehicle Method that returns a copy of the disturbance state of the vehicle function setState inline void setState( const State & state ) Parameters : state A state reference that contains the desired state of the vehicle Method that sets the disturbance state of the vehicle to a new pre-defined state function getNumberThrusters inline unsigned int getNumberThrusters() Return : The number of thrusters of the AUV Method that returns the number of thrusters of the AUV based on the number of lines of the allocation matrix received by the constructor upon object construction Updated on 2022-05-30 at 18:35:05 +0000","title":"AUV"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classAUV/#auv","text":"AUV class - implements a Matlab-like simulation of an AUV in C++. More... #include <AUV.h>","title":"AUV"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classAUV/#public-functions","text":"Name AUV (double mass, double fluid_density, double zg, double vehicle_density, const Eigen::Vector3d & inertia_tensor, const Eigen::Matrix< double, 6, 1 > & linear_damping_tensor, const Eigen::Matrix< double, 6, 1 > & quadratic_damping_tensor, const Eigen::Matrix< double, 6, 1 > & added_mass_tensor, const Eigen::MatrixXd & allocation_matrix, const Eigen::Vector3d & lump_param_positive, const Eigen::Vector3d & lump_param_negative, const Eigen::Vector2d & min_max_thruster_input, double thrusters_gain, double thrusters_pole, double thrusters_delay, double sampling_period, const Eigen::Vector3d & disturbance_mean, const Eigen::Vector3d & disturbance_sigma, const Eigen::Vector3d & disturbance_minimum, const Eigen::Vector3d & disturbance_maximum) void update (double dt, const Eigen::VectorXd & thrust) State getState () void setState (const State & state) unsigned int getNumberThrusters ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classAUV/#detailed-description","text":"class AUV; AUV class - implements a Matlab-like simulation of an AUV in C++. Author : Marcelo Jacinto Version : 1.0.0 Date : 2021/11/12 Copyright : MIT","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classAUV/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classAUV/#function-auv","text":"AUV( double mass, double fluid_density, double zg, double vehicle_density, const Eigen::Vector3d & inertia_tensor, const Eigen::Matrix< double, 6, 1 > & linear_damping_tensor, const Eigen::Matrix< double, 6, 1 > & quadratic_damping_tensor, const Eigen::Matrix< double, 6, 1 > & added_mass_tensor, const Eigen::MatrixXd & allocation_matrix, const Eigen::Vector3d & lump_param_positive, const Eigen::Vector3d & lump_param_negative, const Eigen::Vector2d & min_max_thruster_input, double thrusters_gain, double thrusters_pole, double thrusters_delay, double sampling_period, const Eigen::Vector3d & disturbance_mean, const Eigen::Vector3d & disturbance_sigma, const Eigen::Vector3d & disturbance_minimum, const Eigen::Vector3d & disturbance_maximum ) Parameters : mass The mass of the vehicle in Kg fluid_density The density of the fluid the vehicle is in (a.k.a water density) zg The center of gravity of the (sphere-like) vehicle vehicle_density The density of the vehicle (Kg/m^3) inertia_tensor A vector of 3 elements with the diagonal of the inertia matrix linear_damping_tensor A vector of 6 elements with the diagonal of the linear damping matrix quadratic_damping_tensor A vector of 6 elements with the diagonal of the quadratic damping matrix added_mass_tensor A vector of 6 elements with the diagonal of the added mass matrix allocation_matrix A matrix with the contributions of each thruster to the forces in X,Y and Z and the arms for computing the moments of inertia later [Fx, Fy, Fz, lx, ly, lz] (each line represents one thruster) lump_param_positive The thrust curve parameters for the right side of the curve lump_param_negative The thrust curve parameters for the left side of the curve min_max_thruster_input The minimum and maximum normalized thruster inputs [min_input, max_input]^T thrusters_gain thrusters_pole thrusters_delay sampling_period An approximated sampling period (s) at which the simulation will run (NOTE: this is needed to discretize the thrusters model only and the integration of the dynamics of the vehicle will use the dt variable provided through the update method) disturbance_mean A vector with the mean of the ocean disturbances (gaussian process) disturbance_sigma A vector with the standard deviation of the ocean disturbances (gaussian process) disturbance_minimum A vector with the minimum values for the ocean disturbances disturbance_maximum A vector with the maximum values for the ocean disturbances MedusaAUV class constructor","title":"function AUV"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classAUV/#function-update","text":"void update( double dt, const Eigen::VectorXd & thrust ) Parameters : dt The time difference (in seconds) between the last function call and the disturbance function call thrust A vector of n elements with the thrust to apply to each of the n vehicle thursters (normalized between 0 and 1) Method to update the state of the vehicle given the thrust applied to each individual thruster. This method verifies if (dt >= 0) and the size of thrust vector is the same as the number of thrusters of the model. If some of these conditions does not verify, a std::invalid_argument exception is thrown","title":"function update"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classAUV/#function-getstate","text":"inline State getState() Return : A state object with the state of the vehicle Method that returns a copy of the disturbance state of the vehicle","title":"function getState"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classAUV/#function-setstate","text":"inline void setState( const State & state ) Parameters : state A state reference that contains the desired state of the vehicle Method that sets the disturbance state of the vehicle to a new pre-defined state","title":"function setState"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classAUV/#function-getnumberthrusters","text":"inline unsigned int getNumberThrusters() Return : The number of thrusters of the AUV Method that returns the number of thrusters of the AUV based on the number of lines of the allocation matrix received by the constructor upon object construction Updated on 2022-05-30 at 18:35:05 +0000","title":"function getNumberThrusters"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classSimulationNode/","text":"SimulationNode SimulationNode class - implements the ROS interface to actually perform an AUV simulation. More... #include <SimulationNode.h> Public Functions Name SimulationNode (ros::NodeHandle * nh, ros::NodeHandle * nh_p) ~SimulationNode () Detailed Description class SimulationNode; SimulationNode class - implements the ROS interface to actually perform an AUV simulation. Author : Marcelo Jacinto Version : 1.0.0 Date : 2021/11/12 Copyright : MIT Public Functions Documentation function SimulationNode SimulationNode( ros::NodeHandle * nh, ros::NodeHandle * nh_p ) function ~SimulationNode ~SimulationNode() Updated on 2022-05-30 at 18:35:05 +0000","title":"SimulationNode"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classSimulationNode/#simulationnode","text":"SimulationNode class - implements the ROS interface to actually perform an AUV simulation. More... #include <SimulationNode.h>","title":"SimulationNode"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classSimulationNode/#public-functions","text":"Name SimulationNode (ros::NodeHandle * nh, ros::NodeHandle * nh_p) ~SimulationNode ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classSimulationNode/#detailed-description","text":"class SimulationNode; SimulationNode class - implements the ROS interface to actually perform an AUV simulation. Author : Marcelo Jacinto Version : 1.0.0 Date : 2021/11/12 Copyright : MIT","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classSimulationNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classSimulationNode/#function-simulationnode","text":"SimulationNode( ros::NodeHandle * nh, ros::NodeHandle * nh_p )","title":"function SimulationNode"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classSimulationNode/#function-simulationnode_1","text":"~SimulationNode() Updated on 2022-05-30 at 18:35:05 +0000","title":"function ~SimulationNode"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/structState/","text":"State State class - used to save the state of a vehicle (using SNAME convention) More... #include <State.h> Public Attributes Name Eigen::Vector3d eta1 Eigen::Vector3d eta2 Eigen::Vector3d v1 Eigen::Vector3d v2 Detailed Description struct State; State class - used to save the state of a vehicle (using SNAME convention) Author : Marcelo Jacinto Version : 1.0.0 Date : 2021/11/12 Copyright : MIT Public Attributes Documentation variable eta1 Eigen::Vector3d eta1 {0.0, 0.0, 0.0}; The position of the vehicle expressed in the inertial frame eta1=[x,y,z]^T variable eta2 Eigen::Vector3d eta2 {0.0, 0.0, 0.0}; The orientation of the vehicle expressed in the inertial frame, using euler angles eta2=[roll, pitch, yaw]^T variable v1 Eigen::Vector3d v1 {0.0, 0.0, 0.0}; The body velocity of the vehicle v1=[u,v,w]^T variable v2 Eigen::Vector3d v2 {0.0, 0.0, 0.0}; The body angular velocity of the vehicle v2=[p,q,r]^T Updated on 2022-05-30 at 18:35:05 +0000","title":"State"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/structState/#state","text":"State class - used to save the state of a vehicle (using SNAME convention) More... #include <State.h>","title":"State"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/structState/#public-attributes","text":"Name Eigen::Vector3d eta1 Eigen::Vector3d eta2 Eigen::Vector3d v1 Eigen::Vector3d v2","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/structState/#detailed-description","text":"struct State; State class - used to save the state of a vehicle (using SNAME convention) Author : Marcelo Jacinto Version : 1.0.0 Date : 2021/11/12 Copyright : MIT","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/structState/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/structState/#variable-eta1","text":"Eigen::Vector3d eta1 {0.0, 0.0, 0.0}; The position of the vehicle expressed in the inertial frame eta1=[x,y,z]^T","title":"variable eta1"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/structState/#variable-eta2","text":"Eigen::Vector3d eta2 {0.0, 0.0, 0.0}; The orientation of the vehicle expressed in the inertial frame, using euler angles eta2=[roll, pitch, yaw]^T","title":"variable eta2"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/structState/#variable-v1","text":"Eigen::Vector3d v1 {0.0, 0.0, 0.0}; The body velocity of the vehicle v1=[u,v,w]^T","title":"variable v1"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/structState/#variable-v2","text":"Eigen::Vector3d v2 {0.0, 0.0, 0.0}; The body angular velocity of the vehicle v2=[p,q,r]^T Updated on 2022-05-30 at 18:35:05 +0000","title":"variable v2"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:05 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:05 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:05 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:05 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Namespaces/","text":"Namespaces Updated on 2022-05-30 at 18:35:05 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Namespaces/#namespaces","text":"Updated on 2022-05-30 at 18:35:05 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/","text":"Classes class SensorSim struct Sensor Updated on 2022-05-30 at 18:35:10 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/#classes","text":"class SensorSim struct Sensor Updated on 2022-05-30 at 18:35:10 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/classSensorSim/","text":"SensorSim Public Functions Name SensorSim (ros::NodeHandle * nh, ros::NodeHandle * nh_private) ~SensorSim () double nodeFrequency () Public Functions Documentation function SensorSim SensorSim( ros::NodeHandle * nh, ros::NodeHandle * nh_private ) function ~SensorSim ~SensorSim() function nodeFrequency double nodeFrequency() Updated on 2022-05-30 at 18:35:10 +0000","title":"SensorSim"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/classSensorSim/#sensorsim","text":"","title":"SensorSim"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/classSensorSim/#public-functions","text":"Name SensorSim (ros::NodeHandle * nh, ros::NodeHandle * nh_private) ~SensorSim () double nodeFrequency ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/classSensorSim/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/classSensorSim/#function-sensorsim","text":"SensorSim( ros::NodeHandle * nh, ros::NodeHandle * nh_private )","title":"function SensorSim"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/classSensorSim/#function-sensorsim_1","text":"~SensorSim()","title":"function ~SensorSim"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/classSensorSim/#function-nodefrequency","text":"double nodeFrequency() Updated on 2022-05-30 at 18:35:10 +0000","title":"function nodeFrequency"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/","text":"SensorSim::Sensor Public Types Name enum Type { null, AHRS, DVL_BT, DVL_WT, DEPTH, ALTIMETER, GNSS, RANGE, MODEL} Public Functions Name Sensor () Public Attributes Name Type type std::string frame_id bool debug int count int thresh double last_update double frequency double variance double noise double beacon int zone bool northp double altitude std::map< std::string, Type > enum_map Public Types Documentation enum Type Enumerator Value Description null AHRS DVL_BT DVL_WT DEPTH ALTIMETER GNSS RANGE MODEL Public Functions Documentation function Sensor inline Sensor() Public Attributes Documentation variable type Type type; variable frame_id std::string frame_id; variable debug bool debug; variable count int count; variable thresh int thresh; variable last_update double last_update; variable frequency double frequency; variable variance double variance; variable noise double noise; variable beacon double beacon; variable zone int zone; variable northp bool northp; variable altitude double altitude; variable enum_map std::map< std::string, Type > enum_map; Updated on 2022-05-30 at 18:35:10 +0000","title":"SensorSim::Sensor"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#sensorsimsensor","text":"","title":"SensorSim::Sensor"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#public-types","text":"Name enum Type { null, AHRS, DVL_BT, DVL_WT, DEPTH, ALTIMETER, GNSS, RANGE, MODEL}","title":"Public Types"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#public-functions","text":"Name Sensor ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#public-attributes","text":"Name Type type std::string frame_id bool debug int count int thresh double last_update double frequency double variance double noise double beacon int zone bool northp double altitude std::map< std::string, Type > enum_map","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#enum-type","text":"Enumerator Value Description null AHRS DVL_BT DVL_WT DEPTH ALTIMETER GNSS RANGE MODEL","title":"enum Type"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#function-sensor","text":"inline Sensor()","title":"function Sensor"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#variable-type","text":"Type type;","title":"variable type"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#variable-frame_id","text":"std::string frame_id;","title":"variable frame_id"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#variable-debug","text":"bool debug;","title":"variable debug"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#variable-count","text":"int count;","title":"variable count"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#variable-thresh","text":"int thresh;","title":"variable thresh"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#variable-last_update","text":"double last_update;","title":"variable last_update"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#variable-frequency","text":"double frequency;","title":"variable frequency"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#variable-variance","text":"double variance;","title":"variable variance"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#variable-noise","text":"double noise;","title":"variable noise"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#variable-beacon","text":"double beacon;","title":"variable beacon"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#variable-zone","text":"int zone;","title":"variable zone"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#variable-northp","text":"bool northp;","title":"variable northp"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#variable-altitude","text":"double altitude;","title":"variable altitude"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#variable-enum_map","text":"std::map< std::string, Type > enum_map; Updated on 2022-05-30 at 18:35:10 +0000","title":"variable enum_map"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:10 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:10 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:10 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:10 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Namespaces/","text":"Namespaces Updated on 2022-05-30 at 18:35:10 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Namespaces/#namespaces","text":"Updated on 2022-05-30 at 18:35:10 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_gazebo/medusa_worlds/Classes/","text":"Classes namespace terrain_generator Updated on 2022-05-30 at 18:35:09 +0000","title":"Classes"},{"location":"api/markdown/medusa_gazebo/medusa_worlds/Classes/#classes","text":"namespace terrain_generator Updated on 2022-05-30 at 18:35:09 +0000","title":"Classes"},{"location":"api/markdown/medusa_gazebo/medusa_worlds/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:09 +0000","title":"Examples"},{"location":"api/markdown/medusa_gazebo/medusa_worlds/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:09 +0000","title":"Examples"},{"location":"api/markdown/medusa_gazebo/medusa_worlds/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:09 +0000","title":"Modules"},{"location":"api/markdown/medusa_gazebo/medusa_worlds/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:09 +0000","title":"Modules"},{"location":"api/markdown/medusa_gazebo/medusa_worlds/Namespaces/","text":"Namespaces namespace terrain_generator Updated on 2022-05-30 at 18:35:09 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_gazebo/medusa_worlds/Namespaces/#namespaces","text":"namespace terrain_generator Updated on 2022-05-30 at 18:35:09 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_gazebo/medusa_worlds/Namespaces/namespaceterrain__generator/","text":"terrain_generator More... Functions Name def main () Detailed Description Convert .mat files with that into the corresponding .npy and .stl files @author: Marcelo Fialho Jacinto @email: marcelo.jacinto@tecnico.ulisboa.pt @date: 06/03/2021 Functions Documentation function main def main() Updated on 2022-05-30 at 18:35:09 +0000","title":"terrain_generator"},{"location":"api/markdown/medusa_gazebo/medusa_worlds/Namespaces/namespaceterrain__generator/#terrain_generator","text":"More...","title":"terrain_generator"},{"location":"api/markdown/medusa_gazebo/medusa_worlds/Namespaces/namespaceterrain__generator/#functions","text":"Name def main ()","title":"Functions"},{"location":"api/markdown/medusa_gazebo/medusa_worlds/Namespaces/namespaceterrain__generator/#detailed-description","text":"Convert .mat files with that into the corresponding .npy and .stl files @author: Marcelo Fialho Jacinto @email: marcelo.jacinto@tecnico.ulisboa.pt @date: 06/03/2021","title":"Detailed Description"},{"location":"api/markdown/medusa_gazebo/medusa_worlds/Namespaces/namespaceterrain__generator/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_gazebo/medusa_worlds/Namespaces/namespaceterrain__generator/#function-main","text":"def main() Updated on 2022-05-30 at 18:35:09 +0000","title":"function main"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Classes/","text":"Classes namespace publish_footprints namespace publish_vehicle_footprint class VehicleFootprint namespace publish_world_models class WorldPublisher namespace set_simulation_timer namespace setup namespace tf namespace tf_quaternion namespace transformations class Arcball namespace unpause_simulation Updated on 2022-05-30 at 18:35:11 +0000","title":"Classes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Classes/#classes","text":"namespace publish_footprints namespace publish_vehicle_footprint class VehicleFootprint namespace publish_world_models class WorldPublisher namespace set_simulation_timer namespace setup namespace tf namespace tf_quaternion namespace transformations class Arcball namespace unpause_simulation Updated on 2022-05-30 at 18:35:11 +0000","title":"Classes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Classes/classpublish__vehicle__footprint_1_1VehicleFootprint/","text":"publish_vehicle_footprint::VehicleFootprint Public Functions Name def init (self self) def odometry_callback (self self, msg msg) def rot (alpha alpha) Public Attributes Name MARKER Public Functions Documentation function init def __init__( self self ) function odometry_callback def odometry_callback( self self, msg msg ) function rot static def rot( alpha alpha ) Public Attributes Documentation variable MARKER static MARKER = np.array([[0, 0.75], [-0.5, -0.25], [0.5, -0.25]]); Updated on 2022-05-30 at 18:35:11 +0000","title":"publish_vehicle_footprint::VehicleFootprint"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Classes/classpublish__vehicle__footprint_1_1VehicleFootprint/#publish_vehicle_footprintvehiclefootprint","text":"","title":"publish_vehicle_footprint::VehicleFootprint"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Classes/classpublish__vehicle__footprint_1_1VehicleFootprint/#public-functions","text":"Name def init (self self) def odometry_callback (self self, msg msg) def rot (alpha alpha)","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Classes/classpublish__vehicle__footprint_1_1VehicleFootprint/#public-attributes","text":"Name MARKER","title":"Public Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Classes/classpublish__vehicle__footprint_1_1VehicleFootprint/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Classes/classpublish__vehicle__footprint_1_1VehicleFootprint/#function-init","text":"def __init__( self self )","title":"function init"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Classes/classpublish__vehicle__footprint_1_1VehicleFootprint/#function-odometry_callback","text":"def odometry_callback( self self, msg msg )","title":"function odometry_callback"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Classes/classpublish__vehicle__footprint_1_1VehicleFootprint/#function-rot","text":"static def rot( alpha alpha )","title":"function rot"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Classes/classpublish__vehicle__footprint_1_1VehicleFootprint/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Classes/classpublish__vehicle__footprint_1_1VehicleFootprint/#variable-marker","text":"static MARKER = np.array([[0, 0.75], [-0.5, -0.25], [0.5, -0.25]]); Updated on 2022-05-30 at 18:35:11 +0000","title":"variable MARKER"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Classes/classpublish__world__models_1_1WorldPublisher/","text":"publish_world_models::WorldPublisher Public Functions Name def init (self self) def add_meshes (self self, models models) def publish_meshes (self self) Public Functions Documentation function init def __init__( self self ) function add_meshes def add_meshes( self self, models models ) function publish_meshes def publish_meshes( self self ) Updated on 2022-05-30 at 18:35:11 +0000","title":"publish_world_models::WorldPublisher"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Classes/classpublish__world__models_1_1WorldPublisher/#publish_world_modelsworldpublisher","text":"","title":"publish_world_models::WorldPublisher"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Classes/classpublish__world__models_1_1WorldPublisher/#public-functions","text":"Name def init (self self) def add_meshes (self self, models models) def publish_meshes (self self)","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Classes/classpublish__world__models_1_1WorldPublisher/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Classes/classpublish__world__models_1_1WorldPublisher/#function-init","text":"def __init__( self self )","title":"function init"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Classes/classpublish__world__models_1_1WorldPublisher/#function-add_meshes","text":"def add_meshes( self self, models models )","title":"function add_meshes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Classes/classpublish__world__models_1_1WorldPublisher/#function-publish_meshes","text":"def publish_meshes( self self ) Updated on 2022-05-30 at 18:35:11 +0000","title":"function publish_meshes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Classes/classtf__quaternion_1_1transformations_1_1Arcball/","text":"tf_quaternion::transformations::Arcball More... Inherits from object Public Functions Name def init (self self, initial initial =None) def place (self self, center center, radius radius) def setaxes (self self, * axes) def setconstrain (self self, constrain constrain) def getconstrain (self self) def down (self self, point point) def drag (self self, point point) def next (self self, acceleration acceleration =0.0) def matrix (self self) Detailed Description class tf_quaternion::transformations::Arcball; Virtual Trackball Control. >>> ball = Arcball() >>> ball = Arcball(initial=numpy.identity(4)) >>> ball.place([320, 320], 320) >>> ball.down([500, 250]) >>> ball.drag([475, 275]) >>> R = ball.matrix() >>> numpy.allclose(numpy.sum(R), 3.90583455) True >>> ball = Arcball(initial=[0, 0, 0, 1]) >>> ball.place([320, 320], 320) >>> ball.setaxes([1,1,0], [-1, 1, 0]) >>> ball.setconstrain(True) >>> ball.down([400, 200]) >>> ball.drag([200, 400]) >>> R = ball.matrix() >>> numpy.allclose(numpy.sum(R), 0.2055924) True >>> ball.next()``` ## Public Functions Documentation ### function __init__ ```python def __init__( self self, initial initial =None ) Initialize virtual trackball control. initial : quaternion or rotation matrix``` ### function place ```python def place( self self, center center, radius radius ) Place Arcball, e.g. when window size changes. center : sequence[2] Window coordinates of trackball center. radius : float Radius of trackball in window coordinates.``` ### function setaxes ```python def setaxes( self self, * axes ) Set axes to constrain rotations.``` ### function setconstrain ```python def setconstrain( self self, constrain constrain ) Set state of constrain to axis mode.``` ### function getconstrain ```python def getconstrain( self self ) Return state of constrain to axis mode.``` ### function down ```python def down( self self, point point ) Set initial cursor window coordinates and pick constrain-axis.``` ### function drag ```python def drag( self self, point point ) Update current cursor window coordinates.``` ### function next ```python def next( self self, acceleration acceleration =0.0 ) Continue rotation in direction of last drag.``` ### function matrix ```python def matrix( self self ) Return homogeneous rotation matrix. Updated on 2022-05-30 at 18:35:11 +0000","title":"tf_quaternion::transformations::Arcball"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Classes/classtf__quaternion_1_1transformations_1_1Arcball/#tf_quaterniontransformationsarcball","text":"More... Inherits from object","title":"tf_quaternion::transformations::Arcball"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Classes/classtf__quaternion_1_1transformations_1_1Arcball/#public-functions","text":"Name def init (self self, initial initial =None) def place (self self, center center, radius radius) def setaxes (self self, * axes) def setconstrain (self self, constrain constrain) def getconstrain (self self) def down (self self, point point) def drag (self self, point point) def next (self self, acceleration acceleration =0.0) def matrix (self self)","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Classes/classtf__quaternion_1_1transformations_1_1Arcball/#detailed-description","text":"class tf_quaternion::transformations::Arcball; Virtual Trackball Control. >>> ball = Arcball() >>> ball = Arcball(initial=numpy.identity(4)) >>> ball.place([320, 320], 320) >>> ball.down([500, 250]) >>> ball.drag([475, 275]) >>> R = ball.matrix() >>> numpy.allclose(numpy.sum(R), 3.90583455) True >>> ball = Arcball(initial=[0, 0, 0, 1]) >>> ball.place([320, 320], 320) >>> ball.setaxes([1,1,0], [-1, 1, 0]) >>> ball.setconstrain(True) >>> ball.down([400, 200]) >>> ball.drag([200, 400]) >>> R = ball.matrix() >>> numpy.allclose(numpy.sum(R), 0.2055924) True >>> ball.next()``` ## Public Functions Documentation ### function __init__ ```python def __init__( self self, initial initial =None ) Initialize virtual trackball control. initial : quaternion or rotation matrix``` ### function place ```python def place( self self, center center, radius radius ) Place Arcball, e.g. when window size changes. center : sequence[2] Window coordinates of trackball center. radius : float Radius of trackball in window coordinates.``` ### function setaxes ```python def setaxes( self self, * axes ) Set axes to constrain rotations.``` ### function setconstrain ```python def setconstrain( self self, constrain constrain ) Set state of constrain to axis mode.``` ### function getconstrain ```python def getconstrain( self self ) Return state of constrain to axis mode.``` ### function down ```python def down( self self, point point ) Set initial cursor window coordinates and pick constrain-axis.``` ### function drag ```python def drag( self self, point point ) Update current cursor window coordinates.``` ### function next ```python def next( self self, acceleration acceleration =0.0 ) Continue rotation in direction of last drag.``` ### function matrix ```python def matrix( self self ) Return homogeneous rotation matrix. Updated on 2022-05-30 at 18:35:11 +0000","title":"Detailed Description"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:11 +0000","title":"Examples"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:11 +0000","title":"Examples"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:11 +0000","title":"Modules"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:11 +0000","title":"Modules"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/","text":"Namespaces namespace publish_footprints namespace publish_vehicle_footprint namespace publish_world_models namespace set_simulation_timer namespace setup namespace tf namespace tf_quaternion namespace transformations namespace unpause_simulation Updated on 2022-05-30 at 18:35:11 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/#namespaces","text":"namespace publish_footprints namespace publish_vehicle_footprint namespace publish_world_models namespace set_simulation_timer namespace setup namespace tf namespace tf_quaternion namespace transformations namespace unpause_simulation Updated on 2022-05-30 at 18:35:11 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacepublish__footprints/","text":"publish_footprints Functions Name def rot (alpha alpha) def odometry_callback (msg msg, name name) def get_topics (name name) def sub_odometry_topic (name name) def update_vehicle_list (event event) def main () Attributes Name vehicle_pub odom_sub get_world_props get_model_props marker Functions Documentation function rot def rot( alpha alpha ) function odometry_callback def odometry_callback( msg msg, name name ) function get_topics def get_topics( name name ) function sub_odometry_topic def sub_odometry_topic( name name ) function update_vehicle_list def update_vehicle_list( event event ) Call list of models in the Gazebo simulation and filter out the marine crafts. function main def main() Attributes Documentation variable vehicle_pub vehicle_pub = dict(); variable odom_sub odom_sub = dict(); variable get_world_props get_world_props = None; variable get_model_props get_model_props = None; variable marker marker = np.array([[0, 0.75], [-0.5, -0.25], [0.5, -0.25]]); Updated on 2022-05-30 at 18:35:11 +0000","title":"publish_footprints"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacepublish__footprints/#publish_footprints","text":"","title":"publish_footprints"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacepublish__footprints/#functions","text":"Name def rot (alpha alpha) def odometry_callback (msg msg, name name) def get_topics (name name) def sub_odometry_topic (name name) def update_vehicle_list (event event) def main ()","title":"Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacepublish__footprints/#attributes","text":"Name vehicle_pub odom_sub get_world_props get_model_props marker","title":"Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacepublish__footprints/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacepublish__footprints/#function-rot","text":"def rot( alpha alpha )","title":"function rot"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacepublish__footprints/#function-odometry_callback","text":"def odometry_callback( msg msg, name name )","title":"function odometry_callback"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacepublish__footprints/#function-get_topics","text":"def get_topics( name name )","title":"function get_topics"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacepublish__footprints/#function-sub_odometry_topic","text":"def sub_odometry_topic( name name )","title":"function sub_odometry_topic"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacepublish__footprints/#function-update_vehicle_list","text":"def update_vehicle_list( event event ) Call list of models in the Gazebo simulation and filter out the marine crafts.","title":"function update_vehicle_list"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacepublish__footprints/#function-main","text":"def main()","title":"function main"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacepublish__footprints/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacepublish__footprints/#variable-vehicle_pub","text":"vehicle_pub = dict();","title":"variable vehicle_pub"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacepublish__footprints/#variable-odom_sub","text":"odom_sub = dict();","title":"variable odom_sub"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacepublish__footprints/#variable-get_world_props","text":"get_world_props = None;","title":"variable get_world_props"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacepublish__footprints/#variable-get_model_props","text":"get_model_props = None;","title":"variable get_model_props"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacepublish__footprints/#variable-marker","text":"marker = np.array([[0, 0.75], [-0.5, -0.25], [0.5, -0.25]]); Updated on 2022-05-30 at 18:35:11 +0000","title":"variable marker"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacepublish__vehicle__footprint/","text":"publish_vehicle_footprint Classes Name class publish_vehicle_footprint::VehicleFootprint Attributes Name node Attributes Documentation variable node node = VehicleFootprint(); Updated on 2022-05-30 at 18:35:11 +0000","title":"publish_vehicle_footprint"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacepublish__vehicle__footprint/#publish_vehicle_footprint","text":"","title":"publish_vehicle_footprint"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacepublish__vehicle__footprint/#classes","text":"Name class publish_vehicle_footprint::VehicleFootprint","title":"Classes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacepublish__vehicle__footprint/#attributes","text":"Name node","title":"Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacepublish__vehicle__footprint/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacepublish__vehicle__footprint/#variable-node","text":"node = VehicleFootprint(); Updated on 2022-05-30 at 18:35:11 +0000","title":"variable node"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacepublish__world__models/","text":"publish_world_models Classes Name class publish_world_models::WorldPublisher Attributes Name world_pub Attributes Documentation variable world_pub world_pub = WorldPublisher(); Updated on 2022-05-30 at 18:35:11 +0000","title":"publish_world_models"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacepublish__world__models/#publish_world_models","text":"","title":"publish_world_models"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacepublish__world__models/#classes","text":"Name class publish_world_models::WorldPublisher","title":"Classes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacepublish__world__models/#attributes","text":"Name world_pub","title":"Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacepublish__world__models/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacepublish__world__models/#variable-world_pub","text":"world_pub = WorldPublisher(); Updated on 2022-05-30 at 18:35:11 +0000","title":"variable world_pub"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespaceset__simulation__timer/","text":"set_simulation_timer Attributes Name float timeout rate Attributes Documentation variable timeout float timeout = 0.0; variable rate rate = rospy.Rate(100); Updated on 2022-05-30 at 18:35:11 +0000","title":"set_simulation_timer"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespaceset__simulation__timer/#set_simulation_timer","text":"","title":"set_simulation_timer"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespaceset__simulation__timer/#attributes","text":"Name float timeout rate","title":"Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespaceset__simulation__timer/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespaceset__simulation__timer/#variable-timeout","text":"float timeout = 0.0;","title":"variable timeout"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespaceset__simulation__timer/#variable-rate","text":"rate = rospy.Rate(100); Updated on 2022-05-30 at 18:35:11 +0000","title":"variable rate"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacesetup/","text":"setup Attributes Name setup_args Attributes Documentation variable setup_args setup_args = generate_distutils_setup( packages=['tf_quaternion'], package_dir={'': 'src'}, requires=[] ); Updated on 2022-05-30 at 18:35:11 +0000","title":"setup"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacesetup/#setup","text":"","title":"setup"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacesetup/#attributes","text":"Name setup_args","title":"Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacesetup/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacesetup/#variable-setup_args","text":"setup_args = generate_distutils_setup( packages=['tf_quaternion'], package_dir={'': 'src'}, requires=[] ); Updated on 2022-05-30 at 18:35:11 +0000","title":"variable setup_args"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacetf/","text":"tf Types Name typedef btMatrix3x3 Matrix3x3 Types Documentation typedef Matrix3x3 typedef btMatrix3x3 tf::Matrix3x3; Updated on 2022-05-30 at 18:35:11 +0000","title":"tf"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacetf/#tf","text":"","title":"tf"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacetf/#types","text":"Name typedef btMatrix3x3 Matrix3x3","title":"Types"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacetf/#types-documentation","text":"","title":"Types Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacetf/#typedef-matrix3x3","text":"typedef btMatrix3x3 tf::Matrix3x3; Updated on 2022-05-30 at 18:35:11 +0000","title":"typedef Matrix3x3"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacetf__quaternion/","text":"tf_quaternion Namespaces Name tf_quaternion::transformations Updated on 2022-05-30 at 18:35:11 +0000","title":"tf_quaternion"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacetf__quaternion/#tf_quaternion","text":"","title":"tf_quaternion"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacetf__quaternion/#namespaces","text":"Name tf_quaternion::transformations Updated on 2022-05-30 at 18:35:11 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacetf__quaternion_1_1transformations/","text":"tf_quaternion::transformations Classes Name class tf_quaternion::transformations::Arcball Functions Name def identity_matrix () def translation_matrix (direction direction) def translation_from_matrix (matrix matrix) def reflection_matrix (point point, normal normal) def reflection_from_matrix (matrix matrix) def rotation_matrix (angle angle, direction direction, point point =None) def rotation_from_matrix (matrix matrix) def scale_matrix (factor factor, origin origin =None, direction direction =None) def scale_from_matrix (matrix matrix) def projection_matrix (point point, normal normal, direction direction =None, perspective perspective =None, pseudo pseudo =False) def projection_from_matrix (matrix matrix, pseudo pseudo =False) def clip_matrix (left left, right right, bottom bottom, top top, near near, far far, perspective perspective =False) def shear_matrix (angle angle, direction direction, point point, normal normal) def shear_from_matrix (matrix matrix) def decompose_matrix (matrix matrix) def compose_matrix (scale scale =None, shear shear =None, angles angles =None, translate translate =None, perspective perspective =None) def orthogonalization_matrix (lengths lengths, angles angles) def superimposition_matrix (v0 v0, v1 v1, scaling scaling =False, usesvd usesvd =True) def euler_matrix (ai ai, aj aj, ak ak, axes axes ='sxyz') def euler_from_matrix (matrix matrix, axes axes ='sxyz') def euler_from_quaternion (quaternion quaternion, axes axes ='sxyz') def quaternion_from_euler (ai ai, aj aj, ak ak, axes axes ='sxyz') def quaternion_about_axis (angle angle, axis axis) def quaternion_matrix (quaternion quaternion) def quaternion_from_matrix (matrix matrix) def quaternion_multiply (quaternion1 quaternion1, quaternion0 quaternion0) def quaternion_conjugate (quaternion quaternion) def quaternion_inverse (quaternion quaternion) def quaternion_slerp (quat0 quat0, quat1 quat1, fraction fraction, spin spin =0, shortestpath shortestpath =True) def random_quaternion (rand rand =None) def random_rotation_matrix (rand rand =None) def arcball_map_to_sphere (point point, center center, radius radius) def arcball_constrain_to_axis (point point, axis axis) def arcball_nearest_axis (point point, axes axes) def vector_norm (data data, axis axis =None, out out =None) def unit_vector (data data, axis axis =None, out out =None) def random_vector (size size) def inverse_matrix (matrix matrix) def concatenate_matrices (* matrices) def is_same_transform (matrix0 matrix0, matrix1 matrix1) Functions Documentation function identity_matrix def identity_matrix() Return 4x4 identity/unit matrix. >>> I = identity_matrix() >>> numpy.allclose(I, numpy.dot(I, I)) True >>> numpy.sum(I), numpy.trace(I) (4.0, 4.0) >>> numpy.allclose(I, numpy.identity(4, dtype=numpy.float64)) True``` ### function translation_matrix ```python def translation_matrix( direction direction ) Return matrix to translate by direction vector. >>> v = numpy.random.random(3) - 0.5 >>> numpy.allclose(v, translation_matrix(v)[:3, 3]) True``` ### function translation_from_matrix ```python def translation_from_matrix( matrix matrix ) Return translation vector from translation matrix. >>> v0 = numpy.random.random(3) - 0.5 >>> v1 = translation_from_matrix(translation_matrix(v0)) >>> numpy.allclose(v0, v1) True``` ### function reflection_matrix ```python def reflection_matrix( point point, normal normal ) Return matrix to mirror at plane defined by point and normal vector. >>> v0 = numpy.random.random(4) - 0.5 >>> v0[3] = 1.0 >>> v1 = numpy.random.random(3) - 0.5 >>> R = reflection_matrix(v0, v1) >>> numpy.allclose(2., numpy.trace(R)) True >>> numpy.allclose(v0, numpy.dot(R, v0)) True >>> v2 = v0.copy() >>> v2[:3] += v1 >>> v3 = v0.copy() >>> v2[:3] -= v1 >>> numpy.allclose(v2, numpy.dot(R, v3)) True``` ### function reflection_from_matrix ```python def reflection_from_matrix( matrix matrix ) Return mirror plane point and normal vector from reflection matrix. >>> v0 = numpy.random.random(3) - 0.5 >>> v1 = numpy.random.random(3) - 0.5 >>> M0 = reflection_matrix(v0, v1) >>> point, normal = reflection_from_matrix(M0) >>> M1 = reflection_matrix(point, normal) >>> is_same_transform(M0, M1) True``` ### function rotation_matrix ```python def rotation_matrix( angle angle, direction direction, point point =None ) Return matrix to rotate about axis defined by point and direction. >>> angle = (random.random() - 0.5) * (2*math.pi) >>> direc = numpy.random.random(3) - 0.5 >>> point = numpy.random.random(3) - 0.5 >>> R0 = rotation_matrix(angle, direc, point) >>> R1 = rotation_matrix(angle-2*math.pi, direc, point) >>> is_same_transform(R0, R1) True >>> R0 = rotation_matrix(angle, direc, point) >>> R1 = rotation_matrix(-angle, -direc, point) >>> is_same_transform(R0, R1) True >>> I = numpy.identity(4, numpy.float64) >>> numpy.allclose(I, rotation_matrix(math.pi*2, direc)) True >>> numpy.allclose(2., numpy.trace(rotation_matrix(math.pi/2, ... direc, point))) True``` ### function rotation_from_matrix ```python def rotation_from_matrix( matrix matrix ) Return rotation angle and axis from rotation matrix. >>> angle = (random.random() - 0.5) * (2*math.pi) >>> direc = numpy.random.random(3) - 0.5 >>> point = numpy.random.random(3) - 0.5 >>> R0 = rotation_matrix(angle, direc, point) >>> angle, direc, point = rotation_from_matrix(R0) >>> R1 = rotation_matrix(angle, direc, point) >>> is_same_transform(R0, R1) True``` ### function scale_matrix ```python def scale_matrix( factor factor, origin origin =None, direction direction =None ) Return matrix to scale by factor around origin in direction. Use factor -1 for point symmetry. >>> v = (numpy.random.rand(4, 5) - 0.5) * 20.0 >>> v[3] = 1.0 >>> S = scale_matrix(-1.234) >>> numpy.allclose(numpy.dot(S, v)[:3], -1.234*v[:3]) True >>> factor = random.random() * 10 - 5 >>> origin = numpy.random.random(3) - 0.5 >>> direct = numpy.random.random(3) - 0.5 >>> S = scale_matrix(factor, origin) >>> S = scale_matrix(factor, origin, direct)``` ### function scale_from_matrix ```python def scale_from_matrix( matrix matrix ) Return scaling factor, origin and direction from scaling matrix. >>> factor = random.random() * 10 - 5 >>> origin = numpy.random.random(3) - 0.5 >>> direct = numpy.random.random(3) - 0.5 >>> S0 = scale_matrix(factor, origin) >>> factor, origin, direction = scale_from_matrix(S0) >>> S1 = scale_matrix(factor, origin, direction) >>> is_same_transform(S0, S1) True >>> S0 = scale_matrix(factor, origin, direct) >>> factor, origin, direction = scale_from_matrix(S0) >>> S1 = scale_matrix(factor, origin, direction) >>> is_same_transform(S0, S1) True``` ### function projection_matrix ```python def projection_matrix( point point, normal normal, direction direction =None, perspective perspective =None, pseudo pseudo =False ) Return matrix to project onto plane defined by point and normal. Using either perspective point, projection direction, or none of both. If pseudo is True, perspective projections will preserve relative depth such that Perspective = dot(Orthogonal, PseudoPerspective). >>> P = projection_matrix((0, 0, 0), (1, 0, 0)) >>> numpy.allclose(P[1:, 1:], numpy.identity(4)[1:, 1:]) True >>> point = numpy.random.random(3) - 0.5 >>> normal = numpy.random.random(3) - 0.5 >>> direct = numpy.random.random(3) - 0.5 >>> persp = numpy.random.random(3) - 0.5 >>> P0 = projection_matrix(point, normal) >>> P1 = projection_matrix(point, normal, direction=direct) >>> P2 = projection_matrix(point, normal, perspective=persp) >>> P3 = projection_matrix(point, normal, perspective=persp, pseudo=True) >>> is_same_transform(P2, numpy.dot(P0, P3)) True >>> P = projection_matrix((3, 0, 0), (1, 1, 0), (1, 0, 0)) >>> v0 = (numpy.random.rand(4, 5) - 0.5) * 20.0 >>> v0[3] = 1.0 >>> v1 = numpy.dot(P, v0) >>> numpy.allclose(v1[1], v0[1]) True >>> numpy.allclose(v1[0], 3.0-v1[1]) True``` ### function projection_from_matrix ```python def projection_from_matrix( matrix matrix, pseudo pseudo =False ) Return projection plane and perspective point from projection matrix. Return values are same as arguments for projection_matrix function: point, normal, direction, perspective, and pseudo. >>> point = numpy.random.random(3) - 0.5 >>> normal = numpy.random.random(3) - 0.5 >>> direct = numpy.random.random(3) - 0.5 >>> persp = numpy.random.random(3) - 0.5 >>> P0 = projection_matrix(point, normal) >>> result = projection_from_matrix(P0) >>> P1 = projection_matrix(*result) >>> is_same_transform(P0, P1) True >>> P0 = projection_matrix(point, normal, direct) >>> result = projection_from_matrix(P0) >>> P1 = projection_matrix(*result) >>> is_same_transform(P0, P1) True >>> P0 = projection_matrix(point, normal, perspective=persp, pseudo=False) >>> result = projection_from_matrix(P0, pseudo=False) >>> P1 = projection_matrix(*result) >>> is_same_transform(P0, P1) True >>> P0 = projection_matrix(point, normal, perspective=persp, pseudo=True) >>> result = projection_from_matrix(P0, pseudo=True) >>> P1 = projection_matrix(*result) >>> is_same_transform(P0, P1) True``` ### function clip_matrix ```python def clip_matrix( left left, right right, bottom bottom, top top, near near, far far, perspective perspective =False ) Return matrix to obtain normalized device coordinates from frustrum. The frustrum bounds are axis-aligned along x (left, right), y (bottom, top) and z (near, far). Normalized device coordinates are in range [-1, 1] if coordinates are inside the frustrum. If perspective is True the frustrum is a truncated pyramid with the perspective point at origin and direction along z axis, otherwise an orthographic canonical view volume (a box). Homogeneous coordinates transformed by the perspective clip matrix need to be dehomogenized (devided by w coordinate). >>> frustrum = numpy.random.rand(6) >>> frustrum[1] += frustrum[0] >>> frustrum[3] += frustrum[2] >>> frustrum[5] += frustrum[4] >>> M = clip_matrix(*frustrum, perspective=False) >>> numpy.dot(M, [frustrum[0], frustrum[2], frustrum[4], 1.0]) array([-1., -1., -1., 1.]) >>> numpy.dot(M, [frustrum[1], frustrum[3], frustrum[5], 1.0]) array([ 1., 1., 1., 1.]) >>> M = clip_matrix(*frustrum, perspective=True) >>> v = numpy.dot(M, [frustrum[0], frustrum[2], frustrum[4], 1.0]) >>> v / v[3] array([-1., -1., -1., 1.]) >>> v = numpy.dot(M, [frustrum[1], frustrum[3], frustrum[4], 1.0]) >>> v / v[3] array([ 1., 1., -1., 1.])``` ### function shear_matrix ```python def shear_matrix( angle angle, direction direction, point point, normal normal ) Return matrix to shear by angle along direction vector on shear plane. The shear plane is defined by a point and normal vector. The direction vector must be orthogonal to the plane's normal vector. A point P is transformed by the shear matrix into P\" such that the vector P-P\" is parallel to the direction vector and its extent is given by the angle of P-P'-P\", where P' is the orthogonal projection of P onto the shear plane. >>> angle = (random.random() - 0.5) * 4*math.pi >>> direct = numpy.random.random(3) - 0.5 >>> point = numpy.random.random(3) - 0.5 >>> normal = numpy.cross(direct, numpy.random.random(3)) >>> S = shear_matrix(angle, direct, point, normal) >>> numpy.allclose(1.0, numpy.linalg.det(S)) True``` ### function shear_from_matrix ```python def shear_from_matrix( matrix matrix ) Return shear angle, direction and plane from shear matrix. >>> angle = (random.random() - 0.5) * 4*math.pi >>> direct = numpy.random.random(3) - 0.5 >>> point = numpy.random.random(3) - 0.5 >>> normal = numpy.cross(direct, numpy.random.random(3)) >>> S0 = shear_matrix(angle, direct, point, normal) >>> angle, direct, point, normal = shear_from_matrix(S0) >>> S1 = shear_matrix(angle, direct, point, normal) >>> is_same_transform(S0, S1) True``` ### function decompose_matrix ```python def decompose_matrix( matrix matrix ) Return sequence of transformations from transformation matrix. matrix : array_like Non-degenerative homogeneous transformation matrix Return tuple of: scale : vector of 3 scaling factors shear : list of shear factors for x-y, x-z, y-z axes angles : list of Euler angles about static x, y, z axes translate : translation vector along x, y, z axes perspective : perspective partition of matrix Raise ValueError if matrix is of wrong type or degenerative. >>> T0 = translation_matrix((1, 2, 3)) >>> scale, shear, angles, trans, persp = decompose_matrix(T0) >>> T1 = translation_matrix(trans) >>> numpy.allclose(T0, T1) True >>> S = scale_matrix(0.123) >>> scale, shear, angles, trans, persp = decompose_matrix(S) >>> scale[0] 0.123 >>> R0 = euler_matrix(1, 2, 3) >>> scale, shear, angles, trans, persp = decompose_matrix(R0) >>> R1 = euler_matrix(*angles) >>> numpy.allclose(R0, R1) True``` ### function compose_matrix ```python def compose_matrix( scale scale =None, shear shear =None, angles angles =None, translate translate =None, perspective perspective =None ) Return transformation matrix from sequence of transformations. This is the inverse of the decompose_matrix function. Sequence of transformations: scale : vector of 3 scaling factors shear : list of shear factors for x-y, x-z, y-z axes angles : list of Euler angles about static x, y, z axes translate : translation vector along x, y, z axes perspective : perspective partition of matrix >>> scale = numpy.random.random(3) - 0.5 >>> shear = numpy.random.random(3) - 0.5 >>> angles = (numpy.random.random(3) - 0.5) * (2*math.pi) >>> trans = numpy.random.random(3) - 0.5 >>> persp = numpy.random.random(4) - 0.5 >>> M0 = compose_matrix(scale, shear, angles, trans, persp) >>> result = decompose_matrix(M0) >>> M1 = compose_matrix(*result) >>> is_same_transform(M0, M1) True``` ### function orthogonalization_matrix ```python def orthogonalization_matrix( lengths lengths, angles angles ) Return orthogonalization matrix for crystallographic cell coordinates. Angles are expected in degrees. The de-orthogonalization matrix is the inverse. >>> O = orthogonalization_matrix((10., 10., 10.), (90., 90., 90.)) >>> numpy.allclose(O[:3, :3], numpy.identity(3, float) * 10) True >>> O = orthogonalization_matrix([9.8, 12.0, 15.5], [87.2, 80.7, 69.7]) >>> numpy.allclose(numpy.sum(O), 43.063229) True``` ### function superimposition_matrix ```python def superimposition_matrix( v0 v0, v1 v1, scaling scaling =False, usesvd usesvd =True ) Return matrix to transform given vector set into second vector set. v0 and v1 are shape (3, \\*) or (4, \\*) arrays of at least 3 vectors. If usesvd is True, the weighted sum of squared deviations (RMSD) is minimized according to the algorithm by W. Kabsch [8]. Otherwise the quaternion based algorithm by B. Horn [9] is used (slower when using this Python implementation). The returned matrix performs rotation, translation and uniform scaling (if specified). >>> v0 = numpy.random.rand(3, 10) >>> M = superimposition_matrix(v0, v0) >>> numpy.allclose(M, numpy.identity(4)) True >>> R = random_rotation_matrix(numpy.random.random(3)) >>> v0 = ((1,0,0), (0,1,0), (0,0,1), (1,1,1)) >>> v1 = numpy.dot(R, v0) >>> M = superimposition_matrix(v0, v1) >>> numpy.allclose(v1, numpy.dot(M, v0)) True >>> v0 = (numpy.random.rand(4, 100) - 0.5) * 20.0 >>> v0[3] = 1.0 >>> v1 = numpy.dot(R, v0) >>> M = superimposition_matrix(v0, v1) >>> numpy.allclose(v1, numpy.dot(M, v0)) True >>> S = scale_matrix(random.random()) >>> T = translation_matrix(numpy.random.random(3)-0.5) >>> M = concatenate_matrices(T, R, S) >>> v1 = numpy.dot(M, v0) >>> v0[:3] += numpy.random.normal(0.0, 1e-9, 300).reshape(3, -1) >>> M = superimposition_matrix(v0, v1, scaling=True) >>> numpy.allclose(v1, numpy.dot(M, v0)) True >>> M = superimposition_matrix(v0, v1, scaling=True, usesvd=False) >>> numpy.allclose(v1, numpy.dot(M, v0)) True >>> v = numpy.empty((4, 100, 3), dtype=numpy.float64) >>> v[:, :, 0] = v0 >>> M = superimposition_matrix(v0, v1, scaling=True, usesvd=False) >>> numpy.allclose(v1, numpy.dot(M, v[:, :, 0])) True``` ### function euler_matrix ```python def euler_matrix( ai ai, aj aj, ak ak, axes axes ='sxyz' ) Return homogeneous rotation matrix from Euler angles and axis sequence. ai, aj, ak : Euler's roll, pitch and yaw angles axes : One of 24 axis sequences as string or encoded tuple >>> R = euler_matrix(1, 2, 3, 'syxz') >>> numpy.allclose(numpy.sum(R[0]), -1.34786452) True >>> R = euler_matrix(1, 2, 3, (0, 1, 0, 1)) >>> numpy.allclose(numpy.sum(R[0]), -0.383436184) True >>> ai, aj, ak = (4.0*math.pi) * (numpy.random.random(3) - 0.5) >>> for axes in _AXES2TUPLE.keys(): ... R = euler_matrix(ai, aj, ak, axes) >>> for axes in _TUPLE2AXES.keys(): ... R = euler_matrix(ai, aj, ak, axes)``` ### function euler_from_matrix ```python def euler_from_matrix( matrix matrix, axes axes ='sxyz' ) Return Euler angles from rotation matrix for specified axis sequence. axes : One of 24 axis sequences as string or encoded tuple Note that many Euler angle triplets can describe one matrix. >>> R0 = euler_matrix(1, 2, 3, 'syxz') >>> al, be, ga = euler_from_matrix(R0, 'syxz') >>> R1 = euler_matrix(al, be, ga, 'syxz') >>> numpy.allclose(R0, R1) True >>> angles = (4.0*math.pi) * (numpy.random.random(3) - 0.5) >>> for axes in _AXES2TUPLE.keys(): ... R0 = euler_matrix(axes=axes, *angles) ... R1 = euler_matrix(axes=axes, *euler_from_matrix(R0, axes)) ... if not numpy.allclose(R0, R1): print axes, \"failed\"``` ### function euler_from_quaternion ```python def euler_from_quaternion( quaternion quaternion, axes axes ='sxyz' ) Return Euler angles from quaternion for specified axis sequence. >>> angles = euler_from_quaternion([0.06146124, 0, 0, 0.99810947]) >>> numpy.allclose(angles, [0.123, 0, 0]) True``` ### function quaternion_from_euler ```python def quaternion_from_euler( ai ai, aj aj, ak ak, axes axes ='sxyz' ) Return quaternion from Euler angles and axis sequence. ai, aj, ak : Euler's roll, pitch and yaw angles axes : One of 24 axis sequences as string or encoded tuple >>> q = quaternion_from_euler(1, 2, 3, 'ryxz') >>> numpy.allclose(q, [0.310622, -0.718287, 0.444435, 0.435953]) True``` ### function quaternion_about_axis ```python def quaternion_about_axis( angle angle, axis axis ) Return quaternion for rotation about axis. >>> q = quaternion_about_axis(0.123, (1, 0, 0)) >>> numpy.allclose(q, [0.06146124, 0, 0, 0.99810947]) True``` ### function quaternion_matrix ```python def quaternion_matrix( quaternion quaternion ) Return homogeneous rotation matrix from quaternion. >>> R = quaternion_matrix([0.06146124, 0, 0, 0.99810947]) >>> numpy.allclose(R, rotation_matrix(0.123, (1, 0, 0))) True``` ### function quaternion_from_matrix ```python def quaternion_from_matrix( matrix matrix ) Return quaternion from rotation matrix. >>> R = rotation_matrix(0.123, (1, 2, 3)) >>> q = quaternion_from_matrix(R) >>> numpy.allclose(q, [0.0164262, 0.0328524, 0.0492786, 0.9981095]) True``` ### function quaternion_multiply ```python def quaternion_multiply( quaternion1 quaternion1, quaternion0 quaternion0 ) Return multiplication of two quaternions. >>> q = quaternion_multiply([1, -2, 3, 4], [-5, 6, 7, 8]) >>> numpy.allclose(q, [-44, -14, 48, 28]) True``` ### function quaternion_conjugate ```python def quaternion_conjugate( quaternion quaternion ) Return conjugate of quaternion. >>> q0 = random_quaternion() >>> q1 = quaternion_conjugate(q0) >>> q1[3] == q0[3] and all(q1[:3] == -q0[:3]) True``` ### function quaternion_inverse ```python def quaternion_inverse( quaternion quaternion ) Return inverse of quaternion. >>> q0 = random_quaternion() >>> q1 = quaternion_inverse(q0) >>> numpy.allclose(quaternion_multiply(q0, q1), [0, 0, 0, 1]) True``` ### function quaternion_slerp ```python def quaternion_slerp( quat0 quat0, quat1 quat1, fraction fraction, spin spin =0, shortestpath shortestpath =True ) Return spherical linear interpolation between two quaternions. >>> q0 = random_quaternion() >>> q1 = random_quaternion() >>> q = quaternion_slerp(q0, q1, 0.0) >>> numpy.allclose(q, q0) True >>> q = quaternion_slerp(q0, q1, 1.0, 1) >>> numpy.allclose(q, q1) True >>> q = quaternion_slerp(q0, q1, 0.5) >>> angle = math.acos(numpy.dot(q0, q)) >>> numpy.allclose(2.0, math.acos(numpy.dot(q0, q1)) / angle) or \\ numpy.allclose(2.0, math.acos(-numpy.dot(q0, q1)) / angle) True``` ### function random_quaternion ```python def random_quaternion( rand rand =None ) Return uniform random unit quaternion. rand: array like or None Three independent random variables that are uniformly distributed between 0 and 1. >>> q = random_quaternion() >>> numpy.allclose(1.0, vector_norm(q)) True >>> q = random_quaternion(numpy.random.random(3)) >>> q.shape (4,)``` ### function random_rotation_matrix ```python def random_rotation_matrix( rand rand =None ) Return uniform random rotation matrix. rnd: array like Three independent random variables that are uniformly distributed between 0 and 1 for each returned quaternion. >>> R = random_rotation_matrix() >>> numpy.allclose(numpy.dot(R.T, R), numpy.identity(4)) True``` ### function arcball_map_to_sphere ```python def arcball_map_to_sphere( point point, center center, radius radius ) Return unit sphere coordinates from window coordinates.``` ### function arcball_constrain_to_axis ```python def arcball_constrain_to_axis( point point, axis axis ) Return sphere point perpendicular to axis.``` ### function arcball_nearest_axis ```python def arcball_nearest_axis( point point, axes axes ) Return axis, which arc is nearest to point.``` ### function vector_norm ```python def vector_norm( data data, axis axis =None, out out =None ) Return length, i.e. eucledian norm, of ndarray along axis. >>> v = numpy.random.random(3) >>> n = vector_norm(v) >>> numpy.allclose(n, numpy.linalg.norm(v)) True >>> v = numpy.random.rand(6, 5, 3) >>> n = vector_norm(v, axis=-1) >>> numpy.allclose(n, numpy.sqrt(numpy.sum(v*v, axis=2))) True >>> n = vector_norm(v, axis=1) >>> numpy.allclose(n, numpy.sqrt(numpy.sum(v*v, axis=1))) True >>> v = numpy.random.rand(5, 4, 3) >>> n = numpy.empty((5, 3), dtype=numpy.float64) >>> vector_norm(v, axis=1, out=n) >>> numpy.allclose(n, numpy.sqrt(numpy.sum(v*v, axis=1))) True >>> vector_norm([]) 0.0 >>> vector_norm([1.0]) 1.0``` ### function unit_vector ```python def unit_vector( data data, axis axis =None, out out =None ) Return ndarray normalized by length, i.e. eucledian norm, along axis. >>> v0 = numpy.random.random(3) >>> v1 = unit_vector(v0) >>> numpy.allclose(v1, v0 / numpy.linalg.norm(v0)) True >>> v0 = numpy.random.rand(5, 4, 3) >>> v1 = unit_vector(v0, axis=-1) >>> v2 = v0 / numpy.expand_dims(numpy.sqrt(numpy.sum(v0*v0, axis=2)), 2) >>> numpy.allclose(v1, v2) True >>> v1 = unit_vector(v0, axis=1) >>> v2 = v0 / numpy.expand_dims(numpy.sqrt(numpy.sum(v0*v0, axis=1)), 1) >>> numpy.allclose(v1, v2) True >>> v1 = numpy.empty((5, 4, 3), dtype=numpy.float64) >>> unit_vector(v0, axis=1, out=v1) >>> numpy.allclose(v1, v2) True >>> list(unit_vector([])) [] >>> list(unit_vector([1.0])) [1.0]``` ### function random_vector ```python def random_vector( size size ) Return array of random doubles in the half-open interval [0.0, 1.0). >>> v = random_vector(10000) >>> numpy.all(v >= 0.0) and numpy.all(v < 1.0) True >>> v0 = random_vector(10) >>> v1 = random_vector(10) >>> numpy.any(v0 == v1) False``` ### function inverse_matrix ```python def inverse_matrix( matrix matrix ) Return inverse of square transformation matrix. >>> M0 = random_rotation_matrix() >>> M1 = inverse_matrix(M0.T) >>> numpy.allclose(M1, numpy.linalg.inv(M0.T)) True >>> for size in range(1, 7): ... M0 = numpy.random.rand(size, size) ... M1 = inverse_matrix(M0) ... if not numpy.allclose(M1, numpy.linalg.inv(M0)): print size``` ### function concatenate_matrices ```python def concatenate_matrices( * matrices ) Return concatenation of series of transformation matrices. >>> M = numpy.random.rand(16).reshape((4, 4)) - 0.5 >>> numpy.allclose(M, concatenate_matrices(M)) True >>> numpy.allclose(numpy.dot(M, M.T), concatenate_matrices(M, M.T)) True``` ### function is_same_transform ```python def is_same_transform( matrix0 matrix0, matrix1 matrix1 ) ``` Return True if two matrices perform same transformation. is_same_transform(numpy.identity(4), numpy.identity(4)) True is_same_transform(numpy.identity(4), random_rotation_matrix()) False``` Updated on 2022-05-30 at 18:35:11 +0000","title":"tf_quaternion::transformations"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacetf__quaternion_1_1transformations/#tf_quaterniontransformations","text":"","title":"tf_quaternion::transformations"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacetf__quaternion_1_1transformations/#classes","text":"Name class tf_quaternion::transformations::Arcball","title":"Classes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacetf__quaternion_1_1transformations/#functions","text":"Name def identity_matrix () def translation_matrix (direction direction) def translation_from_matrix (matrix matrix) def reflection_matrix (point point, normal normal) def reflection_from_matrix (matrix matrix) def rotation_matrix (angle angle, direction direction, point point =None) def rotation_from_matrix (matrix matrix) def scale_matrix (factor factor, origin origin =None, direction direction =None) def scale_from_matrix (matrix matrix) def projection_matrix (point point, normal normal, direction direction =None, perspective perspective =None, pseudo pseudo =False) def projection_from_matrix (matrix matrix, pseudo pseudo =False) def clip_matrix (left left, right right, bottom bottom, top top, near near, far far, perspective perspective =False) def shear_matrix (angle angle, direction direction, point point, normal normal) def shear_from_matrix (matrix matrix) def decompose_matrix (matrix matrix) def compose_matrix (scale scale =None, shear shear =None, angles angles =None, translate translate =None, perspective perspective =None) def orthogonalization_matrix (lengths lengths, angles angles) def superimposition_matrix (v0 v0, v1 v1, scaling scaling =False, usesvd usesvd =True) def euler_matrix (ai ai, aj aj, ak ak, axes axes ='sxyz') def euler_from_matrix (matrix matrix, axes axes ='sxyz') def euler_from_quaternion (quaternion quaternion, axes axes ='sxyz') def quaternion_from_euler (ai ai, aj aj, ak ak, axes axes ='sxyz') def quaternion_about_axis (angle angle, axis axis) def quaternion_matrix (quaternion quaternion) def quaternion_from_matrix (matrix matrix) def quaternion_multiply (quaternion1 quaternion1, quaternion0 quaternion0) def quaternion_conjugate (quaternion quaternion) def quaternion_inverse (quaternion quaternion) def quaternion_slerp (quat0 quat0, quat1 quat1, fraction fraction, spin spin =0, shortestpath shortestpath =True) def random_quaternion (rand rand =None) def random_rotation_matrix (rand rand =None) def arcball_map_to_sphere (point point, center center, radius radius) def arcball_constrain_to_axis (point point, axis axis) def arcball_nearest_axis (point point, axes axes) def vector_norm (data data, axis axis =None, out out =None) def unit_vector (data data, axis axis =None, out out =None) def random_vector (size size) def inverse_matrix (matrix matrix) def concatenate_matrices (* matrices) def is_same_transform (matrix0 matrix0, matrix1 matrix1)","title":"Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacetf__quaternion_1_1transformations/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespacetf__quaternion_1_1transformations/#function-identity_matrix","text":"def identity_matrix() Return 4x4 identity/unit matrix. >>> I = identity_matrix() >>> numpy.allclose(I, numpy.dot(I, I)) True >>> numpy.sum(I), numpy.trace(I) (4.0, 4.0) >>> numpy.allclose(I, numpy.identity(4, dtype=numpy.float64)) True``` ### function translation_matrix ```python def translation_matrix( direction direction ) Return matrix to translate by direction vector. >>> v = numpy.random.random(3) - 0.5 >>> numpy.allclose(v, translation_matrix(v)[:3, 3]) True``` ### function translation_from_matrix ```python def translation_from_matrix( matrix matrix ) Return translation vector from translation matrix. >>> v0 = numpy.random.random(3) - 0.5 >>> v1 = translation_from_matrix(translation_matrix(v0)) >>> numpy.allclose(v0, v1) True``` ### function reflection_matrix ```python def reflection_matrix( point point, normal normal ) Return matrix to mirror at plane defined by point and normal vector. >>> v0 = numpy.random.random(4) - 0.5 >>> v0[3] = 1.0 >>> v1 = numpy.random.random(3) - 0.5 >>> R = reflection_matrix(v0, v1) >>> numpy.allclose(2., numpy.trace(R)) True >>> numpy.allclose(v0, numpy.dot(R, v0)) True >>> v2 = v0.copy() >>> v2[:3] += v1 >>> v3 = v0.copy() >>> v2[:3] -= v1 >>> numpy.allclose(v2, numpy.dot(R, v3)) True``` ### function reflection_from_matrix ```python def reflection_from_matrix( matrix matrix ) Return mirror plane point and normal vector from reflection matrix. >>> v0 = numpy.random.random(3) - 0.5 >>> v1 = numpy.random.random(3) - 0.5 >>> M0 = reflection_matrix(v0, v1) >>> point, normal = reflection_from_matrix(M0) >>> M1 = reflection_matrix(point, normal) >>> is_same_transform(M0, M1) True``` ### function rotation_matrix ```python def rotation_matrix( angle angle, direction direction, point point =None ) Return matrix to rotate about axis defined by point and direction. >>> angle = (random.random() - 0.5) * (2*math.pi) >>> direc = numpy.random.random(3) - 0.5 >>> point = numpy.random.random(3) - 0.5 >>> R0 = rotation_matrix(angle, direc, point) >>> R1 = rotation_matrix(angle-2*math.pi, direc, point) >>> is_same_transform(R0, R1) True >>> R0 = rotation_matrix(angle, direc, point) >>> R1 = rotation_matrix(-angle, -direc, point) >>> is_same_transform(R0, R1) True >>> I = numpy.identity(4, numpy.float64) >>> numpy.allclose(I, rotation_matrix(math.pi*2, direc)) True >>> numpy.allclose(2., numpy.trace(rotation_matrix(math.pi/2, ... direc, point))) True``` ### function rotation_from_matrix ```python def rotation_from_matrix( matrix matrix ) Return rotation angle and axis from rotation matrix. >>> angle = (random.random() - 0.5) * (2*math.pi) >>> direc = numpy.random.random(3) - 0.5 >>> point = numpy.random.random(3) - 0.5 >>> R0 = rotation_matrix(angle, direc, point) >>> angle, direc, point = rotation_from_matrix(R0) >>> R1 = rotation_matrix(angle, direc, point) >>> is_same_transform(R0, R1) True``` ### function scale_matrix ```python def scale_matrix( factor factor, origin origin =None, direction direction =None ) Return matrix to scale by factor around origin in direction. Use factor -1 for point symmetry. >>> v = (numpy.random.rand(4, 5) - 0.5) * 20.0 >>> v[3] = 1.0 >>> S = scale_matrix(-1.234) >>> numpy.allclose(numpy.dot(S, v)[:3], -1.234*v[:3]) True >>> factor = random.random() * 10 - 5 >>> origin = numpy.random.random(3) - 0.5 >>> direct = numpy.random.random(3) - 0.5 >>> S = scale_matrix(factor, origin) >>> S = scale_matrix(factor, origin, direct)``` ### function scale_from_matrix ```python def scale_from_matrix( matrix matrix ) Return scaling factor, origin and direction from scaling matrix. >>> factor = random.random() * 10 - 5 >>> origin = numpy.random.random(3) - 0.5 >>> direct = numpy.random.random(3) - 0.5 >>> S0 = scale_matrix(factor, origin) >>> factor, origin, direction = scale_from_matrix(S0) >>> S1 = scale_matrix(factor, origin, direction) >>> is_same_transform(S0, S1) True >>> S0 = scale_matrix(factor, origin, direct) >>> factor, origin, direction = scale_from_matrix(S0) >>> S1 = scale_matrix(factor, origin, direction) >>> is_same_transform(S0, S1) True``` ### function projection_matrix ```python def projection_matrix( point point, normal normal, direction direction =None, perspective perspective =None, pseudo pseudo =False ) Return matrix to project onto plane defined by point and normal. Using either perspective point, projection direction, or none of both. If pseudo is True, perspective projections will preserve relative depth such that Perspective = dot(Orthogonal, PseudoPerspective). >>> P = projection_matrix((0, 0, 0), (1, 0, 0)) >>> numpy.allclose(P[1:, 1:], numpy.identity(4)[1:, 1:]) True >>> point = numpy.random.random(3) - 0.5 >>> normal = numpy.random.random(3) - 0.5 >>> direct = numpy.random.random(3) - 0.5 >>> persp = numpy.random.random(3) - 0.5 >>> P0 = projection_matrix(point, normal) >>> P1 = projection_matrix(point, normal, direction=direct) >>> P2 = projection_matrix(point, normal, perspective=persp) >>> P3 = projection_matrix(point, normal, perspective=persp, pseudo=True) >>> is_same_transform(P2, numpy.dot(P0, P3)) True >>> P = projection_matrix((3, 0, 0), (1, 1, 0), (1, 0, 0)) >>> v0 = (numpy.random.rand(4, 5) - 0.5) * 20.0 >>> v0[3] = 1.0 >>> v1 = numpy.dot(P, v0) >>> numpy.allclose(v1[1], v0[1]) True >>> numpy.allclose(v1[0], 3.0-v1[1]) True``` ### function projection_from_matrix ```python def projection_from_matrix( matrix matrix, pseudo pseudo =False ) Return projection plane and perspective point from projection matrix. Return values are same as arguments for projection_matrix function: point, normal, direction, perspective, and pseudo. >>> point = numpy.random.random(3) - 0.5 >>> normal = numpy.random.random(3) - 0.5 >>> direct = numpy.random.random(3) - 0.5 >>> persp = numpy.random.random(3) - 0.5 >>> P0 = projection_matrix(point, normal) >>> result = projection_from_matrix(P0) >>> P1 = projection_matrix(*result) >>> is_same_transform(P0, P1) True >>> P0 = projection_matrix(point, normal, direct) >>> result = projection_from_matrix(P0) >>> P1 = projection_matrix(*result) >>> is_same_transform(P0, P1) True >>> P0 = projection_matrix(point, normal, perspective=persp, pseudo=False) >>> result = projection_from_matrix(P0, pseudo=False) >>> P1 = projection_matrix(*result) >>> is_same_transform(P0, P1) True >>> P0 = projection_matrix(point, normal, perspective=persp, pseudo=True) >>> result = projection_from_matrix(P0, pseudo=True) >>> P1 = projection_matrix(*result) >>> is_same_transform(P0, P1) True``` ### function clip_matrix ```python def clip_matrix( left left, right right, bottom bottom, top top, near near, far far, perspective perspective =False ) Return matrix to obtain normalized device coordinates from frustrum. The frustrum bounds are axis-aligned along x (left, right), y (bottom, top) and z (near, far). Normalized device coordinates are in range [-1, 1] if coordinates are inside the frustrum. If perspective is True the frustrum is a truncated pyramid with the perspective point at origin and direction along z axis, otherwise an orthographic canonical view volume (a box). Homogeneous coordinates transformed by the perspective clip matrix need to be dehomogenized (devided by w coordinate). >>> frustrum = numpy.random.rand(6) >>> frustrum[1] += frustrum[0] >>> frustrum[3] += frustrum[2] >>> frustrum[5] += frustrum[4] >>> M = clip_matrix(*frustrum, perspective=False) >>> numpy.dot(M, [frustrum[0], frustrum[2], frustrum[4], 1.0]) array([-1., -1., -1., 1.]) >>> numpy.dot(M, [frustrum[1], frustrum[3], frustrum[5], 1.0]) array([ 1., 1., 1., 1.]) >>> M = clip_matrix(*frustrum, perspective=True) >>> v = numpy.dot(M, [frustrum[0], frustrum[2], frustrum[4], 1.0]) >>> v / v[3] array([-1., -1., -1., 1.]) >>> v = numpy.dot(M, [frustrum[1], frustrum[3], frustrum[4], 1.0]) >>> v / v[3] array([ 1., 1., -1., 1.])``` ### function shear_matrix ```python def shear_matrix( angle angle, direction direction, point point, normal normal ) Return matrix to shear by angle along direction vector on shear plane. The shear plane is defined by a point and normal vector. The direction vector must be orthogonal to the plane's normal vector. A point P is transformed by the shear matrix into P\" such that the vector P-P\" is parallel to the direction vector and its extent is given by the angle of P-P'-P\", where P' is the orthogonal projection of P onto the shear plane. >>> angle = (random.random() - 0.5) * 4*math.pi >>> direct = numpy.random.random(3) - 0.5 >>> point = numpy.random.random(3) - 0.5 >>> normal = numpy.cross(direct, numpy.random.random(3)) >>> S = shear_matrix(angle, direct, point, normal) >>> numpy.allclose(1.0, numpy.linalg.det(S)) True``` ### function shear_from_matrix ```python def shear_from_matrix( matrix matrix ) Return shear angle, direction and plane from shear matrix. >>> angle = (random.random() - 0.5) * 4*math.pi >>> direct = numpy.random.random(3) - 0.5 >>> point = numpy.random.random(3) - 0.5 >>> normal = numpy.cross(direct, numpy.random.random(3)) >>> S0 = shear_matrix(angle, direct, point, normal) >>> angle, direct, point, normal = shear_from_matrix(S0) >>> S1 = shear_matrix(angle, direct, point, normal) >>> is_same_transform(S0, S1) True``` ### function decompose_matrix ```python def decompose_matrix( matrix matrix ) Return sequence of transformations from transformation matrix. matrix : array_like Non-degenerative homogeneous transformation matrix Return tuple of: scale : vector of 3 scaling factors shear : list of shear factors for x-y, x-z, y-z axes angles : list of Euler angles about static x, y, z axes translate : translation vector along x, y, z axes perspective : perspective partition of matrix Raise ValueError if matrix is of wrong type or degenerative. >>> T0 = translation_matrix((1, 2, 3)) >>> scale, shear, angles, trans, persp = decompose_matrix(T0) >>> T1 = translation_matrix(trans) >>> numpy.allclose(T0, T1) True >>> S = scale_matrix(0.123) >>> scale, shear, angles, trans, persp = decompose_matrix(S) >>> scale[0] 0.123 >>> R0 = euler_matrix(1, 2, 3) >>> scale, shear, angles, trans, persp = decompose_matrix(R0) >>> R1 = euler_matrix(*angles) >>> numpy.allclose(R0, R1) True``` ### function compose_matrix ```python def compose_matrix( scale scale =None, shear shear =None, angles angles =None, translate translate =None, perspective perspective =None ) Return transformation matrix from sequence of transformations. This is the inverse of the decompose_matrix function. Sequence of transformations: scale : vector of 3 scaling factors shear : list of shear factors for x-y, x-z, y-z axes angles : list of Euler angles about static x, y, z axes translate : translation vector along x, y, z axes perspective : perspective partition of matrix >>> scale = numpy.random.random(3) - 0.5 >>> shear = numpy.random.random(3) - 0.5 >>> angles = (numpy.random.random(3) - 0.5) * (2*math.pi) >>> trans = numpy.random.random(3) - 0.5 >>> persp = numpy.random.random(4) - 0.5 >>> M0 = compose_matrix(scale, shear, angles, trans, persp) >>> result = decompose_matrix(M0) >>> M1 = compose_matrix(*result) >>> is_same_transform(M0, M1) True``` ### function orthogonalization_matrix ```python def orthogonalization_matrix( lengths lengths, angles angles ) Return orthogonalization matrix for crystallographic cell coordinates. Angles are expected in degrees. The de-orthogonalization matrix is the inverse. >>> O = orthogonalization_matrix((10., 10., 10.), (90., 90., 90.)) >>> numpy.allclose(O[:3, :3], numpy.identity(3, float) * 10) True >>> O = orthogonalization_matrix([9.8, 12.0, 15.5], [87.2, 80.7, 69.7]) >>> numpy.allclose(numpy.sum(O), 43.063229) True``` ### function superimposition_matrix ```python def superimposition_matrix( v0 v0, v1 v1, scaling scaling =False, usesvd usesvd =True ) Return matrix to transform given vector set into second vector set. v0 and v1 are shape (3, \\*) or (4, \\*) arrays of at least 3 vectors. If usesvd is True, the weighted sum of squared deviations (RMSD) is minimized according to the algorithm by W. Kabsch [8]. Otherwise the quaternion based algorithm by B. Horn [9] is used (slower when using this Python implementation). The returned matrix performs rotation, translation and uniform scaling (if specified). >>> v0 = numpy.random.rand(3, 10) >>> M = superimposition_matrix(v0, v0) >>> numpy.allclose(M, numpy.identity(4)) True >>> R = random_rotation_matrix(numpy.random.random(3)) >>> v0 = ((1,0,0), (0,1,0), (0,0,1), (1,1,1)) >>> v1 = numpy.dot(R, v0) >>> M = superimposition_matrix(v0, v1) >>> numpy.allclose(v1, numpy.dot(M, v0)) True >>> v0 = (numpy.random.rand(4, 100) - 0.5) * 20.0 >>> v0[3] = 1.0 >>> v1 = numpy.dot(R, v0) >>> M = superimposition_matrix(v0, v1) >>> numpy.allclose(v1, numpy.dot(M, v0)) True >>> S = scale_matrix(random.random()) >>> T = translation_matrix(numpy.random.random(3)-0.5) >>> M = concatenate_matrices(T, R, S) >>> v1 = numpy.dot(M, v0) >>> v0[:3] += numpy.random.normal(0.0, 1e-9, 300).reshape(3, -1) >>> M = superimposition_matrix(v0, v1, scaling=True) >>> numpy.allclose(v1, numpy.dot(M, v0)) True >>> M = superimposition_matrix(v0, v1, scaling=True, usesvd=False) >>> numpy.allclose(v1, numpy.dot(M, v0)) True >>> v = numpy.empty((4, 100, 3), dtype=numpy.float64) >>> v[:, :, 0] = v0 >>> M = superimposition_matrix(v0, v1, scaling=True, usesvd=False) >>> numpy.allclose(v1, numpy.dot(M, v[:, :, 0])) True``` ### function euler_matrix ```python def euler_matrix( ai ai, aj aj, ak ak, axes axes ='sxyz' ) Return homogeneous rotation matrix from Euler angles and axis sequence. ai, aj, ak : Euler's roll, pitch and yaw angles axes : One of 24 axis sequences as string or encoded tuple >>> R = euler_matrix(1, 2, 3, 'syxz') >>> numpy.allclose(numpy.sum(R[0]), -1.34786452) True >>> R = euler_matrix(1, 2, 3, (0, 1, 0, 1)) >>> numpy.allclose(numpy.sum(R[0]), -0.383436184) True >>> ai, aj, ak = (4.0*math.pi) * (numpy.random.random(3) - 0.5) >>> for axes in _AXES2TUPLE.keys(): ... R = euler_matrix(ai, aj, ak, axes) >>> for axes in _TUPLE2AXES.keys(): ... R = euler_matrix(ai, aj, ak, axes)``` ### function euler_from_matrix ```python def euler_from_matrix( matrix matrix, axes axes ='sxyz' ) Return Euler angles from rotation matrix for specified axis sequence. axes : One of 24 axis sequences as string or encoded tuple Note that many Euler angle triplets can describe one matrix. >>> R0 = euler_matrix(1, 2, 3, 'syxz') >>> al, be, ga = euler_from_matrix(R0, 'syxz') >>> R1 = euler_matrix(al, be, ga, 'syxz') >>> numpy.allclose(R0, R1) True >>> angles = (4.0*math.pi) * (numpy.random.random(3) - 0.5) >>> for axes in _AXES2TUPLE.keys(): ... R0 = euler_matrix(axes=axes, *angles) ... R1 = euler_matrix(axes=axes, *euler_from_matrix(R0, axes)) ... if not numpy.allclose(R0, R1): print axes, \"failed\"``` ### function euler_from_quaternion ```python def euler_from_quaternion( quaternion quaternion, axes axes ='sxyz' ) Return Euler angles from quaternion for specified axis sequence. >>> angles = euler_from_quaternion([0.06146124, 0, 0, 0.99810947]) >>> numpy.allclose(angles, [0.123, 0, 0]) True``` ### function quaternion_from_euler ```python def quaternion_from_euler( ai ai, aj aj, ak ak, axes axes ='sxyz' ) Return quaternion from Euler angles and axis sequence. ai, aj, ak : Euler's roll, pitch and yaw angles axes : One of 24 axis sequences as string or encoded tuple >>> q = quaternion_from_euler(1, 2, 3, 'ryxz') >>> numpy.allclose(q, [0.310622, -0.718287, 0.444435, 0.435953]) True``` ### function quaternion_about_axis ```python def quaternion_about_axis( angle angle, axis axis ) Return quaternion for rotation about axis. >>> q = quaternion_about_axis(0.123, (1, 0, 0)) >>> numpy.allclose(q, [0.06146124, 0, 0, 0.99810947]) True``` ### function quaternion_matrix ```python def quaternion_matrix( quaternion quaternion ) Return homogeneous rotation matrix from quaternion. >>> R = quaternion_matrix([0.06146124, 0, 0, 0.99810947]) >>> numpy.allclose(R, rotation_matrix(0.123, (1, 0, 0))) True``` ### function quaternion_from_matrix ```python def quaternion_from_matrix( matrix matrix ) Return quaternion from rotation matrix. >>> R = rotation_matrix(0.123, (1, 2, 3)) >>> q = quaternion_from_matrix(R) >>> numpy.allclose(q, [0.0164262, 0.0328524, 0.0492786, 0.9981095]) True``` ### function quaternion_multiply ```python def quaternion_multiply( quaternion1 quaternion1, quaternion0 quaternion0 ) Return multiplication of two quaternions. >>> q = quaternion_multiply([1, -2, 3, 4], [-5, 6, 7, 8]) >>> numpy.allclose(q, [-44, -14, 48, 28]) True``` ### function quaternion_conjugate ```python def quaternion_conjugate( quaternion quaternion ) Return conjugate of quaternion. >>> q0 = random_quaternion() >>> q1 = quaternion_conjugate(q0) >>> q1[3] == q0[3] and all(q1[:3] == -q0[:3]) True``` ### function quaternion_inverse ```python def quaternion_inverse( quaternion quaternion ) Return inverse of quaternion. >>> q0 = random_quaternion() >>> q1 = quaternion_inverse(q0) >>> numpy.allclose(quaternion_multiply(q0, q1), [0, 0, 0, 1]) True``` ### function quaternion_slerp ```python def quaternion_slerp( quat0 quat0, quat1 quat1, fraction fraction, spin spin =0, shortestpath shortestpath =True ) Return spherical linear interpolation between two quaternions. >>> q0 = random_quaternion() >>> q1 = random_quaternion() >>> q = quaternion_slerp(q0, q1, 0.0) >>> numpy.allclose(q, q0) True >>> q = quaternion_slerp(q0, q1, 1.0, 1) >>> numpy.allclose(q, q1) True >>> q = quaternion_slerp(q0, q1, 0.5) >>> angle = math.acos(numpy.dot(q0, q)) >>> numpy.allclose(2.0, math.acos(numpy.dot(q0, q1)) / angle) or \\ numpy.allclose(2.0, math.acos(-numpy.dot(q0, q1)) / angle) True``` ### function random_quaternion ```python def random_quaternion( rand rand =None ) Return uniform random unit quaternion. rand: array like or None Three independent random variables that are uniformly distributed between 0 and 1. >>> q = random_quaternion() >>> numpy.allclose(1.0, vector_norm(q)) True >>> q = random_quaternion(numpy.random.random(3)) >>> q.shape (4,)``` ### function random_rotation_matrix ```python def random_rotation_matrix( rand rand =None ) Return uniform random rotation matrix. rnd: array like Three independent random variables that are uniformly distributed between 0 and 1 for each returned quaternion. >>> R = random_rotation_matrix() >>> numpy.allclose(numpy.dot(R.T, R), numpy.identity(4)) True``` ### function arcball_map_to_sphere ```python def arcball_map_to_sphere( point point, center center, radius radius ) Return unit sphere coordinates from window coordinates.``` ### function arcball_constrain_to_axis ```python def arcball_constrain_to_axis( point point, axis axis ) Return sphere point perpendicular to axis.``` ### function arcball_nearest_axis ```python def arcball_nearest_axis( point point, axes axes ) Return axis, which arc is nearest to point.``` ### function vector_norm ```python def vector_norm( data data, axis axis =None, out out =None ) Return length, i.e. eucledian norm, of ndarray along axis. >>> v = numpy.random.random(3) >>> n = vector_norm(v) >>> numpy.allclose(n, numpy.linalg.norm(v)) True >>> v = numpy.random.rand(6, 5, 3) >>> n = vector_norm(v, axis=-1) >>> numpy.allclose(n, numpy.sqrt(numpy.sum(v*v, axis=2))) True >>> n = vector_norm(v, axis=1) >>> numpy.allclose(n, numpy.sqrt(numpy.sum(v*v, axis=1))) True >>> v = numpy.random.rand(5, 4, 3) >>> n = numpy.empty((5, 3), dtype=numpy.float64) >>> vector_norm(v, axis=1, out=n) >>> numpy.allclose(n, numpy.sqrt(numpy.sum(v*v, axis=1))) True >>> vector_norm([]) 0.0 >>> vector_norm([1.0]) 1.0``` ### function unit_vector ```python def unit_vector( data data, axis axis =None, out out =None ) Return ndarray normalized by length, i.e. eucledian norm, along axis. >>> v0 = numpy.random.random(3) >>> v1 = unit_vector(v0) >>> numpy.allclose(v1, v0 / numpy.linalg.norm(v0)) True >>> v0 = numpy.random.rand(5, 4, 3) >>> v1 = unit_vector(v0, axis=-1) >>> v2 = v0 / numpy.expand_dims(numpy.sqrt(numpy.sum(v0*v0, axis=2)), 2) >>> numpy.allclose(v1, v2) True >>> v1 = unit_vector(v0, axis=1) >>> v2 = v0 / numpy.expand_dims(numpy.sqrt(numpy.sum(v0*v0, axis=1)), 1) >>> numpy.allclose(v1, v2) True >>> v1 = numpy.empty((5, 4, 3), dtype=numpy.float64) >>> unit_vector(v0, axis=1, out=v1) >>> numpy.allclose(v1, v2) True >>> list(unit_vector([])) [] >>> list(unit_vector([1.0])) [1.0]``` ### function random_vector ```python def random_vector( size size ) Return array of random doubles in the half-open interval [0.0, 1.0). >>> v = random_vector(10000) >>> numpy.all(v >= 0.0) and numpy.all(v < 1.0) True >>> v0 = random_vector(10) >>> v1 = random_vector(10) >>> numpy.any(v0 == v1) False``` ### function inverse_matrix ```python def inverse_matrix( matrix matrix ) Return inverse of square transformation matrix. >>> M0 = random_rotation_matrix() >>> M1 = inverse_matrix(M0.T) >>> numpy.allclose(M1, numpy.linalg.inv(M0.T)) True >>> for size in range(1, 7): ... M0 = numpy.random.rand(size, size) ... M1 = inverse_matrix(M0) ... if not numpy.allclose(M1, numpy.linalg.inv(M0)): print size``` ### function concatenate_matrices ```python def concatenate_matrices( * matrices ) Return concatenation of series of transformation matrices. >>> M = numpy.random.rand(16).reshape((4, 4)) - 0.5 >>> numpy.allclose(M, concatenate_matrices(M)) True >>> numpy.allclose(numpy.dot(M, M.T), concatenate_matrices(M, M.T)) True``` ### function is_same_transform ```python def is_same_transform( matrix0 matrix0, matrix1 matrix1 ) ``` Return True if two matrices perform same transformation. is_same_transform(numpy.identity(4), numpy.identity(4)) True is_same_transform(numpy.identity(4), random_rotation_matrix()) False``` Updated on 2022-05-30 at 18:35:11 +0000","title":"function identity_matrix"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespaceunpause__simulation/","text":"unpause_simulation Attributes Name float timeout start_time unpause Attributes Documentation variable timeout float timeout = 0.0; variable start_time start_time = time.time(); variable unpause unpause = rospy.ServiceProxy('/gazebo/unpause_physics', Empty); Updated on 2022-05-30 at 18:35:11 +0000","title":"unpause_simulation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespaceunpause__simulation/#unpause_simulation","text":"","title":"unpause_simulation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespaceunpause__simulation/#attributes","text":"Name float timeout start_time unpause","title":"Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespaceunpause__simulation/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespaceunpause__simulation/#variable-timeout","text":"float timeout = 0.0;","title":"variable timeout"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespaceunpause__simulation/#variable-start_time","text":"start_time = time.time();","title":"variable start_time"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_assistants/Namespaces/namespaceunpause__simulation/#variable-unpause","text":"unpause = rospy.ServiceProxy('/gazebo/unpause_physics', Empty); Updated on 2022-05-30 at 18:35:11 +0000","title":"variable unpause"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_descriptions/Classes/","text":"Classes namespace test_urdf_files class TestRexROVURDFFiles Updated on 2022-05-30 at 18:35:11 +0000","title":"Classes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_descriptions/Classes/#classes","text":"namespace test_urdf_files class TestRexROVURDFFiles Updated on 2022-05-30 at 18:35:11 +0000","title":"Classes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_descriptions/Classes/classtest__urdf__files_1_1TestRexROVURDFFiles/","text":"test_urdf_files::TestRexROVURDFFiles Inherits from TestCase Public Functions Name def test_xacro (self self) Public Functions Documentation function test_xacro def test_xacro( self self ) Updated on 2022-05-30 at 18:35:11 +0000","title":"test_urdf_files::TestRexROVURDFFiles"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_descriptions/Classes/classtest__urdf__files_1_1TestRexROVURDFFiles/#test_urdf_filestestrexrovurdffiles","text":"Inherits from TestCase","title":"test_urdf_files::TestRexROVURDFFiles"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_descriptions/Classes/classtest__urdf__files_1_1TestRexROVURDFFiles/#public-functions","text":"Name def test_xacro (self self)","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_descriptions/Classes/classtest__urdf__files_1_1TestRexROVURDFFiles/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_descriptions/Classes/classtest__urdf__files_1_1TestRexROVURDFFiles/#function-test_xacro","text":"def test_xacro( self self ) Updated on 2022-05-30 at 18:35:11 +0000","title":"function test_xacro"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_descriptions/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:11 +0000","title":"Examples"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_descriptions/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:11 +0000","title":"Examples"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_descriptions/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:11 +0000","title":"Modules"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_descriptions/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:11 +0000","title":"Modules"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_descriptions/Namespaces/","text":"Namespaces namespace test_urdf_files Updated on 2022-05-30 at 18:35:11 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_descriptions/Namespaces/#namespaces","text":"namespace test_urdf_files Updated on 2022-05-30 at 18:35:11 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_descriptions/Namespaces/namespacetest__urdf__files/","text":"test_urdf_files Classes Name class test_urdf_files::TestRexROVURDFFiles Functions Name def call_xacro (xml_file xml_file) Attributes Name string PKG string NAME Functions Documentation function call_xacro def call_xacro( xml_file xml_file ) Attributes Documentation variable PKG string PKG = 'uuv_descriptions'; variable NAME string NAME = 'test_urdf_files'; Updated on 2022-05-30 at 18:35:11 +0000","title":"test_urdf_files"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_descriptions/Namespaces/namespacetest__urdf__files/#test_urdf_files","text":"","title":"test_urdf_files"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_descriptions/Namespaces/namespacetest__urdf__files/#classes","text":"Name class test_urdf_files::TestRexROVURDFFiles","title":"Classes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_descriptions/Namespaces/namespacetest__urdf__files/#functions","text":"Name def call_xacro (xml_file xml_file)","title":"Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_descriptions/Namespaces/namespacetest__urdf__files/#attributes","text":"Name string PKG string NAME","title":"Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_descriptions/Namespaces/namespacetest__urdf__files/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_descriptions/Namespaces/namespacetest__urdf__files/#function-call_xacro","text":"def call_xacro( xml_file xml_file )","title":"function call_xacro"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_descriptions/Namespaces/namespacetest__urdf__files/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_descriptions/Namespaces/namespacetest__urdf__files/#variable-pkg","text":"string PKG = 'uuv_descriptions';","title":"variable PKG"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_descriptions/Namespaces/namespacetest__urdf__files/#variable-name","text":"string NAME = 'test_urdf_files'; Updated on 2022-05-30 at 18:35:11 +0000","title":"variable NAME"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/","text":"Classes namespace Eigen namespace gazebo class BuoyantObject Class describing the dynamics of a buoyant object, useful for simple representations of underwater structures. class ConversionFunction Abstact base class for a thruster conversion function. class ConversionFunctionBasic The most basic conversion function: Thrust = const. w abs(w) This corresponds to what is attrributed to Yoerger et al. and called Model 1 in Bessa et al.: Dynamic Positioning of Underwater Robotic Vehicles with Thruster Dynamics Compensation. class ConversionFunctionBessa Asymmetric conversion function with dead-zone nonlinearity. This corresponds to what is called Model 2 in Bessa et al.: Dynamic Positioning of Underwater Robotic Vehicles with Thruster Dynamics Compensation. class ConversionFunctionFactory Factory singleton class that creates a ConversionFunction from sdf. class ConversionFunctionLinearInterp Conversion using linear interpolation between given data points. class Dynamics Abstract base class for thruster dynamics. class DynamicsFactory Factory singleton class that creates a ThrusterDynamics from sdf. class DynamicsFirstOrder First-order dynamic system. class DynamicsZeroOrder Trivial (no dynamics) zero-order dynamic system. class FinPlugin class HMBox Class containing the methods and attributes for a hydrodynamic model for a box in the fluid. class HMCylinder Class containing the methods and attributes for a hydrodynamic model for a cylinder in the fluid. class HMFossen Class containting the methods and attributes for a Fossen robot-like hydrodynamic model. The restoring forces are applied by the BuoyantObject class methods. Using the plugin for UUV models will use both this and the buoyant object class definitions, therefore the restoring forces were not inherited here. References: class HMSphere Class containing the methods and attributes for a hydrodynamic model for a sphere in the fluid. class HMSpheroid Class containing the methods and attributes for a hydrodynamic model for a spheroid in the fluid Reference: Antonelli - Underwater Robots. class HydrodynamicModel class HydrodynamicModelFactory Factory singleton class that creates a HydrodynamicModel from sdf. class LiftDrag Abstract base class for Lift&Drag models. class LiftDragFactory Factory singleton class that creates a LiftDrag from sdf. class LiftDragQuadratic Basic quadratic (Hugin) lift&drag model, page 18 from [1]. [1] Engelhardtsen, \u00d8ystein. \"3D AUV Collision Avoidance.\" (2007). class LiftDragTwoLines Lift&drag model that models lift/drag coeffs using two lines. This is based on Gazebo's LiftDragPlugin but implemented as a derived LiftDrag model to allow using it in combination with the dynamics of a Fin. class ThrusterDynamicsBessa Bessa's dynamic thruster model. class ThrusterDynamicsYoerger Yoerger's dynamic thruster model. class ThrusterPlugin Class for the thruster plugin. class UmbilicalModel class UmbilicalModelBerg class UmbilicalModelFactory Factory singleton class that creates an UmbilicalModel from sdf. class UmbilicalPlugin class UmbilicalSegment class UnderwaterObjectPlugin Gazebo model plugin class for underwater objects. Updated on 2022-05-30 at 18:35:12 +0000","title":"Classes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/#classes","text":"namespace Eigen namespace gazebo class BuoyantObject Class describing the dynamics of a buoyant object, useful for simple representations of underwater structures. class ConversionFunction Abstact base class for a thruster conversion function. class ConversionFunctionBasic The most basic conversion function: Thrust = const. w abs(w) This corresponds to what is attrributed to Yoerger et al. and called Model 1 in Bessa et al.: Dynamic Positioning of Underwater Robotic Vehicles with Thruster Dynamics Compensation. class ConversionFunctionBessa Asymmetric conversion function with dead-zone nonlinearity. This corresponds to what is called Model 2 in Bessa et al.: Dynamic Positioning of Underwater Robotic Vehicles with Thruster Dynamics Compensation. class ConversionFunctionFactory Factory singleton class that creates a ConversionFunction from sdf. class ConversionFunctionLinearInterp Conversion using linear interpolation between given data points. class Dynamics Abstract base class for thruster dynamics. class DynamicsFactory Factory singleton class that creates a ThrusterDynamics from sdf. class DynamicsFirstOrder First-order dynamic system. class DynamicsZeroOrder Trivial (no dynamics) zero-order dynamic system. class FinPlugin class HMBox Class containing the methods and attributes for a hydrodynamic model for a box in the fluid. class HMCylinder Class containing the methods and attributes for a hydrodynamic model for a cylinder in the fluid. class HMFossen Class containting the methods and attributes for a Fossen robot-like hydrodynamic model. The restoring forces are applied by the BuoyantObject class methods. Using the plugin for UUV models will use both this and the buoyant object class definitions, therefore the restoring forces were not inherited here. References: class HMSphere Class containing the methods and attributes for a hydrodynamic model for a sphere in the fluid. class HMSpheroid Class containing the methods and attributes for a hydrodynamic model for a spheroid in the fluid Reference: Antonelli - Underwater Robots. class HydrodynamicModel class HydrodynamicModelFactory Factory singleton class that creates a HydrodynamicModel from sdf. class LiftDrag Abstract base class for Lift&Drag models. class LiftDragFactory Factory singleton class that creates a LiftDrag from sdf. class LiftDragQuadratic Basic quadratic (Hugin) lift&drag model, page 18 from [1]. [1] Engelhardtsen, \u00d8ystein. \"3D AUV Collision Avoidance.\" (2007). class LiftDragTwoLines Lift&drag model that models lift/drag coeffs using two lines. This is based on Gazebo's LiftDragPlugin but implemented as a derived LiftDrag model to allow using it in combination with the dynamics of a Fin. class ThrusterDynamicsBessa Bessa's dynamic thruster model. class ThrusterDynamicsYoerger Yoerger's dynamic thruster model. class ThrusterPlugin Class for the thruster plugin. class UmbilicalModel class UmbilicalModelBerg class UmbilicalModelFactory Factory singleton class that creates an UmbilicalModel from sdf. class UmbilicalPlugin class UmbilicalSegment class UnderwaterObjectPlugin Gazebo model plugin class for underwater objects. Updated on 2022-05-30 at 18:35:12 +0000","title":"Classes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/","text":"gazebo::BuoyantObject Class describing the dynamics of a buoyant object, useful for simple representations of underwater structures. #include <BuoyantObject.hh> Inherited by gazebo::HydrodynamicModel Public Functions Name BuoyantObject (physics::LinkPtr _link) Constructor. ~BuoyantObject () Destructor. void GetBuoyancyForce (const ignition::math::Pose3d & _pose, ignition::math::Vector3d & buoyancyForce, ignition::math::Vector3d & buoyancyTorque) Returns the buoyancy force vector in the world frame. void ApplyBuoyancyForce () Applies buoyancy force on link. void SetVolume (double _volume =-1) Sets the link's submerged volume. double GetVolume () Returns the stored link submerged volume. void SetFluidDensity (double _fluidDensity) Sets the fluid density in kg/m^3. double GetFluidDensity () Returns the stored fluid density. void SetCoB (const ignition::math::Vector3d & _centerOfBuoyancy) Sets the position of the center of buoyancy on the body frame. ignition::math::Vector3d GetCoB () Returns the stored center of buoyancy. void SetGravity (double _g) Set acceleration of gravity. double GetGravity () Get stored acceleration of gravity. void SetBoundingBox (const AxisAlignedBox & _bBox) Sets bounding box. void SetStoreVector (std::string _tag) Adds a field in the hydroWrench map. ignition::math::Vector3d GetStoredVector (std::string _tag) Get vector from the hydroWrench map. void SetDebugFlag (bool _debugOn =true) Set debug flag to store intermediate forces and torques. bool IsSubmerged () Returns true if the robot is completely submerged. bool IsNeutrallyBuoyant () Returns true if the link was set to be neutrally buoyant. bool GetDebugFlag () Returns the debug flag. void SetNeutrallyBuoyant () Sets this link as neutrally buoyant. Protected Functions Name void StoreVector (std::string _tag, ignition::math::Vector3d _vec) Store vector in the hydroWrench map if the field has been created. Protected Attributes Name double volume Volume of fluid displaced by the submerged object. double scalingVolume Scaling factor for the volume. double offsetVolume Offset for the volume. double fluidDensity Fluid density. double g Acceleration of gravity. ignition::math::Vector3d centerOfBuoyancy Center of buoyancy in the body frame. AxisAlignedBox boundingBox TEMP for calculation of the buoyancy force close to the surface. std::map< std::string, ignition::math::Vector3d > hydroWrench Storage for hydrodynamic and hydrostatic forces and torques for debugging purposes. bool debugFlag Debug flag, storing all intermediate forces and torques. bool isSubmerged Is submerged flag. physics::LinkPtr link Pointer to the correspondent robot link. bool neutrallyBuoyant If true, the restoring force will be equal to the gravitational. double metacentricWidth double metacentricLength Metacentric length of the robot, used only for surface vessels and floating objects. double waterLevelPlaneArea If the cross section area around water level of the surface vessel is not given, it will be computed from the object's bounding box. double submergedHeight Height of the robot that is submerged (only for surface vessels) bool isSurfaceVessel Flag set to true if the information about the metacentric width and height is available. bool isSurfaceVesselFloating Flag set to true if the vessel has reached its submerged height. Public Functions Documentation function BuoyantObject BuoyantObject( physics::LinkPtr _link ) Constructor. function ~BuoyantObject ~BuoyantObject() Destructor. function GetBuoyancyForce void GetBuoyancyForce( const ignition::math::Pose3d & _pose, ignition::math::Vector3d & buoyancyForce, ignition::math::Vector3d & buoyancyTorque ) Returns the buoyancy force vector in the world frame. function ApplyBuoyancyForce void ApplyBuoyancyForce() Applies buoyancy force on link. function SetVolume void SetVolume( double _volume =-1 ) Sets the link's submerged volume. function GetVolume double GetVolume() Returns the stored link submerged volume. function SetFluidDensity void SetFluidDensity( double _fluidDensity ) Sets the fluid density in kg/m^3. function GetFluidDensity double GetFluidDensity() Returns the stored fluid density. function SetCoB void SetCoB( const ignition::math::Vector3d & _centerOfBuoyancy ) Sets the position of the center of buoyancy on the body frame. function GetCoB ignition::math::Vector3d GetCoB() Returns the stored center of buoyancy. function SetGravity void SetGravity( double _g ) Set acceleration of gravity. function GetGravity double GetGravity() Get stored acceleration of gravity. function SetBoundingBox void SetBoundingBox( const AxisAlignedBox & _bBox ) Sets bounding box. function SetStoreVector void SetStoreVector( std::string _tag ) Adds a field in the hydroWrench map. function GetStoredVector ignition::math::Vector3d GetStoredVector( std::string _tag ) Get vector from the hydroWrench map. function SetDebugFlag void SetDebugFlag( bool _debugOn =true ) Set debug flag to store intermediate forces and torques. function IsSubmerged bool IsSubmerged() Returns true if the robot is completely submerged. function IsNeutrallyBuoyant bool IsNeutrallyBuoyant() Returns true if the link was set to be neutrally buoyant. function GetDebugFlag bool GetDebugFlag() Returns the debug flag. function SetNeutrallyBuoyant void SetNeutrallyBuoyant() Sets this link as neutrally buoyant. Protected Functions Documentation function StoreVector void StoreVector( std::string _tag, ignition::math::Vector3d _vec ) Store vector in the hydroWrench map if the field has been created. Protected Attributes Documentation variable volume double volume; Volume of fluid displaced by the submerged object. variable scalingVolume double scalingVolume; Scaling factor for the volume. variable offsetVolume double offsetVolume; Offset for the volume. variable fluidDensity double fluidDensity; Fluid density. variable g double g; Acceleration of gravity. variable centerOfBuoyancy ignition::math::Vector3d centerOfBuoyancy; Center of buoyancy in the body frame. variable boundingBox AxisAlignedBox boundingBox; TEMP for calculation of the buoyancy force close to the surface. variable hydroWrench std::map< std::string, ignition::math::Vector3d > hydroWrench; Storage for hydrodynamic and hydrostatic forces and torques for debugging purposes. variable debugFlag bool debugFlag; Debug flag, storing all intermediate forces and torques. variable isSubmerged bool isSubmerged; Is submerged flag. variable link physics::LinkPtr link; Pointer to the correspondent robot link. variable neutrallyBuoyant bool neutrallyBuoyant; If true, the restoring force will be equal to the gravitational. variable metacentricWidth double metacentricWidth; variable metacentricLength double metacentricLength; Metacentric length of the robot, used only for surface vessels and floating objects. variable waterLevelPlaneArea double waterLevelPlaneArea; If the cross section area around water level of the surface vessel is not given, it will be computed from the object's bounding box. variable submergedHeight double submergedHeight; Height of the robot that is submerged (only for surface vessels) variable isSurfaceVessel bool isSurfaceVessel; Flag set to true if the information about the metacentric width and height is available. variable isSurfaceVesselFloating bool isSurfaceVesselFloating; Flag set to true if the vessel has reached its submerged height. Updated on 2022-05-30 at 18:35:12 +0000","title":"gazebo::BuoyantObject"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#gazebobuoyantobject","text":"Class describing the dynamics of a buoyant object, useful for simple representations of underwater structures. #include <BuoyantObject.hh> Inherited by gazebo::HydrodynamicModel","title":"gazebo::BuoyantObject"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#public-functions","text":"Name BuoyantObject (physics::LinkPtr _link) Constructor. ~BuoyantObject () Destructor. void GetBuoyancyForce (const ignition::math::Pose3d & _pose, ignition::math::Vector3d & buoyancyForce, ignition::math::Vector3d & buoyancyTorque) Returns the buoyancy force vector in the world frame. void ApplyBuoyancyForce () Applies buoyancy force on link. void SetVolume (double _volume =-1) Sets the link's submerged volume. double GetVolume () Returns the stored link submerged volume. void SetFluidDensity (double _fluidDensity) Sets the fluid density in kg/m^3. double GetFluidDensity () Returns the stored fluid density. void SetCoB (const ignition::math::Vector3d & _centerOfBuoyancy) Sets the position of the center of buoyancy on the body frame. ignition::math::Vector3d GetCoB () Returns the stored center of buoyancy. void SetGravity (double _g) Set acceleration of gravity. double GetGravity () Get stored acceleration of gravity. void SetBoundingBox (const AxisAlignedBox & _bBox) Sets bounding box. void SetStoreVector (std::string _tag) Adds a field in the hydroWrench map. ignition::math::Vector3d GetStoredVector (std::string _tag) Get vector from the hydroWrench map. void SetDebugFlag (bool _debugOn =true) Set debug flag to store intermediate forces and torques. bool IsSubmerged () Returns true if the robot is completely submerged. bool IsNeutrallyBuoyant () Returns true if the link was set to be neutrally buoyant. bool GetDebugFlag () Returns the debug flag. void SetNeutrallyBuoyant () Sets this link as neutrally buoyant.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#protected-functions","text":"Name void StoreVector (std::string _tag, ignition::math::Vector3d _vec) Store vector in the hydroWrench map if the field has been created.","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#protected-attributes","text":"Name double volume Volume of fluid displaced by the submerged object. double scalingVolume Scaling factor for the volume. double offsetVolume Offset for the volume. double fluidDensity Fluid density. double g Acceleration of gravity. ignition::math::Vector3d centerOfBuoyancy Center of buoyancy in the body frame. AxisAlignedBox boundingBox TEMP for calculation of the buoyancy force close to the surface. std::map< std::string, ignition::math::Vector3d > hydroWrench Storage for hydrodynamic and hydrostatic forces and torques for debugging purposes. bool debugFlag Debug flag, storing all intermediate forces and torques. bool isSubmerged Is submerged flag. physics::LinkPtr link Pointer to the correspondent robot link. bool neutrallyBuoyant If true, the restoring force will be equal to the gravitational. double metacentricWidth double metacentricLength Metacentric length of the robot, used only for surface vessels and floating objects. double waterLevelPlaneArea If the cross section area around water level of the surface vessel is not given, it will be computed from the object's bounding box. double submergedHeight Height of the robot that is submerged (only for surface vessels) bool isSurfaceVessel Flag set to true if the information about the metacentric width and height is available. bool isSurfaceVesselFloating Flag set to true if the vessel has reached its submerged height.","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#function-buoyantobject","text":"BuoyantObject( physics::LinkPtr _link ) Constructor.","title":"function BuoyantObject"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#function-buoyantobject_1","text":"~BuoyantObject() Destructor.","title":"function ~BuoyantObject"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#function-getbuoyancyforce","text":"void GetBuoyancyForce( const ignition::math::Pose3d & _pose, ignition::math::Vector3d & buoyancyForce, ignition::math::Vector3d & buoyancyTorque ) Returns the buoyancy force vector in the world frame.","title":"function GetBuoyancyForce"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#function-applybuoyancyforce","text":"void ApplyBuoyancyForce() Applies buoyancy force on link.","title":"function ApplyBuoyancyForce"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#function-setvolume","text":"void SetVolume( double _volume =-1 ) Sets the link's submerged volume.","title":"function SetVolume"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#function-getvolume","text":"double GetVolume() Returns the stored link submerged volume.","title":"function GetVolume"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#function-setfluiddensity","text":"void SetFluidDensity( double _fluidDensity ) Sets the fluid density in kg/m^3.","title":"function SetFluidDensity"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#function-getfluiddensity","text":"double GetFluidDensity() Returns the stored fluid density.","title":"function GetFluidDensity"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#function-setcob","text":"void SetCoB( const ignition::math::Vector3d & _centerOfBuoyancy ) Sets the position of the center of buoyancy on the body frame.","title":"function SetCoB"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#function-getcob","text":"ignition::math::Vector3d GetCoB() Returns the stored center of buoyancy.","title":"function GetCoB"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#function-setgravity","text":"void SetGravity( double _g ) Set acceleration of gravity.","title":"function SetGravity"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#function-getgravity","text":"double GetGravity() Get stored acceleration of gravity.","title":"function GetGravity"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#function-setboundingbox","text":"void SetBoundingBox( const AxisAlignedBox & _bBox ) Sets bounding box.","title":"function SetBoundingBox"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#function-setstorevector","text":"void SetStoreVector( std::string _tag ) Adds a field in the hydroWrench map.","title":"function SetStoreVector"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#function-getstoredvector","text":"ignition::math::Vector3d GetStoredVector( std::string _tag ) Get vector from the hydroWrench map.","title":"function GetStoredVector"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#function-setdebugflag","text":"void SetDebugFlag( bool _debugOn =true ) Set debug flag to store intermediate forces and torques.","title":"function SetDebugFlag"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#function-issubmerged","text":"bool IsSubmerged() Returns true if the robot is completely submerged.","title":"function IsSubmerged"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#function-isneutrallybuoyant","text":"bool IsNeutrallyBuoyant() Returns true if the link was set to be neutrally buoyant.","title":"function IsNeutrallyBuoyant"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#function-getdebugflag","text":"bool GetDebugFlag() Returns the debug flag.","title":"function GetDebugFlag"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#function-setneutrallybuoyant","text":"void SetNeutrallyBuoyant() Sets this link as neutrally buoyant.","title":"function SetNeutrallyBuoyant"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#function-storevector","text":"void StoreVector( std::string _tag, ignition::math::Vector3d _vec ) Store vector in the hydroWrench map if the field has been created.","title":"function StoreVector"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#variable-volume","text":"double volume; Volume of fluid displaced by the submerged object.","title":"variable volume"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#variable-scalingvolume","text":"double scalingVolume; Scaling factor for the volume.","title":"variable scalingVolume"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#variable-offsetvolume","text":"double offsetVolume; Offset for the volume.","title":"variable offsetVolume"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#variable-fluiddensity","text":"double fluidDensity; Fluid density.","title":"variable fluidDensity"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#variable-g","text":"double g; Acceleration of gravity.","title":"variable g"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#variable-centerofbuoyancy","text":"ignition::math::Vector3d centerOfBuoyancy; Center of buoyancy in the body frame.","title":"variable centerOfBuoyancy"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#variable-boundingbox","text":"AxisAlignedBox boundingBox; TEMP for calculation of the buoyancy force close to the surface.","title":"variable boundingBox"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#variable-hydrowrench","text":"std::map< std::string, ignition::math::Vector3d > hydroWrench; Storage for hydrodynamic and hydrostatic forces and torques for debugging purposes.","title":"variable hydroWrench"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#variable-debugflag","text":"bool debugFlag; Debug flag, storing all intermediate forces and torques.","title":"variable debugFlag"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#variable-issubmerged","text":"bool isSubmerged; Is submerged flag.","title":"variable isSubmerged"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#variable-link","text":"physics::LinkPtr link; Pointer to the correspondent robot link.","title":"variable link"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#variable-neutrallybuoyant","text":"bool neutrallyBuoyant; If true, the restoring force will be equal to the gravitational.","title":"variable neutrallyBuoyant"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#variable-metacentricwidth","text":"double metacentricWidth;","title":"variable metacentricWidth"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#variable-metacentriclength","text":"double metacentricLength; Metacentric length of the robot, used only for surface vessels and floating objects.","title":"variable metacentricLength"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#variable-waterlevelplanearea","text":"double waterLevelPlaneArea; If the cross section area around water level of the surface vessel is not given, it will be computed from the object's bounding box.","title":"variable waterLevelPlaneArea"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#variable-submergedheight","text":"double submergedHeight; Height of the robot that is submerged (only for surface vessels)","title":"variable submergedHeight"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#variable-issurfacevessel","text":"bool isSurfaceVessel; Flag set to true if the information about the metacentric width and height is available.","title":"variable isSurfaceVessel"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1BuoyantObject/#variable-issurfacevesselfloating","text":"bool isSurfaceVesselFloating; Flag set to true if the vessel has reached its submerged height. Updated on 2022-05-30 at 18:35:12 +0000","title":"variable isSurfaceVesselFloating"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunction/","text":"gazebo::ConversionFunction Abstact base class for a thruster conversion function. #include <ThrusterConversionFcn.hh> Inherited by gazebo::ConversionFunctionBasic , gazebo::ConversionFunctionBessa , gazebo::ConversionFunctionLinearInterp Public Functions Name virtual ~ConversionFunction () Destructor. virtual std::string GetType () =0 Return (derived) type of conversion function. virtual bool GetParam (std::string _tag, double & _output) =0 Return paramater in vector form for the given tag. virtual std::map< double, double > GetTable () Return input and output vectors of the lookup table. virtual double convert (double _cmd) =0 Convert thruster state (e.g. angular velocity) to thrust force. Protected Functions Name ConversionFunction () Protected constructor: Use the factory instead. Public Functions Documentation function ~ConversionFunction inline virtual ~ConversionFunction() Destructor. function GetType virtual std::string GetType() =0 Return (derived) type of conversion function. Reimplemented by : gazebo::ConversionFunctionBasic::GetType , gazebo::ConversionFunctionBessa::GetType , gazebo::ConversionFunctionLinearInterp::GetType function GetParam virtual bool GetParam( std::string _tag, double & _output ) =0 Return paramater in vector form for the given tag. Reimplemented by : gazebo::ConversionFunctionBasic::GetParam , gazebo::ConversionFunctionBessa::GetParam , gazebo::ConversionFunctionLinearInterp::GetParam function GetTable inline virtual std::map< double, double > GetTable() Return input and output vectors of the lookup table. Reimplemented by : gazebo::ConversionFunctionLinearInterp::GetTable function convert virtual double convert( double _cmd ) =0 Convert thruster state (e.g. angular velocity) to thrust force. Reimplemented by : gazebo::ConversionFunctionBasic::convert , gazebo::ConversionFunctionBessa::convert , gazebo::ConversionFunctionLinearInterp::convert Protected Functions Documentation function ConversionFunction inline ConversionFunction() Protected constructor: Use the factory instead. Updated on 2022-05-30 at 18:35:12 +0000","title":"gazebo::ConversionFunction"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunction/#gazeboconversionfunction","text":"Abstact base class for a thruster conversion function. #include <ThrusterConversionFcn.hh> Inherited by gazebo::ConversionFunctionBasic , gazebo::ConversionFunctionBessa , gazebo::ConversionFunctionLinearInterp","title":"gazebo::ConversionFunction"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunction/#public-functions","text":"Name virtual ~ConversionFunction () Destructor. virtual std::string GetType () =0 Return (derived) type of conversion function. virtual bool GetParam (std::string _tag, double & _output) =0 Return paramater in vector form for the given tag. virtual std::map< double, double > GetTable () Return input and output vectors of the lookup table. virtual double convert (double _cmd) =0 Convert thruster state (e.g. angular velocity) to thrust force.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunction/#protected-functions","text":"Name ConversionFunction () Protected constructor: Use the factory instead.","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunction/#function-conversionfunction","text":"inline virtual ~ConversionFunction() Destructor.","title":"function ~ConversionFunction"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunction/#function-gettype","text":"virtual std::string GetType() =0 Return (derived) type of conversion function. Reimplemented by : gazebo::ConversionFunctionBasic::GetType , gazebo::ConversionFunctionBessa::GetType , gazebo::ConversionFunctionLinearInterp::GetType","title":"function GetType"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunction/#function-getparam","text":"virtual bool GetParam( std::string _tag, double & _output ) =0 Return paramater in vector form for the given tag. Reimplemented by : gazebo::ConversionFunctionBasic::GetParam , gazebo::ConversionFunctionBessa::GetParam , gazebo::ConversionFunctionLinearInterp::GetParam","title":"function GetParam"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunction/#function-gettable","text":"inline virtual std::map< double, double > GetTable() Return input and output vectors of the lookup table. Reimplemented by : gazebo::ConversionFunctionLinearInterp::GetTable","title":"function GetTable"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunction/#function-convert","text":"virtual double convert( double _cmd ) =0 Convert thruster state (e.g. angular velocity) to thrust force. Reimplemented by : gazebo::ConversionFunctionBasic::convert , gazebo::ConversionFunctionBessa::convert , gazebo::ConversionFunctionLinearInterp::convert","title":"function convert"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunction/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunction/#function-conversionfunction_1","text":"inline ConversionFunction() Protected constructor: Use the factory instead. Updated on 2022-05-30 at 18:35:12 +0000","title":"function ConversionFunction"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionBasic/","text":"title: gazebo::ConversionFunctionBasic summary: The most basic conversion function: Thrust = const. w abs(w) This corresponds to what is attrributed to Yoerger et al. and called Model 1 in Bessa et al.: Dynamic Positioning of Underwater Robotic Vehicles with Thruster Dynamics Compensation. gazebo::ConversionFunctionBasic The most basic conversion function: Thrust = const. w abs(w) This corresponds to what is attrributed to Yoerger et al. and called Model 1 in Bessa et al.: Dynamic Positioning of Underwater Robotic Vehicles with Thruster Dynamics Compensation. #include <ThrusterConversionFcn.hh> Inherits from gazebo::ConversionFunction Public Functions Name ConversionFunction * create (sdf::ElementPtr _sdf) Create a ConversionFunction object according to its sdf Description. virtual std::string GetType () Return (derived) type of conversion function. virtual bool GetParam (std::string _tag, double & _output) Return paramater in scalar form for the given tag. virtual double convert (double _cmd) Convert thruster state (e.g. angular velocity) to thrust force. Additional inherited members Public Functions inherited from gazebo::ConversionFunction Name virtual ~ConversionFunction () Destructor. virtual std::map< double, double > GetTable () Return input and output vectors of the lookup table. Protected Functions inherited from gazebo::ConversionFunction Name ConversionFunction () Protected constructor: Use the factory instead. Public Functions Documentation function create static ConversionFunction * create( sdf::ElementPtr _sdf ) Create a ConversionFunction object according to its sdf Description. function GetType inline virtual std::string GetType() Return (derived) type of conversion function. Reimplements : gazebo::ConversionFunction::GetType function GetParam virtual bool GetParam( std::string _tag, double & _output ) Return paramater in scalar form for the given tag. Reimplements : gazebo::ConversionFunction::GetParam function convert virtual double convert( double _cmd ) Convert thruster state (e.g. angular velocity) to thrust force. Reimplements : gazebo::ConversionFunction::convert Updated on 2022-05-30 at 18:35:12 +0000","title":"classgazebo 1 1ConversionFunctionBasic"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionBasic/#gazeboconversionfunctionbasic","text":"The most basic conversion function: Thrust = const. w abs(w) This corresponds to what is attrributed to Yoerger et al. and called Model 1 in Bessa et al.: Dynamic Positioning of Underwater Robotic Vehicles with Thruster Dynamics Compensation. #include <ThrusterConversionFcn.hh> Inherits from gazebo::ConversionFunction","title":"gazebo::ConversionFunctionBasic"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionBasic/#public-functions","text":"Name ConversionFunction * create (sdf::ElementPtr _sdf) Create a ConversionFunction object according to its sdf Description. virtual std::string GetType () Return (derived) type of conversion function. virtual bool GetParam (std::string _tag, double & _output) Return paramater in scalar form for the given tag. virtual double convert (double _cmd) Convert thruster state (e.g. angular velocity) to thrust force.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionBasic/#additional-inherited-members","text":"Public Functions inherited from gazebo::ConversionFunction Name virtual ~ConversionFunction () Destructor. virtual std::map< double, double > GetTable () Return input and output vectors of the lookup table. Protected Functions inherited from gazebo::ConversionFunction Name ConversionFunction () Protected constructor: Use the factory instead.","title":"Additional inherited members"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionBasic/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionBasic/#function-create","text":"static ConversionFunction * create( sdf::ElementPtr _sdf ) Create a ConversionFunction object according to its sdf Description.","title":"function create"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionBasic/#function-gettype","text":"inline virtual std::string GetType() Return (derived) type of conversion function. Reimplements : gazebo::ConversionFunction::GetType","title":"function GetType"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionBasic/#function-getparam","text":"virtual bool GetParam( std::string _tag, double & _output ) Return paramater in scalar form for the given tag. Reimplements : gazebo::ConversionFunction::GetParam","title":"function GetParam"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionBasic/#function-convert","text":"virtual double convert( double _cmd ) Convert thruster state (e.g. angular velocity) to thrust force. Reimplements : gazebo::ConversionFunction::convert Updated on 2022-05-30 at 18:35:12 +0000","title":"function convert"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionBessa/","text":"title: gazebo::ConversionFunctionBessa summary: Asymmetric conversion function with dead-zone nonlinearity. This corresponds to what is called Model 2 in Bessa et al.: Dynamic Positioning of Underwater Robotic Vehicles with Thruster Dynamics Compensation. gazebo::ConversionFunctionBessa Asymmetric conversion function with dead-zone nonlinearity. This corresponds to what is called Model 2 in Bessa et al.: Dynamic Positioning of Underwater Robotic Vehicles with Thruster Dynamics Compensation. #include <ThrusterConversionFcn.hh> Inherits from gazebo::ConversionFunction Public Functions Name ConversionFunction * create (sdf::ElementPtr _sdf) Create a ConversionFunction object according to its sdf Description. virtual std::string GetType () Return (derived) type of conversion function. virtual bool GetParam (std::string _tag, double & _output) Return paramater in scalar form for the given tag. virtual double convert (double _cmd) Convert thruster state (e.g. angular velocity) to thrust force. Additional inherited members Public Functions inherited from gazebo::ConversionFunction Name virtual ~ConversionFunction () Destructor. virtual std::map< double, double > GetTable () Return input and output vectors of the lookup table. Protected Functions inherited from gazebo::ConversionFunction Name ConversionFunction () Protected constructor: Use the factory instead. Public Functions Documentation function create static ConversionFunction * create( sdf::ElementPtr _sdf ) Create a ConversionFunction object according to its sdf Description. function GetType inline virtual std::string GetType() Return (derived) type of conversion function. Reimplements : gazebo::ConversionFunction::GetType function GetParam virtual bool GetParam( std::string _tag, double & _output ) Return paramater in scalar form for the given tag. Reimplements : gazebo::ConversionFunction::GetParam function convert virtual double convert( double _cmd ) Convert thruster state (e.g. angular velocity) to thrust force. Reimplements : gazebo::ConversionFunction::convert Updated on 2022-05-30 at 18:35:12 +0000","title":"classgazebo 1 1ConversionFunctionBessa"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionBessa/#gazeboconversionfunctionbessa","text":"Asymmetric conversion function with dead-zone nonlinearity. This corresponds to what is called Model 2 in Bessa et al.: Dynamic Positioning of Underwater Robotic Vehicles with Thruster Dynamics Compensation. #include <ThrusterConversionFcn.hh> Inherits from gazebo::ConversionFunction","title":"gazebo::ConversionFunctionBessa"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionBessa/#public-functions","text":"Name ConversionFunction * create (sdf::ElementPtr _sdf) Create a ConversionFunction object according to its sdf Description. virtual std::string GetType () Return (derived) type of conversion function. virtual bool GetParam (std::string _tag, double & _output) Return paramater in scalar form for the given tag. virtual double convert (double _cmd) Convert thruster state (e.g. angular velocity) to thrust force.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionBessa/#additional-inherited-members","text":"Public Functions inherited from gazebo::ConversionFunction Name virtual ~ConversionFunction () Destructor. virtual std::map< double, double > GetTable () Return input and output vectors of the lookup table. Protected Functions inherited from gazebo::ConversionFunction Name ConversionFunction () Protected constructor: Use the factory instead.","title":"Additional inherited members"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionBessa/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionBessa/#function-create","text":"static ConversionFunction * create( sdf::ElementPtr _sdf ) Create a ConversionFunction object according to its sdf Description.","title":"function create"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionBessa/#function-gettype","text":"inline virtual std::string GetType() Return (derived) type of conversion function. Reimplements : gazebo::ConversionFunction::GetType","title":"function GetType"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionBessa/#function-getparam","text":"virtual bool GetParam( std::string _tag, double & _output ) Return paramater in scalar form for the given tag. Reimplements : gazebo::ConversionFunction::GetParam","title":"function GetParam"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionBessa/#function-convert","text":"virtual double convert( double _cmd ) Convert thruster state (e.g. angular velocity) to thrust force. Reimplements : gazebo::ConversionFunction::convert Updated on 2022-05-30 at 18:35:12 +0000","title":"function convert"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionFactory/","text":"gazebo::ConversionFunctionFactory Factory singleton class that creates a ConversionFunction from sdf. #include <ThrusterConversionFcn.hh> Public Functions Name ConversionFunction * CreateConversionFunction (sdf::ElementPtr _sdf) Create a ConversionFunction object according to its sdf Description. bool RegisterCreator (const std::string & _identifier, ConversionFunctionCreator _creator) Register a ConversionFunction class with its creator. ConversionFunctionFactory & GetInstance () Return the singleton instance of this factory. Public Functions Documentation function CreateConversionFunction ConversionFunction * CreateConversionFunction( sdf::ElementPtr _sdf ) Create a ConversionFunction object according to its sdf Description. function RegisterCreator bool RegisterCreator( const std::string & _identifier, ConversionFunctionCreator _creator ) Register a ConversionFunction class with its creator. function GetInstance static ConversionFunctionFactory & GetInstance() Return the singleton instance of this factory. Updated on 2022-05-30 at 18:35:12 +0000","title":"gazebo::ConversionFunctionFactory"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionFactory/#gazeboconversionfunctionfactory","text":"Factory singleton class that creates a ConversionFunction from sdf. #include <ThrusterConversionFcn.hh>","title":"gazebo::ConversionFunctionFactory"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionFactory/#public-functions","text":"Name ConversionFunction * CreateConversionFunction (sdf::ElementPtr _sdf) Create a ConversionFunction object according to its sdf Description. bool RegisterCreator (const std::string & _identifier, ConversionFunctionCreator _creator) Register a ConversionFunction class with its creator. ConversionFunctionFactory & GetInstance () Return the singleton instance of this factory.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionFactory/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionFactory/#function-createconversionfunction","text":"ConversionFunction * CreateConversionFunction( sdf::ElementPtr _sdf ) Create a ConversionFunction object according to its sdf Description.","title":"function CreateConversionFunction"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionFactory/#function-registercreator","text":"bool RegisterCreator( const std::string & _identifier, ConversionFunctionCreator _creator ) Register a ConversionFunction class with its creator.","title":"function RegisterCreator"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionFactory/#function-getinstance","text":"static ConversionFunctionFactory & GetInstance() Return the singleton instance of this factory. Updated on 2022-05-30 at 18:35:12 +0000","title":"function GetInstance"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionLinearInterp/","text":"gazebo::ConversionFunctionLinearInterp Conversion using linear interpolation between given data points. #include <ThrusterConversionFcn.hh> Inherits from gazebo::ConversionFunction Public Functions Name ConversionFunction * create (sdf::ElementPtr _sdf) Create a ConversionFunction object according to its sdf Description. virtual std::string GetType () Return (derived) type of conversion function. virtual bool GetParam (std::string _tag, double & _output) Return paramater in scalar form for the given tag. virtual std::map< double, double > GetTable () Return input and output vectors of the lookup table. virtual double convert (double _cmd) Convert thruster state (e.g. angular velocity) to thrust force. Additional inherited members Public Functions inherited from gazebo::ConversionFunction Name virtual ~ConversionFunction () Destructor. Protected Functions inherited from gazebo::ConversionFunction Name ConversionFunction () Protected constructor: Use the factory instead. Public Functions Documentation function create static ConversionFunction * create( sdf::ElementPtr _sdf ) Create a ConversionFunction object according to its sdf Description. function GetType inline virtual std::string GetType() Return (derived) type of conversion function. Reimplements : gazebo::ConversionFunction::GetType function GetParam virtual bool GetParam( std::string _tag, double & _output ) Return paramater in scalar form for the given tag. Reimplements : gazebo::ConversionFunction::GetParam function GetTable virtual std::map< double, double > GetTable() Return input and output vectors of the lookup table. Reimplements : gazebo::ConversionFunction::GetTable function convert virtual double convert( double _cmd ) Convert thruster state (e.g. angular velocity) to thrust force. Reimplements : gazebo::ConversionFunction::convert Updated on 2022-05-30 at 18:35:12 +0000","title":"gazebo::ConversionFunctionLinearInterp"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionLinearInterp/#gazeboconversionfunctionlinearinterp","text":"Conversion using linear interpolation between given data points. #include <ThrusterConversionFcn.hh> Inherits from gazebo::ConversionFunction","title":"gazebo::ConversionFunctionLinearInterp"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionLinearInterp/#public-functions","text":"Name ConversionFunction * create (sdf::ElementPtr _sdf) Create a ConversionFunction object according to its sdf Description. virtual std::string GetType () Return (derived) type of conversion function. virtual bool GetParam (std::string _tag, double & _output) Return paramater in scalar form for the given tag. virtual std::map< double, double > GetTable () Return input and output vectors of the lookup table. virtual double convert (double _cmd) Convert thruster state (e.g. angular velocity) to thrust force.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionLinearInterp/#additional-inherited-members","text":"Public Functions inherited from gazebo::ConversionFunction Name virtual ~ConversionFunction () Destructor. Protected Functions inherited from gazebo::ConversionFunction Name ConversionFunction () Protected constructor: Use the factory instead.","title":"Additional inherited members"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionLinearInterp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionLinearInterp/#function-create","text":"static ConversionFunction * create( sdf::ElementPtr _sdf ) Create a ConversionFunction object according to its sdf Description.","title":"function create"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionLinearInterp/#function-gettype","text":"inline virtual std::string GetType() Return (derived) type of conversion function. Reimplements : gazebo::ConversionFunction::GetType","title":"function GetType"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionLinearInterp/#function-getparam","text":"virtual bool GetParam( std::string _tag, double & _output ) Return paramater in scalar form for the given tag. Reimplements : gazebo::ConversionFunction::GetParam","title":"function GetParam"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionLinearInterp/#function-gettable","text":"virtual std::map< double, double > GetTable() Return input and output vectors of the lookup table. Reimplements : gazebo::ConversionFunction::GetTable","title":"function GetTable"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ConversionFunctionLinearInterp/#function-convert","text":"virtual double convert( double _cmd ) Convert thruster state (e.g. angular velocity) to thrust force. Reimplements : gazebo::ConversionFunction::convert Updated on 2022-05-30 at 18:35:12 +0000","title":"function convert"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1Dynamics/","text":"gazebo::Dynamics Abstract base class for thruster dynamics. #include <Dynamics.hh> Inherited by gazebo::DynamicsFirstOrder , gazebo::DynamicsZeroOrder , gazebo::ThrusterDynamicsBessa , gazebo::ThrusterDynamicsYoerger Public Functions Name virtual ~Dynamics () Destructor. virtual std::string GetType () =0 Return (derived) type of thruster dynamics. virtual double update (double _cmd, double _t) =0 Update the dynamic model. virtual void Reset () Protected Functions Name Dynamics () Protected constructor: Use the factory for object creation. Protected Attributes Name double prevTime Time of last state update. double state Latest state. Public Functions Documentation function ~Dynamics inline virtual ~Dynamics() Destructor. function GetType virtual std::string GetType() =0 Return (derived) type of thruster dynamics. Reimplemented by : gazebo::DynamicsZeroOrder::GetType , gazebo::DynamicsFirstOrder::GetType , gazebo::ThrusterDynamicsYoerger::GetType , gazebo::ThrusterDynamicsBessa::GetType function update virtual double update( double _cmd, double _t ) =0 Update the dynamic model. Parameters : _cmd The commanded value. _t Time stamp of command. Reimplemented by : gazebo::DynamicsZeroOrder::update , gazebo::DynamicsFirstOrder::update , gazebo::ThrusterDynamicsYoerger::update , gazebo::ThrusterDynamicsBessa::update function Reset virtual void Reset() Protected Functions Documentation function Dynamics inline Dynamics() Protected constructor: Use the factory for object creation. Protected Attributes Documentation variable prevTime double prevTime; Time of last state update. variable state double state; Latest state. Updated on 2022-05-30 at 18:35:12 +0000","title":"gazebo::Dynamics"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1Dynamics/#gazebodynamics","text":"Abstract base class for thruster dynamics. #include <Dynamics.hh> Inherited by gazebo::DynamicsFirstOrder , gazebo::DynamicsZeroOrder , gazebo::ThrusterDynamicsBessa , gazebo::ThrusterDynamicsYoerger","title":"gazebo::Dynamics"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1Dynamics/#public-functions","text":"Name virtual ~Dynamics () Destructor. virtual std::string GetType () =0 Return (derived) type of thruster dynamics. virtual double update (double _cmd, double _t) =0 Update the dynamic model. virtual void Reset ()","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1Dynamics/#protected-functions","text":"Name Dynamics () Protected constructor: Use the factory for object creation.","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1Dynamics/#protected-attributes","text":"Name double prevTime Time of last state update. double state Latest state.","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1Dynamics/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1Dynamics/#function-dynamics","text":"inline virtual ~Dynamics() Destructor.","title":"function ~Dynamics"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1Dynamics/#function-gettype","text":"virtual std::string GetType() =0 Return (derived) type of thruster dynamics. Reimplemented by : gazebo::DynamicsZeroOrder::GetType , gazebo::DynamicsFirstOrder::GetType , gazebo::ThrusterDynamicsYoerger::GetType , gazebo::ThrusterDynamicsBessa::GetType","title":"function GetType"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1Dynamics/#function-update","text":"virtual double update( double _cmd, double _t ) =0 Update the dynamic model. Parameters : _cmd The commanded value. _t Time stamp of command. Reimplemented by : gazebo::DynamicsZeroOrder::update , gazebo::DynamicsFirstOrder::update , gazebo::ThrusterDynamicsYoerger::update , gazebo::ThrusterDynamicsBessa::update","title":"function update"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1Dynamics/#function-reset","text":"virtual void Reset()","title":"function Reset"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1Dynamics/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1Dynamics/#function-dynamics_1","text":"inline Dynamics() Protected constructor: Use the factory for object creation.","title":"function Dynamics"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1Dynamics/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1Dynamics/#variable-prevtime","text":"double prevTime; Time of last state update.","title":"variable prevTime"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1Dynamics/#variable-state","text":"double state; Latest state. Updated on 2022-05-30 at 18:35:12 +0000","title":"variable state"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1DynamicsFactory/","text":"gazebo::DynamicsFactory Factory singleton class that creates a ThrusterDynamics from sdf. #include <Dynamics.hh> Public Functions Name Dynamics * CreateDynamics (sdf::ElementPtr _sdf) Create ThrusterDynamics object according to its sdf Description. bool RegisterCreator (const std::string & _identifier, DynamicsCreator _creator) Register a ThrusterDynamic class with its creator. DynamicsFactory & GetInstance () Returns the singleton instance of this factory. Public Functions Documentation function CreateDynamics Dynamics * CreateDynamics( sdf::ElementPtr _sdf ) Create ThrusterDynamics object according to its sdf Description. function RegisterCreator bool RegisterCreator( const std::string & _identifier, DynamicsCreator _creator ) Register a ThrusterDynamic class with its creator. function GetInstance static DynamicsFactory & GetInstance() Returns the singleton instance of this factory. Updated on 2022-05-30 at 18:35:12 +0000","title":"gazebo::DynamicsFactory"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1DynamicsFactory/#gazebodynamicsfactory","text":"Factory singleton class that creates a ThrusterDynamics from sdf. #include <Dynamics.hh>","title":"gazebo::DynamicsFactory"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1DynamicsFactory/#public-functions","text":"Name Dynamics * CreateDynamics (sdf::ElementPtr _sdf) Create ThrusterDynamics object according to its sdf Description. bool RegisterCreator (const std::string & _identifier, DynamicsCreator _creator) Register a ThrusterDynamic class with its creator. DynamicsFactory & GetInstance () Returns the singleton instance of this factory.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1DynamicsFactory/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1DynamicsFactory/#function-createdynamics","text":"Dynamics * CreateDynamics( sdf::ElementPtr _sdf ) Create ThrusterDynamics object according to its sdf Description.","title":"function CreateDynamics"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1DynamicsFactory/#function-registercreator","text":"bool RegisterCreator( const std::string & _identifier, DynamicsCreator _creator ) Register a ThrusterDynamic class with its creator.","title":"function RegisterCreator"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1DynamicsFactory/#function-getinstance","text":"static DynamicsFactory & GetInstance() Returns the singleton instance of this factory. Updated on 2022-05-30 at 18:35:12 +0000","title":"function GetInstance"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1DynamicsFirstOrder/","text":"gazebo::DynamicsFirstOrder First-order dynamic system. #include <Dynamics.hh> Inherits from gazebo::Dynamics Public Functions Name Dynamics * create (sdf::ElementPtr _sdf) Create thruster model of this type with parameter values from sdf. virtual std::string GetType () Return (derived) type of dynamic system. virtual double update (double _cmd, double _t) Update dynamical model given input value and time. Additional inherited members Public Functions inherited from gazebo::Dynamics Name virtual ~Dynamics () Destructor. virtual void Reset () Protected Functions inherited from gazebo::Dynamics Name Dynamics () Protected constructor: Use the factory for object creation. Protected Attributes inherited from gazebo::Dynamics Name double prevTime Time of last state update. double state Latest state. Public Functions Documentation function create static Dynamics * create( sdf::ElementPtr _sdf ) Create thruster model of this type with parameter values from sdf. function GetType inline virtual std::string GetType() Return (derived) type of dynamic system. Reimplements : gazebo::Dynamics::GetType function update virtual double update( double _cmd, double _t ) Update dynamical model given input value and time. Reimplements : gazebo::Dynamics::update Updated on 2022-05-30 at 18:35:12 +0000","title":"gazebo::DynamicsFirstOrder"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1DynamicsFirstOrder/#gazebodynamicsfirstorder","text":"First-order dynamic system. #include <Dynamics.hh> Inherits from gazebo::Dynamics","title":"gazebo::DynamicsFirstOrder"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1DynamicsFirstOrder/#public-functions","text":"Name Dynamics * create (sdf::ElementPtr _sdf) Create thruster model of this type with parameter values from sdf. virtual std::string GetType () Return (derived) type of dynamic system. virtual double update (double _cmd, double _t) Update dynamical model given input value and time.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1DynamicsFirstOrder/#additional-inherited-members","text":"Public Functions inherited from gazebo::Dynamics Name virtual ~Dynamics () Destructor. virtual void Reset () Protected Functions inherited from gazebo::Dynamics Name Dynamics () Protected constructor: Use the factory for object creation. Protected Attributes inherited from gazebo::Dynamics Name double prevTime Time of last state update. double state Latest state.","title":"Additional inherited members"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1DynamicsFirstOrder/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1DynamicsFirstOrder/#function-create","text":"static Dynamics * create( sdf::ElementPtr _sdf ) Create thruster model of this type with parameter values from sdf.","title":"function create"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1DynamicsFirstOrder/#function-gettype","text":"inline virtual std::string GetType() Return (derived) type of dynamic system. Reimplements : gazebo::Dynamics::GetType","title":"function GetType"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1DynamicsFirstOrder/#function-update","text":"virtual double update( double _cmd, double _t ) Update dynamical model given input value and time. Reimplements : gazebo::Dynamics::update Updated on 2022-05-30 at 18:35:12 +0000","title":"function update"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1DynamicsZeroOrder/","text":"gazebo::DynamicsZeroOrder Trivial (no dynamics) zero-order dynamic system. #include <Dynamics.hh> Inherits from gazebo::Dynamics Public Functions Name Dynamics * create (sdf::ElementPtr _sdf) Create thruster model of this type with parameter values from sdf. virtual std::string GetType () Return (derived) type of dynamic system. virtual double update (double _cmd, double _t) Update dynamical model given input value and time. Additional inherited members Public Functions inherited from gazebo::Dynamics Name virtual ~Dynamics () Destructor. virtual void Reset () Protected Functions inherited from gazebo::Dynamics Name Dynamics () Protected constructor: Use the factory for object creation. Protected Attributes inherited from gazebo::Dynamics Name double prevTime Time of last state update. double state Latest state. Public Functions Documentation function create static Dynamics * create( sdf::ElementPtr _sdf ) Create thruster model of this type with parameter values from sdf. function GetType inline virtual std::string GetType() Return (derived) type of dynamic system. Reimplements : gazebo::Dynamics::GetType function update virtual double update( double _cmd, double _t ) Update dynamical model given input value and time. Reimplements : gazebo::Dynamics::update Updated on 2022-05-30 at 18:35:12 +0000","title":"gazebo::DynamicsZeroOrder"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1DynamicsZeroOrder/#gazebodynamicszeroorder","text":"Trivial (no dynamics) zero-order dynamic system. #include <Dynamics.hh> Inherits from gazebo::Dynamics","title":"gazebo::DynamicsZeroOrder"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1DynamicsZeroOrder/#public-functions","text":"Name Dynamics * create (sdf::ElementPtr _sdf) Create thruster model of this type with parameter values from sdf. virtual std::string GetType () Return (derived) type of dynamic system. virtual double update (double _cmd, double _t) Update dynamical model given input value and time.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1DynamicsZeroOrder/#additional-inherited-members","text":"Public Functions inherited from gazebo::Dynamics Name virtual ~Dynamics () Destructor. virtual void Reset () Protected Functions inherited from gazebo::Dynamics Name Dynamics () Protected constructor: Use the factory for object creation. Protected Attributes inherited from gazebo::Dynamics Name double prevTime Time of last state update. double state Latest state.","title":"Additional inherited members"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1DynamicsZeroOrder/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1DynamicsZeroOrder/#function-create","text":"static Dynamics * create( sdf::ElementPtr _sdf ) Create thruster model of this type with parameter values from sdf.","title":"function create"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1DynamicsZeroOrder/#function-gettype","text":"inline virtual std::string GetType() Return (derived) type of dynamic system. Reimplements : gazebo::Dynamics::GetType","title":"function GetType"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1DynamicsZeroOrder/#function-update","text":"virtual double update( double _cmd, double _t ) Update dynamical model given input value and time. Reimplements : gazebo::Dynamics::update Updated on 2022-05-30 at 18:35:12 +0000","title":"function update"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1FinPlugin/","text":"gazebo::FinPlugin Inherits from ModelPlugin Public Functions Name FinPlugin () Constructor. virtual ~FinPlugin () Destructor. virtual void Load (physics::ModelPtr _model, sdf::ElementPtr _sdf) virtual void Init () void OnUpdate (const common::UpdateInfo & _info) Update the simulation state. Protected Functions Name void UpdateInput (ConstDoublePtr & _msg) Callback for the input topic subscriber. void UpdateCurrentVelocity (ConstVector3dPtr & _msg) Reads current velocity topic. Protected Attributes Name std::shared_ptr< Dynamics > dynamics Fin dynamic model. std::shared_ptr< LiftDrag > liftdrag Lift&Drag model. event::ConnectionPtr updateConnection Update event. transport::NodePtr node Gazebo node. physics::JointPtr joint The fin joint. physics::LinkPtr link The fin link. transport::SubscriberPtr commandSubscriber Subscriber to the reference signal topic. transport::PublisherPtr anglePublisher Publisher to the output thrust topic. ignition::math::Vector3d finForce Force component calculated from the lift and drag module. double inputCommand Latest input command. int finID Fin ID. std::string topicPrefix Topic prefix. double angle Latest fin angle in [rad]. common::Time angleStamp Time stamp of latest thrust force. transport::SubscriberPtr currentSubscriber Subcriber to current message. ignition::math::Vector3d currentVelocity Current velocity vector read from topic. Public Functions Documentation function FinPlugin FinPlugin() Constructor. function ~FinPlugin virtual ~FinPlugin() Destructor. function Load virtual void Load( physics::ModelPtr _model, sdf::ElementPtr _sdf ) function Init virtual void Init() function OnUpdate void OnUpdate( const common::UpdateInfo & _info ) Update the simulation state. Parameters : _info Information used in the update event. Protected Functions Documentation function UpdateInput void UpdateInput( ConstDoublePtr & _msg ) Callback for the input topic subscriber. function UpdateCurrentVelocity void UpdateCurrentVelocity( ConstVector3dPtr & _msg ) Reads current velocity topic. Protected Attributes Documentation variable dynamics std::shared_ptr< Dynamics > dynamics; Fin dynamic model. variable liftdrag std::shared_ptr< LiftDrag > liftdrag; Lift&Drag model. variable updateConnection event::ConnectionPtr updateConnection; Update event. variable node transport::NodePtr node; Gazebo node. variable joint physics::JointPtr joint; The fin joint. variable link physics::LinkPtr link; The fin link. variable commandSubscriber transport::SubscriberPtr commandSubscriber; Subscriber to the reference signal topic. variable anglePublisher transport::PublisherPtr anglePublisher; Publisher to the output thrust topic. variable finForce ignition::math::Vector3d finForce; Force component calculated from the lift and drag module. variable inputCommand double inputCommand; Latest input command. variable finID int finID; Fin ID. variable topicPrefix std::string topicPrefix; Topic prefix. variable angle double angle; Latest fin angle in [rad]. variable angleStamp common::Time angleStamp; Time stamp of latest thrust force. variable currentSubscriber transport::SubscriberPtr currentSubscriber; Subcriber to current message. variable currentVelocity ignition::math::Vector3d currentVelocity; Current velocity vector read from topic. Updated on 2022-05-30 at 18:35:12 +0000","title":"gazebo::FinPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1FinPlugin/#gazebofinplugin","text":"Inherits from ModelPlugin","title":"gazebo::FinPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1FinPlugin/#public-functions","text":"Name FinPlugin () Constructor. virtual ~FinPlugin () Destructor. virtual void Load (physics::ModelPtr _model, sdf::ElementPtr _sdf) virtual void Init () void OnUpdate (const common::UpdateInfo & _info) Update the simulation state.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1FinPlugin/#protected-functions","text":"Name void UpdateInput (ConstDoublePtr & _msg) Callback for the input topic subscriber. void UpdateCurrentVelocity (ConstVector3dPtr & _msg) Reads current velocity topic.","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1FinPlugin/#protected-attributes","text":"Name std::shared_ptr< Dynamics > dynamics Fin dynamic model. std::shared_ptr< LiftDrag > liftdrag Lift&Drag model. event::ConnectionPtr updateConnection Update event. transport::NodePtr node Gazebo node. physics::JointPtr joint The fin joint. physics::LinkPtr link The fin link. transport::SubscriberPtr commandSubscriber Subscriber to the reference signal topic. transport::PublisherPtr anglePublisher Publisher to the output thrust topic. ignition::math::Vector3d finForce Force component calculated from the lift and drag module. double inputCommand Latest input command. int finID Fin ID. std::string topicPrefix Topic prefix. double angle Latest fin angle in [rad]. common::Time angleStamp Time stamp of latest thrust force. transport::SubscriberPtr currentSubscriber Subcriber to current message. ignition::math::Vector3d currentVelocity Current velocity vector read from topic.","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1FinPlugin/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1FinPlugin/#function-finplugin","text":"FinPlugin() Constructor.","title":"function FinPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1FinPlugin/#function-finplugin_1","text":"virtual ~FinPlugin() Destructor.","title":"function ~FinPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1FinPlugin/#function-load","text":"virtual void Load( physics::ModelPtr _model, sdf::ElementPtr _sdf )","title":"function Load"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1FinPlugin/#function-init","text":"virtual void Init()","title":"function Init"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1FinPlugin/#function-onupdate","text":"void OnUpdate( const common::UpdateInfo & _info ) Update the simulation state. Parameters : _info Information used in the update event.","title":"function OnUpdate"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1FinPlugin/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1FinPlugin/#function-updateinput","text":"void UpdateInput( ConstDoublePtr & _msg ) Callback for the input topic subscriber.","title":"function UpdateInput"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1FinPlugin/#function-updatecurrentvelocity","text":"void UpdateCurrentVelocity( ConstVector3dPtr & _msg ) Reads current velocity topic.","title":"function UpdateCurrentVelocity"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1FinPlugin/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1FinPlugin/#variable-dynamics","text":"std::shared_ptr< Dynamics > dynamics; Fin dynamic model.","title":"variable dynamics"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1FinPlugin/#variable-liftdrag","text":"std::shared_ptr< LiftDrag > liftdrag; Lift&Drag model.","title":"variable liftdrag"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1FinPlugin/#variable-updateconnection","text":"event::ConnectionPtr updateConnection; Update event.","title":"variable updateConnection"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1FinPlugin/#variable-node","text":"transport::NodePtr node; Gazebo node.","title":"variable node"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1FinPlugin/#variable-joint","text":"physics::JointPtr joint; The fin joint.","title":"variable joint"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1FinPlugin/#variable-link","text":"physics::LinkPtr link; The fin link.","title":"variable link"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1FinPlugin/#variable-commandsubscriber","text":"transport::SubscriberPtr commandSubscriber; Subscriber to the reference signal topic.","title":"variable commandSubscriber"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1FinPlugin/#variable-anglepublisher","text":"transport::PublisherPtr anglePublisher; Publisher to the output thrust topic.","title":"variable anglePublisher"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1FinPlugin/#variable-finforce","text":"ignition::math::Vector3d finForce; Force component calculated from the lift and drag module.","title":"variable finForce"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1FinPlugin/#variable-inputcommand","text":"double inputCommand; Latest input command.","title":"variable inputCommand"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1FinPlugin/#variable-finid","text":"int finID; Fin ID.","title":"variable finID"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1FinPlugin/#variable-topicprefix","text":"std::string topicPrefix; Topic prefix.","title":"variable topicPrefix"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1FinPlugin/#variable-angle","text":"double angle; Latest fin angle in [rad].","title":"variable angle"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1FinPlugin/#variable-anglestamp","text":"common::Time angleStamp; Time stamp of latest thrust force.","title":"variable angleStamp"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1FinPlugin/#variable-currentsubscriber","text":"transport::SubscriberPtr currentSubscriber; Subcriber to current message.","title":"variable currentSubscriber"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1FinPlugin/#variable-currentvelocity","text":"ignition::math::Vector3d currentVelocity; Current velocity vector read from topic. Updated on 2022-05-30 at 18:35:12 +0000","title":"variable currentVelocity"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMBox/","text":"gazebo::HMBox Class containing the methods and attributes for a hydrodynamic model for a box in the fluid. #include <HydrodynamicModel.hh> Inherits from gazebo::HMFossen , gazebo::HydrodynamicModel , gazebo::BuoyantObject Public Functions Name HydrodynamicModel * create (sdf::ElementPtr _sdf, physics::LinkPtr _link) Create model of this type with parameter values from sdf. virtual std::string GetType () Return (derived) type of hydrodynamic model. virtual void Print (std::string _paramName, std::string _message =std::string()) Prints parameters. Protected Functions Name HMBox (sdf::ElementPtr _sdf, physics::LinkPtr _link) Constructor. Protected Attributes Name const std::string IDENTIFIER Unique identifier for this geometry. double Cd Drag coefficient. double length Length of the box. double width Width of the box. double height Height of the box. Additional inherited members Public Functions inherited from gazebo::HMFossen Name virtual bool GetParam (std::string _tag, std::vector< double > & _output) Return paramater in vector form for the given tag. virtual bool GetParam (std::string _tag, double & _output) Return paramater in scalar form for the given tag. virtual bool SetParam (std::string _tag, double _input) Set scalar parameter. virtual void ApplyHydrodynamicForces (double time, const ignition::math::Vector3d & _flowVelWorld) Computation of the hydrodynamic forces. Protected Functions inherited from gazebo::HMFossen Name HMFossen (sdf::ElementPtr _sdf, physics::LinkPtr _link) void ComputeAddedCoriolisMatrix (const Eigen::Vector6d & _vel, const Eigen::Matrix6d & _Ma, Eigen::Matrix6d & _Ca) const Computes the added-mass Coriolis matrix Ca. void ComputeDampingMatrix (const Eigen::Vector6d & _vel, Eigen::Matrix6d & _D) const Updates the damping matrix for the current velocity. Eigen::Matrix6d GetAddedMass () const Returns the added-mass matrix with the scaling and offset. Protected Attributes inherited from gazebo::HMFossen Name Eigen::Matrix6d Ma Added-mass matrix. double scalingAddedMass Scaling of the added-mass matrix. double offsetAddedMass Offset for the added-mass matrix. Eigen::Matrix6d Ca Added-mass associated Coriolis matrix. Eigen::Matrix6d D Damping matrix. double scalingDamping Scaling of the damping matrix. double offsetLinearDamping Offset for the linear damping matrix. double offsetLinForwardSpeedDamping Offset for the linear damping matrix. double offsetNonLinDamping Offset for the linear damping matrix. Eigen::Matrix6d DLin Linear damping matrix. Eigen::Matrix6d DLinForwardSpeed Linear damping matrix proportional only to the forward speed (useful for modeling AUVs). From [1], according to Newman (1977), there is a damping force component that linearly increases with the presence of forward speed, particularly so for slender bodies. Eigen::Matrix6d DNonLin Nonlinear damping coefficients. std::vector< double > linearDampCoef Linear damping coefficients. std::vector< double > quadDampCoef Quadratic damping coefficients. Public Functions inherited from gazebo::HydrodynamicModel Name virtual void ApplyHydrodynamicForces (double time, const ignition::math::Vector3d & _flowVelWorld) =0 Computation of the hydrodynamic forces. virtual bool GetParam (std::string _tag, std::vector< double > & _output) =0 Return paramater in vector form for the given tag. virtual bool GetParam (std::string _tag, double & _output) =0 Return paramater in vector form for the given tag. virtual bool SetParam (std::string _tag, double _input) =0 Set a scalar parameters. Protected Functions inherited from gazebo::HydrodynamicModel Name HydrodynamicModel (sdf::ElementPtr _sdf, physics::LinkPtr _link) Protected constructor: Use the factory for object creation. void ComputeAcc ( Eigen::Vector6d _velRel, double _time, double _alpha =0.3) Filter acceleration (fix due to the update structure of Gazebo) bool CheckParams (sdf::ElementPtr _sdf) Returns true if all parameters are available from the SDF element. ignition::math::Vector3d ToNED (ignition::math::Vector3d _vec) Convert vector to comply with the NED reference frame. ignition::math::Vector3d FromNED (ignition::math::Vector3d _vec) Convert vector to comply with the NED reference frame. Protected Attributes inherited from gazebo::HydrodynamicModel Name Eigen::Vector6d filteredAcc Filtered linear & angular acceleration vector in link frame. This is used to prevent the model to become unstable given that Gazebo only calls the update function at the beginning or at the end of a iteration of the physics engine. double lastTime Last timestamp (in seconds) at which ApplyHydrodynamicForces was called. Eigen::Vector6d lastVelRel Last body-fixed relative velocity (nu_R in Fossen's equations) std::vector< std::string > params List of parameters needed from the SDF element. double Re Reynolds number (not used by all models) double temperature Temperature (not used by all models) Public Functions inherited from gazebo::BuoyantObject Name BuoyantObject (physics::LinkPtr _link) Constructor. ~BuoyantObject () Destructor. void GetBuoyancyForce (const ignition::math::Pose3d & _pose, ignition::math::Vector3d & buoyancyForce, ignition::math::Vector3d & buoyancyTorque) Returns the buoyancy force vector in the world frame. void ApplyBuoyancyForce () Applies buoyancy force on link. void SetVolume (double _volume =-1) Sets the link's submerged volume. double GetVolume () Returns the stored link submerged volume. void SetFluidDensity (double _fluidDensity) Sets the fluid density in kg/m^3. double GetFluidDensity () Returns the stored fluid density. void SetCoB (const ignition::math::Vector3d & _centerOfBuoyancy) Sets the position of the center of buoyancy on the body frame. ignition::math::Vector3d GetCoB () Returns the stored center of buoyancy. void SetGravity (double _g) Set acceleration of gravity. double GetGravity () Get stored acceleration of gravity. void SetBoundingBox (const AxisAlignedBox & _bBox) Sets bounding box. void SetStoreVector (std::string _tag) Adds a field in the hydroWrench map. ignition::math::Vector3d GetStoredVector (std::string _tag) Get vector from the hydroWrench map. void SetDebugFlag (bool _debugOn =true) Set debug flag to store intermediate forces and torques. bool IsSubmerged () Returns true if the robot is completely submerged. bool IsNeutrallyBuoyant () Returns true if the link was set to be neutrally buoyant. bool GetDebugFlag () Returns the debug flag. void SetNeutrallyBuoyant () Sets this link as neutrally buoyant. Protected Functions inherited from gazebo::BuoyantObject Name void StoreVector (std::string _tag, ignition::math::Vector3d _vec) Store vector in the hydroWrench map if the field has been created. Protected Attributes inherited from gazebo::BuoyantObject Name double volume Volume of fluid displaced by the submerged object. double scalingVolume Scaling factor for the volume. double offsetVolume Offset for the volume. double fluidDensity Fluid density. double g Acceleration of gravity. ignition::math::Vector3d centerOfBuoyancy Center of buoyancy in the body frame. AxisAlignedBox boundingBox TEMP for calculation of the buoyancy force close to the surface. std::map< std::string, ignition::math::Vector3d > hydroWrench Storage for hydrodynamic and hydrostatic forces and torques for debugging purposes. bool debugFlag Debug flag, storing all intermediate forces and torques. bool isSubmerged Is submerged flag. physics::LinkPtr link Pointer to the correspondent robot link. bool neutrallyBuoyant If true, the restoring force will be equal to the gravitational. double metacentricWidth double metacentricLength Metacentric length of the robot, used only for surface vessels and floating objects. double waterLevelPlaneArea If the cross section area around water level of the surface vessel is not given, it will be computed from the object's bounding box. double submergedHeight Height of the robot that is submerged (only for surface vessels) bool isSurfaceVessel Flag set to true if the information about the metacentric width and height is available. bool isSurfaceVesselFloating Flag set to true if the vessel has reached its submerged height. Public Functions Documentation function create static HydrodynamicModel * create( sdf::ElementPtr _sdf, physics::LinkPtr _link ) Create model of this type with parameter values from sdf. function GetType inline virtual std::string GetType() Return (derived) type of hydrodynamic model. Reimplements : gazebo::HMFossen::GetType function Print virtual void Print( std::string _paramName, std::string _message =std::string() ) Prints parameters. Reimplements : gazebo::HMFossen::Print Protected Functions Documentation function HMBox HMBox( sdf::ElementPtr _sdf, physics::LinkPtr _link ) Constructor. Protected Attributes Documentation variable IDENTIFIER static const std::string IDENTIFIER = \"box\"; Unique identifier for this geometry. variable Cd double Cd; Drag coefficient. variable length double length; Length of the box. variable width double width; Width of the box. variable height double height; Height of the box. Updated on 2022-05-30 at 18:35:12 +0000","title":"gazebo::HMBox"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMBox/#gazebohmbox","text":"Class containing the methods and attributes for a hydrodynamic model for a box in the fluid. #include <HydrodynamicModel.hh> Inherits from gazebo::HMFossen , gazebo::HydrodynamicModel , gazebo::BuoyantObject","title":"gazebo::HMBox"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMBox/#public-functions","text":"Name HydrodynamicModel * create (sdf::ElementPtr _sdf, physics::LinkPtr _link) Create model of this type with parameter values from sdf. virtual std::string GetType () Return (derived) type of hydrodynamic model. virtual void Print (std::string _paramName, std::string _message =std::string()) Prints parameters.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMBox/#protected-functions","text":"Name HMBox (sdf::ElementPtr _sdf, physics::LinkPtr _link) Constructor.","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMBox/#protected-attributes","text":"Name const std::string IDENTIFIER Unique identifier for this geometry. double Cd Drag coefficient. double length Length of the box. double width Width of the box. double height Height of the box.","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMBox/#additional-inherited-members","text":"Public Functions inherited from gazebo::HMFossen Name virtual bool GetParam (std::string _tag, std::vector< double > & _output) Return paramater in vector form for the given tag. virtual bool GetParam (std::string _tag, double & _output) Return paramater in scalar form for the given tag. virtual bool SetParam (std::string _tag, double _input) Set scalar parameter. virtual void ApplyHydrodynamicForces (double time, const ignition::math::Vector3d & _flowVelWorld) Computation of the hydrodynamic forces. Protected Functions inherited from gazebo::HMFossen Name HMFossen (sdf::ElementPtr _sdf, physics::LinkPtr _link) void ComputeAddedCoriolisMatrix (const Eigen::Vector6d & _vel, const Eigen::Matrix6d & _Ma, Eigen::Matrix6d & _Ca) const Computes the added-mass Coriolis matrix Ca. void ComputeDampingMatrix (const Eigen::Vector6d & _vel, Eigen::Matrix6d & _D) const Updates the damping matrix for the current velocity. Eigen::Matrix6d GetAddedMass () const Returns the added-mass matrix with the scaling and offset. Protected Attributes inherited from gazebo::HMFossen Name Eigen::Matrix6d Ma Added-mass matrix. double scalingAddedMass Scaling of the added-mass matrix. double offsetAddedMass Offset for the added-mass matrix. Eigen::Matrix6d Ca Added-mass associated Coriolis matrix. Eigen::Matrix6d D Damping matrix. double scalingDamping Scaling of the damping matrix. double offsetLinearDamping Offset for the linear damping matrix. double offsetLinForwardSpeedDamping Offset for the linear damping matrix. double offsetNonLinDamping Offset for the linear damping matrix. Eigen::Matrix6d DLin Linear damping matrix. Eigen::Matrix6d DLinForwardSpeed Linear damping matrix proportional only to the forward speed (useful for modeling AUVs). From [1], according to Newman (1977), there is a damping force component that linearly increases with the presence of forward speed, particularly so for slender bodies. Eigen::Matrix6d DNonLin Nonlinear damping coefficients. std::vector< double > linearDampCoef Linear damping coefficients. std::vector< double > quadDampCoef Quadratic damping coefficients. Public Functions inherited from gazebo::HydrodynamicModel Name virtual void ApplyHydrodynamicForces (double time, const ignition::math::Vector3d & _flowVelWorld) =0 Computation of the hydrodynamic forces. virtual bool GetParam (std::string _tag, std::vector< double > & _output) =0 Return paramater in vector form for the given tag. virtual bool GetParam (std::string _tag, double & _output) =0 Return paramater in vector form for the given tag. virtual bool SetParam (std::string _tag, double _input) =0 Set a scalar parameters. Protected Functions inherited from gazebo::HydrodynamicModel Name HydrodynamicModel (sdf::ElementPtr _sdf, physics::LinkPtr _link) Protected constructor: Use the factory for object creation. void ComputeAcc ( Eigen::Vector6d _velRel, double _time, double _alpha =0.3) Filter acceleration (fix due to the update structure of Gazebo) bool CheckParams (sdf::ElementPtr _sdf) Returns true if all parameters are available from the SDF element. ignition::math::Vector3d ToNED (ignition::math::Vector3d _vec) Convert vector to comply with the NED reference frame. ignition::math::Vector3d FromNED (ignition::math::Vector3d _vec) Convert vector to comply with the NED reference frame. Protected Attributes inherited from gazebo::HydrodynamicModel Name Eigen::Vector6d filteredAcc Filtered linear & angular acceleration vector in link frame. This is used to prevent the model to become unstable given that Gazebo only calls the update function at the beginning or at the end of a iteration of the physics engine. double lastTime Last timestamp (in seconds) at which ApplyHydrodynamicForces was called. Eigen::Vector6d lastVelRel Last body-fixed relative velocity (nu_R in Fossen's equations) std::vector< std::string > params List of parameters needed from the SDF element. double Re Reynolds number (not used by all models) double temperature Temperature (not used by all models) Public Functions inherited from gazebo::BuoyantObject Name BuoyantObject (physics::LinkPtr _link) Constructor. ~BuoyantObject () Destructor. void GetBuoyancyForce (const ignition::math::Pose3d & _pose, ignition::math::Vector3d & buoyancyForce, ignition::math::Vector3d & buoyancyTorque) Returns the buoyancy force vector in the world frame. void ApplyBuoyancyForce () Applies buoyancy force on link. void SetVolume (double _volume =-1) Sets the link's submerged volume. double GetVolume () Returns the stored link submerged volume. void SetFluidDensity (double _fluidDensity) Sets the fluid density in kg/m^3. double GetFluidDensity () Returns the stored fluid density. void SetCoB (const ignition::math::Vector3d & _centerOfBuoyancy) Sets the position of the center of buoyancy on the body frame. ignition::math::Vector3d GetCoB () Returns the stored center of buoyancy. void SetGravity (double _g) Set acceleration of gravity. double GetGravity () Get stored acceleration of gravity. void SetBoundingBox (const AxisAlignedBox & _bBox) Sets bounding box. void SetStoreVector (std::string _tag) Adds a field in the hydroWrench map. ignition::math::Vector3d GetStoredVector (std::string _tag) Get vector from the hydroWrench map. void SetDebugFlag (bool _debugOn =true) Set debug flag to store intermediate forces and torques. bool IsSubmerged () Returns true if the robot is completely submerged. bool IsNeutrallyBuoyant () Returns true if the link was set to be neutrally buoyant. bool GetDebugFlag () Returns the debug flag. void SetNeutrallyBuoyant () Sets this link as neutrally buoyant. Protected Functions inherited from gazebo::BuoyantObject Name void StoreVector (std::string _tag, ignition::math::Vector3d _vec) Store vector in the hydroWrench map if the field has been created. Protected Attributes inherited from gazebo::BuoyantObject Name double volume Volume of fluid displaced by the submerged object. double scalingVolume Scaling factor for the volume. double offsetVolume Offset for the volume. double fluidDensity Fluid density. double g Acceleration of gravity. ignition::math::Vector3d centerOfBuoyancy Center of buoyancy in the body frame. AxisAlignedBox boundingBox TEMP for calculation of the buoyancy force close to the surface. std::map< std::string, ignition::math::Vector3d > hydroWrench Storage for hydrodynamic and hydrostatic forces and torques for debugging purposes. bool debugFlag Debug flag, storing all intermediate forces and torques. bool isSubmerged Is submerged flag. physics::LinkPtr link Pointer to the correspondent robot link. bool neutrallyBuoyant If true, the restoring force will be equal to the gravitational. double metacentricWidth double metacentricLength Metacentric length of the robot, used only for surface vessels and floating objects. double waterLevelPlaneArea If the cross section area around water level of the surface vessel is not given, it will be computed from the object's bounding box. double submergedHeight Height of the robot that is submerged (only for surface vessels) bool isSurfaceVessel Flag set to true if the information about the metacentric width and height is available. bool isSurfaceVesselFloating Flag set to true if the vessel has reached its submerged height.","title":"Additional inherited members"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMBox/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMBox/#function-create","text":"static HydrodynamicModel * create( sdf::ElementPtr _sdf, physics::LinkPtr _link ) Create model of this type with parameter values from sdf.","title":"function create"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMBox/#function-gettype","text":"inline virtual std::string GetType() Return (derived) type of hydrodynamic model. Reimplements : gazebo::HMFossen::GetType","title":"function GetType"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMBox/#function-print","text":"virtual void Print( std::string _paramName, std::string _message =std::string() ) Prints parameters. Reimplements : gazebo::HMFossen::Print","title":"function Print"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMBox/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMBox/#function-hmbox","text":"HMBox( sdf::ElementPtr _sdf, physics::LinkPtr _link ) Constructor.","title":"function HMBox"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMBox/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMBox/#variable-identifier","text":"static const std::string IDENTIFIER = \"box\"; Unique identifier for this geometry.","title":"variable IDENTIFIER"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMBox/#variable-cd","text":"double Cd; Drag coefficient.","title":"variable Cd"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMBox/#variable-length","text":"double length; Length of the box.","title":"variable length"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMBox/#variable-width","text":"double width; Width of the box.","title":"variable width"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMBox/#variable-height","text":"double height; Height of the box. Updated on 2022-05-30 at 18:35:12 +0000","title":"variable height"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMCylinder/","text":"gazebo::HMCylinder Class containing the methods and attributes for a hydrodynamic model for a cylinder in the fluid. #include <HydrodynamicModel.hh> Inherits from gazebo::HMFossen , gazebo::HydrodynamicModel , gazebo::BuoyantObject Public Functions Name HydrodynamicModel * create (sdf::ElementPtr _sdf, physics::LinkPtr _link) Create model of this type with parameter values from sdf. virtual std::string GetType () Return (derived) type of hydrodynamic model. virtual void Print (std::string _paramName, std::string _message =std::string()) Prints parameters. Protected Functions Name HMCylinder (sdf::ElementPtr _sdf, physics::LinkPtr _link) Protected Attributes Name const std::string IDENTIFIER Unique identifier for this geometry. double length Length of the cylinder. double radius Sphere radius. std::string axis Name of the unit rotation axis (just a tag for x, y or z) double dimRatio Ratio between length and diameter. double cdCirc Approximated drag coefficient for the circular area. double cdLength Approximated drag coefficient for the rectangular section. Additional inherited members Public Functions inherited from gazebo::HMFossen Name virtual bool GetParam (std::string _tag, std::vector< double > & _output) Return paramater in vector form for the given tag. virtual bool GetParam (std::string _tag, double & _output) Return paramater in scalar form for the given tag. virtual bool SetParam (std::string _tag, double _input) Set scalar parameter. virtual void ApplyHydrodynamicForces (double time, const ignition::math::Vector3d & _flowVelWorld) Computation of the hydrodynamic forces. Protected Functions inherited from gazebo::HMFossen Name HMFossen (sdf::ElementPtr _sdf, physics::LinkPtr _link) void ComputeAddedCoriolisMatrix (const Eigen::Vector6d & _vel, const Eigen::Matrix6d & _Ma, Eigen::Matrix6d & _Ca) const Computes the added-mass Coriolis matrix Ca. void ComputeDampingMatrix (const Eigen::Vector6d & _vel, Eigen::Matrix6d & _D) const Updates the damping matrix for the current velocity. Eigen::Matrix6d GetAddedMass () const Returns the added-mass matrix with the scaling and offset. Protected Attributes inherited from gazebo::HMFossen Name Eigen::Matrix6d Ma Added-mass matrix. double scalingAddedMass Scaling of the added-mass matrix. double offsetAddedMass Offset for the added-mass matrix. Eigen::Matrix6d Ca Added-mass associated Coriolis matrix. Eigen::Matrix6d D Damping matrix. double scalingDamping Scaling of the damping matrix. double offsetLinearDamping Offset for the linear damping matrix. double offsetLinForwardSpeedDamping Offset for the linear damping matrix. double offsetNonLinDamping Offset for the linear damping matrix. Eigen::Matrix6d DLin Linear damping matrix. Eigen::Matrix6d DLinForwardSpeed Linear damping matrix proportional only to the forward speed (useful for modeling AUVs). From [1], according to Newman (1977), there is a damping force component that linearly increases with the presence of forward speed, particularly so for slender bodies. Eigen::Matrix6d DNonLin Nonlinear damping coefficients. std::vector< double > linearDampCoef Linear damping coefficients. std::vector< double > quadDampCoef Quadratic damping coefficients. Public Functions inherited from gazebo::HydrodynamicModel Name virtual void ApplyHydrodynamicForces (double time, const ignition::math::Vector3d & _flowVelWorld) =0 Computation of the hydrodynamic forces. virtual bool GetParam (std::string _tag, std::vector< double > & _output) =0 Return paramater in vector form for the given tag. virtual bool GetParam (std::string _tag, double & _output) =0 Return paramater in vector form for the given tag. virtual bool SetParam (std::string _tag, double _input) =0 Set a scalar parameters. Protected Functions inherited from gazebo::HydrodynamicModel Name HydrodynamicModel (sdf::ElementPtr _sdf, physics::LinkPtr _link) Protected constructor: Use the factory for object creation. void ComputeAcc ( Eigen::Vector6d _velRel, double _time, double _alpha =0.3) Filter acceleration (fix due to the update structure of Gazebo) bool CheckParams (sdf::ElementPtr _sdf) Returns true if all parameters are available from the SDF element. ignition::math::Vector3d ToNED (ignition::math::Vector3d _vec) Convert vector to comply with the NED reference frame. ignition::math::Vector3d FromNED (ignition::math::Vector3d _vec) Convert vector to comply with the NED reference frame. Protected Attributes inherited from gazebo::HydrodynamicModel Name Eigen::Vector6d filteredAcc Filtered linear & angular acceleration vector in link frame. This is used to prevent the model to become unstable given that Gazebo only calls the update function at the beginning or at the end of a iteration of the physics engine. double lastTime Last timestamp (in seconds) at which ApplyHydrodynamicForces was called. Eigen::Vector6d lastVelRel Last body-fixed relative velocity (nu_R in Fossen's equations) std::vector< std::string > params List of parameters needed from the SDF element. double Re Reynolds number (not used by all models) double temperature Temperature (not used by all models) Public Functions inherited from gazebo::BuoyantObject Name BuoyantObject (physics::LinkPtr _link) Constructor. ~BuoyantObject () Destructor. void GetBuoyancyForce (const ignition::math::Pose3d & _pose, ignition::math::Vector3d & buoyancyForce, ignition::math::Vector3d & buoyancyTorque) Returns the buoyancy force vector in the world frame. void ApplyBuoyancyForce () Applies buoyancy force on link. void SetVolume (double _volume =-1) Sets the link's submerged volume. double GetVolume () Returns the stored link submerged volume. void SetFluidDensity (double _fluidDensity) Sets the fluid density in kg/m^3. double GetFluidDensity () Returns the stored fluid density. void SetCoB (const ignition::math::Vector3d & _centerOfBuoyancy) Sets the position of the center of buoyancy on the body frame. ignition::math::Vector3d GetCoB () Returns the stored center of buoyancy. void SetGravity (double _g) Set acceleration of gravity. double GetGravity () Get stored acceleration of gravity. void SetBoundingBox (const AxisAlignedBox & _bBox) Sets bounding box. void SetStoreVector (std::string _tag) Adds a field in the hydroWrench map. ignition::math::Vector3d GetStoredVector (std::string _tag) Get vector from the hydroWrench map. void SetDebugFlag (bool _debugOn =true) Set debug flag to store intermediate forces and torques. bool IsSubmerged () Returns true if the robot is completely submerged. bool IsNeutrallyBuoyant () Returns true if the link was set to be neutrally buoyant. bool GetDebugFlag () Returns the debug flag. void SetNeutrallyBuoyant () Sets this link as neutrally buoyant. Protected Functions inherited from gazebo::BuoyantObject Name void StoreVector (std::string _tag, ignition::math::Vector3d _vec) Store vector in the hydroWrench map if the field has been created. Protected Attributes inherited from gazebo::BuoyantObject Name double volume Volume of fluid displaced by the submerged object. double scalingVolume Scaling factor for the volume. double offsetVolume Offset for the volume. double fluidDensity Fluid density. double g Acceleration of gravity. ignition::math::Vector3d centerOfBuoyancy Center of buoyancy in the body frame. AxisAlignedBox boundingBox TEMP for calculation of the buoyancy force close to the surface. std::map< std::string, ignition::math::Vector3d > hydroWrench Storage for hydrodynamic and hydrostatic forces and torques for debugging purposes. bool debugFlag Debug flag, storing all intermediate forces and torques. bool isSubmerged Is submerged flag. physics::LinkPtr link Pointer to the correspondent robot link. bool neutrallyBuoyant If true, the restoring force will be equal to the gravitational. double metacentricWidth double metacentricLength Metacentric length of the robot, used only for surface vessels and floating objects. double waterLevelPlaneArea If the cross section area around water level of the surface vessel is not given, it will be computed from the object's bounding box. double submergedHeight Height of the robot that is submerged (only for surface vessels) bool isSurfaceVessel Flag set to true if the information about the metacentric width and height is available. bool isSurfaceVesselFloating Flag set to true if the vessel has reached its submerged height. Public Functions Documentation function create static HydrodynamicModel * create( sdf::ElementPtr _sdf, physics::LinkPtr _link ) Create model of this type with parameter values from sdf. function GetType inline virtual std::string GetType() Return (derived) type of hydrodynamic model. Reimplements : gazebo::HMFossen::GetType function Print virtual void Print( std::string _paramName, std::string _message =std::string() ) Prints parameters. Reimplements : gazebo::HMFossen::Print Protected Functions Documentation function HMCylinder HMCylinder( sdf::ElementPtr _sdf, physics::LinkPtr _link ) Protected Attributes Documentation variable IDENTIFIER static const std::string IDENTIFIER = \"cylinder\"; Unique identifier for this geometry. variable length double length; Length of the cylinder. variable radius double radius; Sphere radius. variable axis std::string axis; Name of the unit rotation axis (just a tag for x, y or z) variable dimRatio double dimRatio; Ratio between length and diameter. variable cdCirc double cdCirc; Approximated drag coefficient for the circular area. variable cdLength double cdLength; Approximated drag coefficient for the rectangular section. Updated on 2022-05-30 at 18:35:12 +0000","title":"gazebo::HMCylinder"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMCylinder/#gazebohmcylinder","text":"Class containing the methods and attributes for a hydrodynamic model for a cylinder in the fluid. #include <HydrodynamicModel.hh> Inherits from gazebo::HMFossen , gazebo::HydrodynamicModel , gazebo::BuoyantObject","title":"gazebo::HMCylinder"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMCylinder/#public-functions","text":"Name HydrodynamicModel * create (sdf::ElementPtr _sdf, physics::LinkPtr _link) Create model of this type with parameter values from sdf. virtual std::string GetType () Return (derived) type of hydrodynamic model. virtual void Print (std::string _paramName, std::string _message =std::string()) Prints parameters.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMCylinder/#protected-functions","text":"Name HMCylinder (sdf::ElementPtr _sdf, physics::LinkPtr _link)","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMCylinder/#protected-attributes","text":"Name const std::string IDENTIFIER Unique identifier for this geometry. double length Length of the cylinder. double radius Sphere radius. std::string axis Name of the unit rotation axis (just a tag for x, y or z) double dimRatio Ratio between length and diameter. double cdCirc Approximated drag coefficient for the circular area. double cdLength Approximated drag coefficient for the rectangular section.","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMCylinder/#additional-inherited-members","text":"Public Functions inherited from gazebo::HMFossen Name virtual bool GetParam (std::string _tag, std::vector< double > & _output) Return paramater in vector form for the given tag. virtual bool GetParam (std::string _tag, double & _output) Return paramater in scalar form for the given tag. virtual bool SetParam (std::string _tag, double _input) Set scalar parameter. virtual void ApplyHydrodynamicForces (double time, const ignition::math::Vector3d & _flowVelWorld) Computation of the hydrodynamic forces. Protected Functions inherited from gazebo::HMFossen Name HMFossen (sdf::ElementPtr _sdf, physics::LinkPtr _link) void ComputeAddedCoriolisMatrix (const Eigen::Vector6d & _vel, const Eigen::Matrix6d & _Ma, Eigen::Matrix6d & _Ca) const Computes the added-mass Coriolis matrix Ca. void ComputeDampingMatrix (const Eigen::Vector6d & _vel, Eigen::Matrix6d & _D) const Updates the damping matrix for the current velocity. Eigen::Matrix6d GetAddedMass () const Returns the added-mass matrix with the scaling and offset. Protected Attributes inherited from gazebo::HMFossen Name Eigen::Matrix6d Ma Added-mass matrix. double scalingAddedMass Scaling of the added-mass matrix. double offsetAddedMass Offset for the added-mass matrix. Eigen::Matrix6d Ca Added-mass associated Coriolis matrix. Eigen::Matrix6d D Damping matrix. double scalingDamping Scaling of the damping matrix. double offsetLinearDamping Offset for the linear damping matrix. double offsetLinForwardSpeedDamping Offset for the linear damping matrix. double offsetNonLinDamping Offset for the linear damping matrix. Eigen::Matrix6d DLin Linear damping matrix. Eigen::Matrix6d DLinForwardSpeed Linear damping matrix proportional only to the forward speed (useful for modeling AUVs). From [1], according to Newman (1977), there is a damping force component that linearly increases with the presence of forward speed, particularly so for slender bodies. Eigen::Matrix6d DNonLin Nonlinear damping coefficients. std::vector< double > linearDampCoef Linear damping coefficients. std::vector< double > quadDampCoef Quadratic damping coefficients. Public Functions inherited from gazebo::HydrodynamicModel Name virtual void ApplyHydrodynamicForces (double time, const ignition::math::Vector3d & _flowVelWorld) =0 Computation of the hydrodynamic forces. virtual bool GetParam (std::string _tag, std::vector< double > & _output) =0 Return paramater in vector form for the given tag. virtual bool GetParam (std::string _tag, double & _output) =0 Return paramater in vector form for the given tag. virtual bool SetParam (std::string _tag, double _input) =0 Set a scalar parameters. Protected Functions inherited from gazebo::HydrodynamicModel Name HydrodynamicModel (sdf::ElementPtr _sdf, physics::LinkPtr _link) Protected constructor: Use the factory for object creation. void ComputeAcc ( Eigen::Vector6d _velRel, double _time, double _alpha =0.3) Filter acceleration (fix due to the update structure of Gazebo) bool CheckParams (sdf::ElementPtr _sdf) Returns true if all parameters are available from the SDF element. ignition::math::Vector3d ToNED (ignition::math::Vector3d _vec) Convert vector to comply with the NED reference frame. ignition::math::Vector3d FromNED (ignition::math::Vector3d _vec) Convert vector to comply with the NED reference frame. Protected Attributes inherited from gazebo::HydrodynamicModel Name Eigen::Vector6d filteredAcc Filtered linear & angular acceleration vector in link frame. This is used to prevent the model to become unstable given that Gazebo only calls the update function at the beginning or at the end of a iteration of the physics engine. double lastTime Last timestamp (in seconds) at which ApplyHydrodynamicForces was called. Eigen::Vector6d lastVelRel Last body-fixed relative velocity (nu_R in Fossen's equations) std::vector< std::string > params List of parameters needed from the SDF element. double Re Reynolds number (not used by all models) double temperature Temperature (not used by all models) Public Functions inherited from gazebo::BuoyantObject Name BuoyantObject (physics::LinkPtr _link) Constructor. ~BuoyantObject () Destructor. void GetBuoyancyForce (const ignition::math::Pose3d & _pose, ignition::math::Vector3d & buoyancyForce, ignition::math::Vector3d & buoyancyTorque) Returns the buoyancy force vector in the world frame. void ApplyBuoyancyForce () Applies buoyancy force on link. void SetVolume (double _volume =-1) Sets the link's submerged volume. double GetVolume () Returns the stored link submerged volume. void SetFluidDensity (double _fluidDensity) Sets the fluid density in kg/m^3. double GetFluidDensity () Returns the stored fluid density. void SetCoB (const ignition::math::Vector3d & _centerOfBuoyancy) Sets the position of the center of buoyancy on the body frame. ignition::math::Vector3d GetCoB () Returns the stored center of buoyancy. void SetGravity (double _g) Set acceleration of gravity. double GetGravity () Get stored acceleration of gravity. void SetBoundingBox (const AxisAlignedBox & _bBox) Sets bounding box. void SetStoreVector (std::string _tag) Adds a field in the hydroWrench map. ignition::math::Vector3d GetStoredVector (std::string _tag) Get vector from the hydroWrench map. void SetDebugFlag (bool _debugOn =true) Set debug flag to store intermediate forces and torques. bool IsSubmerged () Returns true if the robot is completely submerged. bool IsNeutrallyBuoyant () Returns true if the link was set to be neutrally buoyant. bool GetDebugFlag () Returns the debug flag. void SetNeutrallyBuoyant () Sets this link as neutrally buoyant. Protected Functions inherited from gazebo::BuoyantObject Name void StoreVector (std::string _tag, ignition::math::Vector3d _vec) Store vector in the hydroWrench map if the field has been created. Protected Attributes inherited from gazebo::BuoyantObject Name double volume Volume of fluid displaced by the submerged object. double scalingVolume Scaling factor for the volume. double offsetVolume Offset for the volume. double fluidDensity Fluid density. double g Acceleration of gravity. ignition::math::Vector3d centerOfBuoyancy Center of buoyancy in the body frame. AxisAlignedBox boundingBox TEMP for calculation of the buoyancy force close to the surface. std::map< std::string, ignition::math::Vector3d > hydroWrench Storage for hydrodynamic and hydrostatic forces and torques for debugging purposes. bool debugFlag Debug flag, storing all intermediate forces and torques. bool isSubmerged Is submerged flag. physics::LinkPtr link Pointer to the correspondent robot link. bool neutrallyBuoyant If true, the restoring force will be equal to the gravitational. double metacentricWidth double metacentricLength Metacentric length of the robot, used only for surface vessels and floating objects. double waterLevelPlaneArea If the cross section area around water level of the surface vessel is not given, it will be computed from the object's bounding box. double submergedHeight Height of the robot that is submerged (only for surface vessels) bool isSurfaceVessel Flag set to true if the information about the metacentric width and height is available. bool isSurfaceVesselFloating Flag set to true if the vessel has reached its submerged height.","title":"Additional inherited members"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMCylinder/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMCylinder/#function-create","text":"static HydrodynamicModel * create( sdf::ElementPtr _sdf, physics::LinkPtr _link ) Create model of this type with parameter values from sdf.","title":"function create"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMCylinder/#function-gettype","text":"inline virtual std::string GetType() Return (derived) type of hydrodynamic model. Reimplements : gazebo::HMFossen::GetType","title":"function GetType"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMCylinder/#function-print","text":"virtual void Print( std::string _paramName, std::string _message =std::string() ) Prints parameters. Reimplements : gazebo::HMFossen::Print","title":"function Print"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMCylinder/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMCylinder/#function-hmcylinder","text":"HMCylinder( sdf::ElementPtr _sdf, physics::LinkPtr _link )","title":"function HMCylinder"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMCylinder/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMCylinder/#variable-identifier","text":"static const std::string IDENTIFIER = \"cylinder\"; Unique identifier for this geometry.","title":"variable IDENTIFIER"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMCylinder/#variable-length","text":"double length; Length of the cylinder.","title":"variable length"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMCylinder/#variable-radius","text":"double radius; Sphere radius.","title":"variable radius"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMCylinder/#variable-axis","text":"std::string axis; Name of the unit rotation axis (just a tag for x, y or z)","title":"variable axis"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMCylinder/#variable-dimratio","text":"double dimRatio; Ratio between length and diameter.","title":"variable dimRatio"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMCylinder/#variable-cdcirc","text":"double cdCirc; Approximated drag coefficient for the circular area.","title":"variable cdCirc"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMCylinder/#variable-cdlength","text":"double cdLength; Approximated drag coefficient for the rectangular section. Updated on 2022-05-30 at 18:35:12 +0000","title":"variable cdLength"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/","text":"title: gazebo::HMFossen summary: Class containting the methods and attributes for a Fossen robot-like hydrodynamic model. The restoring forces are applied by the BuoyantObject class methods. Using the plugin for UUV models will use both this and the buoyant object class definitions, therefore the restoring forces were not inherited here. References: gazebo::HMFossen Class containting the methods and attributes for a Fossen robot-like hydrodynamic model. The restoring forces are applied by the BuoyantObject class methods. Using the plugin for UUV models will use both this and the buoyant object class definitions, therefore the restoring forces were not inherited here. References: More... #include <HydrodynamicModel.hh> Inherits from gazebo::HydrodynamicModel , gazebo::BuoyantObject Inherited by gazebo::HMBox , gazebo::HMCylinder , gazebo::HMSphere , gazebo::HMSpheroid Public Functions Name HydrodynamicModel * create (sdf::ElementPtr _sdf, physics::LinkPtr _link) Create model of this type with parameter values from sdf. virtual std::string GetType () Return (derived) type of hydrodynamic model. virtual void Print (std::string _paramName, std::string _message =std::string()) Prints parameters. virtual bool GetParam (std::string _tag, std::vector< double > & _output) Return paramater in vector form for the given tag. virtual bool GetParam (std::string _tag, double & _output) Return paramater in scalar form for the given tag. virtual bool SetParam (std::string _tag, double _input) Set scalar parameter. virtual void ApplyHydrodynamicForces (double time, const ignition::math::Vector3d & _flowVelWorld) Computation of the hydrodynamic forces. Protected Functions Name REGISTER_HYDRODYNAMICMODEL ( HMFossen ) Register this model with the factory. HMFossen (sdf::ElementPtr _sdf, physics::LinkPtr _link) void ComputeAddedCoriolisMatrix (const Eigen::Vector6d & _vel, const Eigen::Matrix6d & _Ma, Eigen::Matrix6d & _Ca) const Computes the added-mass Coriolis matrix Ca. void ComputeDampingMatrix (const Eigen::Vector6d & _vel, Eigen::Matrix6d & _D) const Updates the damping matrix for the current velocity. Eigen::Matrix6d GetAddedMass () const Returns the added-mass matrix with the scaling and offset. Protected Attributes Name const std::string IDENTIFIER Unique identifier for this geometry. Eigen::Matrix6d Ma Added-mass matrix. double scalingAddedMass Scaling of the added-mass matrix. double offsetAddedMass Offset for the added-mass matrix. Eigen::Matrix6d Ca Added-mass associated Coriolis matrix. Eigen::Matrix6d D Damping matrix. double scalingDamping Scaling of the damping matrix. double offsetLinearDamping Offset for the linear damping matrix. double offsetLinForwardSpeedDamping Offset for the linear damping matrix. double offsetNonLinDamping Offset for the linear damping matrix. Eigen::Matrix6d DLin Linear damping matrix. Eigen::Matrix6d DLinForwardSpeed Linear damping matrix proportional only to the forward speed (useful for modeling AUVs). From [1], according to Newman (1977), there is a damping force component that linearly increases with the presence of forward speed, particularly so for slender bodies. Eigen::Matrix6d DNonLin Nonlinear damping coefficients. std::vector< double > linearDampCoef Linear damping coefficients. std::vector< double > quadDampCoef Quadratic damping coefficients. Additional inherited members Protected Functions inherited from gazebo::HydrodynamicModel Name HydrodynamicModel (sdf::ElementPtr _sdf, physics::LinkPtr _link) Protected constructor: Use the factory for object creation. void ComputeAcc ( Eigen::Vector6d _velRel, double _time, double _alpha =0.3) Filter acceleration (fix due to the update structure of Gazebo) bool CheckParams (sdf::ElementPtr _sdf) Returns true if all parameters are available from the SDF element. ignition::math::Vector3d ToNED (ignition::math::Vector3d _vec) Convert vector to comply with the NED reference frame. ignition::math::Vector3d FromNED (ignition::math::Vector3d _vec) Convert vector to comply with the NED reference frame. Protected Attributes inherited from gazebo::HydrodynamicModel Name Eigen::Vector6d filteredAcc Filtered linear & angular acceleration vector in link frame. This is used to prevent the model to become unstable given that Gazebo only calls the update function at the beginning or at the end of a iteration of the physics engine. double lastTime Last timestamp (in seconds) at which ApplyHydrodynamicForces was called. Eigen::Vector6d lastVelRel Last body-fixed relative velocity (nu_R in Fossen's equations) std::vector< std::string > params List of parameters needed from the SDF element. double Re Reynolds number (not used by all models) double temperature Temperature (not used by all models) Public Functions inherited from gazebo::BuoyantObject Name BuoyantObject (physics::LinkPtr _link) Constructor. ~BuoyantObject () Destructor. void GetBuoyancyForce (const ignition::math::Pose3d & _pose, ignition::math::Vector3d & buoyancyForce, ignition::math::Vector3d & buoyancyTorque) Returns the buoyancy force vector in the world frame. void ApplyBuoyancyForce () Applies buoyancy force on link. void SetVolume (double _volume =-1) Sets the link's submerged volume. double GetVolume () Returns the stored link submerged volume. void SetFluidDensity (double _fluidDensity) Sets the fluid density in kg/m^3. double GetFluidDensity () Returns the stored fluid density. void SetCoB (const ignition::math::Vector3d & _centerOfBuoyancy) Sets the position of the center of buoyancy on the body frame. ignition::math::Vector3d GetCoB () Returns the stored center of buoyancy. void SetGravity (double _g) Set acceleration of gravity. double GetGravity () Get stored acceleration of gravity. void SetBoundingBox (const AxisAlignedBox & _bBox) Sets bounding box. void SetStoreVector (std::string _tag) Adds a field in the hydroWrench map. ignition::math::Vector3d GetStoredVector (std::string _tag) Get vector from the hydroWrench map. void SetDebugFlag (bool _debugOn =true) Set debug flag to store intermediate forces and torques. bool IsSubmerged () Returns true if the robot is completely submerged. bool IsNeutrallyBuoyant () Returns true if the link was set to be neutrally buoyant. bool GetDebugFlag () Returns the debug flag. void SetNeutrallyBuoyant () Sets this link as neutrally buoyant. Protected Functions inherited from gazebo::BuoyantObject Name void StoreVector (std::string _tag, ignition::math::Vector3d _vec) Store vector in the hydroWrench map if the field has been created. Protected Attributes inherited from gazebo::BuoyantObject Name double volume Volume of fluid displaced by the submerged object. double scalingVolume Scaling factor for the volume. double offsetVolume Offset for the volume. double fluidDensity Fluid density. double g Acceleration of gravity. ignition::math::Vector3d centerOfBuoyancy Center of buoyancy in the body frame. AxisAlignedBox boundingBox TEMP for calculation of the buoyancy force close to the surface. std::map< std::string, ignition::math::Vector3d > hydroWrench Storage for hydrodynamic and hydrostatic forces and torques for debugging purposes. bool debugFlag Debug flag, storing all intermediate forces and torques. bool isSubmerged Is submerged flag. physics::LinkPtr link Pointer to the correspondent robot link. bool neutrallyBuoyant If true, the restoring force will be equal to the gravitational. double metacentricWidth double metacentricLength Metacentric length of the robot, used only for surface vessels and floating objects. double waterLevelPlaneArea If the cross section area around water level of the surface vessel is not given, it will be computed from the object's bounding box. double submergedHeight Height of the robot that is submerged (only for surface vessels) bool isSurfaceVessel Flag set to true if the information about the metacentric width and height is available. bool isSurfaceVesselFloating Flag set to true if the vessel has reached its submerged height. Detailed Description class gazebo::HMFossen; Class containting the methods and attributes for a Fossen robot-like hydrodynamic model. The restoring forces are applied by the BuoyantObject class methods. Using the plugin for UUV models will use both this and the buoyant object class definitions, therefore the restoring forces were not inherited here. References: Fossen, Thor, \"Handbook of Marine Craft and Hydrodynamics and Motion Control\", 2011 Public Functions Documentation function create static HydrodynamicModel * create( sdf::ElementPtr _sdf, physics::LinkPtr _link ) Create model of this type with parameter values from sdf. function GetType inline virtual std::string GetType() Return (derived) type of hydrodynamic model. Reimplements : gazebo::HydrodynamicModel::GetType Reimplemented by : gazebo::HMSphere::GetType , gazebo::HMCylinder::GetType , gazebo::HMSpheroid::GetType , gazebo::HMBox::GetType function Print virtual void Print( std::string _paramName, std::string _message =std::string() ) Prints parameters. Reimplements : gazebo::HydrodynamicModel::Print Reimplemented by : gazebo::HMSphere::Print , gazebo::HMCylinder::Print , gazebo::HMSpheroid::Print , gazebo::HMBox::Print function GetParam virtual bool GetParam( std::string _tag, std::vector< double > & _output ) Return paramater in vector form for the given tag. Reimplements : gazebo::HydrodynamicModel::GetParam function GetParam virtual bool GetParam( std::string _tag, double & _output ) Return paramater in scalar form for the given tag. Reimplements : gazebo::HydrodynamicModel::GetParam function SetParam virtual bool SetParam( std::string _tag, double _input ) Set scalar parameter. Reimplements : gazebo::HydrodynamicModel::SetParam function ApplyHydrodynamicForces virtual void ApplyHydrodynamicForces( double time, const ignition::math::Vector3d & _flowVelWorld ) Computation of the hydrodynamic forces. Reimplements : gazebo::HydrodynamicModel::ApplyHydrodynamicForces Protected Functions Documentation function REGISTER_HYDRODYNAMICMODEL REGISTER_HYDRODYNAMICMODEL( HMFossen ) Register this model with the factory. function HMFossen HMFossen( sdf::ElementPtr _sdf, physics::LinkPtr _link ) function ComputeAddedCoriolisMatrix void ComputeAddedCoriolisMatrix( const Eigen::Vector6d & _vel, const Eigen::Matrix6d & _Ma, Eigen::Matrix6d & _Ca ) const Computes the added-mass Coriolis matrix Ca. function ComputeDampingMatrix void ComputeDampingMatrix( const Eigen::Vector6d & _vel, Eigen::Matrix6d & _D ) const Updates the damping matrix for the current velocity. function GetAddedMass Eigen::Matrix6d GetAddedMass() const Returns the added-mass matrix with the scaling and offset. Protected Attributes Documentation variable IDENTIFIER static const std::string IDENTIFIER = \"fossen\"; Unique identifier for this geometry. variable Ma Eigen::Matrix6d Ma; Added-mass matrix. variable scalingAddedMass double scalingAddedMass; Scaling of the added-mass matrix. variable offsetAddedMass double offsetAddedMass; Offset for the added-mass matrix. variable Ca Eigen::Matrix6d Ca; Added-mass associated Coriolis matrix. variable D Eigen::Matrix6d D; Damping matrix. variable scalingDamping double scalingDamping; Scaling of the damping matrix. variable offsetLinearDamping double offsetLinearDamping; Offset for the linear damping matrix. variable offsetLinForwardSpeedDamping double offsetLinForwardSpeedDamping; Offset for the linear damping matrix. variable offsetNonLinDamping double offsetNonLinDamping; Offset for the linear damping matrix. variable DLin Eigen::Matrix6d DLin; Linear damping matrix. variable DLinForwardSpeed Eigen::Matrix6d DLinForwardSpeed; Linear damping matrix proportional only to the forward speed (useful for modeling AUVs). From [1], according to Newman (1977), there is a damping force component that linearly increases with the presence of forward speed, particularly so for slender bodies. References: [1] Refsnes - 2007 - Nonlinear model-based control of slender body AUVs variable DNonLin Eigen::Matrix6d DNonLin; Nonlinear damping coefficients. variable linearDampCoef std::vector< double > linearDampCoef; Linear damping coefficients. variable quadDampCoef std::vector< double > quadDampCoef; Quadratic damping coefficients. Updated on 2022-05-30 at 18:35:12 +0000","title":"classgazebo 1 1HMFossen"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#gazebohmfossen","text":"Class containting the methods and attributes for a Fossen robot-like hydrodynamic model. The restoring forces are applied by the BuoyantObject class methods. Using the plugin for UUV models will use both this and the buoyant object class definitions, therefore the restoring forces were not inherited here. References: More... #include <HydrodynamicModel.hh> Inherits from gazebo::HydrodynamicModel , gazebo::BuoyantObject Inherited by gazebo::HMBox , gazebo::HMCylinder , gazebo::HMSphere , gazebo::HMSpheroid","title":"gazebo::HMFossen"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#public-functions","text":"Name HydrodynamicModel * create (sdf::ElementPtr _sdf, physics::LinkPtr _link) Create model of this type with parameter values from sdf. virtual std::string GetType () Return (derived) type of hydrodynamic model. virtual void Print (std::string _paramName, std::string _message =std::string()) Prints parameters. virtual bool GetParam (std::string _tag, std::vector< double > & _output) Return paramater in vector form for the given tag. virtual bool GetParam (std::string _tag, double & _output) Return paramater in scalar form for the given tag. virtual bool SetParam (std::string _tag, double _input) Set scalar parameter. virtual void ApplyHydrodynamicForces (double time, const ignition::math::Vector3d & _flowVelWorld) Computation of the hydrodynamic forces.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#protected-functions","text":"Name REGISTER_HYDRODYNAMICMODEL ( HMFossen ) Register this model with the factory. HMFossen (sdf::ElementPtr _sdf, physics::LinkPtr _link) void ComputeAddedCoriolisMatrix (const Eigen::Vector6d & _vel, const Eigen::Matrix6d & _Ma, Eigen::Matrix6d & _Ca) const Computes the added-mass Coriolis matrix Ca. void ComputeDampingMatrix (const Eigen::Vector6d & _vel, Eigen::Matrix6d & _D) const Updates the damping matrix for the current velocity. Eigen::Matrix6d GetAddedMass () const Returns the added-mass matrix with the scaling and offset.","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#protected-attributes","text":"Name const std::string IDENTIFIER Unique identifier for this geometry. Eigen::Matrix6d Ma Added-mass matrix. double scalingAddedMass Scaling of the added-mass matrix. double offsetAddedMass Offset for the added-mass matrix. Eigen::Matrix6d Ca Added-mass associated Coriolis matrix. Eigen::Matrix6d D Damping matrix. double scalingDamping Scaling of the damping matrix. double offsetLinearDamping Offset for the linear damping matrix. double offsetLinForwardSpeedDamping Offset for the linear damping matrix. double offsetNonLinDamping Offset for the linear damping matrix. Eigen::Matrix6d DLin Linear damping matrix. Eigen::Matrix6d DLinForwardSpeed Linear damping matrix proportional only to the forward speed (useful for modeling AUVs). From [1], according to Newman (1977), there is a damping force component that linearly increases with the presence of forward speed, particularly so for slender bodies. Eigen::Matrix6d DNonLin Nonlinear damping coefficients. std::vector< double > linearDampCoef Linear damping coefficients. std::vector< double > quadDampCoef Quadratic damping coefficients.","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#additional-inherited-members","text":"Protected Functions inherited from gazebo::HydrodynamicModel Name HydrodynamicModel (sdf::ElementPtr _sdf, physics::LinkPtr _link) Protected constructor: Use the factory for object creation. void ComputeAcc ( Eigen::Vector6d _velRel, double _time, double _alpha =0.3) Filter acceleration (fix due to the update structure of Gazebo) bool CheckParams (sdf::ElementPtr _sdf) Returns true if all parameters are available from the SDF element. ignition::math::Vector3d ToNED (ignition::math::Vector3d _vec) Convert vector to comply with the NED reference frame. ignition::math::Vector3d FromNED (ignition::math::Vector3d _vec) Convert vector to comply with the NED reference frame. Protected Attributes inherited from gazebo::HydrodynamicModel Name Eigen::Vector6d filteredAcc Filtered linear & angular acceleration vector in link frame. This is used to prevent the model to become unstable given that Gazebo only calls the update function at the beginning or at the end of a iteration of the physics engine. double lastTime Last timestamp (in seconds) at which ApplyHydrodynamicForces was called. Eigen::Vector6d lastVelRel Last body-fixed relative velocity (nu_R in Fossen's equations) std::vector< std::string > params List of parameters needed from the SDF element. double Re Reynolds number (not used by all models) double temperature Temperature (not used by all models) Public Functions inherited from gazebo::BuoyantObject Name BuoyantObject (physics::LinkPtr _link) Constructor. ~BuoyantObject () Destructor. void GetBuoyancyForce (const ignition::math::Pose3d & _pose, ignition::math::Vector3d & buoyancyForce, ignition::math::Vector3d & buoyancyTorque) Returns the buoyancy force vector in the world frame. void ApplyBuoyancyForce () Applies buoyancy force on link. void SetVolume (double _volume =-1) Sets the link's submerged volume. double GetVolume () Returns the stored link submerged volume. void SetFluidDensity (double _fluidDensity) Sets the fluid density in kg/m^3. double GetFluidDensity () Returns the stored fluid density. void SetCoB (const ignition::math::Vector3d & _centerOfBuoyancy) Sets the position of the center of buoyancy on the body frame. ignition::math::Vector3d GetCoB () Returns the stored center of buoyancy. void SetGravity (double _g) Set acceleration of gravity. double GetGravity () Get stored acceleration of gravity. void SetBoundingBox (const AxisAlignedBox & _bBox) Sets bounding box. void SetStoreVector (std::string _tag) Adds a field in the hydroWrench map. ignition::math::Vector3d GetStoredVector (std::string _tag) Get vector from the hydroWrench map. void SetDebugFlag (bool _debugOn =true) Set debug flag to store intermediate forces and torques. bool IsSubmerged () Returns true if the robot is completely submerged. bool IsNeutrallyBuoyant () Returns true if the link was set to be neutrally buoyant. bool GetDebugFlag () Returns the debug flag. void SetNeutrallyBuoyant () Sets this link as neutrally buoyant. Protected Functions inherited from gazebo::BuoyantObject Name void StoreVector (std::string _tag, ignition::math::Vector3d _vec) Store vector in the hydroWrench map if the field has been created. Protected Attributes inherited from gazebo::BuoyantObject Name double volume Volume of fluid displaced by the submerged object. double scalingVolume Scaling factor for the volume. double offsetVolume Offset for the volume. double fluidDensity Fluid density. double g Acceleration of gravity. ignition::math::Vector3d centerOfBuoyancy Center of buoyancy in the body frame. AxisAlignedBox boundingBox TEMP for calculation of the buoyancy force close to the surface. std::map< std::string, ignition::math::Vector3d > hydroWrench Storage for hydrodynamic and hydrostatic forces and torques for debugging purposes. bool debugFlag Debug flag, storing all intermediate forces and torques. bool isSubmerged Is submerged flag. physics::LinkPtr link Pointer to the correspondent robot link. bool neutrallyBuoyant If true, the restoring force will be equal to the gravitational. double metacentricWidth double metacentricLength Metacentric length of the robot, used only for surface vessels and floating objects. double waterLevelPlaneArea If the cross section area around water level of the surface vessel is not given, it will be computed from the object's bounding box. double submergedHeight Height of the robot that is submerged (only for surface vessels) bool isSurfaceVessel Flag set to true if the information about the metacentric width and height is available. bool isSurfaceVesselFloating Flag set to true if the vessel has reached its submerged height.","title":"Additional inherited members"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#detailed-description","text":"class gazebo::HMFossen; Class containting the methods and attributes for a Fossen robot-like hydrodynamic model. The restoring forces are applied by the BuoyantObject class methods. Using the plugin for UUV models will use both this and the buoyant object class definitions, therefore the restoring forces were not inherited here. References: Fossen, Thor, \"Handbook of Marine Craft and Hydrodynamics and Motion Control\", 2011","title":"Detailed Description"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#function-create","text":"static HydrodynamicModel * create( sdf::ElementPtr _sdf, physics::LinkPtr _link ) Create model of this type with parameter values from sdf.","title":"function create"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#function-gettype","text":"inline virtual std::string GetType() Return (derived) type of hydrodynamic model. Reimplements : gazebo::HydrodynamicModel::GetType Reimplemented by : gazebo::HMSphere::GetType , gazebo::HMCylinder::GetType , gazebo::HMSpheroid::GetType , gazebo::HMBox::GetType","title":"function GetType"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#function-print","text":"virtual void Print( std::string _paramName, std::string _message =std::string() ) Prints parameters. Reimplements : gazebo::HydrodynamicModel::Print Reimplemented by : gazebo::HMSphere::Print , gazebo::HMCylinder::Print , gazebo::HMSpheroid::Print , gazebo::HMBox::Print","title":"function Print"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#function-getparam","text":"virtual bool GetParam( std::string _tag, std::vector< double > & _output ) Return paramater in vector form for the given tag. Reimplements : gazebo::HydrodynamicModel::GetParam","title":"function GetParam"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#function-getparam_1","text":"virtual bool GetParam( std::string _tag, double & _output ) Return paramater in scalar form for the given tag. Reimplements : gazebo::HydrodynamicModel::GetParam","title":"function GetParam"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#function-setparam","text":"virtual bool SetParam( std::string _tag, double _input ) Set scalar parameter. Reimplements : gazebo::HydrodynamicModel::SetParam","title":"function SetParam"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#function-applyhydrodynamicforces","text":"virtual void ApplyHydrodynamicForces( double time, const ignition::math::Vector3d & _flowVelWorld ) Computation of the hydrodynamic forces. Reimplements : gazebo::HydrodynamicModel::ApplyHydrodynamicForces","title":"function ApplyHydrodynamicForces"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#function-register_hydrodynamicmodel","text":"REGISTER_HYDRODYNAMICMODEL( HMFossen ) Register this model with the factory.","title":"function REGISTER_HYDRODYNAMICMODEL"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#function-hmfossen","text":"HMFossen( sdf::ElementPtr _sdf, physics::LinkPtr _link )","title":"function HMFossen"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#function-computeaddedcoriolismatrix","text":"void ComputeAddedCoriolisMatrix( const Eigen::Vector6d & _vel, const Eigen::Matrix6d & _Ma, Eigen::Matrix6d & _Ca ) const Computes the added-mass Coriolis matrix Ca.","title":"function ComputeAddedCoriolisMatrix"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#function-computedampingmatrix","text":"void ComputeDampingMatrix( const Eigen::Vector6d & _vel, Eigen::Matrix6d & _D ) const Updates the damping matrix for the current velocity.","title":"function ComputeDampingMatrix"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#function-getaddedmass","text":"Eigen::Matrix6d GetAddedMass() const Returns the added-mass matrix with the scaling and offset.","title":"function GetAddedMass"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#variable-identifier","text":"static const std::string IDENTIFIER = \"fossen\"; Unique identifier for this geometry.","title":"variable IDENTIFIER"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#variable-ma","text":"Eigen::Matrix6d Ma; Added-mass matrix.","title":"variable Ma"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#variable-scalingaddedmass","text":"double scalingAddedMass; Scaling of the added-mass matrix.","title":"variable scalingAddedMass"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#variable-offsetaddedmass","text":"double offsetAddedMass; Offset for the added-mass matrix.","title":"variable offsetAddedMass"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#variable-ca","text":"Eigen::Matrix6d Ca; Added-mass associated Coriolis matrix.","title":"variable Ca"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#variable-d","text":"Eigen::Matrix6d D; Damping matrix.","title":"variable D"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#variable-scalingdamping","text":"double scalingDamping; Scaling of the damping matrix.","title":"variable scalingDamping"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#variable-offsetlineardamping","text":"double offsetLinearDamping; Offset for the linear damping matrix.","title":"variable offsetLinearDamping"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#variable-offsetlinforwardspeeddamping","text":"double offsetLinForwardSpeedDamping; Offset for the linear damping matrix.","title":"variable offsetLinForwardSpeedDamping"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#variable-offsetnonlindamping","text":"double offsetNonLinDamping; Offset for the linear damping matrix.","title":"variable offsetNonLinDamping"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#variable-dlin","text":"Eigen::Matrix6d DLin; Linear damping matrix.","title":"variable DLin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#variable-dlinforwardspeed","text":"Eigen::Matrix6d DLinForwardSpeed; Linear damping matrix proportional only to the forward speed (useful for modeling AUVs). From [1], according to Newman (1977), there is a damping force component that linearly increases with the presence of forward speed, particularly so for slender bodies. References: [1] Refsnes - 2007 - Nonlinear model-based control of slender body AUVs","title":"variable DLinForwardSpeed"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#variable-dnonlin","text":"Eigen::Matrix6d DNonLin; Nonlinear damping coefficients.","title":"variable DNonLin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#variable-lineardampcoef","text":"std::vector< double > linearDampCoef; Linear damping coefficients.","title":"variable linearDampCoef"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMFossen/#variable-quaddampcoef","text":"std::vector< double > quadDampCoef; Quadratic damping coefficients. Updated on 2022-05-30 at 18:35:12 +0000","title":"variable quadDampCoef"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSphere/","text":"gazebo::HMSphere Class containing the methods and attributes for a hydrodynamic model for a sphere in the fluid. #include <HydrodynamicModel.hh> Inherits from gazebo::HMFossen , gazebo::HydrodynamicModel , gazebo::BuoyantObject Public Functions Name HydrodynamicModel * create (sdf::ElementPtr _sdf, physics::LinkPtr _link) Create model of this type with parameter values from sdf. virtual std::string GetType () Return (derived) type of hydrodynamic model. virtual void Print (std::string _paramName, std::string _message =std::string()) Prints parameters. Protected Functions Name REGISTER_HYDRODYNAMICMODEL ( HMSphere ) Register this model with the factory. HMSphere (sdf::ElementPtr _sdf, physics::LinkPtr _link) Protected Attributes Name const std::string IDENTIFIER Unique identifier for this geometry. double radius Sphere radius. double Cd Drag coefficient. double areaSection Area of the cross section. Additional inherited members Public Functions inherited from gazebo::HMFossen Name virtual bool GetParam (std::string _tag, std::vector< double > & _output) Return paramater in vector form for the given tag. virtual bool GetParam (std::string _tag, double & _output) Return paramater in scalar form for the given tag. virtual bool SetParam (std::string _tag, double _input) Set scalar parameter. virtual void ApplyHydrodynamicForces (double time, const ignition::math::Vector3d & _flowVelWorld) Computation of the hydrodynamic forces. Protected Functions inherited from gazebo::HMFossen Name HMFossen (sdf::ElementPtr _sdf, physics::LinkPtr _link) void ComputeAddedCoriolisMatrix (const Eigen::Vector6d & _vel, const Eigen::Matrix6d & _Ma, Eigen::Matrix6d & _Ca) const Computes the added-mass Coriolis matrix Ca. void ComputeDampingMatrix (const Eigen::Vector6d & _vel, Eigen::Matrix6d & _D) const Updates the damping matrix for the current velocity. Eigen::Matrix6d GetAddedMass () const Returns the added-mass matrix with the scaling and offset. Protected Attributes inherited from gazebo::HMFossen Name Eigen::Matrix6d Ma Added-mass matrix. double scalingAddedMass Scaling of the added-mass matrix. double offsetAddedMass Offset for the added-mass matrix. Eigen::Matrix6d Ca Added-mass associated Coriolis matrix. Eigen::Matrix6d D Damping matrix. double scalingDamping Scaling of the damping matrix. double offsetLinearDamping Offset for the linear damping matrix. double offsetLinForwardSpeedDamping Offset for the linear damping matrix. double offsetNonLinDamping Offset for the linear damping matrix. Eigen::Matrix6d DLin Linear damping matrix. Eigen::Matrix6d DLinForwardSpeed Linear damping matrix proportional only to the forward speed (useful for modeling AUVs). From [1], according to Newman (1977), there is a damping force component that linearly increases with the presence of forward speed, particularly so for slender bodies. Eigen::Matrix6d DNonLin Nonlinear damping coefficients. std::vector< double > linearDampCoef Linear damping coefficients. std::vector< double > quadDampCoef Quadratic damping coefficients. Public Functions inherited from gazebo::HydrodynamicModel Name virtual void ApplyHydrodynamicForces (double time, const ignition::math::Vector3d & _flowVelWorld) =0 Computation of the hydrodynamic forces. virtual bool GetParam (std::string _tag, std::vector< double > & _output) =0 Return paramater in vector form for the given tag. virtual bool GetParam (std::string _tag, double & _output) =0 Return paramater in vector form for the given tag. virtual bool SetParam (std::string _tag, double _input) =0 Set a scalar parameters. Protected Functions inherited from gazebo::HydrodynamicModel Name HydrodynamicModel (sdf::ElementPtr _sdf, physics::LinkPtr _link) Protected constructor: Use the factory for object creation. void ComputeAcc ( Eigen::Vector6d _velRel, double _time, double _alpha =0.3) Filter acceleration (fix due to the update structure of Gazebo) bool CheckParams (sdf::ElementPtr _sdf) Returns true if all parameters are available from the SDF element. ignition::math::Vector3d ToNED (ignition::math::Vector3d _vec) Convert vector to comply with the NED reference frame. ignition::math::Vector3d FromNED (ignition::math::Vector3d _vec) Convert vector to comply with the NED reference frame. Protected Attributes inherited from gazebo::HydrodynamicModel Name Eigen::Vector6d filteredAcc Filtered linear & angular acceleration vector in link frame. This is used to prevent the model to become unstable given that Gazebo only calls the update function at the beginning or at the end of a iteration of the physics engine. double lastTime Last timestamp (in seconds) at which ApplyHydrodynamicForces was called. Eigen::Vector6d lastVelRel Last body-fixed relative velocity (nu_R in Fossen's equations) std::vector< std::string > params List of parameters needed from the SDF element. double Re Reynolds number (not used by all models) double temperature Temperature (not used by all models) Public Functions inherited from gazebo::BuoyantObject Name BuoyantObject (physics::LinkPtr _link) Constructor. ~BuoyantObject () Destructor. void GetBuoyancyForce (const ignition::math::Pose3d & _pose, ignition::math::Vector3d & buoyancyForce, ignition::math::Vector3d & buoyancyTorque) Returns the buoyancy force vector in the world frame. void ApplyBuoyancyForce () Applies buoyancy force on link. void SetVolume (double _volume =-1) Sets the link's submerged volume. double GetVolume () Returns the stored link submerged volume. void SetFluidDensity (double _fluidDensity) Sets the fluid density in kg/m^3. double GetFluidDensity () Returns the stored fluid density. void SetCoB (const ignition::math::Vector3d & _centerOfBuoyancy) Sets the position of the center of buoyancy on the body frame. ignition::math::Vector3d GetCoB () Returns the stored center of buoyancy. void SetGravity (double _g) Set acceleration of gravity. double GetGravity () Get stored acceleration of gravity. void SetBoundingBox (const AxisAlignedBox & _bBox) Sets bounding box. void SetStoreVector (std::string _tag) Adds a field in the hydroWrench map. ignition::math::Vector3d GetStoredVector (std::string _tag) Get vector from the hydroWrench map. void SetDebugFlag (bool _debugOn =true) Set debug flag to store intermediate forces and torques. bool IsSubmerged () Returns true if the robot is completely submerged. bool IsNeutrallyBuoyant () Returns true if the link was set to be neutrally buoyant. bool GetDebugFlag () Returns the debug flag. void SetNeutrallyBuoyant () Sets this link as neutrally buoyant. Protected Functions inherited from gazebo::BuoyantObject Name void StoreVector (std::string _tag, ignition::math::Vector3d _vec) Store vector in the hydroWrench map if the field has been created. Protected Attributes inherited from gazebo::BuoyantObject Name double volume Volume of fluid displaced by the submerged object. double scalingVolume Scaling factor for the volume. double offsetVolume Offset for the volume. double fluidDensity Fluid density. double g Acceleration of gravity. ignition::math::Vector3d centerOfBuoyancy Center of buoyancy in the body frame. AxisAlignedBox boundingBox TEMP for calculation of the buoyancy force close to the surface. std::map< std::string, ignition::math::Vector3d > hydroWrench Storage for hydrodynamic and hydrostatic forces and torques for debugging purposes. bool debugFlag Debug flag, storing all intermediate forces and torques. bool isSubmerged Is submerged flag. physics::LinkPtr link Pointer to the correspondent robot link. bool neutrallyBuoyant If true, the restoring force will be equal to the gravitational. double metacentricWidth double metacentricLength Metacentric length of the robot, used only for surface vessels and floating objects. double waterLevelPlaneArea If the cross section area around water level of the surface vessel is not given, it will be computed from the object's bounding box. double submergedHeight Height of the robot that is submerged (only for surface vessels) bool isSurfaceVessel Flag set to true if the information about the metacentric width and height is available. bool isSurfaceVesselFloating Flag set to true if the vessel has reached its submerged height. Public Functions Documentation function create static HydrodynamicModel * create( sdf::ElementPtr _sdf, physics::LinkPtr _link ) Create model of this type with parameter values from sdf. function GetType inline virtual std::string GetType() Return (derived) type of hydrodynamic model. Reimplements : gazebo::HMFossen::GetType function Print virtual void Print( std::string _paramName, std::string _message =std::string() ) Prints parameters. Reimplements : gazebo::HMFossen::Print Protected Functions Documentation function REGISTER_HYDRODYNAMICMODEL REGISTER_HYDRODYNAMICMODEL( HMSphere ) Register this model with the factory. function HMSphere HMSphere( sdf::ElementPtr _sdf, physics::LinkPtr _link ) Protected Attributes Documentation variable IDENTIFIER static const std::string IDENTIFIER = \"sphere\"; Unique identifier for this geometry. variable radius double radius; Sphere radius. variable Cd double Cd; Drag coefficient. variable areaSection double areaSection; Area of the cross section. Updated on 2022-05-30 at 18:35:12 +0000","title":"gazebo::HMSphere"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSphere/#gazebohmsphere","text":"Class containing the methods and attributes for a hydrodynamic model for a sphere in the fluid. #include <HydrodynamicModel.hh> Inherits from gazebo::HMFossen , gazebo::HydrodynamicModel , gazebo::BuoyantObject","title":"gazebo::HMSphere"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSphere/#public-functions","text":"Name HydrodynamicModel * create (sdf::ElementPtr _sdf, physics::LinkPtr _link) Create model of this type with parameter values from sdf. virtual std::string GetType () Return (derived) type of hydrodynamic model. virtual void Print (std::string _paramName, std::string _message =std::string()) Prints parameters.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSphere/#protected-functions","text":"Name REGISTER_HYDRODYNAMICMODEL ( HMSphere ) Register this model with the factory. HMSphere (sdf::ElementPtr _sdf, physics::LinkPtr _link)","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSphere/#protected-attributes","text":"Name const std::string IDENTIFIER Unique identifier for this geometry. double radius Sphere radius. double Cd Drag coefficient. double areaSection Area of the cross section.","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSphere/#additional-inherited-members","text":"Public Functions inherited from gazebo::HMFossen Name virtual bool GetParam (std::string _tag, std::vector< double > & _output) Return paramater in vector form for the given tag. virtual bool GetParam (std::string _tag, double & _output) Return paramater in scalar form for the given tag. virtual bool SetParam (std::string _tag, double _input) Set scalar parameter. virtual void ApplyHydrodynamicForces (double time, const ignition::math::Vector3d & _flowVelWorld) Computation of the hydrodynamic forces. Protected Functions inherited from gazebo::HMFossen Name HMFossen (sdf::ElementPtr _sdf, physics::LinkPtr _link) void ComputeAddedCoriolisMatrix (const Eigen::Vector6d & _vel, const Eigen::Matrix6d & _Ma, Eigen::Matrix6d & _Ca) const Computes the added-mass Coriolis matrix Ca. void ComputeDampingMatrix (const Eigen::Vector6d & _vel, Eigen::Matrix6d & _D) const Updates the damping matrix for the current velocity. Eigen::Matrix6d GetAddedMass () const Returns the added-mass matrix with the scaling and offset. Protected Attributes inherited from gazebo::HMFossen Name Eigen::Matrix6d Ma Added-mass matrix. double scalingAddedMass Scaling of the added-mass matrix. double offsetAddedMass Offset for the added-mass matrix. Eigen::Matrix6d Ca Added-mass associated Coriolis matrix. Eigen::Matrix6d D Damping matrix. double scalingDamping Scaling of the damping matrix. double offsetLinearDamping Offset for the linear damping matrix. double offsetLinForwardSpeedDamping Offset for the linear damping matrix. double offsetNonLinDamping Offset for the linear damping matrix. Eigen::Matrix6d DLin Linear damping matrix. Eigen::Matrix6d DLinForwardSpeed Linear damping matrix proportional only to the forward speed (useful for modeling AUVs). From [1], according to Newman (1977), there is a damping force component that linearly increases with the presence of forward speed, particularly so for slender bodies. Eigen::Matrix6d DNonLin Nonlinear damping coefficients. std::vector< double > linearDampCoef Linear damping coefficients. std::vector< double > quadDampCoef Quadratic damping coefficients. Public Functions inherited from gazebo::HydrodynamicModel Name virtual void ApplyHydrodynamicForces (double time, const ignition::math::Vector3d & _flowVelWorld) =0 Computation of the hydrodynamic forces. virtual bool GetParam (std::string _tag, std::vector< double > & _output) =0 Return paramater in vector form for the given tag. virtual bool GetParam (std::string _tag, double & _output) =0 Return paramater in vector form for the given tag. virtual bool SetParam (std::string _tag, double _input) =0 Set a scalar parameters. Protected Functions inherited from gazebo::HydrodynamicModel Name HydrodynamicModel (sdf::ElementPtr _sdf, physics::LinkPtr _link) Protected constructor: Use the factory for object creation. void ComputeAcc ( Eigen::Vector6d _velRel, double _time, double _alpha =0.3) Filter acceleration (fix due to the update structure of Gazebo) bool CheckParams (sdf::ElementPtr _sdf) Returns true if all parameters are available from the SDF element. ignition::math::Vector3d ToNED (ignition::math::Vector3d _vec) Convert vector to comply with the NED reference frame. ignition::math::Vector3d FromNED (ignition::math::Vector3d _vec) Convert vector to comply with the NED reference frame. Protected Attributes inherited from gazebo::HydrodynamicModel Name Eigen::Vector6d filteredAcc Filtered linear & angular acceleration vector in link frame. This is used to prevent the model to become unstable given that Gazebo only calls the update function at the beginning or at the end of a iteration of the physics engine. double lastTime Last timestamp (in seconds) at which ApplyHydrodynamicForces was called. Eigen::Vector6d lastVelRel Last body-fixed relative velocity (nu_R in Fossen's equations) std::vector< std::string > params List of parameters needed from the SDF element. double Re Reynolds number (not used by all models) double temperature Temperature (not used by all models) Public Functions inherited from gazebo::BuoyantObject Name BuoyantObject (physics::LinkPtr _link) Constructor. ~BuoyantObject () Destructor. void GetBuoyancyForce (const ignition::math::Pose3d & _pose, ignition::math::Vector3d & buoyancyForce, ignition::math::Vector3d & buoyancyTorque) Returns the buoyancy force vector in the world frame. void ApplyBuoyancyForce () Applies buoyancy force on link. void SetVolume (double _volume =-1) Sets the link's submerged volume. double GetVolume () Returns the stored link submerged volume. void SetFluidDensity (double _fluidDensity) Sets the fluid density in kg/m^3. double GetFluidDensity () Returns the stored fluid density. void SetCoB (const ignition::math::Vector3d & _centerOfBuoyancy) Sets the position of the center of buoyancy on the body frame. ignition::math::Vector3d GetCoB () Returns the stored center of buoyancy. void SetGravity (double _g) Set acceleration of gravity. double GetGravity () Get stored acceleration of gravity. void SetBoundingBox (const AxisAlignedBox & _bBox) Sets bounding box. void SetStoreVector (std::string _tag) Adds a field in the hydroWrench map. ignition::math::Vector3d GetStoredVector (std::string _tag) Get vector from the hydroWrench map. void SetDebugFlag (bool _debugOn =true) Set debug flag to store intermediate forces and torques. bool IsSubmerged () Returns true if the robot is completely submerged. bool IsNeutrallyBuoyant () Returns true if the link was set to be neutrally buoyant. bool GetDebugFlag () Returns the debug flag. void SetNeutrallyBuoyant () Sets this link as neutrally buoyant. Protected Functions inherited from gazebo::BuoyantObject Name void StoreVector (std::string _tag, ignition::math::Vector3d _vec) Store vector in the hydroWrench map if the field has been created. Protected Attributes inherited from gazebo::BuoyantObject Name double volume Volume of fluid displaced by the submerged object. double scalingVolume Scaling factor for the volume. double offsetVolume Offset for the volume. double fluidDensity Fluid density. double g Acceleration of gravity. ignition::math::Vector3d centerOfBuoyancy Center of buoyancy in the body frame. AxisAlignedBox boundingBox TEMP for calculation of the buoyancy force close to the surface. std::map< std::string, ignition::math::Vector3d > hydroWrench Storage for hydrodynamic and hydrostatic forces and torques for debugging purposes. bool debugFlag Debug flag, storing all intermediate forces and torques. bool isSubmerged Is submerged flag. physics::LinkPtr link Pointer to the correspondent robot link. bool neutrallyBuoyant If true, the restoring force will be equal to the gravitational. double metacentricWidth double metacentricLength Metacentric length of the robot, used only for surface vessels and floating objects. double waterLevelPlaneArea If the cross section area around water level of the surface vessel is not given, it will be computed from the object's bounding box. double submergedHeight Height of the robot that is submerged (only for surface vessels) bool isSurfaceVessel Flag set to true if the information about the metacentric width and height is available. bool isSurfaceVesselFloating Flag set to true if the vessel has reached its submerged height.","title":"Additional inherited members"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSphere/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSphere/#function-create","text":"static HydrodynamicModel * create( sdf::ElementPtr _sdf, physics::LinkPtr _link ) Create model of this type with parameter values from sdf.","title":"function create"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSphere/#function-gettype","text":"inline virtual std::string GetType() Return (derived) type of hydrodynamic model. Reimplements : gazebo::HMFossen::GetType","title":"function GetType"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSphere/#function-print","text":"virtual void Print( std::string _paramName, std::string _message =std::string() ) Prints parameters. Reimplements : gazebo::HMFossen::Print","title":"function Print"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSphere/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSphere/#function-register_hydrodynamicmodel","text":"REGISTER_HYDRODYNAMICMODEL( HMSphere ) Register this model with the factory.","title":"function REGISTER_HYDRODYNAMICMODEL"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSphere/#function-hmsphere","text":"HMSphere( sdf::ElementPtr _sdf, physics::LinkPtr _link )","title":"function HMSphere"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSphere/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSphere/#variable-identifier","text":"static const std::string IDENTIFIER = \"sphere\"; Unique identifier for this geometry.","title":"variable IDENTIFIER"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSphere/#variable-radius","text":"double radius; Sphere radius.","title":"variable radius"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSphere/#variable-cd","text":"double Cd; Drag coefficient.","title":"variable Cd"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSphere/#variable-areasection","text":"double areaSection; Area of the cross section. Updated on 2022-05-30 at 18:35:12 +0000","title":"variable areaSection"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSpheroid/","text":"title: gazebo::HMSpheroid summary: Class containing the methods and attributes for a hydrodynamic model for a spheroid in the fluid Reference: Antonelli - Underwater Robots. gazebo::HMSpheroid Class containing the methods and attributes for a hydrodynamic model for a spheroid in the fluid Reference: Antonelli - Underwater Robots. #include <HydrodynamicModel.hh> Inherits from gazebo::HMFossen , gazebo::HydrodynamicModel , gazebo::BuoyantObject Public Functions Name HydrodynamicModel * create (sdf::ElementPtr _sdf, physics::LinkPtr _link) Create model of this type with parameter values from sdf. virtual std::string GetType () Return (derived) type of hydrodynamic model. virtual void Print (std::string _paramName, std::string _message =std::string()) Prints parameters. Protected Functions Name HMSpheroid (sdf::ElementPtr _sdf, physics::LinkPtr _link) Protected Attributes Name const std::string IDENTIFIER Unique identifier for this geometry. double length Length of the sphroid. double radius Prolate spheroid's smaller radius. Additional inherited members Public Functions inherited from gazebo::HMFossen Name virtual bool GetParam (std::string _tag, std::vector< double > & _output) Return paramater in vector form for the given tag. virtual bool GetParam (std::string _tag, double & _output) Return paramater in scalar form for the given tag. virtual bool SetParam (std::string _tag, double _input) Set scalar parameter. virtual void ApplyHydrodynamicForces (double time, const ignition::math::Vector3d & _flowVelWorld) Computation of the hydrodynamic forces. Protected Functions inherited from gazebo::HMFossen Name HMFossen (sdf::ElementPtr _sdf, physics::LinkPtr _link) void ComputeAddedCoriolisMatrix (const Eigen::Vector6d & _vel, const Eigen::Matrix6d & _Ma, Eigen::Matrix6d & _Ca) const Computes the added-mass Coriolis matrix Ca. void ComputeDampingMatrix (const Eigen::Vector6d & _vel, Eigen::Matrix6d & _D) const Updates the damping matrix for the current velocity. Eigen::Matrix6d GetAddedMass () const Returns the added-mass matrix with the scaling and offset. Protected Attributes inherited from gazebo::HMFossen Name Eigen::Matrix6d Ma Added-mass matrix. double scalingAddedMass Scaling of the added-mass matrix. double offsetAddedMass Offset for the added-mass matrix. Eigen::Matrix6d Ca Added-mass associated Coriolis matrix. Eigen::Matrix6d D Damping matrix. double scalingDamping Scaling of the damping matrix. double offsetLinearDamping Offset for the linear damping matrix. double offsetLinForwardSpeedDamping Offset for the linear damping matrix. double offsetNonLinDamping Offset for the linear damping matrix. Eigen::Matrix6d DLin Linear damping matrix. Eigen::Matrix6d DLinForwardSpeed Linear damping matrix proportional only to the forward speed (useful for modeling AUVs). From [1], according to Newman (1977), there is a damping force component that linearly increases with the presence of forward speed, particularly so for slender bodies. Eigen::Matrix6d DNonLin Nonlinear damping coefficients. std::vector< double > linearDampCoef Linear damping coefficients. std::vector< double > quadDampCoef Quadratic damping coefficients. Public Functions inherited from gazebo::HydrodynamicModel Name virtual void ApplyHydrodynamicForces (double time, const ignition::math::Vector3d & _flowVelWorld) =0 Computation of the hydrodynamic forces. virtual bool GetParam (std::string _tag, std::vector< double > & _output) =0 Return paramater in vector form for the given tag. virtual bool GetParam (std::string _tag, double & _output) =0 Return paramater in vector form for the given tag. virtual bool SetParam (std::string _tag, double _input) =0 Set a scalar parameters. Protected Functions inherited from gazebo::HydrodynamicModel Name HydrodynamicModel (sdf::ElementPtr _sdf, physics::LinkPtr _link) Protected constructor: Use the factory for object creation. void ComputeAcc ( Eigen::Vector6d _velRel, double _time, double _alpha =0.3) Filter acceleration (fix due to the update structure of Gazebo) bool CheckParams (sdf::ElementPtr _sdf) Returns true if all parameters are available from the SDF element. ignition::math::Vector3d ToNED (ignition::math::Vector3d _vec) Convert vector to comply with the NED reference frame. ignition::math::Vector3d FromNED (ignition::math::Vector3d _vec) Convert vector to comply with the NED reference frame. Protected Attributes inherited from gazebo::HydrodynamicModel Name Eigen::Vector6d filteredAcc Filtered linear & angular acceleration vector in link frame. This is used to prevent the model to become unstable given that Gazebo only calls the update function at the beginning or at the end of a iteration of the physics engine. double lastTime Last timestamp (in seconds) at which ApplyHydrodynamicForces was called. Eigen::Vector6d lastVelRel Last body-fixed relative velocity (nu_R in Fossen's equations) std::vector< std::string > params List of parameters needed from the SDF element. double Re Reynolds number (not used by all models) double temperature Temperature (not used by all models) Public Functions inherited from gazebo::BuoyantObject Name BuoyantObject (physics::LinkPtr _link) Constructor. ~BuoyantObject () Destructor. void GetBuoyancyForce (const ignition::math::Pose3d & _pose, ignition::math::Vector3d & buoyancyForce, ignition::math::Vector3d & buoyancyTorque) Returns the buoyancy force vector in the world frame. void ApplyBuoyancyForce () Applies buoyancy force on link. void SetVolume (double _volume =-1) Sets the link's submerged volume. double GetVolume () Returns the stored link submerged volume. void SetFluidDensity (double _fluidDensity) Sets the fluid density in kg/m^3. double GetFluidDensity () Returns the stored fluid density. void SetCoB (const ignition::math::Vector3d & _centerOfBuoyancy) Sets the position of the center of buoyancy on the body frame. ignition::math::Vector3d GetCoB () Returns the stored center of buoyancy. void SetGravity (double _g) Set acceleration of gravity. double GetGravity () Get stored acceleration of gravity. void SetBoundingBox (const AxisAlignedBox & _bBox) Sets bounding box. void SetStoreVector (std::string _tag) Adds a field in the hydroWrench map. ignition::math::Vector3d GetStoredVector (std::string _tag) Get vector from the hydroWrench map. void SetDebugFlag (bool _debugOn =true) Set debug flag to store intermediate forces and torques. bool IsSubmerged () Returns true if the robot is completely submerged. bool IsNeutrallyBuoyant () Returns true if the link was set to be neutrally buoyant. bool GetDebugFlag () Returns the debug flag. void SetNeutrallyBuoyant () Sets this link as neutrally buoyant. Protected Functions inherited from gazebo::BuoyantObject Name void StoreVector (std::string _tag, ignition::math::Vector3d _vec) Store vector in the hydroWrench map if the field has been created. Protected Attributes inherited from gazebo::BuoyantObject Name double volume Volume of fluid displaced by the submerged object. double scalingVolume Scaling factor for the volume. double offsetVolume Offset for the volume. double fluidDensity Fluid density. double g Acceleration of gravity. ignition::math::Vector3d centerOfBuoyancy Center of buoyancy in the body frame. AxisAlignedBox boundingBox TEMP for calculation of the buoyancy force close to the surface. std::map< std::string, ignition::math::Vector3d > hydroWrench Storage for hydrodynamic and hydrostatic forces and torques for debugging purposes. bool debugFlag Debug flag, storing all intermediate forces and torques. bool isSubmerged Is submerged flag. physics::LinkPtr link Pointer to the correspondent robot link. bool neutrallyBuoyant If true, the restoring force will be equal to the gravitational. double metacentricWidth double metacentricLength Metacentric length of the robot, used only for surface vessels and floating objects. double waterLevelPlaneArea If the cross section area around water level of the surface vessel is not given, it will be computed from the object's bounding box. double submergedHeight Height of the robot that is submerged (only for surface vessels) bool isSurfaceVessel Flag set to true if the information about the metacentric width and height is available. bool isSurfaceVesselFloating Flag set to true if the vessel has reached its submerged height. Public Functions Documentation function create static HydrodynamicModel * create( sdf::ElementPtr _sdf, physics::LinkPtr _link ) Create model of this type with parameter values from sdf. function GetType inline virtual std::string GetType() Return (derived) type of hydrodynamic model. Reimplements : gazebo::HMFossen::GetType function Print virtual void Print( std::string _paramName, std::string _message =std::string() ) Prints parameters. Reimplements : gazebo::HMFossen::Print Protected Functions Documentation function HMSpheroid HMSpheroid( sdf::ElementPtr _sdf, physics::LinkPtr _link ) Protected Attributes Documentation variable IDENTIFIER static const std::string IDENTIFIER = \"spheroid\"; Unique identifier for this geometry. variable length double length; Length of the sphroid. variable radius double radius; Prolate spheroid's smaller radius. Updated on 2022-05-30 at 18:35:12 +0000","title":"classgazebo 1 1HMSpheroid"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSpheroid/#gazebohmspheroid","text":"Class containing the methods and attributes for a hydrodynamic model for a spheroid in the fluid Reference: Antonelli - Underwater Robots. #include <HydrodynamicModel.hh> Inherits from gazebo::HMFossen , gazebo::HydrodynamicModel , gazebo::BuoyantObject","title":"gazebo::HMSpheroid"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSpheroid/#public-functions","text":"Name HydrodynamicModel * create (sdf::ElementPtr _sdf, physics::LinkPtr _link) Create model of this type with parameter values from sdf. virtual std::string GetType () Return (derived) type of hydrodynamic model. virtual void Print (std::string _paramName, std::string _message =std::string()) Prints parameters.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSpheroid/#protected-functions","text":"Name HMSpheroid (sdf::ElementPtr _sdf, physics::LinkPtr _link)","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSpheroid/#protected-attributes","text":"Name const std::string IDENTIFIER Unique identifier for this geometry. double length Length of the sphroid. double radius Prolate spheroid's smaller radius.","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSpheroid/#additional-inherited-members","text":"Public Functions inherited from gazebo::HMFossen Name virtual bool GetParam (std::string _tag, std::vector< double > & _output) Return paramater in vector form for the given tag. virtual bool GetParam (std::string _tag, double & _output) Return paramater in scalar form for the given tag. virtual bool SetParam (std::string _tag, double _input) Set scalar parameter. virtual void ApplyHydrodynamicForces (double time, const ignition::math::Vector3d & _flowVelWorld) Computation of the hydrodynamic forces. Protected Functions inherited from gazebo::HMFossen Name HMFossen (sdf::ElementPtr _sdf, physics::LinkPtr _link) void ComputeAddedCoriolisMatrix (const Eigen::Vector6d & _vel, const Eigen::Matrix6d & _Ma, Eigen::Matrix6d & _Ca) const Computes the added-mass Coriolis matrix Ca. void ComputeDampingMatrix (const Eigen::Vector6d & _vel, Eigen::Matrix6d & _D) const Updates the damping matrix for the current velocity. Eigen::Matrix6d GetAddedMass () const Returns the added-mass matrix with the scaling and offset. Protected Attributes inherited from gazebo::HMFossen Name Eigen::Matrix6d Ma Added-mass matrix. double scalingAddedMass Scaling of the added-mass matrix. double offsetAddedMass Offset for the added-mass matrix. Eigen::Matrix6d Ca Added-mass associated Coriolis matrix. Eigen::Matrix6d D Damping matrix. double scalingDamping Scaling of the damping matrix. double offsetLinearDamping Offset for the linear damping matrix. double offsetLinForwardSpeedDamping Offset for the linear damping matrix. double offsetNonLinDamping Offset for the linear damping matrix. Eigen::Matrix6d DLin Linear damping matrix. Eigen::Matrix6d DLinForwardSpeed Linear damping matrix proportional only to the forward speed (useful for modeling AUVs). From [1], according to Newman (1977), there is a damping force component that linearly increases with the presence of forward speed, particularly so for slender bodies. Eigen::Matrix6d DNonLin Nonlinear damping coefficients. std::vector< double > linearDampCoef Linear damping coefficients. std::vector< double > quadDampCoef Quadratic damping coefficients. Public Functions inherited from gazebo::HydrodynamicModel Name virtual void ApplyHydrodynamicForces (double time, const ignition::math::Vector3d & _flowVelWorld) =0 Computation of the hydrodynamic forces. virtual bool GetParam (std::string _tag, std::vector< double > & _output) =0 Return paramater in vector form for the given tag. virtual bool GetParam (std::string _tag, double & _output) =0 Return paramater in vector form for the given tag. virtual bool SetParam (std::string _tag, double _input) =0 Set a scalar parameters. Protected Functions inherited from gazebo::HydrodynamicModel Name HydrodynamicModel (sdf::ElementPtr _sdf, physics::LinkPtr _link) Protected constructor: Use the factory for object creation. void ComputeAcc ( Eigen::Vector6d _velRel, double _time, double _alpha =0.3) Filter acceleration (fix due to the update structure of Gazebo) bool CheckParams (sdf::ElementPtr _sdf) Returns true if all parameters are available from the SDF element. ignition::math::Vector3d ToNED (ignition::math::Vector3d _vec) Convert vector to comply with the NED reference frame. ignition::math::Vector3d FromNED (ignition::math::Vector3d _vec) Convert vector to comply with the NED reference frame. Protected Attributes inherited from gazebo::HydrodynamicModel Name Eigen::Vector6d filteredAcc Filtered linear & angular acceleration vector in link frame. This is used to prevent the model to become unstable given that Gazebo only calls the update function at the beginning or at the end of a iteration of the physics engine. double lastTime Last timestamp (in seconds) at which ApplyHydrodynamicForces was called. Eigen::Vector6d lastVelRel Last body-fixed relative velocity (nu_R in Fossen's equations) std::vector< std::string > params List of parameters needed from the SDF element. double Re Reynolds number (not used by all models) double temperature Temperature (not used by all models) Public Functions inherited from gazebo::BuoyantObject Name BuoyantObject (physics::LinkPtr _link) Constructor. ~BuoyantObject () Destructor. void GetBuoyancyForce (const ignition::math::Pose3d & _pose, ignition::math::Vector3d & buoyancyForce, ignition::math::Vector3d & buoyancyTorque) Returns the buoyancy force vector in the world frame. void ApplyBuoyancyForce () Applies buoyancy force on link. void SetVolume (double _volume =-1) Sets the link's submerged volume. double GetVolume () Returns the stored link submerged volume. void SetFluidDensity (double _fluidDensity) Sets the fluid density in kg/m^3. double GetFluidDensity () Returns the stored fluid density. void SetCoB (const ignition::math::Vector3d & _centerOfBuoyancy) Sets the position of the center of buoyancy on the body frame. ignition::math::Vector3d GetCoB () Returns the stored center of buoyancy. void SetGravity (double _g) Set acceleration of gravity. double GetGravity () Get stored acceleration of gravity. void SetBoundingBox (const AxisAlignedBox & _bBox) Sets bounding box. void SetStoreVector (std::string _tag) Adds a field in the hydroWrench map. ignition::math::Vector3d GetStoredVector (std::string _tag) Get vector from the hydroWrench map. void SetDebugFlag (bool _debugOn =true) Set debug flag to store intermediate forces and torques. bool IsSubmerged () Returns true if the robot is completely submerged. bool IsNeutrallyBuoyant () Returns true if the link was set to be neutrally buoyant. bool GetDebugFlag () Returns the debug flag. void SetNeutrallyBuoyant () Sets this link as neutrally buoyant. Protected Functions inherited from gazebo::BuoyantObject Name void StoreVector (std::string _tag, ignition::math::Vector3d _vec) Store vector in the hydroWrench map if the field has been created. Protected Attributes inherited from gazebo::BuoyantObject Name double volume Volume of fluid displaced by the submerged object. double scalingVolume Scaling factor for the volume. double offsetVolume Offset for the volume. double fluidDensity Fluid density. double g Acceleration of gravity. ignition::math::Vector3d centerOfBuoyancy Center of buoyancy in the body frame. AxisAlignedBox boundingBox TEMP for calculation of the buoyancy force close to the surface. std::map< std::string, ignition::math::Vector3d > hydroWrench Storage for hydrodynamic and hydrostatic forces and torques for debugging purposes. bool debugFlag Debug flag, storing all intermediate forces and torques. bool isSubmerged Is submerged flag. physics::LinkPtr link Pointer to the correspondent robot link. bool neutrallyBuoyant If true, the restoring force will be equal to the gravitational. double metacentricWidth double metacentricLength Metacentric length of the robot, used only for surface vessels and floating objects. double waterLevelPlaneArea If the cross section area around water level of the surface vessel is not given, it will be computed from the object's bounding box. double submergedHeight Height of the robot that is submerged (only for surface vessels) bool isSurfaceVessel Flag set to true if the information about the metacentric width and height is available. bool isSurfaceVesselFloating Flag set to true if the vessel has reached its submerged height.","title":"Additional inherited members"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSpheroid/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSpheroid/#function-create","text":"static HydrodynamicModel * create( sdf::ElementPtr _sdf, physics::LinkPtr _link ) Create model of this type with parameter values from sdf.","title":"function create"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSpheroid/#function-gettype","text":"inline virtual std::string GetType() Return (derived) type of hydrodynamic model. Reimplements : gazebo::HMFossen::GetType","title":"function GetType"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSpheroid/#function-print","text":"virtual void Print( std::string _paramName, std::string _message =std::string() ) Prints parameters. Reimplements : gazebo::HMFossen::Print","title":"function Print"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSpheroid/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSpheroid/#function-hmspheroid","text":"HMSpheroid( sdf::ElementPtr _sdf, physics::LinkPtr _link )","title":"function HMSpheroid"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSpheroid/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSpheroid/#variable-identifier","text":"static const std::string IDENTIFIER = \"spheroid\"; Unique identifier for this geometry.","title":"variable IDENTIFIER"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSpheroid/#variable-length","text":"double length; Length of the sphroid.","title":"variable length"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HMSpheroid/#variable-radius","text":"double radius; Prolate spheroid's smaller radius. Updated on 2022-05-30 at 18:35:12 +0000","title":"variable radius"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HydrodynamicModel/","text":"gazebo::HydrodynamicModel Inherits from gazebo::BuoyantObject Inherited by gazebo::HMFossen Public Functions Name virtual std::string GetType () =0 Returns type of model. virtual void ApplyHydrodynamicForces (double time, const ignition::math::Vector3d & _flowVelWorld) =0 Computation of the hydrodynamic forces. virtual void Print (std::string _paramName, std::string _message =std::string()) =0 Prints parameters. virtual bool GetParam (std::string _tag, std::vector< double > & _output) =0 Return paramater in vector form for the given tag. virtual bool GetParam (std::string _tag, double & _output) =0 Return paramater in vector form for the given tag. virtual bool SetParam (std::string _tag, double _input) =0 Set a scalar parameters. Protected Functions Name HydrodynamicModel (sdf::ElementPtr _sdf, physics::LinkPtr _link) Protected constructor: Use the factory for object creation. void ComputeAcc ( Eigen::Vector6d _velRel, double _time, double _alpha =0.3) Filter acceleration (fix due to the update structure of Gazebo) bool CheckParams (sdf::ElementPtr _sdf) Returns true if all parameters are available from the SDF element. ignition::math::Vector3d ToNED (ignition::math::Vector3d _vec) Convert vector to comply with the NED reference frame. ignition::math::Vector3d FromNED (ignition::math::Vector3d _vec) Convert vector to comply with the NED reference frame. Protected Attributes Name Eigen::Vector6d filteredAcc Filtered linear & angular acceleration vector in link frame. This is used to prevent the model to become unstable given that Gazebo only calls the update function at the beginning or at the end of a iteration of the physics engine. double lastTime Last timestamp (in seconds) at which ApplyHydrodynamicForces was called. Eigen::Vector6d lastVelRel Last body-fixed relative velocity (nu_R in Fossen's equations) std::vector< std::string > params List of parameters needed from the SDF element. double Re Reynolds number (not used by all models) double temperature Temperature (not used by all models) Additional inherited members Public Functions inherited from gazebo::BuoyantObject Name BuoyantObject (physics::LinkPtr _link) Constructor. ~BuoyantObject () Destructor. void GetBuoyancyForce (const ignition::math::Pose3d & _pose, ignition::math::Vector3d & buoyancyForce, ignition::math::Vector3d & buoyancyTorque) Returns the buoyancy force vector in the world frame. void ApplyBuoyancyForce () Applies buoyancy force on link. void SetVolume (double _volume =-1) Sets the link's submerged volume. double GetVolume () Returns the stored link submerged volume. void SetFluidDensity (double _fluidDensity) Sets the fluid density in kg/m^3. double GetFluidDensity () Returns the stored fluid density. void SetCoB (const ignition::math::Vector3d & _centerOfBuoyancy) Sets the position of the center of buoyancy on the body frame. ignition::math::Vector3d GetCoB () Returns the stored center of buoyancy. void SetGravity (double _g) Set acceleration of gravity. double GetGravity () Get stored acceleration of gravity. void SetBoundingBox (const AxisAlignedBox & _bBox) Sets bounding box. void SetStoreVector (std::string _tag) Adds a field in the hydroWrench map. ignition::math::Vector3d GetStoredVector (std::string _tag) Get vector from the hydroWrench map. void SetDebugFlag (bool _debugOn =true) Set debug flag to store intermediate forces and torques. bool IsSubmerged () Returns true if the robot is completely submerged. bool IsNeutrallyBuoyant () Returns true if the link was set to be neutrally buoyant. bool GetDebugFlag () Returns the debug flag. void SetNeutrallyBuoyant () Sets this link as neutrally buoyant. Protected Functions inherited from gazebo::BuoyantObject Name void StoreVector (std::string _tag, ignition::math::Vector3d _vec) Store vector in the hydroWrench map if the field has been created. Protected Attributes inherited from gazebo::BuoyantObject Name double volume Volume of fluid displaced by the submerged object. double scalingVolume Scaling factor for the volume. double offsetVolume Offset for the volume. double fluidDensity Fluid density. double g Acceleration of gravity. ignition::math::Vector3d centerOfBuoyancy Center of buoyancy in the body frame. AxisAlignedBox boundingBox TEMP for calculation of the buoyancy force close to the surface. std::map< std::string, ignition::math::Vector3d > hydroWrench Storage for hydrodynamic and hydrostatic forces and torques for debugging purposes. bool debugFlag Debug flag, storing all intermediate forces and torques. bool isSubmerged Is submerged flag. physics::LinkPtr link Pointer to the correspondent robot link. bool neutrallyBuoyant If true, the restoring force will be equal to the gravitational. double metacentricWidth double metacentricLength Metacentric length of the robot, used only for surface vessels and floating objects. double waterLevelPlaneArea If the cross section area around water level of the surface vessel is not given, it will be computed from the object's bounding box. double submergedHeight Height of the robot that is submerged (only for surface vessels) bool isSurfaceVessel Flag set to true if the information about the metacentric width and height is available. bool isSurfaceVesselFloating Flag set to true if the vessel has reached its submerged height. Public Functions Documentation function GetType virtual std::string GetType() =0 Returns type of model. Reimplemented by : gazebo::HMFossen::GetType , gazebo::HMSphere::GetType , gazebo::HMCylinder::GetType , gazebo::HMSpheroid::GetType , gazebo::HMBox::GetType function ApplyHydrodynamicForces virtual void ApplyHydrodynamicForces( double time, const ignition::math::Vector3d & _flowVelWorld ) =0 Computation of the hydrodynamic forces. Reimplemented by : gazebo::HMFossen::ApplyHydrodynamicForces function Print virtual void Print( std::string _paramName, std::string _message =std::string() ) =0 Prints parameters. Reimplemented by : gazebo::HMFossen::Print , gazebo::HMSphere::Print , gazebo::HMCylinder::Print , gazebo::HMSpheroid::Print , gazebo::HMBox::Print function GetParam virtual bool GetParam( std::string _tag, std::vector< double > & _output ) =0 Return paramater in vector form for the given tag. Reimplemented by : gazebo::HMFossen::GetParam function GetParam virtual bool GetParam( std::string _tag, double & _output ) =0 Return paramater in vector form for the given tag. Reimplemented by : gazebo::HMFossen::GetParam function SetParam virtual bool SetParam( std::string _tag, double _input ) =0 Set a scalar parameters. Reimplemented by : gazebo::HMFossen::SetParam Protected Functions Documentation function HydrodynamicModel HydrodynamicModel( sdf::ElementPtr _sdf, physics::LinkPtr _link ) Protected constructor: Use the factory for object creation. function ComputeAcc void ComputeAcc( Eigen::Vector6d _velRel, double _time, double _alpha =0.3 ) Filter acceleration (fix due to the update structure of Gazebo) function CheckParams bool CheckParams( sdf::ElementPtr _sdf ) Returns true if all parameters are available from the SDF element. function ToNED ignition::math::Vector3d ToNED( ignition::math::Vector3d _vec ) Convert vector to comply with the NED reference frame. function FromNED ignition::math::Vector3d FromNED( ignition::math::Vector3d _vec ) Convert vector to comply with the NED reference frame. Protected Attributes Documentation variable filteredAcc Eigen::Vector6d filteredAcc; Filtered linear & angular acceleration vector in link frame. This is used to prevent the model to become unstable given that Gazebo only calls the update function at the beginning or at the end of a iteration of the physics engine. variable lastTime double lastTime; Last timestamp (in seconds) at which ApplyHydrodynamicForces was called. variable lastVelRel Eigen::Vector6d lastVelRel; Last body-fixed relative velocity (nu_R in Fossen's equations) variable params std::vector< std::string > params; List of parameters needed from the SDF element. variable Re double Re; Reynolds number (not used by all models) variable temperature double temperature; Temperature (not used by all models) Updated on 2022-05-30 at 18:35:12 +0000","title":"gazebo::HydrodynamicModel"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HydrodynamicModel/#gazebohydrodynamicmodel","text":"Inherits from gazebo::BuoyantObject Inherited by gazebo::HMFossen","title":"gazebo::HydrodynamicModel"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HydrodynamicModel/#public-functions","text":"Name virtual std::string GetType () =0 Returns type of model. virtual void ApplyHydrodynamicForces (double time, const ignition::math::Vector3d & _flowVelWorld) =0 Computation of the hydrodynamic forces. virtual void Print (std::string _paramName, std::string _message =std::string()) =0 Prints parameters. virtual bool GetParam (std::string _tag, std::vector< double > & _output) =0 Return paramater in vector form for the given tag. virtual bool GetParam (std::string _tag, double & _output) =0 Return paramater in vector form for the given tag. virtual bool SetParam (std::string _tag, double _input) =0 Set a scalar parameters.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HydrodynamicModel/#protected-functions","text":"Name HydrodynamicModel (sdf::ElementPtr _sdf, physics::LinkPtr _link) Protected constructor: Use the factory for object creation. void ComputeAcc ( Eigen::Vector6d _velRel, double _time, double _alpha =0.3) Filter acceleration (fix due to the update structure of Gazebo) bool CheckParams (sdf::ElementPtr _sdf) Returns true if all parameters are available from the SDF element. ignition::math::Vector3d ToNED (ignition::math::Vector3d _vec) Convert vector to comply with the NED reference frame. ignition::math::Vector3d FromNED (ignition::math::Vector3d _vec) Convert vector to comply with the NED reference frame.","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HydrodynamicModel/#protected-attributes","text":"Name Eigen::Vector6d filteredAcc Filtered linear & angular acceleration vector in link frame. This is used to prevent the model to become unstable given that Gazebo only calls the update function at the beginning or at the end of a iteration of the physics engine. double lastTime Last timestamp (in seconds) at which ApplyHydrodynamicForces was called. Eigen::Vector6d lastVelRel Last body-fixed relative velocity (nu_R in Fossen's equations) std::vector< std::string > params List of parameters needed from the SDF element. double Re Reynolds number (not used by all models) double temperature Temperature (not used by all models)","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HydrodynamicModel/#additional-inherited-members","text":"Public Functions inherited from gazebo::BuoyantObject Name BuoyantObject (physics::LinkPtr _link) Constructor. ~BuoyantObject () Destructor. void GetBuoyancyForce (const ignition::math::Pose3d & _pose, ignition::math::Vector3d & buoyancyForce, ignition::math::Vector3d & buoyancyTorque) Returns the buoyancy force vector in the world frame. void ApplyBuoyancyForce () Applies buoyancy force on link. void SetVolume (double _volume =-1) Sets the link's submerged volume. double GetVolume () Returns the stored link submerged volume. void SetFluidDensity (double _fluidDensity) Sets the fluid density in kg/m^3. double GetFluidDensity () Returns the stored fluid density. void SetCoB (const ignition::math::Vector3d & _centerOfBuoyancy) Sets the position of the center of buoyancy on the body frame. ignition::math::Vector3d GetCoB () Returns the stored center of buoyancy. void SetGravity (double _g) Set acceleration of gravity. double GetGravity () Get stored acceleration of gravity. void SetBoundingBox (const AxisAlignedBox & _bBox) Sets bounding box. void SetStoreVector (std::string _tag) Adds a field in the hydroWrench map. ignition::math::Vector3d GetStoredVector (std::string _tag) Get vector from the hydroWrench map. void SetDebugFlag (bool _debugOn =true) Set debug flag to store intermediate forces and torques. bool IsSubmerged () Returns true if the robot is completely submerged. bool IsNeutrallyBuoyant () Returns true if the link was set to be neutrally buoyant. bool GetDebugFlag () Returns the debug flag. void SetNeutrallyBuoyant () Sets this link as neutrally buoyant. Protected Functions inherited from gazebo::BuoyantObject Name void StoreVector (std::string _tag, ignition::math::Vector3d _vec) Store vector in the hydroWrench map if the field has been created. Protected Attributes inherited from gazebo::BuoyantObject Name double volume Volume of fluid displaced by the submerged object. double scalingVolume Scaling factor for the volume. double offsetVolume Offset for the volume. double fluidDensity Fluid density. double g Acceleration of gravity. ignition::math::Vector3d centerOfBuoyancy Center of buoyancy in the body frame. AxisAlignedBox boundingBox TEMP for calculation of the buoyancy force close to the surface. std::map< std::string, ignition::math::Vector3d > hydroWrench Storage for hydrodynamic and hydrostatic forces and torques for debugging purposes. bool debugFlag Debug flag, storing all intermediate forces and torques. bool isSubmerged Is submerged flag. physics::LinkPtr link Pointer to the correspondent robot link. bool neutrallyBuoyant If true, the restoring force will be equal to the gravitational. double metacentricWidth double metacentricLength Metacentric length of the robot, used only for surface vessels and floating objects. double waterLevelPlaneArea If the cross section area around water level of the surface vessel is not given, it will be computed from the object's bounding box. double submergedHeight Height of the robot that is submerged (only for surface vessels) bool isSurfaceVessel Flag set to true if the information about the metacentric width and height is available. bool isSurfaceVesselFloating Flag set to true if the vessel has reached its submerged height.","title":"Additional inherited members"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HydrodynamicModel/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HydrodynamicModel/#function-gettype","text":"virtual std::string GetType() =0 Returns type of model. Reimplemented by : gazebo::HMFossen::GetType , gazebo::HMSphere::GetType , gazebo::HMCylinder::GetType , gazebo::HMSpheroid::GetType , gazebo::HMBox::GetType","title":"function GetType"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HydrodynamicModel/#function-applyhydrodynamicforces","text":"virtual void ApplyHydrodynamicForces( double time, const ignition::math::Vector3d & _flowVelWorld ) =0 Computation of the hydrodynamic forces. Reimplemented by : gazebo::HMFossen::ApplyHydrodynamicForces","title":"function ApplyHydrodynamicForces"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HydrodynamicModel/#function-print","text":"virtual void Print( std::string _paramName, std::string _message =std::string() ) =0 Prints parameters. Reimplemented by : gazebo::HMFossen::Print , gazebo::HMSphere::Print , gazebo::HMCylinder::Print , gazebo::HMSpheroid::Print , gazebo::HMBox::Print","title":"function Print"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HydrodynamicModel/#function-getparam","text":"virtual bool GetParam( std::string _tag, std::vector< double > & _output ) =0 Return paramater in vector form for the given tag. Reimplemented by : gazebo::HMFossen::GetParam","title":"function GetParam"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HydrodynamicModel/#function-getparam_1","text":"virtual bool GetParam( std::string _tag, double & _output ) =0 Return paramater in vector form for the given tag. Reimplemented by : gazebo::HMFossen::GetParam","title":"function GetParam"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HydrodynamicModel/#function-setparam","text":"virtual bool SetParam( std::string _tag, double _input ) =0 Set a scalar parameters. Reimplemented by : gazebo::HMFossen::SetParam","title":"function SetParam"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HydrodynamicModel/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HydrodynamicModel/#function-hydrodynamicmodel","text":"HydrodynamicModel( sdf::ElementPtr _sdf, physics::LinkPtr _link ) Protected constructor: Use the factory for object creation.","title":"function HydrodynamicModel"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HydrodynamicModel/#function-computeacc","text":"void ComputeAcc( Eigen::Vector6d _velRel, double _time, double _alpha =0.3 ) Filter acceleration (fix due to the update structure of Gazebo)","title":"function ComputeAcc"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HydrodynamicModel/#function-checkparams","text":"bool CheckParams( sdf::ElementPtr _sdf ) Returns true if all parameters are available from the SDF element.","title":"function CheckParams"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HydrodynamicModel/#function-toned","text":"ignition::math::Vector3d ToNED( ignition::math::Vector3d _vec ) Convert vector to comply with the NED reference frame.","title":"function ToNED"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HydrodynamicModel/#function-fromned","text":"ignition::math::Vector3d FromNED( ignition::math::Vector3d _vec ) Convert vector to comply with the NED reference frame.","title":"function FromNED"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HydrodynamicModel/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HydrodynamicModel/#variable-filteredacc","text":"Eigen::Vector6d filteredAcc; Filtered linear & angular acceleration vector in link frame. This is used to prevent the model to become unstable given that Gazebo only calls the update function at the beginning or at the end of a iteration of the physics engine.","title":"variable filteredAcc"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HydrodynamicModel/#variable-lasttime","text":"double lastTime; Last timestamp (in seconds) at which ApplyHydrodynamicForces was called.","title":"variable lastTime"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HydrodynamicModel/#variable-lastvelrel","text":"Eigen::Vector6d lastVelRel; Last body-fixed relative velocity (nu_R in Fossen's equations)","title":"variable lastVelRel"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HydrodynamicModel/#variable-params","text":"std::vector< std::string > params; List of parameters needed from the SDF element.","title":"variable params"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HydrodynamicModel/#variable-re","text":"double Re; Reynolds number (not used by all models)","title":"variable Re"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HydrodynamicModel/#variable-temperature","text":"double temperature; Temperature (not used by all models) Updated on 2022-05-30 at 18:35:12 +0000","title":"variable temperature"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HydrodynamicModelFactory/","text":"gazebo::HydrodynamicModelFactory Factory singleton class that creates a HydrodynamicModel from sdf. #include <HydrodynamicModel.hh> Public Functions Name HydrodynamicModel * CreateHydrodynamicModel (sdf::ElementPtr _sdf, physics::LinkPtr _link) Create HydrodynamicModel object according to its sdf Description. bool RegisterCreator (const std::string & _identifier, HydrodynamicModelCreator _creator) Register a class with its creator. HydrodynamicModelFactory & GetInstance () Returns the singleton instance of this factory. Public Functions Documentation function CreateHydrodynamicModel HydrodynamicModel * CreateHydrodynamicModel( sdf::ElementPtr _sdf, physics::LinkPtr _link ) Create HydrodynamicModel object according to its sdf Description. function RegisterCreator bool RegisterCreator( const std::string & _identifier, HydrodynamicModelCreator _creator ) Register a class with its creator. function GetInstance static HydrodynamicModelFactory & GetInstance() Returns the singleton instance of this factory. Updated on 2022-05-30 at 18:35:12 +0000","title":"gazebo::HydrodynamicModelFactory"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HydrodynamicModelFactory/#gazebohydrodynamicmodelfactory","text":"Factory singleton class that creates a HydrodynamicModel from sdf. #include <HydrodynamicModel.hh>","title":"gazebo::HydrodynamicModelFactory"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HydrodynamicModelFactory/#public-functions","text":"Name HydrodynamicModel * CreateHydrodynamicModel (sdf::ElementPtr _sdf, physics::LinkPtr _link) Create HydrodynamicModel object according to its sdf Description. bool RegisterCreator (const std::string & _identifier, HydrodynamicModelCreator _creator) Register a class with its creator. HydrodynamicModelFactory & GetInstance () Returns the singleton instance of this factory.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HydrodynamicModelFactory/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HydrodynamicModelFactory/#function-createhydrodynamicmodel","text":"HydrodynamicModel * CreateHydrodynamicModel( sdf::ElementPtr _sdf, physics::LinkPtr _link ) Create HydrodynamicModel object according to its sdf Description.","title":"function CreateHydrodynamicModel"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HydrodynamicModelFactory/#function-registercreator","text":"bool RegisterCreator( const std::string & _identifier, HydrodynamicModelCreator _creator ) Register a class with its creator.","title":"function RegisterCreator"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1HydrodynamicModelFactory/#function-getinstance","text":"static HydrodynamicModelFactory & GetInstance() Returns the singleton instance of this factory. Updated on 2022-05-30 at 18:35:12 +0000","title":"function GetInstance"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDrag/","text":"gazebo::LiftDrag Abstract base class for Lift&Drag models. #include <LiftDragModel.hh> Inherited by gazebo::LiftDragQuadratic , gazebo::LiftDragTwoLines Public Functions Name bool CheckForElement (sdf::ElementPtr _sdf, const std::string & element) Check for element. Complain and return 0 if it is missing. virtual ~LiftDrag () Destructor. virtual std::string GetType () =0 Return (derived) type of lift&drag model. virtual ignition::math::Vector3d compute (const ignition::math::Vector3d & _velL) =0 Compute the lift and drag force. virtual bool GetParam (std::string _tag, double & _output) =0 Return paramater in vector form for the given tag. virtual std::map< std::string, double > GetListParams () =0 Return list of all parameters. Protected Functions Name LiftDrag () Protected constructor: Use the factory for object creation. Protected Attributes Name double prevTime Time of last state update. double state Latest state. Public Functions Documentation function CheckForElement static bool CheckForElement( sdf::ElementPtr _sdf, const std::string & element ) Check for element. Complain and return 0 if it is missing. function ~LiftDrag inline virtual ~LiftDrag() Destructor. function GetType virtual std::string GetType() =0 Return (derived) type of lift&drag model. Reimplemented by : gazebo::LiftDragQuadratic::GetType , gazebo::LiftDragTwoLines::GetType function compute virtual ignition::math::Vector3d compute( const ignition::math::Vector3d & _velL ) =0 Compute the lift and drag force. Reimplemented by : gazebo::LiftDragTwoLines::compute , gazebo::LiftDragQuadratic::compute function GetParam virtual bool GetParam( std::string _tag, double & _output ) =0 Return paramater in vector form for the given tag. Reimplemented by : gazebo::LiftDragQuadratic::GetParam , gazebo::LiftDragTwoLines::GetParam function GetListParams virtual std::map< std::string, double > GetListParams() =0 Return list of all parameters. Reimplemented by : gazebo::LiftDragQuadratic::GetListParams , gazebo::LiftDragTwoLines::GetListParams Protected Functions Documentation function LiftDrag inline LiftDrag() Protected constructor: Use the factory for object creation. Protected Attributes Documentation variable prevTime double prevTime; Time of last state update. variable state double state; Latest state. Updated on 2022-05-30 at 18:35:12 +0000","title":"gazebo::LiftDrag"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDrag/#gazeboliftdrag","text":"Abstract base class for Lift&Drag models. #include <LiftDragModel.hh> Inherited by gazebo::LiftDragQuadratic , gazebo::LiftDragTwoLines","title":"gazebo::LiftDrag"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDrag/#public-functions","text":"Name bool CheckForElement (sdf::ElementPtr _sdf, const std::string & element) Check for element. Complain and return 0 if it is missing. virtual ~LiftDrag () Destructor. virtual std::string GetType () =0 Return (derived) type of lift&drag model. virtual ignition::math::Vector3d compute (const ignition::math::Vector3d & _velL) =0 Compute the lift and drag force. virtual bool GetParam (std::string _tag, double & _output) =0 Return paramater in vector form for the given tag. virtual std::map< std::string, double > GetListParams () =0 Return list of all parameters.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDrag/#protected-functions","text":"Name LiftDrag () Protected constructor: Use the factory for object creation.","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDrag/#protected-attributes","text":"Name double prevTime Time of last state update. double state Latest state.","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDrag/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDrag/#function-checkforelement","text":"static bool CheckForElement( sdf::ElementPtr _sdf, const std::string & element ) Check for element. Complain and return 0 if it is missing.","title":"function CheckForElement"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDrag/#function-liftdrag","text":"inline virtual ~LiftDrag() Destructor.","title":"function ~LiftDrag"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDrag/#function-gettype","text":"virtual std::string GetType() =0 Return (derived) type of lift&drag model. Reimplemented by : gazebo::LiftDragQuadratic::GetType , gazebo::LiftDragTwoLines::GetType","title":"function GetType"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDrag/#function-compute","text":"virtual ignition::math::Vector3d compute( const ignition::math::Vector3d & _velL ) =0 Compute the lift and drag force. Reimplemented by : gazebo::LiftDragTwoLines::compute , gazebo::LiftDragQuadratic::compute","title":"function compute"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDrag/#function-getparam","text":"virtual bool GetParam( std::string _tag, double & _output ) =0 Return paramater in vector form for the given tag. Reimplemented by : gazebo::LiftDragQuadratic::GetParam , gazebo::LiftDragTwoLines::GetParam","title":"function GetParam"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDrag/#function-getlistparams","text":"virtual std::map< std::string, double > GetListParams() =0 Return list of all parameters. Reimplemented by : gazebo::LiftDragQuadratic::GetListParams , gazebo::LiftDragTwoLines::GetListParams","title":"function GetListParams"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDrag/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDrag/#function-liftdrag_1","text":"inline LiftDrag() Protected constructor: Use the factory for object creation.","title":"function LiftDrag"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDrag/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDrag/#variable-prevtime","text":"double prevTime; Time of last state update.","title":"variable prevTime"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDrag/#variable-state","text":"double state; Latest state. Updated on 2022-05-30 at 18:35:12 +0000","title":"variable state"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragFactory/","text":"gazebo::LiftDragFactory Factory singleton class that creates a LiftDrag from sdf. #include <LiftDragModel.hh> Public Functions Name LiftDrag * CreateLiftDrag (sdf::ElementPtr _sdf) Create LiftDrag object according to its sdf Description. bool RegisterCreator (const std::string & _identifier, LiftDragCreator _creator) Register a LiftDrag class with its creator. LiftDragFactory & GetInstance () Returns the singleton instance of this factory. Public Functions Documentation function CreateLiftDrag LiftDrag * CreateLiftDrag( sdf::ElementPtr _sdf ) Create LiftDrag object according to its sdf Description. function RegisterCreator bool RegisterCreator( const std::string & _identifier, LiftDragCreator _creator ) Register a LiftDrag class with its creator. function GetInstance static LiftDragFactory & GetInstance() Returns the singleton instance of this factory. Updated on 2022-05-30 at 18:35:12 +0000","title":"gazebo::LiftDragFactory"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragFactory/#gazeboliftdragfactory","text":"Factory singleton class that creates a LiftDrag from sdf. #include <LiftDragModel.hh>","title":"gazebo::LiftDragFactory"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragFactory/#public-functions","text":"Name LiftDrag * CreateLiftDrag (sdf::ElementPtr _sdf) Create LiftDrag object according to its sdf Description. bool RegisterCreator (const std::string & _identifier, LiftDragCreator _creator) Register a LiftDrag class with its creator. LiftDragFactory & GetInstance () Returns the singleton instance of this factory.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragFactory/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragFactory/#function-createliftdrag","text":"LiftDrag * CreateLiftDrag( sdf::ElementPtr _sdf ) Create LiftDrag object according to its sdf Description.","title":"function CreateLiftDrag"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragFactory/#function-registercreator","text":"bool RegisterCreator( const std::string & _identifier, LiftDragCreator _creator ) Register a LiftDrag class with its creator.","title":"function RegisterCreator"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragFactory/#function-getinstance","text":"static LiftDragFactory & GetInstance() Returns the singleton instance of this factory. Updated on 2022-05-30 at 18:35:12 +0000","title":"function GetInstance"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragQuadratic/","text":"gazebo::LiftDragQuadratic Basic quadratic (Hugin) lift&drag model, page 18 from [1]. [1] Engelhardtsen, \u00d8ystein. \"3D AUV Collision Avoidance.\" (2007). #include <LiftDragModel.hh> Inherits from gazebo::LiftDrag Public Functions Name LiftDrag * create (sdf::ElementPtr _sdf) Create thruster model of this type with parameter values from sdf. virtual std::string GetType () Return (derived) type of dynamic system. virtual ignition::math::Vector3d compute (const ignition::math::Vector3d & velL) Compute the lift and drag force. virtual bool GetParam (std::string _tag, double & _output) Return paramater in scalar form for the given tag. virtual std::map< std::string, double > GetListParams () Return list of all parameters. Protected Attributes Name double liftConstant Lift constant. double dragConstant Drag constant. Additional inherited members Public Functions inherited from gazebo::LiftDrag Name bool CheckForElement (sdf::ElementPtr _sdf, const std::string & element) Check for element. Complain and return 0 if it is missing. virtual ~LiftDrag () Destructor. Protected Functions inherited from gazebo::LiftDrag Name LiftDrag () Protected constructor: Use the factory for object creation. Protected Attributes inherited from gazebo::LiftDrag Name double prevTime Time of last state update. double state Latest state. Public Functions Documentation function create static LiftDrag * create( sdf::ElementPtr _sdf ) Create thruster model of this type with parameter values from sdf. function GetType inline virtual std::string GetType() Return (derived) type of dynamic system. Reimplements : gazebo::LiftDrag::GetType function compute virtual ignition::math::Vector3d compute( const ignition::math::Vector3d & velL ) Compute the lift and drag force. Reimplements : gazebo::LiftDrag::compute function GetParam virtual bool GetParam( std::string _tag, double & _output ) Return paramater in scalar form for the given tag. Reimplements : gazebo::LiftDrag::GetParam function GetListParams virtual std::map< std::string, double > GetListParams() Return list of all parameters. Reimplements : gazebo::LiftDrag::GetListParams Protected Attributes Documentation variable liftConstant double liftConstant; Lift constant. variable dragConstant double dragConstant; Drag constant. Updated on 2022-05-30 at 18:35:12 +0000","title":"gazebo::LiftDragQuadratic"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragQuadratic/#gazeboliftdragquadratic","text":"Basic quadratic (Hugin) lift&drag model, page 18 from [1]. [1] Engelhardtsen, \u00d8ystein. \"3D AUV Collision Avoidance.\" (2007). #include <LiftDragModel.hh> Inherits from gazebo::LiftDrag","title":"gazebo::LiftDragQuadratic"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragQuadratic/#public-functions","text":"Name LiftDrag * create (sdf::ElementPtr _sdf) Create thruster model of this type with parameter values from sdf. virtual std::string GetType () Return (derived) type of dynamic system. virtual ignition::math::Vector3d compute (const ignition::math::Vector3d & velL) Compute the lift and drag force. virtual bool GetParam (std::string _tag, double & _output) Return paramater in scalar form for the given tag. virtual std::map< std::string, double > GetListParams () Return list of all parameters.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragQuadratic/#protected-attributes","text":"Name double liftConstant Lift constant. double dragConstant Drag constant.","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragQuadratic/#additional-inherited-members","text":"Public Functions inherited from gazebo::LiftDrag Name bool CheckForElement (sdf::ElementPtr _sdf, const std::string & element) Check for element. Complain and return 0 if it is missing. virtual ~LiftDrag () Destructor. Protected Functions inherited from gazebo::LiftDrag Name LiftDrag () Protected constructor: Use the factory for object creation. Protected Attributes inherited from gazebo::LiftDrag Name double prevTime Time of last state update. double state Latest state.","title":"Additional inherited members"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragQuadratic/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragQuadratic/#function-create","text":"static LiftDrag * create( sdf::ElementPtr _sdf ) Create thruster model of this type with parameter values from sdf.","title":"function create"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragQuadratic/#function-gettype","text":"inline virtual std::string GetType() Return (derived) type of dynamic system. Reimplements : gazebo::LiftDrag::GetType","title":"function GetType"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragQuadratic/#function-compute","text":"virtual ignition::math::Vector3d compute( const ignition::math::Vector3d & velL ) Compute the lift and drag force. Reimplements : gazebo::LiftDrag::compute","title":"function compute"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragQuadratic/#function-getparam","text":"virtual bool GetParam( std::string _tag, double & _output ) Return paramater in scalar form for the given tag. Reimplements : gazebo::LiftDrag::GetParam","title":"function GetParam"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragQuadratic/#function-getlistparams","text":"virtual std::map< std::string, double > GetListParams() Return list of all parameters. Reimplements : gazebo::LiftDrag::GetListParams","title":"function GetListParams"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragQuadratic/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragQuadratic/#variable-liftconstant","text":"double liftConstant; Lift constant.","title":"variable liftConstant"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragQuadratic/#variable-dragconstant","text":"double dragConstant; Drag constant. Updated on 2022-05-30 at 18:35:12 +0000","title":"variable dragConstant"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragTwoLines/","text":"gazebo::LiftDragTwoLines Lift&drag model that models lift/drag coeffs using two lines. This is based on Gazebo's LiftDragPlugin but implemented as a derived LiftDrag model to allow using it in combination with the dynamics of a Fin. #include <LiftDragModel.hh> Inherits from gazebo::LiftDrag Public Functions Name LiftDrag * create (sdf::ElementPtr _sdf) Create thruster model of this type with parameter values from sdf. virtual std::string GetType () Return (derived) type of dynamic system. virtual ignition::math::Vector3d compute (const ignition::math::Vector3d & _velL) Compute the lift and drag force. virtual bool GetParam (std::string _tag, double & _output) Return paramater in scalar form for the given tag. virtual std::map< std::string, double > GetListParams () Return list of all parameters. Protected Attributes Name double area Airfoil area. double fluidDensity Fluid density. double a0 Original zero angle of attack location. double alphaStall Stall angle. double cla Lift coefficient without stall. double claStall Lift coefficient with stall. double cda Drag coefficient without stall. double cdaStall Drag coefficient with stall. Additional inherited members Public Functions inherited from gazebo::LiftDrag Name bool CheckForElement (sdf::ElementPtr _sdf, const std::string & element) Check for element. Complain and return 0 if it is missing. virtual ~LiftDrag () Destructor. Protected Functions inherited from gazebo::LiftDrag Name LiftDrag () Protected constructor: Use the factory for object creation. Protected Attributes inherited from gazebo::LiftDrag Name double prevTime Time of last state update. double state Latest state. Public Functions Documentation function create static LiftDrag * create( sdf::ElementPtr _sdf ) Create thruster model of this type with parameter values from sdf. function GetType inline virtual std::string GetType() Return (derived) type of dynamic system. Reimplements : gazebo::LiftDrag::GetType function compute virtual ignition::math::Vector3d compute( const ignition::math::Vector3d & _velL ) Compute the lift and drag force. Reimplements : gazebo::LiftDrag::compute function GetParam virtual bool GetParam( std::string _tag, double & _output ) Return paramater in scalar form for the given tag. Reimplements : gazebo::LiftDrag::GetParam function GetListParams virtual std::map< std::string, double > GetListParams() Return list of all parameters. Reimplements : gazebo::LiftDrag::GetListParams Protected Attributes Documentation variable area double area; Airfoil area. variable fluidDensity double fluidDensity; Fluid density. variable a0 double a0; Original zero angle of attack location. variable alphaStall double alphaStall; Stall angle. variable cla double cla; Lift coefficient without stall. variable claStall double claStall; Lift coefficient with stall. variable cda double cda; Drag coefficient without stall. variable cdaStall double cdaStall; Drag coefficient with stall. Updated on 2022-05-30 at 18:35:12 +0000","title":"gazebo::LiftDragTwoLines"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragTwoLines/#gazeboliftdragtwolines","text":"Lift&drag model that models lift/drag coeffs using two lines. This is based on Gazebo's LiftDragPlugin but implemented as a derived LiftDrag model to allow using it in combination with the dynamics of a Fin. #include <LiftDragModel.hh> Inherits from gazebo::LiftDrag","title":"gazebo::LiftDragTwoLines"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragTwoLines/#public-functions","text":"Name LiftDrag * create (sdf::ElementPtr _sdf) Create thruster model of this type with parameter values from sdf. virtual std::string GetType () Return (derived) type of dynamic system. virtual ignition::math::Vector3d compute (const ignition::math::Vector3d & _velL) Compute the lift and drag force. virtual bool GetParam (std::string _tag, double & _output) Return paramater in scalar form for the given tag. virtual std::map< std::string, double > GetListParams () Return list of all parameters.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragTwoLines/#protected-attributes","text":"Name double area Airfoil area. double fluidDensity Fluid density. double a0 Original zero angle of attack location. double alphaStall Stall angle. double cla Lift coefficient without stall. double claStall Lift coefficient with stall. double cda Drag coefficient without stall. double cdaStall Drag coefficient with stall.","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragTwoLines/#additional-inherited-members","text":"Public Functions inherited from gazebo::LiftDrag Name bool CheckForElement (sdf::ElementPtr _sdf, const std::string & element) Check for element. Complain and return 0 if it is missing. virtual ~LiftDrag () Destructor. Protected Functions inherited from gazebo::LiftDrag Name LiftDrag () Protected constructor: Use the factory for object creation. Protected Attributes inherited from gazebo::LiftDrag Name double prevTime Time of last state update. double state Latest state.","title":"Additional inherited members"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragTwoLines/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragTwoLines/#function-create","text":"static LiftDrag * create( sdf::ElementPtr _sdf ) Create thruster model of this type with parameter values from sdf.","title":"function create"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragTwoLines/#function-gettype","text":"inline virtual std::string GetType() Return (derived) type of dynamic system. Reimplements : gazebo::LiftDrag::GetType","title":"function GetType"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragTwoLines/#function-compute","text":"virtual ignition::math::Vector3d compute( const ignition::math::Vector3d & _velL ) Compute the lift and drag force. Reimplements : gazebo::LiftDrag::compute","title":"function compute"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragTwoLines/#function-getparam","text":"virtual bool GetParam( std::string _tag, double & _output ) Return paramater in scalar form for the given tag. Reimplements : gazebo::LiftDrag::GetParam","title":"function GetParam"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragTwoLines/#function-getlistparams","text":"virtual std::map< std::string, double > GetListParams() Return list of all parameters. Reimplements : gazebo::LiftDrag::GetListParams","title":"function GetListParams"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragTwoLines/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragTwoLines/#variable-area","text":"double area; Airfoil area.","title":"variable area"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragTwoLines/#variable-fluiddensity","text":"double fluidDensity; Fluid density.","title":"variable fluidDensity"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragTwoLines/#variable-a0","text":"double a0; Original zero angle of attack location.","title":"variable a0"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragTwoLines/#variable-alphastall","text":"double alphaStall; Stall angle.","title":"variable alphaStall"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragTwoLines/#variable-cla","text":"double cla; Lift coefficient without stall.","title":"variable cla"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragTwoLines/#variable-clastall","text":"double claStall; Lift coefficient with stall.","title":"variable claStall"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragTwoLines/#variable-cda","text":"double cda; Drag coefficient without stall.","title":"variable cda"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1LiftDragTwoLines/#variable-cdastall","text":"double cdaStall; Drag coefficient with stall. Updated on 2022-05-30 at 18:35:12 +0000","title":"variable cdaStall"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterDynamicsBessa/","text":"gazebo::ThrusterDynamicsBessa Bessa's dynamic thruster model. More... #include <Dynamics.hh> Inherits from gazebo::Dynamics Public Functions Name Dynamics * create (sdf::ElementPtr _sdf) Create thruster model of this type with parameter values from sdf. virtual std::string GetType () Return (derived) type of dynamic system. virtual double update (double _cmd, double _t) Update dynamical model given input value and time. Additional inherited members Public Functions inherited from gazebo::Dynamics Name virtual ~Dynamics () Destructor. virtual void Reset () Protected Functions inherited from gazebo::Dynamics Name Dynamics () Protected constructor: Use the factory for object creation. Protected Attributes inherited from gazebo::Dynamics Name double prevTime Time of last state update. double state Latest state. Detailed Description class gazebo::ThrusterDynamicsBessa; Bessa's dynamic thruster model. This is \"Model 2\" described in Bessa et al.: Dynamic Positioning of Underwater Robotic Vehicles with Thruster Dynamics Compensation. Public Functions Documentation function create static Dynamics * create( sdf::ElementPtr _sdf ) Create thruster model of this type with parameter values from sdf. function GetType inline virtual std::string GetType() Return (derived) type of dynamic system. Reimplements : gazebo::Dynamics::GetType function update virtual double update( double _cmd, double _t ) Update dynamical model given input value and time. Reimplements : gazebo::Dynamics::update Updated on 2022-05-30 at 18:35:12 +0000","title":"gazebo::ThrusterDynamicsBessa"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterDynamicsBessa/#gazebothrusterdynamicsbessa","text":"Bessa's dynamic thruster model. More... #include <Dynamics.hh> Inherits from gazebo::Dynamics","title":"gazebo::ThrusterDynamicsBessa"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterDynamicsBessa/#public-functions","text":"Name Dynamics * create (sdf::ElementPtr _sdf) Create thruster model of this type with parameter values from sdf. virtual std::string GetType () Return (derived) type of dynamic system. virtual double update (double _cmd, double _t) Update dynamical model given input value and time.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterDynamicsBessa/#additional-inherited-members","text":"Public Functions inherited from gazebo::Dynamics Name virtual ~Dynamics () Destructor. virtual void Reset () Protected Functions inherited from gazebo::Dynamics Name Dynamics () Protected constructor: Use the factory for object creation. Protected Attributes inherited from gazebo::Dynamics Name double prevTime Time of last state update. double state Latest state.","title":"Additional inherited members"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterDynamicsBessa/#detailed-description","text":"class gazebo::ThrusterDynamicsBessa; Bessa's dynamic thruster model. This is \"Model 2\" described in Bessa et al.: Dynamic Positioning of Underwater Robotic Vehicles with Thruster Dynamics Compensation.","title":"Detailed Description"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterDynamicsBessa/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterDynamicsBessa/#function-create","text":"static Dynamics * create( sdf::ElementPtr _sdf ) Create thruster model of this type with parameter values from sdf.","title":"function create"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterDynamicsBessa/#function-gettype","text":"inline virtual std::string GetType() Return (derived) type of dynamic system. Reimplements : gazebo::Dynamics::GetType","title":"function GetType"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterDynamicsBessa/#function-update","text":"virtual double update( double _cmd, double _t ) Update dynamical model given input value and time. Reimplements : gazebo::Dynamics::update Updated on 2022-05-30 at 18:35:12 +0000","title":"function update"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterDynamicsYoerger/","text":"gazebo::ThrusterDynamicsYoerger Yoerger's dynamic thruster model. More... #include <Dynamics.hh> Inherits from gazebo::Dynamics Public Functions Name Dynamics * create (sdf::ElementPtr _sdf) Create thruster model of this type with parameter values from sdf. virtual std::string GetType () Return (derived) type of dynamic system. virtual double update (double _cmd, double _t) Update dynamical model given input value and time. Additional inherited members Public Functions inherited from gazebo::Dynamics Name virtual ~Dynamics () Destructor. virtual void Reset () Protected Functions inherited from gazebo::Dynamics Name Dynamics () Protected constructor: Use the factory for object creation. Protected Attributes inherited from gazebo::Dynamics Name double prevTime Time of last state update. double state Latest state. Detailed Description class gazebo::ThrusterDynamicsYoerger; Yoerger's dynamic thruster model. This is the lumped-parameter model of Yoerger et al.: The influence of thruster dynamics on underwater vehicle behavior and their incorporation into control system design. (1990) Public Functions Documentation function create static Dynamics * create( sdf::ElementPtr _sdf ) Create thruster model of this type with parameter values from sdf. function GetType inline virtual std::string GetType() Return (derived) type of dynamic system. Reimplements : gazebo::Dynamics::GetType function update virtual double update( double _cmd, double _t ) Update dynamical model given input value and time. Reimplements : gazebo::Dynamics::update Updated on 2022-05-30 at 18:35:12 +0000","title":"gazebo::ThrusterDynamicsYoerger"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterDynamicsYoerger/#gazebothrusterdynamicsyoerger","text":"Yoerger's dynamic thruster model. More... #include <Dynamics.hh> Inherits from gazebo::Dynamics","title":"gazebo::ThrusterDynamicsYoerger"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterDynamicsYoerger/#public-functions","text":"Name Dynamics * create (sdf::ElementPtr _sdf) Create thruster model of this type with parameter values from sdf. virtual std::string GetType () Return (derived) type of dynamic system. virtual double update (double _cmd, double _t) Update dynamical model given input value and time.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterDynamicsYoerger/#additional-inherited-members","text":"Public Functions inherited from gazebo::Dynamics Name virtual ~Dynamics () Destructor. virtual void Reset () Protected Functions inherited from gazebo::Dynamics Name Dynamics () Protected constructor: Use the factory for object creation. Protected Attributes inherited from gazebo::Dynamics Name double prevTime Time of last state update. double state Latest state.","title":"Additional inherited members"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterDynamicsYoerger/#detailed-description","text":"class gazebo::ThrusterDynamicsYoerger; Yoerger's dynamic thruster model. This is the lumped-parameter model of Yoerger et al.: The influence of thruster dynamics on underwater vehicle behavior and their incorporation into control system design. (1990)","title":"Detailed Description"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterDynamicsYoerger/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterDynamicsYoerger/#function-create","text":"static Dynamics * create( sdf::ElementPtr _sdf ) Create thruster model of this type with parameter values from sdf.","title":"function create"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterDynamicsYoerger/#function-gettype","text":"inline virtual std::string GetType() Return (derived) type of dynamic system. Reimplements : gazebo::Dynamics::GetType","title":"function GetType"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterDynamicsYoerger/#function-update","text":"virtual double update( double _cmd, double _t ) Update dynamical model given input value and time. Reimplements : gazebo::Dynamics::update Updated on 2022-05-30 at 18:35:12 +0000","title":"function update"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/","text":"gazebo::ThrusterPlugin Class for the thruster plugin. #include <ThrusterPlugin.hh> Inherits from ModelPlugin Public Functions Name ThrusterPlugin () Constructor. virtual ~ThrusterPlugin () Destructor. virtual void Load (physics::ModelPtr _model, sdf::ElementPtr _sdf) virtual void Init () virtual void Reset () Custom plugin reset behavior. void Update (const common::UpdateInfo & _info) Update the simulation state. Protected Functions Name void UpdateInput (ConstDoublePtr & _msg) Callback for the input topic subscriber. Protected Attributes Name std::shared_ptr< Dynamics > thrusterDynamics Thruster dynamic model. std::shared_ptr< ConversionFunction > conversionFunction Thruster conversion function. event::ConnectionPtr updateConnection Update event. physics::LinkPtr thrusterLink Pointer to the thruster link. transport::NodePtr node Gazebo node. transport::SubscriberPtr commandSubscriber Subscriber to the reference signal topic. transport::PublisherPtr thrustTopicPublisher Publisher to the output thrust topic. double inputCommand Input command, typically desired angular velocity of the rotor. double thrustForce Latest thrust force in [N]. common::Time thrustForceStamp Time stamp of latest thrust force. physics::JointPtr joint Optional: The rotor joint, used for visualization. double clampMin : Optional: Commands less than this value will be clamped. double clampMax : Optional: Commands greater than this value will be clamped. double thrustMin : Optional: Minimum thrust force output double thrustMax : Optional: Maximum thrust force output int thrusterID Thruster ID, used to generated topic names automatically. std::string topicPrefix Thruster topics prefix. double gain : Optional: Gain factor: Desired angular velocity = command * gain bool isOn Optional: Flag to indicate if the thruster is turned on or off. double thrustEfficiency Optional: Output thrust efficiency factor of the thruster. double propellerEfficiency Optional: Propeller angular velocity efficiency term. ignition::math::Vector3d thrusterAxis The axis about which the thruster rotates. Public Functions Documentation function ThrusterPlugin ThrusterPlugin() Constructor. function ~ThrusterPlugin virtual ~ThrusterPlugin() Destructor. function Load virtual void Load( physics::ModelPtr _model, sdf::ElementPtr _sdf ) function Init virtual void Init() function Reset virtual void Reset() Custom plugin reset behavior. function Update void Update( const common::UpdateInfo & _info ) Update the simulation state. Parameters : _info Information used in the update event. Protected Functions Documentation function UpdateInput void UpdateInput( ConstDoublePtr & _msg ) Callback for the input topic subscriber. Protected Attributes Documentation variable thrusterDynamics std::shared_ptr< Dynamics > thrusterDynamics; Thruster dynamic model. variable conversionFunction std::shared_ptr< ConversionFunction > conversionFunction; Thruster conversion function. variable updateConnection event::ConnectionPtr updateConnection; Update event. variable thrusterLink physics::LinkPtr thrusterLink; Pointer to the thruster link. variable node transport::NodePtr node; Gazebo node. variable commandSubscriber transport::SubscriberPtr commandSubscriber; Subscriber to the reference signal topic. variable thrustTopicPublisher transport::PublisherPtr thrustTopicPublisher; Publisher to the output thrust topic. variable inputCommand double inputCommand; Input command, typically desired angular velocity of the rotor. variable thrustForce double thrustForce; Latest thrust force in [N]. variable thrustForceStamp common::Time thrustForceStamp; Time stamp of latest thrust force. variable joint physics::JointPtr joint; Optional: The rotor joint, used for visualization. variable clampMin double clampMin; : Optional: Commands less than this value will be clamped. variable clampMax double clampMax; : Optional: Commands greater than this value will be clamped. variable thrustMin double thrustMin; : Optional: Minimum thrust force output variable thrustMax double thrustMax; : Optional: Maximum thrust force output variable thrusterID int thrusterID; Thruster ID, used to generated topic names automatically. variable topicPrefix std::string topicPrefix; Thruster topics prefix. variable gain double gain; : Optional: Gain factor: Desired angular velocity = command * gain variable isOn bool isOn; Optional: Flag to indicate if the thruster is turned on or off. variable thrustEfficiency double thrustEfficiency; Optional: Output thrust efficiency factor of the thruster. variable propellerEfficiency double propellerEfficiency; Optional: Propeller angular velocity efficiency term. variable thrusterAxis ignition::math::Vector3d thrusterAxis; The axis about which the thruster rotates. Updated on 2022-05-30 at 18:35:12 +0000","title":"gazebo::ThrusterPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#gazebothrusterplugin","text":"Class for the thruster plugin. #include <ThrusterPlugin.hh> Inherits from ModelPlugin","title":"gazebo::ThrusterPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#public-functions","text":"Name ThrusterPlugin () Constructor. virtual ~ThrusterPlugin () Destructor. virtual void Load (physics::ModelPtr _model, sdf::ElementPtr _sdf) virtual void Init () virtual void Reset () Custom plugin reset behavior. void Update (const common::UpdateInfo & _info) Update the simulation state.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#protected-functions","text":"Name void UpdateInput (ConstDoublePtr & _msg) Callback for the input topic subscriber.","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#protected-attributes","text":"Name std::shared_ptr< Dynamics > thrusterDynamics Thruster dynamic model. std::shared_ptr< ConversionFunction > conversionFunction Thruster conversion function. event::ConnectionPtr updateConnection Update event. physics::LinkPtr thrusterLink Pointer to the thruster link. transport::NodePtr node Gazebo node. transport::SubscriberPtr commandSubscriber Subscriber to the reference signal topic. transport::PublisherPtr thrustTopicPublisher Publisher to the output thrust topic. double inputCommand Input command, typically desired angular velocity of the rotor. double thrustForce Latest thrust force in [N]. common::Time thrustForceStamp Time stamp of latest thrust force. physics::JointPtr joint Optional: The rotor joint, used for visualization. double clampMin : Optional: Commands less than this value will be clamped. double clampMax : Optional: Commands greater than this value will be clamped. double thrustMin : Optional: Minimum thrust force output double thrustMax : Optional: Maximum thrust force output int thrusterID Thruster ID, used to generated topic names automatically. std::string topicPrefix Thruster topics prefix. double gain : Optional: Gain factor: Desired angular velocity = command * gain bool isOn Optional: Flag to indicate if the thruster is turned on or off. double thrustEfficiency Optional: Output thrust efficiency factor of the thruster. double propellerEfficiency Optional: Propeller angular velocity efficiency term. ignition::math::Vector3d thrusterAxis The axis about which the thruster rotates.","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#function-thrusterplugin","text":"ThrusterPlugin() Constructor.","title":"function ThrusterPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#function-thrusterplugin_1","text":"virtual ~ThrusterPlugin() Destructor.","title":"function ~ThrusterPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#function-load","text":"virtual void Load( physics::ModelPtr _model, sdf::ElementPtr _sdf )","title":"function Load"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#function-init","text":"virtual void Init()","title":"function Init"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#function-reset","text":"virtual void Reset() Custom plugin reset behavior.","title":"function Reset"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#function-update","text":"void Update( const common::UpdateInfo & _info ) Update the simulation state. Parameters : _info Information used in the update event.","title":"function Update"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#function-updateinput","text":"void UpdateInput( ConstDoublePtr & _msg ) Callback for the input topic subscriber.","title":"function UpdateInput"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#variable-thrusterdynamics","text":"std::shared_ptr< Dynamics > thrusterDynamics; Thruster dynamic model.","title":"variable thrusterDynamics"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#variable-conversionfunction","text":"std::shared_ptr< ConversionFunction > conversionFunction; Thruster conversion function.","title":"variable conversionFunction"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#variable-updateconnection","text":"event::ConnectionPtr updateConnection; Update event.","title":"variable updateConnection"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#variable-thrusterlink","text":"physics::LinkPtr thrusterLink; Pointer to the thruster link.","title":"variable thrusterLink"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#variable-node","text":"transport::NodePtr node; Gazebo node.","title":"variable node"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#variable-commandsubscriber","text":"transport::SubscriberPtr commandSubscriber; Subscriber to the reference signal topic.","title":"variable commandSubscriber"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#variable-thrusttopicpublisher","text":"transport::PublisherPtr thrustTopicPublisher; Publisher to the output thrust topic.","title":"variable thrustTopicPublisher"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#variable-inputcommand","text":"double inputCommand; Input command, typically desired angular velocity of the rotor.","title":"variable inputCommand"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#variable-thrustforce","text":"double thrustForce; Latest thrust force in [N].","title":"variable thrustForce"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#variable-thrustforcestamp","text":"common::Time thrustForceStamp; Time stamp of latest thrust force.","title":"variable thrustForceStamp"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#variable-joint","text":"physics::JointPtr joint; Optional: The rotor joint, used for visualization.","title":"variable joint"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#variable-clampmin","text":"double clampMin; : Optional: Commands less than this value will be clamped.","title":"variable clampMin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#variable-clampmax","text":"double clampMax; : Optional: Commands greater than this value will be clamped.","title":"variable clampMax"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#variable-thrustmin","text":"double thrustMin; : Optional: Minimum thrust force output","title":"variable thrustMin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#variable-thrustmax","text":"double thrustMax; : Optional: Maximum thrust force output","title":"variable thrustMax"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#variable-thrusterid","text":"int thrusterID; Thruster ID, used to generated topic names automatically.","title":"variable thrusterID"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#variable-topicprefix","text":"std::string topicPrefix; Thruster topics prefix.","title":"variable topicPrefix"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#variable-gain","text":"double gain; : Optional: Gain factor: Desired angular velocity = command * gain","title":"variable gain"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#variable-ison","text":"bool isOn; Optional: Flag to indicate if the thruster is turned on or off.","title":"variable isOn"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#variable-thrustefficiency","text":"double thrustEfficiency; Optional: Output thrust efficiency factor of the thruster.","title":"variable thrustEfficiency"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#variable-propellerefficiency","text":"double propellerEfficiency; Optional: Propeller angular velocity efficiency term.","title":"variable propellerEfficiency"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1ThrusterPlugin/#variable-thrusteraxis","text":"ignition::math::Vector3d thrusterAxis; The axis about which the thruster rotates. Updated on 2022-05-30 at 18:35:12 +0000","title":"variable thrusterAxis"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalModel/","text":"gazebo::UmbilicalModel Inherited by gazebo::UmbilicalModelBerg Public Functions Name virtual ~UmbilicalModel () Destructor. virtual void Init () Initialize model. virtual void OnUpdate (const common::UpdateInfo & _info, const ignition::math::Vector3d & _flow) =0 Update Umbilical (and apply forces) Protected Functions Name UmbilicalModel () Protected constructor: Use the factory instead. Protected Attributes Name physics::ModelPtr model Gazebo model to which this umbilical belongs. physics::LinkPtr connector Moving connector link of this umbilical. Public Functions Documentation function ~UmbilicalModel inline virtual ~UmbilicalModel() Destructor. function Init virtual void Init() Initialize model. function OnUpdate virtual void OnUpdate( const common::UpdateInfo & _info, const ignition::math::Vector3d & _flow ) =0 Update Umbilical (and apply forces) Reimplemented by : gazebo::UmbilicalModelBerg::OnUpdate Protected Functions Documentation function UmbilicalModel inline UmbilicalModel() Protected constructor: Use the factory instead. Protected Attributes Documentation variable model physics::ModelPtr model; Gazebo model to which this umbilical belongs. variable connector physics::LinkPtr connector; Moving connector link of this umbilical. Updated on 2022-05-30 at 18:35:12 +0000","title":"gazebo::UmbilicalModel"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalModel/#gazeboumbilicalmodel","text":"Inherited by gazebo::UmbilicalModelBerg","title":"gazebo::UmbilicalModel"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalModel/#public-functions","text":"Name virtual ~UmbilicalModel () Destructor. virtual void Init () Initialize model. virtual void OnUpdate (const common::UpdateInfo & _info, const ignition::math::Vector3d & _flow) =0 Update Umbilical (and apply forces)","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalModel/#protected-functions","text":"Name UmbilicalModel () Protected constructor: Use the factory instead.","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalModel/#protected-attributes","text":"Name physics::ModelPtr model Gazebo model to which this umbilical belongs. physics::LinkPtr connector Moving connector link of this umbilical.","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalModel/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalModel/#function-umbilicalmodel","text":"inline virtual ~UmbilicalModel() Destructor.","title":"function ~UmbilicalModel"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalModel/#function-init","text":"virtual void Init() Initialize model.","title":"function Init"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalModel/#function-onupdate","text":"virtual void OnUpdate( const common::UpdateInfo & _info, const ignition::math::Vector3d & _flow ) =0 Update Umbilical (and apply forces) Reimplemented by : gazebo::UmbilicalModelBerg::OnUpdate","title":"function OnUpdate"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalModel/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalModel/#function-umbilicalmodel_1","text":"inline UmbilicalModel() Protected constructor: Use the factory instead.","title":"function UmbilicalModel"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalModel/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalModel/#variable-model","text":"physics::ModelPtr model; Gazebo model to which this umbilical belongs.","title":"variable model"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalModel/#variable-connector","text":"physics::LinkPtr connector; Moving connector link of this umbilical. Updated on 2022-05-30 at 18:35:12 +0000","title":"variable connector"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalModelBerg/","text":"gazebo::UmbilicalModelBerg Inherits from gazebo::UmbilicalModel Public Functions Name UmbilicalModel * create (sdf::ElementPtr _sdf, physics::ModelPtr _model) Create UmbilicalModel according to its description. virtual void OnUpdate (const common::UpdateInfo & _info, const ignition::math::Vector3d & _flow) Update Umbilical (and apply forces) Protected Functions Name UmbilicalModelBerg (sdf::ElementPtr _sdf, physics::ModelPtr _model) Protected constructor: Use the factory instead. Additional inherited members Public Functions inherited from gazebo::UmbilicalModel Name virtual ~UmbilicalModel () Destructor. virtual void Init () Initialize model. Protected Functions inherited from gazebo::UmbilicalModel Name UmbilicalModel () Protected constructor: Use the factory instead. Protected Attributes inherited from gazebo::UmbilicalModel Name physics::ModelPtr model Gazebo model to which this umbilical belongs. physics::LinkPtr connector Moving connector link of this umbilical. Public Functions Documentation function create static UmbilicalModel * create( sdf::ElementPtr _sdf, physics::ModelPtr _model ) Create UmbilicalModel according to its description. function OnUpdate virtual void OnUpdate( const common::UpdateInfo & _info, const ignition::math::Vector3d & _flow ) Update Umbilical (and apply forces) Reimplements : gazebo::UmbilicalModel::OnUpdate Protected Functions Documentation function UmbilicalModelBerg UmbilicalModelBerg( sdf::ElementPtr _sdf, physics::ModelPtr _model ) Protected constructor: Use the factory instead. Updated on 2022-05-30 at 18:35:12 +0000","title":"gazebo::UmbilicalModelBerg"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalModelBerg/#gazeboumbilicalmodelberg","text":"Inherits from gazebo::UmbilicalModel","title":"gazebo::UmbilicalModelBerg"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalModelBerg/#public-functions","text":"Name UmbilicalModel * create (sdf::ElementPtr _sdf, physics::ModelPtr _model) Create UmbilicalModel according to its description. virtual void OnUpdate (const common::UpdateInfo & _info, const ignition::math::Vector3d & _flow) Update Umbilical (and apply forces)","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalModelBerg/#protected-functions","text":"Name UmbilicalModelBerg (sdf::ElementPtr _sdf, physics::ModelPtr _model) Protected constructor: Use the factory instead.","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalModelBerg/#additional-inherited-members","text":"Public Functions inherited from gazebo::UmbilicalModel Name virtual ~UmbilicalModel () Destructor. virtual void Init () Initialize model. Protected Functions inherited from gazebo::UmbilicalModel Name UmbilicalModel () Protected constructor: Use the factory instead. Protected Attributes inherited from gazebo::UmbilicalModel Name physics::ModelPtr model Gazebo model to which this umbilical belongs. physics::LinkPtr connector Moving connector link of this umbilical.","title":"Additional inherited members"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalModelBerg/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalModelBerg/#function-create","text":"static UmbilicalModel * create( sdf::ElementPtr _sdf, physics::ModelPtr _model ) Create UmbilicalModel according to its description.","title":"function create"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalModelBerg/#function-onupdate","text":"virtual void OnUpdate( const common::UpdateInfo & _info, const ignition::math::Vector3d & _flow ) Update Umbilical (and apply forces) Reimplements : gazebo::UmbilicalModel::OnUpdate","title":"function OnUpdate"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalModelBerg/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalModelBerg/#function-umbilicalmodelberg","text":"UmbilicalModelBerg( sdf::ElementPtr _sdf, physics::ModelPtr _model ) Protected constructor: Use the factory instead. Updated on 2022-05-30 at 18:35:12 +0000","title":"function UmbilicalModelBerg"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalModelFactory/","text":"gazebo::UmbilicalModelFactory Factory singleton class that creates an UmbilicalModel from sdf. #include <UmbilicalModel.hh> Public Functions Name UmbilicalModel * CreateUmbilicalModel (sdf::ElementPtr _sdf, physics::ModelPtr _model) Create a ConversionFunction object according to its sdf Description. bool RegisterCreator (const std::string & _identifier, UmbilicalModelCreator _creator) Register an UmbilicalModel class with its creator. UmbilicalModelFactory & GetInstance () Return the singleton instance of this factory. Public Functions Documentation function CreateUmbilicalModel UmbilicalModel * CreateUmbilicalModel( sdf::ElementPtr _sdf, physics::ModelPtr _model ) Create a ConversionFunction object according to its sdf Description. function RegisterCreator bool RegisterCreator( const std::string & _identifier, UmbilicalModelCreator _creator ) Register an UmbilicalModel class with its creator. function GetInstance static UmbilicalModelFactory & GetInstance() Return the singleton instance of this factory. Updated on 2022-05-30 at 18:35:12 +0000","title":"gazebo::UmbilicalModelFactory"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalModelFactory/#gazeboumbilicalmodelfactory","text":"Factory singleton class that creates an UmbilicalModel from sdf. #include <UmbilicalModel.hh>","title":"gazebo::UmbilicalModelFactory"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalModelFactory/#public-functions","text":"Name UmbilicalModel * CreateUmbilicalModel (sdf::ElementPtr _sdf, physics::ModelPtr _model) Create a ConversionFunction object according to its sdf Description. bool RegisterCreator (const std::string & _identifier, UmbilicalModelCreator _creator) Register an UmbilicalModel class with its creator. UmbilicalModelFactory & GetInstance () Return the singleton instance of this factory.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalModelFactory/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalModelFactory/#function-createumbilicalmodel","text":"UmbilicalModel * CreateUmbilicalModel( sdf::ElementPtr _sdf, physics::ModelPtr _model ) Create a ConversionFunction object according to its sdf Description.","title":"function CreateUmbilicalModel"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalModelFactory/#function-registercreator","text":"bool RegisterCreator( const std::string & _identifier, UmbilicalModelCreator _creator ) Register an UmbilicalModel class with its creator.","title":"function RegisterCreator"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalModelFactory/#function-getinstance","text":"static UmbilicalModelFactory & GetInstance() Return the singleton instance of this factory. Updated on 2022-05-30 at 18:35:12 +0000","title":"function GetInstance"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalPlugin/","text":"gazebo::UmbilicalPlugin Inherits from ModelPlugin Public Functions Name UmbilicalPlugin () Destructor. ~UmbilicalPlugin () Constructor. Protected Functions Name virtual void Load (physics::ModelPtr _model, sdf::ElementPtr _sdf) Load plugin and its configuration from sdf. virtual void OnUpdate (const common::UpdateInfo & _info) Update callback from simulation. void UpdateFlowVelocity (ConstVector3dPtr & _msg) Reads flow velocity topic. Protected Attributes Name event::ConnectionPtr updateConnection Pointer to the update event connection. gazebo::physics::ModelPtr model Pointer to the model structure. gazebo::physics::WorldPtr world Pointer to the world plugin. gazebo::transport::NodePtr node Gazebo node. gazebo::transport::SubscriberPtr flowSubscriber Subcriber to flow message. ignition::math::Vector3d flowVelocity Flow velocity vector read from topic. std::shared_ptr< UmbilicalModel > umbilical Pointer to UmbilicalModel used in this plugin. Public Functions Documentation function UmbilicalPlugin UmbilicalPlugin() Destructor. function ~UmbilicalPlugin ~UmbilicalPlugin() Constructor. Protected Functions Documentation function Load virtual void Load( physics::ModelPtr _model, sdf::ElementPtr _sdf ) Load plugin and its configuration from sdf. function OnUpdate virtual void OnUpdate( const common::UpdateInfo & _info ) Update callback from simulation. function UpdateFlowVelocity void UpdateFlowVelocity( ConstVector3dPtr & _msg ) Reads flow velocity topic. Protected Attributes Documentation variable updateConnection event::ConnectionPtr updateConnection; Pointer to the update event connection. variable model gazebo::physics::ModelPtr model; Pointer to the model structure. variable world gazebo::physics::WorldPtr world; Pointer to the world plugin. variable node gazebo::transport::NodePtr node; Gazebo node. variable flowSubscriber gazebo::transport::SubscriberPtr flowSubscriber; Subcriber to flow message. variable flowVelocity ignition::math::Vector3d flowVelocity; Flow velocity vector read from topic. variable umbilical std::shared_ptr< UmbilicalModel > umbilical; Pointer to UmbilicalModel used in this plugin. Updated on 2022-05-30 at 18:35:12 +0000","title":"gazebo::UmbilicalPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalPlugin/#gazeboumbilicalplugin","text":"Inherits from ModelPlugin","title":"gazebo::UmbilicalPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalPlugin/#public-functions","text":"Name UmbilicalPlugin () Destructor. ~UmbilicalPlugin () Constructor.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalPlugin/#protected-functions","text":"Name virtual void Load (physics::ModelPtr _model, sdf::ElementPtr _sdf) Load plugin and its configuration from sdf. virtual void OnUpdate (const common::UpdateInfo & _info) Update callback from simulation. void UpdateFlowVelocity (ConstVector3dPtr & _msg) Reads flow velocity topic.","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalPlugin/#protected-attributes","text":"Name event::ConnectionPtr updateConnection Pointer to the update event connection. gazebo::physics::ModelPtr model Pointer to the model structure. gazebo::physics::WorldPtr world Pointer to the world plugin. gazebo::transport::NodePtr node Gazebo node. gazebo::transport::SubscriberPtr flowSubscriber Subcriber to flow message. ignition::math::Vector3d flowVelocity Flow velocity vector read from topic. std::shared_ptr< UmbilicalModel > umbilical Pointer to UmbilicalModel used in this plugin.","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalPlugin/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalPlugin/#function-umbilicalplugin","text":"UmbilicalPlugin() Destructor.","title":"function UmbilicalPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalPlugin/#function-umbilicalplugin_1","text":"~UmbilicalPlugin() Constructor.","title":"function ~UmbilicalPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalPlugin/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalPlugin/#function-load","text":"virtual void Load( physics::ModelPtr _model, sdf::ElementPtr _sdf ) Load plugin and its configuration from sdf.","title":"function Load"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalPlugin/#function-onupdate","text":"virtual void OnUpdate( const common::UpdateInfo & _info ) Update callback from simulation.","title":"function OnUpdate"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalPlugin/#function-updateflowvelocity","text":"void UpdateFlowVelocity( ConstVector3dPtr & _msg ) Reads flow velocity topic.","title":"function UpdateFlowVelocity"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalPlugin/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalPlugin/#variable-updateconnection","text":"event::ConnectionPtr updateConnection; Pointer to the update event connection.","title":"variable updateConnection"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalPlugin/#variable-model","text":"gazebo::physics::ModelPtr model; Pointer to the model structure.","title":"variable model"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalPlugin/#variable-world","text":"gazebo::physics::WorldPtr world; Pointer to the world plugin.","title":"variable world"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalPlugin/#variable-node","text":"gazebo::transport::NodePtr node; Gazebo node.","title":"variable node"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalPlugin/#variable-flowsubscriber","text":"gazebo::transport::SubscriberPtr flowSubscriber; Subcriber to flow message.","title":"variable flowSubscriber"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalPlugin/#variable-flowvelocity","text":"ignition::math::Vector3d flowVelocity; Flow velocity vector read from topic.","title":"variable flowVelocity"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalPlugin/#variable-umbilical","text":"std::shared_ptr< UmbilicalModel > umbilical; Pointer to UmbilicalModel used in this plugin. Updated on 2022-05-30 at 18:35:12 +0000","title":"variable umbilical"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalSegment/","text":"gazebo::UmbilicalSegment Public Functions Name UmbilicalSegment () UmbilicalSegment (const std::string & _name, const std::string & _fromLink, const ignition::math::Pose3d & _fromPose, const ignition::math::Pose3d & _toPose, physics::ModelPtr _model) void initSdfSegment () Public Attributes Name physics::LinkPtr link physics::LinkPtr linkA physics::JointPtr jointA physics::JointPtr jointB std::shared_ptr< UmbilicalSegment > prev std::shared_ptr< UmbilicalSegment > next sdf::SDFPtr sdfSegment Public Functions Documentation function UmbilicalSegment inline UmbilicalSegment() function UmbilicalSegment UmbilicalSegment( const std::string & _name, const std::string & _fromLink, const ignition::math::Pose3d & _fromPose, const ignition::math::Pose3d & _toPose, physics::ModelPtr _model ) function initSdfSegment void initSdfSegment() Public Attributes Documentation variable link physics::LinkPtr link; variable linkA physics::LinkPtr linkA; variable jointA physics::JointPtr jointA; variable jointB physics::JointPtr jointB; variable prev std::shared_ptr< UmbilicalSegment > prev; variable next std::shared_ptr< UmbilicalSegment > next; variable sdfSegment static sdf::SDFPtr sdfSegment; Updated on 2022-05-30 at 18:35:12 +0000","title":"gazebo::UmbilicalSegment"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalSegment/#gazeboumbilicalsegment","text":"","title":"gazebo::UmbilicalSegment"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalSegment/#public-functions","text":"Name UmbilicalSegment () UmbilicalSegment (const std::string & _name, const std::string & _fromLink, const ignition::math::Pose3d & _fromPose, const ignition::math::Pose3d & _toPose, physics::ModelPtr _model) void initSdfSegment ()","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalSegment/#public-attributes","text":"Name physics::LinkPtr link physics::LinkPtr linkA physics::JointPtr jointA physics::JointPtr jointB std::shared_ptr< UmbilicalSegment > prev std::shared_ptr< UmbilicalSegment > next sdf::SDFPtr sdfSegment","title":"Public Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalSegment/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalSegment/#function-umbilicalsegment","text":"inline UmbilicalSegment()","title":"function UmbilicalSegment"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalSegment/#function-umbilicalsegment_1","text":"UmbilicalSegment( const std::string & _name, const std::string & _fromLink, const ignition::math::Pose3d & _fromPose, const ignition::math::Pose3d & _toPose, physics::ModelPtr _model )","title":"function UmbilicalSegment"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalSegment/#function-initsdfsegment","text":"void initSdfSegment()","title":"function initSdfSegment"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalSegment/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalSegment/#variable-link","text":"physics::LinkPtr link;","title":"variable link"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalSegment/#variable-linka","text":"physics::LinkPtr linkA;","title":"variable linkA"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalSegment/#variable-jointa","text":"physics::JointPtr jointA;","title":"variable jointA"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalSegment/#variable-jointb","text":"physics::JointPtr jointB;","title":"variable jointB"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalSegment/#variable-prev","text":"std::shared_ptr< UmbilicalSegment > prev;","title":"variable prev"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalSegment/#variable-next","text":"std::shared_ptr< UmbilicalSegment > next;","title":"variable next"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UmbilicalSegment/#variable-sdfsegment","text":"static sdf::SDFPtr sdfSegment; Updated on 2022-05-30 at 18:35:12 +0000","title":"variable sdfSegment"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UnderwaterObjectPlugin/","text":"gazebo::UnderwaterObjectPlugin Gazebo model plugin class for underwater objects. #include <UnderwaterObjectPlugin.hh> Inherits from ModelPlugin Public Functions Name UnderwaterObjectPlugin () Constructor. virtual ~UnderwaterObjectPlugin () Destructor. virtual void Load (gazebo::physics::ModelPtr _model, sdf::ElementPtr _sdf) virtual void Init () virtual void Update (const gazebo::common::UpdateInfo & _info) Update the simulation state. Protected Functions Name virtual void Connect () Connects the update event callback. void UpdateFlowVelocity (ConstVector3dPtr & _msg) Reads flow velocity topic. virtual void PublishCurrentVelocityMarker () Publish current velocity marker. virtual void PublishIsSubmerged () Publishes the state of the vehicle (is submerged) virtual void PublishRestoringForce (gazebo::physics::LinkPtr _link) Publish restoring force. virtual void PublishHydrodynamicWrenches (gazebo::physics::LinkPtr _link) Publish hydrodynamic wrenches. virtual void GenWrenchMsg (ignition::math::Vector3d _force, ignition::math::Vector3d _torque, gazebo::msgs::WrenchStamped & _output) Returns the wrench message for debugging topics. virtual void InitDebug (gazebo::physics::LinkPtr _link, gazebo::HydrodynamicModelPtr _hydro) Sets the topics used for publishing the intermediate data during the simulation. Protected Attributes Name std::map< gazebo::physics::LinkPtr, HydrodynamicModelPtr > models Pairs of links & corresponding hydrodynamic models. ignition::math::Vector3d flowVelocity Flow velocity vector read from topic. gazebo::event::ConnectionPtr updateConnection Update event. gazebo::physics::WorldPtr world Pointer to the world plugin. gazebo::physics::ModelPtr model Pointer to the model structure. gazebo::transport::NodePtr node Gazebo node. std::string baseLinkName Name of vehicle's base_link. gazebo::transport::SubscriberPtr flowSubscriber Subcriber to flow message. bool useGlobalCurrent Flag to use the global current velocity or the individually assigned current velocity. std::map< std::string, gazebo::transport::PublisherPtr > hydroPub Publishers of hydrodynamic and hydrostatic forces and torques in the case the debug flag is on. Public Functions Documentation function UnderwaterObjectPlugin UnderwaterObjectPlugin() Constructor. function ~UnderwaterObjectPlugin virtual ~UnderwaterObjectPlugin() Destructor. function Load virtual void Load( gazebo::physics::ModelPtr _model, sdf::ElementPtr _sdf ) function Init virtual void Init() function Update virtual void Update( const gazebo::common::UpdateInfo & _info ) Update the simulation state. Parameters : _info Information used in the update event. Protected Functions Documentation function Connect virtual void Connect() Connects the update event callback. function UpdateFlowVelocity void UpdateFlowVelocity( ConstVector3dPtr & _msg ) Reads flow velocity topic. function PublishCurrentVelocityMarker virtual void PublishCurrentVelocityMarker() Publish current velocity marker. function PublishIsSubmerged virtual void PublishIsSubmerged() Publishes the state of the vehicle (is submerged) function PublishRestoringForce virtual void PublishRestoringForce( gazebo::physics::LinkPtr _link ) Publish restoring force. Parameters : _link Pointer to the link where the force information will be extracted from function PublishHydrodynamicWrenches virtual void PublishHydrodynamicWrenches( gazebo::physics::LinkPtr _link ) Publish hydrodynamic wrenches. Parameters : _link Pointer to the link where the force information will be extracted from function GenWrenchMsg virtual void GenWrenchMsg( ignition::math::Vector3d _force, ignition::math::Vector3d _torque, gazebo::msgs::WrenchStamped & _output ) Returns the wrench message for debugging topics. Parameters : _force Force vector _torque Torque vector _output Stamped wrench message to be updated function InitDebug virtual void InitDebug( gazebo::physics::LinkPtr _link, gazebo::HydrodynamicModelPtr _hydro ) Sets the topics used for publishing the intermediate data during the simulation. Parameters : _link Pointer to the link _hydro Pointer to the hydrodynamic model Protected Attributes Documentation variable models std::map< gazebo::physics::LinkPtr, HydrodynamicModelPtr > models; Pairs of links & corresponding hydrodynamic models. variable flowVelocity ignition::math::Vector3d flowVelocity; Flow velocity vector read from topic. variable updateConnection gazebo::event::ConnectionPtr updateConnection; Update event. variable world gazebo::physics::WorldPtr world; Pointer to the world plugin. variable model gazebo::physics::ModelPtr model; Pointer to the model structure. variable node gazebo::transport::NodePtr node; Gazebo node. variable baseLinkName std::string baseLinkName; Name of vehicle's base_link. variable flowSubscriber gazebo::transport::SubscriberPtr flowSubscriber; Subcriber to flow message. variable useGlobalCurrent bool useGlobalCurrent; Flag to use the global current velocity or the individually assigned current velocity. variable hydroPub std::map< std::string, gazebo::transport::PublisherPtr > hydroPub; Publishers of hydrodynamic and hydrostatic forces and torques in the case the debug flag is on. Updated on 2022-05-30 at 18:35:12 +0000","title":"gazebo::UnderwaterObjectPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UnderwaterObjectPlugin/#gazebounderwaterobjectplugin","text":"Gazebo model plugin class for underwater objects. #include <UnderwaterObjectPlugin.hh> Inherits from ModelPlugin","title":"gazebo::UnderwaterObjectPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UnderwaterObjectPlugin/#public-functions","text":"Name UnderwaterObjectPlugin () Constructor. virtual ~UnderwaterObjectPlugin () Destructor. virtual void Load (gazebo::physics::ModelPtr _model, sdf::ElementPtr _sdf) virtual void Init () virtual void Update (const gazebo::common::UpdateInfo & _info) Update the simulation state.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UnderwaterObjectPlugin/#protected-functions","text":"Name virtual void Connect () Connects the update event callback. void UpdateFlowVelocity (ConstVector3dPtr & _msg) Reads flow velocity topic. virtual void PublishCurrentVelocityMarker () Publish current velocity marker. virtual void PublishIsSubmerged () Publishes the state of the vehicle (is submerged) virtual void PublishRestoringForce (gazebo::physics::LinkPtr _link) Publish restoring force. virtual void PublishHydrodynamicWrenches (gazebo::physics::LinkPtr _link) Publish hydrodynamic wrenches. virtual void GenWrenchMsg (ignition::math::Vector3d _force, ignition::math::Vector3d _torque, gazebo::msgs::WrenchStamped & _output) Returns the wrench message for debugging topics. virtual void InitDebug (gazebo::physics::LinkPtr _link, gazebo::HydrodynamicModelPtr _hydro) Sets the topics used for publishing the intermediate data during the simulation.","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UnderwaterObjectPlugin/#protected-attributes","text":"Name std::map< gazebo::physics::LinkPtr, HydrodynamicModelPtr > models Pairs of links & corresponding hydrodynamic models. ignition::math::Vector3d flowVelocity Flow velocity vector read from topic. gazebo::event::ConnectionPtr updateConnection Update event. gazebo::physics::WorldPtr world Pointer to the world plugin. gazebo::physics::ModelPtr model Pointer to the model structure. gazebo::transport::NodePtr node Gazebo node. std::string baseLinkName Name of vehicle's base_link. gazebo::transport::SubscriberPtr flowSubscriber Subcriber to flow message. bool useGlobalCurrent Flag to use the global current velocity or the individually assigned current velocity. std::map< std::string, gazebo::transport::PublisherPtr > hydroPub Publishers of hydrodynamic and hydrostatic forces and torques in the case the debug flag is on.","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UnderwaterObjectPlugin/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UnderwaterObjectPlugin/#function-underwaterobjectplugin","text":"UnderwaterObjectPlugin() Constructor.","title":"function UnderwaterObjectPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UnderwaterObjectPlugin/#function-underwaterobjectplugin_1","text":"virtual ~UnderwaterObjectPlugin() Destructor.","title":"function ~UnderwaterObjectPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UnderwaterObjectPlugin/#function-load","text":"virtual void Load( gazebo::physics::ModelPtr _model, sdf::ElementPtr _sdf )","title":"function Load"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UnderwaterObjectPlugin/#function-init","text":"virtual void Init()","title":"function Init"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UnderwaterObjectPlugin/#function-update","text":"virtual void Update( const gazebo::common::UpdateInfo & _info ) Update the simulation state. Parameters : _info Information used in the update event.","title":"function Update"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UnderwaterObjectPlugin/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UnderwaterObjectPlugin/#function-connect","text":"virtual void Connect() Connects the update event callback.","title":"function Connect"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UnderwaterObjectPlugin/#function-updateflowvelocity","text":"void UpdateFlowVelocity( ConstVector3dPtr & _msg ) Reads flow velocity topic.","title":"function UpdateFlowVelocity"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UnderwaterObjectPlugin/#function-publishcurrentvelocitymarker","text":"virtual void PublishCurrentVelocityMarker() Publish current velocity marker.","title":"function PublishCurrentVelocityMarker"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UnderwaterObjectPlugin/#function-publishissubmerged","text":"virtual void PublishIsSubmerged() Publishes the state of the vehicle (is submerged)","title":"function PublishIsSubmerged"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UnderwaterObjectPlugin/#function-publishrestoringforce","text":"virtual void PublishRestoringForce( gazebo::physics::LinkPtr _link ) Publish restoring force. Parameters : _link Pointer to the link where the force information will be extracted from","title":"function PublishRestoringForce"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UnderwaterObjectPlugin/#function-publishhydrodynamicwrenches","text":"virtual void PublishHydrodynamicWrenches( gazebo::physics::LinkPtr _link ) Publish hydrodynamic wrenches. Parameters : _link Pointer to the link where the force information will be extracted from","title":"function PublishHydrodynamicWrenches"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UnderwaterObjectPlugin/#function-genwrenchmsg","text":"virtual void GenWrenchMsg( ignition::math::Vector3d _force, ignition::math::Vector3d _torque, gazebo::msgs::WrenchStamped & _output ) Returns the wrench message for debugging topics. Parameters : _force Force vector _torque Torque vector _output Stamped wrench message to be updated","title":"function GenWrenchMsg"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UnderwaterObjectPlugin/#function-initdebug","text":"virtual void InitDebug( gazebo::physics::LinkPtr _link, gazebo::HydrodynamicModelPtr _hydro ) Sets the topics used for publishing the intermediate data during the simulation. Parameters : _link Pointer to the link _hydro Pointer to the hydrodynamic model","title":"function InitDebug"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UnderwaterObjectPlugin/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UnderwaterObjectPlugin/#variable-models","text":"std::map< gazebo::physics::LinkPtr, HydrodynamicModelPtr > models; Pairs of links & corresponding hydrodynamic models.","title":"variable models"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UnderwaterObjectPlugin/#variable-flowvelocity","text":"ignition::math::Vector3d flowVelocity; Flow velocity vector read from topic.","title":"variable flowVelocity"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UnderwaterObjectPlugin/#variable-updateconnection","text":"gazebo::event::ConnectionPtr updateConnection; Update event.","title":"variable updateConnection"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UnderwaterObjectPlugin/#variable-world","text":"gazebo::physics::WorldPtr world; Pointer to the world plugin.","title":"variable world"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UnderwaterObjectPlugin/#variable-model","text":"gazebo::physics::ModelPtr model; Pointer to the model structure.","title":"variable model"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UnderwaterObjectPlugin/#variable-node","text":"gazebo::transport::NodePtr node; Gazebo node.","title":"variable node"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UnderwaterObjectPlugin/#variable-baselinkname","text":"std::string baseLinkName; Name of vehicle's base_link.","title":"variable baseLinkName"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UnderwaterObjectPlugin/#variable-flowsubscriber","text":"gazebo::transport::SubscriberPtr flowSubscriber; Subcriber to flow message.","title":"variable flowSubscriber"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UnderwaterObjectPlugin/#variable-useglobalcurrent","text":"bool useGlobalCurrent; Flag to use the global current velocity or the individually assigned current velocity.","title":"variable useGlobalCurrent"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Classes/classgazebo_1_1UnderwaterObjectPlugin/#variable-hydropub","text":"std::map< std::string, gazebo::transport::PublisherPtr > hydroPub; Publishers of hydrodynamic and hydrostatic forces and torques in the case the debug flag is on. Updated on 2022-05-30 at 18:35:12 +0000","title":"variable hydroPub"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:12 +0000","title":"Examples"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:12 +0000","title":"Examples"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:12 +0000","title":"Modules"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:12 +0000","title":"Modules"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/","text":"Namespaces namespace Eigen namespace gazebo Updated on 2022-05-30 at 18:35:12 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/#namespaces","text":"namespace Eigen namespace gazebo Updated on 2022-05-30 at 18:35:12 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespaceEigen/","text":"Eigen Types Name typedef Eigen::Matrix< double, 6, 6 > Matrix6d Definition of a 6x6 Eigen matrix. typedef Eigen::Matrix< double, 6, 1 > Vector6d Definition of a 6 element Eigen vector. Types Documentation typedef Matrix6d typedef Eigen::Matrix<double, 6, 6> Eigen::Matrix6d; Definition of a 6x6 Eigen matrix. typedef Vector6d typedef Eigen::Matrix<double, 6, 1> Eigen::Vector6d; Definition of a 6 element Eigen vector. Updated on 2022-05-30 at 18:35:12 +0000","title":"Eigen"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespaceEigen/#eigen","text":"","title":"Eigen"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespaceEigen/#types","text":"Name typedef Eigen::Matrix< double, 6, 6 > Matrix6d Definition of a 6x6 Eigen matrix. typedef Eigen::Matrix< double, 6, 1 > Vector6d Definition of a 6 element Eigen vector.","title":"Types"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespaceEigen/#types-documentation","text":"","title":"Types Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespaceEigen/#typedef-matrix6d","text":"typedef Eigen::Matrix<double, 6, 6> Eigen::Matrix6d; Definition of a 6x6 Eigen matrix.","title":"typedef Matrix6d"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespaceEigen/#typedef-vector6d","text":"typedef Eigen::Matrix<double, 6, 1> Eigen::Vector6d; Definition of a 6 element Eigen vector. Updated on 2022-05-30 at 18:35:12 +0000","title":"typedef Vector6d"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespacegazebo/","text":"gazebo Classes Name class gazebo::BuoyantObject Class describing the dynamics of a buoyant object, useful for simple representations of underwater structures. class gazebo::ConversionFunction Abstact base class for a thruster conversion function. class gazebo::ConversionFunctionBasic The most basic conversion function: Thrust = const. w abs(w) This corresponds to what is attrributed to Yoerger et al. and called Model 1 in Bessa et al.: Dynamic Positioning of Underwater Robotic Vehicles with Thruster Dynamics Compensation. class gazebo::ConversionFunctionBessa Asymmetric conversion function with dead-zone nonlinearity. This corresponds to what is called Model 2 in Bessa et al.: Dynamic Positioning of Underwater Robotic Vehicles with Thruster Dynamics Compensation. class gazebo::ConversionFunctionFactory Factory singleton class that creates a ConversionFunction from sdf. class gazebo::ConversionFunctionLinearInterp Conversion using linear interpolation between given data points. class gazebo::Dynamics Abstract base class for thruster dynamics. class gazebo::DynamicsFactory Factory singleton class that creates a ThrusterDynamics from sdf. class gazebo::DynamicsFirstOrder First-order dynamic system. class gazebo::DynamicsZeroOrder Trivial (no dynamics) zero-order dynamic system. class gazebo::FinPlugin class gazebo::HMBox Class containing the methods and attributes for a hydrodynamic model for a box in the fluid. class gazebo::HMCylinder Class containing the methods and attributes for a hydrodynamic model for a cylinder in the fluid. class gazebo::HMFossen Class containting the methods and attributes for a Fossen robot-like hydrodynamic model. The restoring forces are applied by the BuoyantObject class methods. Using the plugin for UUV models will use both this and the buoyant object class definitions, therefore the restoring forces were not inherited here. References: class gazebo::HMSphere Class containing the methods and attributes for a hydrodynamic model for a sphere in the fluid. class gazebo::HMSpheroid Class containing the methods and attributes for a hydrodynamic model for a spheroid in the fluid Reference: Antonelli - Underwater Robots. class gazebo::HydrodynamicModel class gazebo::HydrodynamicModelFactory Factory singleton class that creates a HydrodynamicModel from sdf. class gazebo::LiftDrag Abstract base class for Lift&Drag models. class gazebo::LiftDragFactory Factory singleton class that creates a LiftDrag from sdf. class gazebo::LiftDragQuadratic Basic quadratic (Hugin) lift&drag model, page 18 from [1]. [1] Engelhardtsen, \u00d8ystein. \"3D AUV Collision Avoidance.\" (2007). class gazebo::LiftDragTwoLines Lift&drag model that models lift/drag coeffs using two lines. This is based on Gazebo's LiftDragPlugin but implemented as a derived LiftDrag model to allow using it in combination with the dynamics of a Fin. class gazebo::ThrusterDynamicsBessa Bessa's dynamic thruster model. class gazebo::ThrusterDynamicsYoerger Yoerger's dynamic thruster model. class gazebo::ThrusterPlugin Class for the thruster plugin. class gazebo::UmbilicalModel class gazebo::UmbilicalModelBerg class gazebo::UmbilicalModelFactory Factory singleton class that creates an UmbilicalModel from sdf. class gazebo::UmbilicalPlugin class gazebo::UmbilicalSegment class gazebo::UnderwaterObjectPlugin Gazebo model plugin class for underwater objects. Types Name typedef Dynamics ( )(sdf::ElementPtr) DynamicsCreator Function pointer to create a certain thruster dynamics object. typedef boost::shared_ptr< HydrodynamicModel > HydrodynamicModelPtr Pointer to model. typedef HydrodynamicModel ( )(sdf::ElementPtr, physics::LinkPtr) HydrodynamicModelCreator Function pointer to create a certain a model. typedef LiftDrag ( )(sdf::ElementPtr) LiftDragCreator Function pointer to create a certain LiftDrag object. typedef ConversionFunction ( )(sdf::ElementPtr) ConversionFunctionCreator Function pointer to create a certain conversion function. typedef UmbilicalModel ( )(sdf::ElementPtr, physics::ModelPtr) UmbilicalModelCreator Function pointer to create a certain conversion function. typedef boost::shared_ptr< UmbilicalSegment > UmbilicalSegmentPtr Functions Name std::vector< double > Str2Vector (std::string _input) Conversion of a string to a double vector. Eigen::Matrix3d CrossProductOperator (Eigen::Vector3d _x) Returns the cross product operator matrix for Eigen vectors. Eigen::Matrix3d CrossProductOperator (ignition::math::Vector3d _x) Returns the cross product operator matrix for Gazebo vectors. Eigen::Vector3d ToEigen (const ignition::math::Vector3d & _x) Eigen::Matrix3d ToEigen (const ignition::math::Matrix3d & _x) Eigen::Vector6d EigenStack (const ignition::math::Vector3d & _x, const ignition::math::Vector3d & _y) ignition::math::Vector3d Vec3dToGazebo (const Eigen::Vector3d & _x) ignition::math::Matrix3d Mat3dToGazebo (const Eigen::Matrix3d & _x) REGISTER_HYDRODYNAMICMODEL_CREATOR ( HMFossen , & HMFossen::create ) REGISTER_HYDRODYNAMICMODEL_CREATOR ( HMSphere , & HMSphere::create ) REGISTER_HYDRODYNAMICMODEL_CREATOR ( HMCylinder , & HMCylinder::create ) REGISTER_HYDRODYNAMICMODEL_CREATOR ( HMSpheroid , & HMSpheroid::create ) REGISTER_HYDRODYNAMICMODEL_CREATOR ( HMBox , & HMBox::create ) GZ_REGISTER_MODEL_PLUGIN ( UmbilicalPlugin ) Attributes Name const typedef boost::shared_ptr< const uuv_gazebo_plugins_msgs::msgs::Double > ConstDoublePtr Definition of a pointer to the floating point message. Types Documentation typedef DynamicsCreator typedef Dynamics*(* gazebo::DynamicsCreator) (sdf::ElementPtr); Function pointer to create a certain thruster dynamics object. typedef HydrodynamicModelPtr typedef boost::shared_ptr<HydrodynamicModel> gazebo::HydrodynamicModelPtr; Pointer to model. typedef HydrodynamicModelCreator typedef HydrodynamicModel*(* gazebo::HydrodynamicModelCreator) (sdf::ElementPtr, physics::LinkPtr); Function pointer to create a certain a model. typedef LiftDragCreator typedef LiftDrag*(* gazebo::LiftDragCreator) (sdf::ElementPtr); Function pointer to create a certain LiftDrag object. typedef ConversionFunctionCreator typedef ConversionFunction*(* gazebo::ConversionFunctionCreator) (sdf::ElementPtr); Function pointer to create a certain conversion function. typedef UmbilicalModelCreator typedef UmbilicalModel*(* gazebo::UmbilicalModelCreator) (sdf::ElementPtr, physics::ModelPtr); Function pointer to create a certain conversion function. typedef UmbilicalSegmentPtr typedef boost::shared_ptr<UmbilicalSegment> gazebo::UmbilicalSegmentPtr; Functions Documentation function Str2Vector inline std::vector< double > Str2Vector( std::string _input ) Conversion of a string to a double vector. function CrossProductOperator inline Eigen::Matrix3d CrossProductOperator( Eigen::Vector3d _x ) Returns the cross product operator matrix for Eigen vectors. function CrossProductOperator inline Eigen::Matrix3d CrossProductOperator( ignition::math::Vector3d _x ) Returns the cross product operator matrix for Gazebo vectors. function ToEigen inline Eigen::Vector3d ToEigen( const ignition::math::Vector3d & _x ) function ToEigen inline Eigen::Matrix3d ToEigen( const ignition::math::Matrix3d & _x ) function EigenStack inline Eigen::Vector6d EigenStack( const ignition::math::Vector3d & _x, const ignition::math::Vector3d & _y ) function Vec3dToGazebo inline ignition::math::Vector3d Vec3dToGazebo( const Eigen::Vector3d & _x ) function Mat3dToGazebo inline ignition::math::Matrix3d Mat3dToGazebo( const Eigen::Matrix3d & _x ) function REGISTER_HYDRODYNAMICMODEL_CREATOR REGISTER_HYDRODYNAMICMODEL_CREATOR( HMFossen , &HMFossen::create ) function REGISTER_HYDRODYNAMICMODEL_CREATOR REGISTER_HYDRODYNAMICMODEL_CREATOR( HMSphere , &HMSphere::create ) function REGISTER_HYDRODYNAMICMODEL_CREATOR REGISTER_HYDRODYNAMICMODEL_CREATOR( HMCylinder , &HMCylinder::create ) function REGISTER_HYDRODYNAMICMODEL_CREATOR REGISTER_HYDRODYNAMICMODEL_CREATOR( HMSpheroid , &HMSpheroid::create ) function REGISTER_HYDRODYNAMICMODEL_CREATOR REGISTER_HYDRODYNAMICMODEL_CREATOR( HMBox , &HMBox::create ) function GZ_REGISTER_MODEL_PLUGIN GZ_REGISTER_MODEL_PLUGIN( UmbilicalPlugin ) Attributes Documentation variable ConstDoublePtr const typedef boost::shared_ptr< const uuv_gazebo_plugins_msgs::msgs::Double > ConstDoublePtr; Definition of a pointer to the floating point message. Updated on 2022-05-30 at 18:35:12 +0000","title":"gazebo"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespacegazebo/#gazebo","text":"","title":"gazebo"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespacegazebo/#classes","text":"Name class gazebo::BuoyantObject Class describing the dynamics of a buoyant object, useful for simple representations of underwater structures. class gazebo::ConversionFunction Abstact base class for a thruster conversion function. class gazebo::ConversionFunctionBasic The most basic conversion function: Thrust = const. w abs(w) This corresponds to what is attrributed to Yoerger et al. and called Model 1 in Bessa et al.: Dynamic Positioning of Underwater Robotic Vehicles with Thruster Dynamics Compensation. class gazebo::ConversionFunctionBessa Asymmetric conversion function with dead-zone nonlinearity. This corresponds to what is called Model 2 in Bessa et al.: Dynamic Positioning of Underwater Robotic Vehicles with Thruster Dynamics Compensation. class gazebo::ConversionFunctionFactory Factory singleton class that creates a ConversionFunction from sdf. class gazebo::ConversionFunctionLinearInterp Conversion using linear interpolation between given data points. class gazebo::Dynamics Abstract base class for thruster dynamics. class gazebo::DynamicsFactory Factory singleton class that creates a ThrusterDynamics from sdf. class gazebo::DynamicsFirstOrder First-order dynamic system. class gazebo::DynamicsZeroOrder Trivial (no dynamics) zero-order dynamic system. class gazebo::FinPlugin class gazebo::HMBox Class containing the methods and attributes for a hydrodynamic model for a box in the fluid. class gazebo::HMCylinder Class containing the methods and attributes for a hydrodynamic model for a cylinder in the fluid. class gazebo::HMFossen Class containting the methods and attributes for a Fossen robot-like hydrodynamic model. The restoring forces are applied by the BuoyantObject class methods. Using the plugin for UUV models will use both this and the buoyant object class definitions, therefore the restoring forces were not inherited here. References: class gazebo::HMSphere Class containing the methods and attributes for a hydrodynamic model for a sphere in the fluid. class gazebo::HMSpheroid Class containing the methods and attributes for a hydrodynamic model for a spheroid in the fluid Reference: Antonelli - Underwater Robots. class gazebo::HydrodynamicModel class gazebo::HydrodynamicModelFactory Factory singleton class that creates a HydrodynamicModel from sdf. class gazebo::LiftDrag Abstract base class for Lift&Drag models. class gazebo::LiftDragFactory Factory singleton class that creates a LiftDrag from sdf. class gazebo::LiftDragQuadratic Basic quadratic (Hugin) lift&drag model, page 18 from [1]. [1] Engelhardtsen, \u00d8ystein. \"3D AUV Collision Avoidance.\" (2007). class gazebo::LiftDragTwoLines Lift&drag model that models lift/drag coeffs using two lines. This is based on Gazebo's LiftDragPlugin but implemented as a derived LiftDrag model to allow using it in combination with the dynamics of a Fin. class gazebo::ThrusterDynamicsBessa Bessa's dynamic thruster model. class gazebo::ThrusterDynamicsYoerger Yoerger's dynamic thruster model. class gazebo::ThrusterPlugin Class for the thruster plugin. class gazebo::UmbilicalModel class gazebo::UmbilicalModelBerg class gazebo::UmbilicalModelFactory Factory singleton class that creates an UmbilicalModel from sdf. class gazebo::UmbilicalPlugin class gazebo::UmbilicalSegment class gazebo::UnderwaterObjectPlugin Gazebo model plugin class for underwater objects.","title":"Classes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespacegazebo/#types","text":"Name typedef Dynamics ( )(sdf::ElementPtr) DynamicsCreator Function pointer to create a certain thruster dynamics object. typedef boost::shared_ptr< HydrodynamicModel > HydrodynamicModelPtr Pointer to model. typedef HydrodynamicModel ( )(sdf::ElementPtr, physics::LinkPtr) HydrodynamicModelCreator Function pointer to create a certain a model. typedef LiftDrag ( )(sdf::ElementPtr) LiftDragCreator Function pointer to create a certain LiftDrag object. typedef ConversionFunction ( )(sdf::ElementPtr) ConversionFunctionCreator Function pointer to create a certain conversion function. typedef UmbilicalModel ( )(sdf::ElementPtr, physics::ModelPtr) UmbilicalModelCreator Function pointer to create a certain conversion function. typedef boost::shared_ptr< UmbilicalSegment > UmbilicalSegmentPtr","title":"Types"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespacegazebo/#functions","text":"Name std::vector< double > Str2Vector (std::string _input) Conversion of a string to a double vector. Eigen::Matrix3d CrossProductOperator (Eigen::Vector3d _x) Returns the cross product operator matrix for Eigen vectors. Eigen::Matrix3d CrossProductOperator (ignition::math::Vector3d _x) Returns the cross product operator matrix for Gazebo vectors. Eigen::Vector3d ToEigen (const ignition::math::Vector3d & _x) Eigen::Matrix3d ToEigen (const ignition::math::Matrix3d & _x) Eigen::Vector6d EigenStack (const ignition::math::Vector3d & _x, const ignition::math::Vector3d & _y) ignition::math::Vector3d Vec3dToGazebo (const Eigen::Vector3d & _x) ignition::math::Matrix3d Mat3dToGazebo (const Eigen::Matrix3d & _x) REGISTER_HYDRODYNAMICMODEL_CREATOR ( HMFossen , & HMFossen::create ) REGISTER_HYDRODYNAMICMODEL_CREATOR ( HMSphere , & HMSphere::create ) REGISTER_HYDRODYNAMICMODEL_CREATOR ( HMCylinder , & HMCylinder::create ) REGISTER_HYDRODYNAMICMODEL_CREATOR ( HMSpheroid , & HMSpheroid::create ) REGISTER_HYDRODYNAMICMODEL_CREATOR ( HMBox , & HMBox::create ) GZ_REGISTER_MODEL_PLUGIN ( UmbilicalPlugin )","title":"Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespacegazebo/#attributes","text":"Name const typedef boost::shared_ptr< const uuv_gazebo_plugins_msgs::msgs::Double > ConstDoublePtr Definition of a pointer to the floating point message.","title":"Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespacegazebo/#types-documentation","text":"","title":"Types Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespacegazebo/#typedef-dynamicscreator","text":"typedef Dynamics*(* gazebo::DynamicsCreator) (sdf::ElementPtr); Function pointer to create a certain thruster dynamics object.","title":"typedef DynamicsCreator"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespacegazebo/#typedef-hydrodynamicmodelptr","text":"typedef boost::shared_ptr<HydrodynamicModel> gazebo::HydrodynamicModelPtr; Pointer to model.","title":"typedef HydrodynamicModelPtr"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespacegazebo/#typedef-hydrodynamicmodelcreator","text":"typedef HydrodynamicModel*(* gazebo::HydrodynamicModelCreator) (sdf::ElementPtr, physics::LinkPtr); Function pointer to create a certain a model.","title":"typedef HydrodynamicModelCreator"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespacegazebo/#typedef-liftdragcreator","text":"typedef LiftDrag*(* gazebo::LiftDragCreator) (sdf::ElementPtr); Function pointer to create a certain LiftDrag object.","title":"typedef LiftDragCreator"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespacegazebo/#typedef-conversionfunctioncreator","text":"typedef ConversionFunction*(* gazebo::ConversionFunctionCreator) (sdf::ElementPtr); Function pointer to create a certain conversion function.","title":"typedef ConversionFunctionCreator"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespacegazebo/#typedef-umbilicalmodelcreator","text":"typedef UmbilicalModel*(* gazebo::UmbilicalModelCreator) (sdf::ElementPtr, physics::ModelPtr); Function pointer to create a certain conversion function.","title":"typedef UmbilicalModelCreator"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespacegazebo/#typedef-umbilicalsegmentptr","text":"typedef boost::shared_ptr<UmbilicalSegment> gazebo::UmbilicalSegmentPtr;","title":"typedef UmbilicalSegmentPtr"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespacegazebo/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespacegazebo/#function-str2vector","text":"inline std::vector< double > Str2Vector( std::string _input ) Conversion of a string to a double vector.","title":"function Str2Vector"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespacegazebo/#function-crossproductoperator","text":"inline Eigen::Matrix3d CrossProductOperator( Eigen::Vector3d _x ) Returns the cross product operator matrix for Eigen vectors.","title":"function CrossProductOperator"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespacegazebo/#function-crossproductoperator_1","text":"inline Eigen::Matrix3d CrossProductOperator( ignition::math::Vector3d _x ) Returns the cross product operator matrix for Gazebo vectors.","title":"function CrossProductOperator"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespacegazebo/#function-toeigen","text":"inline Eigen::Vector3d ToEigen( const ignition::math::Vector3d & _x )","title":"function ToEigen"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespacegazebo/#function-toeigen_1","text":"inline Eigen::Matrix3d ToEigen( const ignition::math::Matrix3d & _x )","title":"function ToEigen"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespacegazebo/#function-eigenstack","text":"inline Eigen::Vector6d EigenStack( const ignition::math::Vector3d & _x, const ignition::math::Vector3d & _y )","title":"function EigenStack"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespacegazebo/#function-vec3dtogazebo","text":"inline ignition::math::Vector3d Vec3dToGazebo( const Eigen::Vector3d & _x )","title":"function Vec3dToGazebo"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespacegazebo/#function-mat3dtogazebo","text":"inline ignition::math::Matrix3d Mat3dToGazebo( const Eigen::Matrix3d & _x )","title":"function Mat3dToGazebo"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespacegazebo/#function-register_hydrodynamicmodel_creator","text":"REGISTER_HYDRODYNAMICMODEL_CREATOR( HMFossen , &HMFossen::create )","title":"function REGISTER_HYDRODYNAMICMODEL_CREATOR"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespacegazebo/#function-register_hydrodynamicmodel_creator_1","text":"REGISTER_HYDRODYNAMICMODEL_CREATOR( HMSphere , &HMSphere::create )","title":"function REGISTER_HYDRODYNAMICMODEL_CREATOR"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespacegazebo/#function-register_hydrodynamicmodel_creator_2","text":"REGISTER_HYDRODYNAMICMODEL_CREATOR( HMCylinder , &HMCylinder::create )","title":"function REGISTER_HYDRODYNAMICMODEL_CREATOR"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespacegazebo/#function-register_hydrodynamicmodel_creator_3","text":"REGISTER_HYDRODYNAMICMODEL_CREATOR( HMSpheroid , &HMSpheroid::create )","title":"function REGISTER_HYDRODYNAMICMODEL_CREATOR"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespacegazebo/#function-register_hydrodynamicmodel_creator_4","text":"REGISTER_HYDRODYNAMICMODEL_CREATOR( HMBox , &HMBox::create )","title":"function REGISTER_HYDRODYNAMICMODEL_CREATOR"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespacegazebo/#function-gz_register_model_plugin","text":"GZ_REGISTER_MODEL_PLUGIN( UmbilicalPlugin )","title":"function GZ_REGISTER_MODEL_PLUGIN"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespacegazebo/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_plugins/Namespaces/namespacegazebo/#variable-constdoubleptr","text":"const typedef boost::shared_ptr< const uuv_gazebo_plugins_msgs::msgs::Double > ConstDoublePtr; Definition of a pointer to the floating point message. Updated on 2022-05-30 at 18:35:12 +0000","title":"variable ConstDoublePtr"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/","text":"Classes namespace gazebo class AccelerationsTestPlugin Gazebo model plugin class for underwater objects. class CustomBatteryConsumerROSPlugin class LinearBatteryROSPlugin class ThrusterManagerROSPlugin namespace test_default_fossen_vehicle class TestDefaultFossenVehicle namespace test_sphere_vehicle class TestSphereVehicle namespace test_thrusters class TestThrusters namespace uuv_gazebo_ros_plugins_msgs::srv namespace uuv_simulator_ros class FinROSPlugin class JointStatePublisher class ThrusterROSPlugin class UnderwaterObjectROSPlugin Updated on 2022-05-30 at 18:35:13 +0000","title":"Classes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/#classes","text":"namespace gazebo class AccelerationsTestPlugin Gazebo model plugin class for underwater objects. class CustomBatteryConsumerROSPlugin class LinearBatteryROSPlugin class ThrusterManagerROSPlugin namespace test_default_fossen_vehicle class TestDefaultFossenVehicle namespace test_sphere_vehicle class TestSphereVehicle namespace test_thrusters class TestThrusters namespace uuv_gazebo_ros_plugins_msgs::srv namespace uuv_simulator_ros class FinROSPlugin class JointStatePublisher class ThrusterROSPlugin class UnderwaterObjectROSPlugin Updated on 2022-05-30 at 18:35:13 +0000","title":"Classes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1AccelerationsTestPlugin/","text":"gazebo::AccelerationsTestPlugin Gazebo model plugin class for underwater objects. #include <AccelerationsTestPlugin.hh> Inherits from ModelPlugin Public Functions Name AccelerationsTestPlugin () Constructor. virtual ~AccelerationsTestPlugin () Destructor. virtual void Load (gazebo::physics::ModelPtr _model, sdf::ElementPtr _sdf) virtual void Init () void Update (const gazebo::common::UpdateInfo & _info) Update the simulation state. Protected Functions Name virtual void Connect () Connects the update event callback. Protected Attributes Name gazebo::event::ConnectionPtr updateConnection Update event. gazebo::physics::WorldPtr world Pointer to the world plugin. gazebo::physics::ModelPtr model Pointer to the model structure. gazebo::transport::NodePtr node Gazebo node. physics::LinkPtr link Link of test object. ros::Publisher pub_accel_b_gazebo ros::Publisher pub_accel_b_numeric ros::Publisher pub_accel_w_gazebo ros::Publisher pub_accel_w_numeric Eigen::Vector6d last_w_v_w_b Velocity of link with respect to world frame in previous time step. common::Time lastTime Time stamp of previous time step. Public Functions Documentation function AccelerationsTestPlugin AccelerationsTestPlugin() Constructor. function ~AccelerationsTestPlugin virtual ~AccelerationsTestPlugin() Destructor. function Load virtual void Load( gazebo::physics::ModelPtr _model, sdf::ElementPtr _sdf ) function Init virtual void Init() function Update void Update( const gazebo::common::UpdateInfo & _info ) Update the simulation state. Parameters : _info Information used in the update event. Protected Functions Documentation function Connect virtual void Connect() Connects the update event callback. Protected Attributes Documentation variable updateConnection gazebo::event::ConnectionPtr updateConnection; Update event. variable world gazebo::physics::WorldPtr world; Pointer to the world plugin. variable model gazebo::physics::ModelPtr model; Pointer to the model structure. variable node gazebo::transport::NodePtr node; Gazebo node. variable link physics::LinkPtr link; Link of test object. variable pub_accel_b_gazebo ros::Publisher pub_accel_b_gazebo; variable pub_accel_b_numeric ros::Publisher pub_accel_b_numeric; variable pub_accel_w_gazebo ros::Publisher pub_accel_w_gazebo; variable pub_accel_w_numeric ros::Publisher pub_accel_w_numeric; variable last_w_v_w_b Eigen::Vector6d last_w_v_w_b; Velocity of link with respect to world frame in previous time step. variable lastTime common::Time lastTime; Time stamp of previous time step. Updated on 2022-05-30 at 18:35:13 +0000","title":"gazebo::AccelerationsTestPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1AccelerationsTestPlugin/#gazeboaccelerationstestplugin","text":"Gazebo model plugin class for underwater objects. #include <AccelerationsTestPlugin.hh> Inherits from ModelPlugin","title":"gazebo::AccelerationsTestPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1AccelerationsTestPlugin/#public-functions","text":"Name AccelerationsTestPlugin () Constructor. virtual ~AccelerationsTestPlugin () Destructor. virtual void Load (gazebo::physics::ModelPtr _model, sdf::ElementPtr _sdf) virtual void Init () void Update (const gazebo::common::UpdateInfo & _info) Update the simulation state.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1AccelerationsTestPlugin/#protected-functions","text":"Name virtual void Connect () Connects the update event callback.","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1AccelerationsTestPlugin/#protected-attributes","text":"Name gazebo::event::ConnectionPtr updateConnection Update event. gazebo::physics::WorldPtr world Pointer to the world plugin. gazebo::physics::ModelPtr model Pointer to the model structure. gazebo::transport::NodePtr node Gazebo node. physics::LinkPtr link Link of test object. ros::Publisher pub_accel_b_gazebo ros::Publisher pub_accel_b_numeric ros::Publisher pub_accel_w_gazebo ros::Publisher pub_accel_w_numeric Eigen::Vector6d last_w_v_w_b Velocity of link with respect to world frame in previous time step. common::Time lastTime Time stamp of previous time step.","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1AccelerationsTestPlugin/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1AccelerationsTestPlugin/#function-accelerationstestplugin","text":"AccelerationsTestPlugin() Constructor.","title":"function AccelerationsTestPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1AccelerationsTestPlugin/#function-accelerationstestplugin_1","text":"virtual ~AccelerationsTestPlugin() Destructor.","title":"function ~AccelerationsTestPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1AccelerationsTestPlugin/#function-load","text":"virtual void Load( gazebo::physics::ModelPtr _model, sdf::ElementPtr _sdf )","title":"function Load"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1AccelerationsTestPlugin/#function-init","text":"virtual void Init()","title":"function Init"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1AccelerationsTestPlugin/#function-update","text":"void Update( const gazebo::common::UpdateInfo & _info ) Update the simulation state. Parameters : _info Information used in the update event.","title":"function Update"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1AccelerationsTestPlugin/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1AccelerationsTestPlugin/#function-connect","text":"virtual void Connect() Connects the update event callback.","title":"function Connect"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1AccelerationsTestPlugin/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1AccelerationsTestPlugin/#variable-updateconnection","text":"gazebo::event::ConnectionPtr updateConnection; Update event.","title":"variable updateConnection"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1AccelerationsTestPlugin/#variable-world","text":"gazebo::physics::WorldPtr world; Pointer to the world plugin.","title":"variable world"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1AccelerationsTestPlugin/#variable-model","text":"gazebo::physics::ModelPtr model; Pointer to the model structure.","title":"variable model"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1AccelerationsTestPlugin/#variable-node","text":"gazebo::transport::NodePtr node; Gazebo node.","title":"variable node"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1AccelerationsTestPlugin/#variable-link","text":"physics::LinkPtr link; Link of test object.","title":"variable link"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1AccelerationsTestPlugin/#variable-pub_accel_b_gazebo","text":"ros::Publisher pub_accel_b_gazebo;","title":"variable pub_accel_b_gazebo"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1AccelerationsTestPlugin/#variable-pub_accel_b_numeric","text":"ros::Publisher pub_accel_b_numeric;","title":"variable pub_accel_b_numeric"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1AccelerationsTestPlugin/#variable-pub_accel_w_gazebo","text":"ros::Publisher pub_accel_w_gazebo;","title":"variable pub_accel_w_gazebo"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1AccelerationsTestPlugin/#variable-pub_accel_w_numeric","text":"ros::Publisher pub_accel_w_numeric;","title":"variable pub_accel_w_numeric"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1AccelerationsTestPlugin/#variable-last_w_v_w_b","text":"Eigen::Vector6d last_w_v_w_b; Velocity of link with respect to world frame in previous time step.","title":"variable last_w_v_w_b"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1AccelerationsTestPlugin/#variable-lasttime","text":"common::Time lastTime; Time stamp of previous time step. Updated on 2022-05-30 at 18:35:13 +0000","title":"variable lastTime"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1CustomBatteryConsumerROSPlugin/","text":"gazebo::CustomBatteryConsumerROSPlugin Inherits from ModelPlugin Public Functions Name CustomBatteryConsumerROSPlugin () Constructor. virtual ~CustomBatteryConsumerROSPlugin () Destructor. void Load (physics::ModelPtr _parent, sdf::ElementPtr _sdf) Load module and read parameters from SDF. Protected Functions Name void UpdateDeviceState (const std_msgs::Bool::ConstPtr & _msg) Callback for the device state topic subscriber. void UpdatePowerLoad (double _powerLoad =0.0) Update power load. Protected Attributes Name boost::scoped_ptr< ros::NodeHandle > rosNode Pointer to this ROS node's handle. ros::Subscriber deviceStateSub Subscriber to the device state flag. common::BatteryPtr battery Pointer to battery. bool isDeviceOn Flag to signal whether a specific device is running. double powerLoad Power load in W. int consumerID Battery consumer ID. std::string linkName Link name. std::string batteryName Battery model name. event::ConnectionPtr rosPublishConnection Connection for callbacks on update world. Public Functions Documentation function CustomBatteryConsumerROSPlugin CustomBatteryConsumerROSPlugin() Constructor. function ~CustomBatteryConsumerROSPlugin virtual ~CustomBatteryConsumerROSPlugin() Destructor. function Load void Load( physics::ModelPtr _parent, sdf::ElementPtr _sdf ) Load module and read parameters from SDF. Protected Functions Documentation function UpdateDeviceState void UpdateDeviceState( const std_msgs::Bool::ConstPtr & _msg ) Callback for the device state topic subscriber. function UpdatePowerLoad void UpdatePowerLoad( double _powerLoad =0.0 ) Update power load. Protected Attributes Documentation variable rosNode boost::scoped_ptr< ros::NodeHandle > rosNode; Pointer to this ROS node's handle. variable deviceStateSub ros::Subscriber deviceStateSub; Subscriber to the device state flag. variable battery common::BatteryPtr battery; Pointer to battery. variable isDeviceOn bool isDeviceOn; Flag to signal whether a specific device is running. variable powerLoad double powerLoad; Power load in W. variable consumerID int consumerID; Battery consumer ID. variable linkName std::string linkName; Link name. variable batteryName std::string batteryName; Battery model name. variable rosPublishConnection event::ConnectionPtr rosPublishConnection; Connection for callbacks on update world. Updated on 2022-05-30 at 18:35:13 +0000","title":"gazebo::CustomBatteryConsumerROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1CustomBatteryConsumerROSPlugin/#gazebocustombatteryconsumerrosplugin","text":"Inherits from ModelPlugin","title":"gazebo::CustomBatteryConsumerROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1CustomBatteryConsumerROSPlugin/#public-functions","text":"Name CustomBatteryConsumerROSPlugin () Constructor. virtual ~CustomBatteryConsumerROSPlugin () Destructor. void Load (physics::ModelPtr _parent, sdf::ElementPtr _sdf) Load module and read parameters from SDF.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1CustomBatteryConsumerROSPlugin/#protected-functions","text":"Name void UpdateDeviceState (const std_msgs::Bool::ConstPtr & _msg) Callback for the device state topic subscriber. void UpdatePowerLoad (double _powerLoad =0.0) Update power load.","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1CustomBatteryConsumerROSPlugin/#protected-attributes","text":"Name boost::scoped_ptr< ros::NodeHandle > rosNode Pointer to this ROS node's handle. ros::Subscriber deviceStateSub Subscriber to the device state flag. common::BatteryPtr battery Pointer to battery. bool isDeviceOn Flag to signal whether a specific device is running. double powerLoad Power load in W. int consumerID Battery consumer ID. std::string linkName Link name. std::string batteryName Battery model name. event::ConnectionPtr rosPublishConnection Connection for callbacks on update world.","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1CustomBatteryConsumerROSPlugin/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1CustomBatteryConsumerROSPlugin/#function-custombatteryconsumerrosplugin","text":"CustomBatteryConsumerROSPlugin() Constructor.","title":"function CustomBatteryConsumerROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1CustomBatteryConsumerROSPlugin/#function-custombatteryconsumerrosplugin_1","text":"virtual ~CustomBatteryConsumerROSPlugin() Destructor.","title":"function ~CustomBatteryConsumerROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1CustomBatteryConsumerROSPlugin/#function-load","text":"void Load( physics::ModelPtr _parent, sdf::ElementPtr _sdf ) Load module and read parameters from SDF.","title":"function Load"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1CustomBatteryConsumerROSPlugin/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1CustomBatteryConsumerROSPlugin/#function-updatedevicestate","text":"void UpdateDeviceState( const std_msgs::Bool::ConstPtr & _msg ) Callback for the device state topic subscriber.","title":"function UpdateDeviceState"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1CustomBatteryConsumerROSPlugin/#function-updatepowerload","text":"void UpdatePowerLoad( double _powerLoad =0.0 ) Update power load.","title":"function UpdatePowerLoad"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1CustomBatteryConsumerROSPlugin/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1CustomBatteryConsumerROSPlugin/#variable-rosnode","text":"boost::scoped_ptr< ros::NodeHandle > rosNode; Pointer to this ROS node's handle.","title":"variable rosNode"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1CustomBatteryConsumerROSPlugin/#variable-devicestatesub","text":"ros::Subscriber deviceStateSub; Subscriber to the device state flag.","title":"variable deviceStateSub"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1CustomBatteryConsumerROSPlugin/#variable-battery","text":"common::BatteryPtr battery; Pointer to battery.","title":"variable battery"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1CustomBatteryConsumerROSPlugin/#variable-isdeviceon","text":"bool isDeviceOn; Flag to signal whether a specific device is running.","title":"variable isDeviceOn"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1CustomBatteryConsumerROSPlugin/#variable-powerload","text":"double powerLoad; Power load in W.","title":"variable powerLoad"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1CustomBatteryConsumerROSPlugin/#variable-consumerid","text":"int consumerID; Battery consumer ID.","title":"variable consumerID"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1CustomBatteryConsumerROSPlugin/#variable-linkname","text":"std::string linkName; Link name.","title":"variable linkName"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1CustomBatteryConsumerROSPlugin/#variable-batteryname","text":"std::string batteryName; Battery model name.","title":"variable batteryName"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1CustomBatteryConsumerROSPlugin/#variable-rospublishconnection","text":"event::ConnectionPtr rosPublishConnection; Connection for callbacks on update world. Updated on 2022-05-30 at 18:35:13 +0000","title":"variable rosPublishConnection"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1LinearBatteryROSPlugin/","text":"gazebo::LinearBatteryROSPlugin Inherits from LinearBatteryPlugin Public Functions Name LinearBatteryROSPlugin () Constructor. virtual ~LinearBatteryROSPlugin () Destructor. void Load (physics::ModelPtr _parent, sdf::ElementPtr _sdf) Load module and read parameters from SDF. virtual void Init () Initialize Module. virtual void Reset () Reset Module. Protected Functions Name void PublishBatteryState () Publish battery states. Protected Attributes Name boost::scoped_ptr< ros::NodeHandle > rosNode Pointer to this ROS node's handle. std::string robotNamespace Namespace for this ROS node. sensor_msgs::BatteryState batteryStateMsg Battery state ROS message. ros::Timer updateTimer Connection for callbacks on update world. Public Functions Documentation function LinearBatteryROSPlugin LinearBatteryROSPlugin() Constructor. function ~LinearBatteryROSPlugin virtual ~LinearBatteryROSPlugin() Destructor. function Load void Load( physics::ModelPtr _parent, sdf::ElementPtr _sdf ) Load module and read parameters from SDF. function Init virtual void Init() Initialize Module. function Reset virtual void Reset() Reset Module. Protected Functions Documentation function PublishBatteryState void PublishBatteryState() Publish battery states. Protected Attributes Documentation variable rosNode boost::scoped_ptr< ros::NodeHandle > rosNode; Pointer to this ROS node's handle. variable robotNamespace std::string robotNamespace; Namespace for this ROS node. variable batteryStateMsg sensor_msgs::BatteryState batteryStateMsg; Battery state ROS message. variable updateTimer ros::Timer updateTimer; Connection for callbacks on update world. Updated on 2022-05-30 at 18:35:13 +0000","title":"gazebo::LinearBatteryROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1LinearBatteryROSPlugin/#gazebolinearbatteryrosplugin","text":"Inherits from LinearBatteryPlugin","title":"gazebo::LinearBatteryROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1LinearBatteryROSPlugin/#public-functions","text":"Name LinearBatteryROSPlugin () Constructor. virtual ~LinearBatteryROSPlugin () Destructor. void Load (physics::ModelPtr _parent, sdf::ElementPtr _sdf) Load module and read parameters from SDF. virtual void Init () Initialize Module. virtual void Reset () Reset Module.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1LinearBatteryROSPlugin/#protected-functions","text":"Name void PublishBatteryState () Publish battery states.","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1LinearBatteryROSPlugin/#protected-attributes","text":"Name boost::scoped_ptr< ros::NodeHandle > rosNode Pointer to this ROS node's handle. std::string robotNamespace Namespace for this ROS node. sensor_msgs::BatteryState batteryStateMsg Battery state ROS message. ros::Timer updateTimer Connection for callbacks on update world.","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1LinearBatteryROSPlugin/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1LinearBatteryROSPlugin/#function-linearbatteryrosplugin","text":"LinearBatteryROSPlugin() Constructor.","title":"function LinearBatteryROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1LinearBatteryROSPlugin/#function-linearbatteryrosplugin_1","text":"virtual ~LinearBatteryROSPlugin() Destructor.","title":"function ~LinearBatteryROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1LinearBatteryROSPlugin/#function-load","text":"void Load( physics::ModelPtr _parent, sdf::ElementPtr _sdf ) Load module and read parameters from SDF.","title":"function Load"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1LinearBatteryROSPlugin/#function-init","text":"virtual void Init() Initialize Module.","title":"function Init"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1LinearBatteryROSPlugin/#function-reset","text":"virtual void Reset() Reset Module.","title":"function Reset"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1LinearBatteryROSPlugin/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1LinearBatteryROSPlugin/#function-publishbatterystate","text":"void PublishBatteryState() Publish battery states.","title":"function PublishBatteryState"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1LinearBatteryROSPlugin/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1LinearBatteryROSPlugin/#variable-rosnode","text":"boost::scoped_ptr< ros::NodeHandle > rosNode; Pointer to this ROS node's handle.","title":"variable rosNode"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1LinearBatteryROSPlugin/#variable-robotnamespace","text":"std::string robotNamespace; Namespace for this ROS node.","title":"variable robotNamespace"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1LinearBatteryROSPlugin/#variable-batterystatemsg","text":"sensor_msgs::BatteryState batteryStateMsg; Battery state ROS message.","title":"variable batteryStateMsg"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1LinearBatteryROSPlugin/#variable-updatetimer","text":"ros::Timer updateTimer; Connection for callbacks on update world. Updated on 2022-05-30 at 18:35:13 +0000","title":"variable updateTimer"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1ThrusterManagerROSPlugin/","text":"gazebo::ThrusterManagerROSPlugin Inherits from ModelPlugin Public Functions Name ThrusterManagerROSPlugin () Constrcutor. ~ThrusterManagerROSPlugin () Destructor. void Load (physics::ModelPtr _model, sdf::ElementPtr _sdf) Load module and read parameters from SDF. void Update (const common::UpdateInfo & _info) Update the simulation state. Protected Functions Name void SetThrustReference (const dsor_msgs::Thruster & _msg) Callback for the input topic subscriber. Protected Attributes Name boost::scoped_ptr< ros::NodeHandle > rosNode Pointer to this ROS node's handle. transport::NodePtr node Gazebo node. event::ConnectionPtr updateConnection Gazebo update event. ros::Subscriber thrusterStackSubscriber Subscriber to the reference signal topic from DSOR stack. std::vector< ros::Publisher > thrustInputPublisher Vector of publishers to the output thrust topic for each thruster (ros) int thrustersNumber : Number of thrusters in vehicle. std::string dsorTopicThrusters : Thrusters topic from DSOR stack. std::vector< double > thrustVector : Vector of thrusters received from DSOR stack Public Functions Documentation function ThrusterManagerROSPlugin ThrusterManagerROSPlugin() Constrcutor. function ~ThrusterManagerROSPlugin ~ThrusterManagerROSPlugin() Destructor. function Load void Load( physics::ModelPtr _model, sdf::ElementPtr _sdf ) Load module and read parameters from SDF. function Update void Update( const common::UpdateInfo & _info ) Update the simulation state. Parameters : _info Information used in the update event. Protected Functions Documentation function SetThrustReference void SetThrustReference( const dsor_msgs::Thruster & _msg ) Callback for the input topic subscriber. Protected Attributes Documentation variable rosNode boost::scoped_ptr< ros::NodeHandle > rosNode; Pointer to this ROS node's handle. variable node transport::NodePtr node; Gazebo node. variable updateConnection event::ConnectionPtr updateConnection; Gazebo update event. variable thrusterStackSubscriber ros::Subscriber thrusterStackSubscriber; Subscriber to the reference signal topic from DSOR stack. variable thrustInputPublisher std::vector< ros::Publisher > thrustInputPublisher; Vector of publishers to the output thrust topic for each thruster (ros) variable thrustersNumber int thrustersNumber; : Number of thrusters in vehicle. variable dsorTopicThrusters std::string dsorTopicThrusters; : Thrusters topic from DSOR stack. variable thrustVector std::vector< double > thrustVector; : Vector of thrusters received from DSOR stack Updated on 2022-05-30 at 18:35:13 +0000","title":"gazebo::ThrusterManagerROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1ThrusterManagerROSPlugin/#gazebothrustermanagerrosplugin","text":"Inherits from ModelPlugin","title":"gazebo::ThrusterManagerROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1ThrusterManagerROSPlugin/#public-functions","text":"Name ThrusterManagerROSPlugin () Constrcutor. ~ThrusterManagerROSPlugin () Destructor. void Load (physics::ModelPtr _model, sdf::ElementPtr _sdf) Load module and read parameters from SDF. void Update (const common::UpdateInfo & _info) Update the simulation state.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1ThrusterManagerROSPlugin/#protected-functions","text":"Name void SetThrustReference (const dsor_msgs::Thruster & _msg) Callback for the input topic subscriber.","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1ThrusterManagerROSPlugin/#protected-attributes","text":"Name boost::scoped_ptr< ros::NodeHandle > rosNode Pointer to this ROS node's handle. transport::NodePtr node Gazebo node. event::ConnectionPtr updateConnection Gazebo update event. ros::Subscriber thrusterStackSubscriber Subscriber to the reference signal topic from DSOR stack. std::vector< ros::Publisher > thrustInputPublisher Vector of publishers to the output thrust topic for each thruster (ros) int thrustersNumber : Number of thrusters in vehicle. std::string dsorTopicThrusters : Thrusters topic from DSOR stack. std::vector< double > thrustVector : Vector of thrusters received from DSOR stack","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1ThrusterManagerROSPlugin/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1ThrusterManagerROSPlugin/#function-thrustermanagerrosplugin","text":"ThrusterManagerROSPlugin() Constrcutor.","title":"function ThrusterManagerROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1ThrusterManagerROSPlugin/#function-thrustermanagerrosplugin_1","text":"~ThrusterManagerROSPlugin() Destructor.","title":"function ~ThrusterManagerROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1ThrusterManagerROSPlugin/#function-load","text":"void Load( physics::ModelPtr _model, sdf::ElementPtr _sdf ) Load module and read parameters from SDF.","title":"function Load"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1ThrusterManagerROSPlugin/#function-update","text":"void Update( const common::UpdateInfo & _info ) Update the simulation state. Parameters : _info Information used in the update event.","title":"function Update"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1ThrusterManagerROSPlugin/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1ThrusterManagerROSPlugin/#function-setthrustreference","text":"void SetThrustReference( const dsor_msgs::Thruster & _msg ) Callback for the input topic subscriber.","title":"function SetThrustReference"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1ThrusterManagerROSPlugin/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1ThrusterManagerROSPlugin/#variable-rosnode","text":"boost::scoped_ptr< ros::NodeHandle > rosNode; Pointer to this ROS node's handle.","title":"variable rosNode"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1ThrusterManagerROSPlugin/#variable-node","text":"transport::NodePtr node; Gazebo node.","title":"variable node"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1ThrusterManagerROSPlugin/#variable-updateconnection","text":"event::ConnectionPtr updateConnection; Gazebo update event.","title":"variable updateConnection"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1ThrusterManagerROSPlugin/#variable-thrusterstacksubscriber","text":"ros::Subscriber thrusterStackSubscriber; Subscriber to the reference signal topic from DSOR stack.","title":"variable thrusterStackSubscriber"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1ThrusterManagerROSPlugin/#variable-thrustinputpublisher","text":"std::vector< ros::Publisher > thrustInputPublisher; Vector of publishers to the output thrust topic for each thruster (ros)","title":"variable thrustInputPublisher"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1ThrusterManagerROSPlugin/#variable-thrustersnumber","text":"int thrustersNumber; : Number of thrusters in vehicle.","title":"variable thrustersNumber"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1ThrusterManagerROSPlugin/#variable-dsortopicthrusters","text":"std::string dsorTopicThrusters; : Thrusters topic from DSOR stack.","title":"variable dsorTopicThrusters"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classgazebo_1_1ThrusterManagerROSPlugin/#variable-thrustvector","text":"std::vector< double > thrustVector; : Vector of thrusters received from DSOR stack Updated on 2022-05-30 at 18:35:13 +0000","title":"variable thrustVector"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__default__fossen__vehicle_1_1TestDefaultFossenVehicle/","text":"test_default_fossen_vehicle::TestDefaultFossenVehicle Inherits from TestCase Public Functions Name def test_get_model_parameters (self self) def test_set_fluid_density (self self) def test_volume_offset (self self) def test_added_mass_scaling (self self) def test_damping_scaling (self self) def test_volume_scaling (self self) def test_added_mass_offset (self self) def test_linear_damping_offset (self self) def test_linear_forward_speed_damping_offset (self self) def test_linear_forward_speed_damping_offset (self self) Public Functions Documentation function test_get_model_parameters def test_get_model_parameters( self self ) function test_set_fluid_density def test_set_fluid_density( self self ) function test_volume_offset def test_volume_offset( self self ) function test_added_mass_scaling def test_added_mass_scaling( self self ) function test_damping_scaling def test_damping_scaling( self self ) function test_volume_scaling def test_volume_scaling( self self ) function test_added_mass_offset def test_added_mass_offset( self self ) function test_linear_damping_offset def test_linear_damping_offset( self self ) function test_linear_forward_speed_damping_offset def test_linear_forward_speed_damping_offset( self self ) function test_linear_forward_speed_damping_offset def test_linear_forward_speed_damping_offset( self self ) Updated on 2022-05-30 at 18:35:13 +0000","title":"test_default_fossen_vehicle::TestDefaultFossenVehicle"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__default__fossen__vehicle_1_1TestDefaultFossenVehicle/#test_default_fossen_vehicletestdefaultfossenvehicle","text":"Inherits from TestCase","title":"test_default_fossen_vehicle::TestDefaultFossenVehicle"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__default__fossen__vehicle_1_1TestDefaultFossenVehicle/#public-functions","text":"Name def test_get_model_parameters (self self) def test_set_fluid_density (self self) def test_volume_offset (self self) def test_added_mass_scaling (self self) def test_damping_scaling (self self) def test_volume_scaling (self self) def test_added_mass_offset (self self) def test_linear_damping_offset (self self) def test_linear_forward_speed_damping_offset (self self) def test_linear_forward_speed_damping_offset (self self)","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__default__fossen__vehicle_1_1TestDefaultFossenVehicle/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__default__fossen__vehicle_1_1TestDefaultFossenVehicle/#function-test_get_model_parameters","text":"def test_get_model_parameters( self self )","title":"function test_get_model_parameters"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__default__fossen__vehicle_1_1TestDefaultFossenVehicle/#function-test_set_fluid_density","text":"def test_set_fluid_density( self self )","title":"function test_set_fluid_density"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__default__fossen__vehicle_1_1TestDefaultFossenVehicle/#function-test_volume_offset","text":"def test_volume_offset( self self )","title":"function test_volume_offset"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__default__fossen__vehicle_1_1TestDefaultFossenVehicle/#function-test_added_mass_scaling","text":"def test_added_mass_scaling( self self )","title":"function test_added_mass_scaling"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__default__fossen__vehicle_1_1TestDefaultFossenVehicle/#function-test_damping_scaling","text":"def test_damping_scaling( self self )","title":"function test_damping_scaling"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__default__fossen__vehicle_1_1TestDefaultFossenVehicle/#function-test_volume_scaling","text":"def test_volume_scaling( self self )","title":"function test_volume_scaling"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__default__fossen__vehicle_1_1TestDefaultFossenVehicle/#function-test_added_mass_offset","text":"def test_added_mass_offset( self self )","title":"function test_added_mass_offset"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__default__fossen__vehicle_1_1TestDefaultFossenVehicle/#function-test_linear_damping_offset","text":"def test_linear_damping_offset( self self )","title":"function test_linear_damping_offset"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__default__fossen__vehicle_1_1TestDefaultFossenVehicle/#function-test_linear_forward_speed_damping_offset","text":"def test_linear_forward_speed_damping_offset( self self )","title":"function test_linear_forward_speed_damping_offset"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__default__fossen__vehicle_1_1TestDefaultFossenVehicle/#function-test_linear_forward_speed_damping_offset_1","text":"def test_linear_forward_speed_damping_offset( self self ) Updated on 2022-05-30 at 18:35:13 +0000","title":"function test_linear_forward_speed_damping_offset"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__sphere__vehicle_1_1TestSphereVehicle/","text":"test_sphere_vehicle::TestSphereVehicle Inherits from TestCase Public Functions Name def test_get_model_parameters (self self) def test_added_mass_coefs (self self) def test_nonlinear_damping_coefs (self self) Public Functions Documentation function test_get_model_parameters def test_get_model_parameters( self self ) function test_added_mass_coefs def test_added_mass_coefs( self self ) function test_nonlinear_damping_coefs def test_nonlinear_damping_coefs( self self ) Updated on 2022-05-30 at 18:35:13 +0000","title":"test_sphere_vehicle::TestSphereVehicle"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__sphere__vehicle_1_1TestSphereVehicle/#test_sphere_vehicletestspherevehicle","text":"Inherits from TestCase","title":"test_sphere_vehicle::TestSphereVehicle"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__sphere__vehicle_1_1TestSphereVehicle/#public-functions","text":"Name def test_get_model_parameters (self self) def test_added_mass_coefs (self self) def test_nonlinear_damping_coefs (self self)","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__sphere__vehicle_1_1TestSphereVehicle/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__sphere__vehicle_1_1TestSphereVehicle/#function-test_get_model_parameters","text":"def test_get_model_parameters( self self )","title":"function test_get_model_parameters"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__sphere__vehicle_1_1TestSphereVehicle/#function-test_added_mass_coefs","text":"def test_added_mass_coefs( self self )","title":"function test_added_mass_coefs"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__sphere__vehicle_1_1TestSphereVehicle/#function-test_nonlinear_damping_coefs","text":"def test_nonlinear_damping_coefs( self self ) Updated on 2022-05-30 at 18:35:13 +0000","title":"function test_nonlinear_damping_coefs"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__thrusters_1_1TestThrusters/","text":"test_thrusters::TestThrusters Inherits from TestCase Public Functions Name def init (self self, * args) def test_input_output_topics_exist (self self) def test_convertion_fcn_parameters (self self) def test_change_thruster_state (self self) def test_change_thrust_efficiency (self self) def test_change_dyn_state_efficiency (self self) Public Attributes Name thruster_input_pub Public Functions Documentation function init def __init__( self self, * args ) function test_input_output_topics_exist def test_input_output_topics_exist( self self ) function test_convertion_fcn_parameters def test_convertion_fcn_parameters( self self ) function test_change_thruster_state def test_change_thruster_state( self self ) function test_change_thrust_efficiency def test_change_thrust_efficiency( self self ) function test_change_dyn_state_efficiency def test_change_dyn_state_efficiency( self self ) Public Attributes Documentation variable thruster_input_pub thruster_input_pub; Updated on 2022-05-30 at 18:35:13 +0000","title":"test_thrusters::TestThrusters"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__thrusters_1_1TestThrusters/#test_thrusterstestthrusters","text":"Inherits from TestCase","title":"test_thrusters::TestThrusters"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__thrusters_1_1TestThrusters/#public-functions","text":"Name def init (self self, * args) def test_input_output_topics_exist (self self) def test_convertion_fcn_parameters (self self) def test_change_thruster_state (self self) def test_change_thrust_efficiency (self self) def test_change_dyn_state_efficiency (self self)","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__thrusters_1_1TestThrusters/#public-attributes","text":"Name thruster_input_pub","title":"Public Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__thrusters_1_1TestThrusters/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__thrusters_1_1TestThrusters/#function-init","text":"def __init__( self self, * args )","title":"function init"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__thrusters_1_1TestThrusters/#function-test_input_output_topics_exist","text":"def test_input_output_topics_exist( self self )","title":"function test_input_output_topics_exist"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__thrusters_1_1TestThrusters/#function-test_convertion_fcn_parameters","text":"def test_convertion_fcn_parameters( self self )","title":"function test_convertion_fcn_parameters"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__thrusters_1_1TestThrusters/#function-test_change_thruster_state","text":"def test_change_thruster_state( self self )","title":"function test_change_thruster_state"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__thrusters_1_1TestThrusters/#function-test_change_thrust_efficiency","text":"def test_change_thrust_efficiency( self self )","title":"function test_change_thrust_efficiency"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__thrusters_1_1TestThrusters/#function-test_change_dyn_state_efficiency","text":"def test_change_dyn_state_efficiency( self self )","title":"function test_change_dyn_state_efficiency"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__thrusters_1_1TestThrusters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classtest__thrusters_1_1TestThrusters/#variable-thruster_input_pub","text":"thruster_input_pub; Updated on 2022-05-30 at 18:35:13 +0000","title":"variable thruster_input_pub"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1FinROSPlugin/","text":"uuv_simulator_ros::FinROSPlugin Inherits from FinPlugin Public Functions Name FinROSPlugin () Constrcutor. ~FinROSPlugin () Destructor. void Load (gazebo::physics::ModelPtr _parent, sdf::ElementPtr _sdf) Load module and read parameters from SDF. void RosPublishStates () Publish state via ROS. void SetReference (const uuv_gazebo_ros_plugins_msgs::FloatStamped::ConstPtr & _msg) Set new set point. bool GetLiftDragParams (uuv_gazebo_ros_plugins_msgs::GetListParam::Request & _req, uuv_gazebo_ros_plugins_msgs::GetListParam::Response & _res) Return the list of paramaters of the lift and drag model. gazebo::common::Time GetRosPublishPeriod () Return the ROS publish period. void SetRosPublishRate (double _hz) Set the ROS publish frequency (Hz). virtual void Init () Initialize Module. virtual void Reset () Reset Module. Public Functions Documentation function FinROSPlugin FinROSPlugin() Constrcutor. function ~FinROSPlugin ~FinROSPlugin() Destructor. function Load void Load( gazebo::physics::ModelPtr _parent, sdf::ElementPtr _sdf ) Load module and read parameters from SDF. function RosPublishStates void RosPublishStates() Publish state via ROS. function SetReference void SetReference( const uuv_gazebo_ros_plugins_msgs::FloatStamped::ConstPtr & _msg ) Set new set point. function GetLiftDragParams bool GetLiftDragParams( uuv_gazebo_ros_plugins_msgs::GetListParam::Request & _req, uuv_gazebo_ros_plugins_msgs::GetListParam::Response & _res ) Return the list of paramaters of the lift and drag model. function GetRosPublishPeriod gazebo::common::Time GetRosPublishPeriod() Return the ROS publish period. function SetRosPublishRate void SetRosPublishRate( double _hz ) Set the ROS publish frequency (Hz). function Init virtual void Init() Initialize Module. function Reset virtual void Reset() Reset Module. Updated on 2022-05-30 at 18:35:13 +0000","title":"uuv_simulator_ros::FinROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1FinROSPlugin/#uuv_simulator_rosfinrosplugin","text":"Inherits from FinPlugin","title":"uuv_simulator_ros::FinROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1FinROSPlugin/#public-functions","text":"Name FinROSPlugin () Constrcutor. ~FinROSPlugin () Destructor. void Load (gazebo::physics::ModelPtr _parent, sdf::ElementPtr _sdf) Load module and read parameters from SDF. void RosPublishStates () Publish state via ROS. void SetReference (const uuv_gazebo_ros_plugins_msgs::FloatStamped::ConstPtr & _msg) Set new set point. bool GetLiftDragParams (uuv_gazebo_ros_plugins_msgs::GetListParam::Request & _req, uuv_gazebo_ros_plugins_msgs::GetListParam::Response & _res) Return the list of paramaters of the lift and drag model. gazebo::common::Time GetRosPublishPeriod () Return the ROS publish period. void SetRosPublishRate (double _hz) Set the ROS publish frequency (Hz). virtual void Init () Initialize Module. virtual void Reset () Reset Module.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1FinROSPlugin/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1FinROSPlugin/#function-finrosplugin","text":"FinROSPlugin() Constrcutor.","title":"function FinROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1FinROSPlugin/#function-finrosplugin_1","text":"~FinROSPlugin() Destructor.","title":"function ~FinROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1FinROSPlugin/#function-load","text":"void Load( gazebo::physics::ModelPtr _parent, sdf::ElementPtr _sdf ) Load module and read parameters from SDF.","title":"function Load"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1FinROSPlugin/#function-rospublishstates","text":"void RosPublishStates() Publish state via ROS.","title":"function RosPublishStates"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1FinROSPlugin/#function-setreference","text":"void SetReference( const uuv_gazebo_ros_plugins_msgs::FloatStamped::ConstPtr & _msg ) Set new set point.","title":"function SetReference"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1FinROSPlugin/#function-getliftdragparams","text":"bool GetLiftDragParams( uuv_gazebo_ros_plugins_msgs::GetListParam::Request & _req, uuv_gazebo_ros_plugins_msgs::GetListParam::Response & _res ) Return the list of paramaters of the lift and drag model.","title":"function GetLiftDragParams"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1FinROSPlugin/#function-getrospublishperiod","text":"gazebo::common::Time GetRosPublishPeriod() Return the ROS publish period.","title":"function GetRosPublishPeriod"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1FinROSPlugin/#function-setrospublishrate","text":"void SetRosPublishRate( double _hz ) Set the ROS publish frequency (Hz).","title":"function SetRosPublishRate"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1FinROSPlugin/#function-init","text":"virtual void Init() Initialize Module.","title":"function Init"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1FinROSPlugin/#function-reset","text":"virtual void Reset() Reset Module. Updated on 2022-05-30 at 18:35:13 +0000","title":"function Reset"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1JointStatePublisher/","text":"uuv_simulator_ros::JointStatePublisher Inherits from ModelPlugin Public Functions Name JointStatePublisher () ~JointStatePublisher () void Load (gazebo::physics::ModelPtr _parent, sdf::ElementPtr _sdf) void OnUpdate (const gazebo::common::UpdateInfo & _info) void PublishJointStates () Public Functions Documentation function JointStatePublisher JointStatePublisher() function ~JointStatePublisher ~JointStatePublisher() function Load void Load( gazebo::physics::ModelPtr _parent, sdf::ElementPtr _sdf ) function OnUpdate void OnUpdate( const gazebo::common::UpdateInfo & _info ) function PublishJointStates void PublishJointStates() Updated on 2022-05-30 at 18:35:13 +0000","title":"uuv_simulator_ros::JointStatePublisher"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1JointStatePublisher/#uuv_simulator_rosjointstatepublisher","text":"Inherits from ModelPlugin","title":"uuv_simulator_ros::JointStatePublisher"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1JointStatePublisher/#public-functions","text":"Name JointStatePublisher () ~JointStatePublisher () void Load (gazebo::physics::ModelPtr _parent, sdf::ElementPtr _sdf) void OnUpdate (const gazebo::common::UpdateInfo & _info) void PublishJointStates ()","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1JointStatePublisher/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1JointStatePublisher/#function-jointstatepublisher","text":"JointStatePublisher()","title":"function JointStatePublisher"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1JointStatePublisher/#function-jointstatepublisher_1","text":"~JointStatePublisher()","title":"function ~JointStatePublisher"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1JointStatePublisher/#function-load","text":"void Load( gazebo::physics::ModelPtr _parent, sdf::ElementPtr _sdf )","title":"function Load"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1JointStatePublisher/#function-onupdate","text":"void OnUpdate( const gazebo::common::UpdateInfo & _info )","title":"function OnUpdate"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1JointStatePublisher/#function-publishjointstates","text":"void PublishJointStates() Updated on 2022-05-30 at 18:35:13 +0000","title":"function PublishJointStates"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1ThrusterROSPlugin/","text":"uuv_simulator_ros::ThrusterROSPlugin Inherits from ThrusterPlugin Public Functions Name ThrusterROSPlugin () Constrcutor. ~ThrusterROSPlugin () Destructor. void Load (gazebo::physics::ModelPtr _parent, sdf::ElementPtr _sdf) Load module and read parameters from SDF. void RosPublishStates () Publish thruster state via ROS. void SetThrustReference (const uuv_gazebo_ros_plugins_msgs::FloatStamped::ConstPtr & _msg) Set new set point (desired thrust [N]) for thruster. gazebo::common::Time GetRosPublishPeriod () Return the ROS publish period. void SetRosPublishRate (double _hz) Set the ROS publish frequency (Hz). virtual void Init () Initialize Module. virtual void Reset () Reset Module. bool SetThrustForceEfficiency (uuv_gazebo_ros_plugins_msgs::SetThrusterEfficiency::Request & _req, uuv_gazebo_ros_plugins_msgs::SetThrusterEfficiency::Response & _res) Set the thrust efficiency factor. bool GetThrustForceEfficiency (uuv_gazebo_ros_plugins_msgs::GetThrusterEfficiency::Request & _req, uuv_gazebo_ros_plugins_msgs::GetThrusterEfficiency::Response & _res) Get the thrust efficiency factor. bool SetDynamicStateEfficiency (uuv_gazebo_ros_plugins_msgs::SetThrusterEfficiency::Request & _req, uuv_gazebo_ros_plugins_msgs::SetThrusterEfficiency::Response & _res) Set the dynamic state efficiency factor. bool GetDynamicStateEfficiency (uuv_gazebo_ros_plugins_msgs::GetThrusterEfficiency::Request & _req, uuv_gazebo_ros_plugins_msgs::GetThrusterEfficiency::Response & _res) Get the dynamic state efficiency factor. bool SetThrusterState (uuv_gazebo_ros_plugins_msgs::SetThrusterState::Request & _req, uuv_gazebo_ros_plugins_msgs::SetThrusterState::Response & _res) Turn thruster on/off. bool GetThrusterState (uuv_gazebo_ros_plugins_msgs::GetThrusterState::Request & _req, uuv_gazebo_ros_plugins_msgs::GetThrusterState::Response & _res) Get thruster state. bool GetThrusterConversionFcn (uuv_gazebo_ros_plugins_msgs::GetThrusterConversionFcn::Request & _req, uuv_gazebo_ros_plugins_msgs::GetThrusterConversionFcn::Response & _res) Get thruster conversion function parameters. Public Functions Documentation function ThrusterROSPlugin ThrusterROSPlugin() Constrcutor. function ~ThrusterROSPlugin ~ThrusterROSPlugin() Destructor. function Load void Load( gazebo::physics::ModelPtr _parent, sdf::ElementPtr _sdf ) Load module and read parameters from SDF. function RosPublishStates void RosPublishStates() Publish thruster state via ROS. function SetThrustReference void SetThrustReference( const uuv_gazebo_ros_plugins_msgs::FloatStamped::ConstPtr & _msg ) Set new set point (desired thrust [N]) for thruster. function GetRosPublishPeriod gazebo::common::Time GetRosPublishPeriod() Return the ROS publish period. function SetRosPublishRate void SetRosPublishRate( double _hz ) Set the ROS publish frequency (Hz). function Init virtual void Init() Initialize Module. function Reset virtual void Reset() Reset Module. function SetThrustForceEfficiency bool SetThrustForceEfficiency( uuv_gazebo_ros_plugins_msgs::SetThrusterEfficiency::Request & _req, uuv_gazebo_ros_plugins_msgs::SetThrusterEfficiency::Response & _res ) Set the thrust efficiency factor. function GetThrustForceEfficiency bool GetThrustForceEfficiency( uuv_gazebo_ros_plugins_msgs::GetThrusterEfficiency::Request & _req, uuv_gazebo_ros_plugins_msgs::GetThrusterEfficiency::Response & _res ) Get the thrust efficiency factor. function SetDynamicStateEfficiency bool SetDynamicStateEfficiency( uuv_gazebo_ros_plugins_msgs::SetThrusterEfficiency::Request & _req, uuv_gazebo_ros_plugins_msgs::SetThrusterEfficiency::Response & _res ) Set the dynamic state efficiency factor. function GetDynamicStateEfficiency bool GetDynamicStateEfficiency( uuv_gazebo_ros_plugins_msgs::GetThrusterEfficiency::Request & _req, uuv_gazebo_ros_plugins_msgs::GetThrusterEfficiency::Response & _res ) Get the dynamic state efficiency factor. function SetThrusterState bool SetThrusterState( uuv_gazebo_ros_plugins_msgs::SetThrusterState::Request & _req, uuv_gazebo_ros_plugins_msgs::SetThrusterState::Response & _res ) Turn thruster on/off. function GetThrusterState bool GetThrusterState( uuv_gazebo_ros_plugins_msgs::GetThrusterState::Request & _req, uuv_gazebo_ros_plugins_msgs::GetThrusterState::Response & _res ) Get thruster state. function GetThrusterConversionFcn bool GetThrusterConversionFcn( uuv_gazebo_ros_plugins_msgs::GetThrusterConversionFcn::Request & _req, uuv_gazebo_ros_plugins_msgs::GetThrusterConversionFcn::Response & _res ) Get thruster conversion function parameters. Updated on 2022-05-30 at 18:35:13 +0000","title":"uuv_simulator_ros::ThrusterROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1ThrusterROSPlugin/#uuv_simulator_rosthrusterrosplugin","text":"Inherits from ThrusterPlugin","title":"uuv_simulator_ros::ThrusterROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1ThrusterROSPlugin/#public-functions","text":"Name ThrusterROSPlugin () Constrcutor. ~ThrusterROSPlugin () Destructor. void Load (gazebo::physics::ModelPtr _parent, sdf::ElementPtr _sdf) Load module and read parameters from SDF. void RosPublishStates () Publish thruster state via ROS. void SetThrustReference (const uuv_gazebo_ros_plugins_msgs::FloatStamped::ConstPtr & _msg) Set new set point (desired thrust [N]) for thruster. gazebo::common::Time GetRosPublishPeriod () Return the ROS publish period. void SetRosPublishRate (double _hz) Set the ROS publish frequency (Hz). virtual void Init () Initialize Module. virtual void Reset () Reset Module. bool SetThrustForceEfficiency (uuv_gazebo_ros_plugins_msgs::SetThrusterEfficiency::Request & _req, uuv_gazebo_ros_plugins_msgs::SetThrusterEfficiency::Response & _res) Set the thrust efficiency factor. bool GetThrustForceEfficiency (uuv_gazebo_ros_plugins_msgs::GetThrusterEfficiency::Request & _req, uuv_gazebo_ros_plugins_msgs::GetThrusterEfficiency::Response & _res) Get the thrust efficiency factor. bool SetDynamicStateEfficiency (uuv_gazebo_ros_plugins_msgs::SetThrusterEfficiency::Request & _req, uuv_gazebo_ros_plugins_msgs::SetThrusterEfficiency::Response & _res) Set the dynamic state efficiency factor. bool GetDynamicStateEfficiency (uuv_gazebo_ros_plugins_msgs::GetThrusterEfficiency::Request & _req, uuv_gazebo_ros_plugins_msgs::GetThrusterEfficiency::Response & _res) Get the dynamic state efficiency factor. bool SetThrusterState (uuv_gazebo_ros_plugins_msgs::SetThrusterState::Request & _req, uuv_gazebo_ros_plugins_msgs::SetThrusterState::Response & _res) Turn thruster on/off. bool GetThrusterState (uuv_gazebo_ros_plugins_msgs::GetThrusterState::Request & _req, uuv_gazebo_ros_plugins_msgs::GetThrusterState::Response & _res) Get thruster state. bool GetThrusterConversionFcn (uuv_gazebo_ros_plugins_msgs::GetThrusterConversionFcn::Request & _req, uuv_gazebo_ros_plugins_msgs::GetThrusterConversionFcn::Response & _res) Get thruster conversion function parameters.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1ThrusterROSPlugin/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1ThrusterROSPlugin/#function-thrusterrosplugin","text":"ThrusterROSPlugin() Constrcutor.","title":"function ThrusterROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1ThrusterROSPlugin/#function-thrusterrosplugin_1","text":"~ThrusterROSPlugin() Destructor.","title":"function ~ThrusterROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1ThrusterROSPlugin/#function-load","text":"void Load( gazebo::physics::ModelPtr _parent, sdf::ElementPtr _sdf ) Load module and read parameters from SDF.","title":"function Load"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1ThrusterROSPlugin/#function-rospublishstates","text":"void RosPublishStates() Publish thruster state via ROS.","title":"function RosPublishStates"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1ThrusterROSPlugin/#function-setthrustreference","text":"void SetThrustReference( const uuv_gazebo_ros_plugins_msgs::FloatStamped::ConstPtr & _msg ) Set new set point (desired thrust [N]) for thruster.","title":"function SetThrustReference"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1ThrusterROSPlugin/#function-getrospublishperiod","text":"gazebo::common::Time GetRosPublishPeriod() Return the ROS publish period.","title":"function GetRosPublishPeriod"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1ThrusterROSPlugin/#function-setrospublishrate","text":"void SetRosPublishRate( double _hz ) Set the ROS publish frequency (Hz).","title":"function SetRosPublishRate"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1ThrusterROSPlugin/#function-init","text":"virtual void Init() Initialize Module.","title":"function Init"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1ThrusterROSPlugin/#function-reset","text":"virtual void Reset() Reset Module.","title":"function Reset"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1ThrusterROSPlugin/#function-setthrustforceefficiency","text":"bool SetThrustForceEfficiency( uuv_gazebo_ros_plugins_msgs::SetThrusterEfficiency::Request & _req, uuv_gazebo_ros_plugins_msgs::SetThrusterEfficiency::Response & _res ) Set the thrust efficiency factor.","title":"function SetThrustForceEfficiency"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1ThrusterROSPlugin/#function-getthrustforceefficiency","text":"bool GetThrustForceEfficiency( uuv_gazebo_ros_plugins_msgs::GetThrusterEfficiency::Request & _req, uuv_gazebo_ros_plugins_msgs::GetThrusterEfficiency::Response & _res ) Get the thrust efficiency factor.","title":"function GetThrustForceEfficiency"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1ThrusterROSPlugin/#function-setdynamicstateefficiency","text":"bool SetDynamicStateEfficiency( uuv_gazebo_ros_plugins_msgs::SetThrusterEfficiency::Request & _req, uuv_gazebo_ros_plugins_msgs::SetThrusterEfficiency::Response & _res ) Set the dynamic state efficiency factor.","title":"function SetDynamicStateEfficiency"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1ThrusterROSPlugin/#function-getdynamicstateefficiency","text":"bool GetDynamicStateEfficiency( uuv_gazebo_ros_plugins_msgs::GetThrusterEfficiency::Request & _req, uuv_gazebo_ros_plugins_msgs::GetThrusterEfficiency::Response & _res ) Get the dynamic state efficiency factor.","title":"function GetDynamicStateEfficiency"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1ThrusterROSPlugin/#function-setthrusterstate","text":"bool SetThrusterState( uuv_gazebo_ros_plugins_msgs::SetThrusterState::Request & _req, uuv_gazebo_ros_plugins_msgs::SetThrusterState::Response & _res ) Turn thruster on/off.","title":"function SetThrusterState"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1ThrusterROSPlugin/#function-getthrusterstate","text":"bool GetThrusterState( uuv_gazebo_ros_plugins_msgs::GetThrusterState::Request & _req, uuv_gazebo_ros_plugins_msgs::GetThrusterState::Response & _res ) Get thruster state.","title":"function GetThrusterState"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1ThrusterROSPlugin/#function-getthrusterconversionfcn","text":"bool GetThrusterConversionFcn( uuv_gazebo_ros_plugins_msgs::GetThrusterConversionFcn::Request & _req, uuv_gazebo_ros_plugins_msgs::GetThrusterConversionFcn::Response & _res ) Get thruster conversion function parameters. Updated on 2022-05-30 at 18:35:13 +0000","title":"function GetThrusterConversionFcn"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/","text":"uuv_simulator_ros::UnderwaterObjectROSPlugin Inherits from UnderwaterObjectPlugin Public Functions Name UnderwaterObjectROSPlugin () Constructor. virtual ~UnderwaterObjectROSPlugin () Destructor. void Load (gazebo::physics::ModelPtr _parent, sdf::ElementPtr _sdf) Load module and read parameters from SDF. virtual void Init () Initialize Module. virtual void Reset () Reset Module. virtual void Update (const gazebo::common::UpdateInfo & _info) Update the simulation state. void UpdateLocalCurrentVelocity (const geometry_msgs::Vector3::ConstPtr & _msg) Update the local current velocity, this data will be used only if the useGlobalCurrent flag is set to false. bool SetUseGlobalCurrentVel (uuv_gazebo_ros_plugins_msgs::SetUseGlobalCurrentVel::Request & _req, uuv_gazebo_ros_plugins_msgs::SetUseGlobalCurrentVel::Response & _res) Set flag to use the global current velocity topic input. bool GetModelProperties (uuv_gazebo_ros_plugins_msgs::GetModelProperties::Request & _req, uuv_gazebo_ros_plugins_msgs::GetModelProperties::Response & _res) Return the model properties, along with parameters from the hydrodynamic and hydrostatic models. bool SetScalingAddedMass (uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res) Set the scaling factor for the added-mass matrix. bool GetScalingAddedMass (uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res) Return current scaling factor for the added-mass matrix. bool SetScalingDamping (uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res) Set a scaling factor for the overall damping matrix. bool GetScalingDamping (uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res) Return the scaling factor for the overall damping matrix. bool SetScalingVolume (uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res) Set scaling factor for the model's volume used for buoyancy force computation. bool GetScalingVolume (uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res) Get scaling factor for the model's volume used for buoyancy force computation. bool SetFluidDensity (uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res) Set new fluid density (this will alter the value for the buoyancy force) bool GetFluidDensity (uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res) Get current value for the fluid density. bool SetOffsetVolume (uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res) Set offset factor for the model's volume (this will alter the value for the buoyancy force) bool GetOffsetVolume (uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res) Return the offset factor for the model's volume. bool SetOffsetAddedMass (uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res) Set the offset factor for the added-mass matrix. bool GetOffsetAddedMass (uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res) Return the offset factor for the added-mass matrix. bool SetOffsetLinearDamping (uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res) Set the offset factor for the linear damping matrix. bool GetOffsetLinearDamping (uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res) Return the offset factor for the linear damping matrix. bool SetOffsetLinearForwardSpeedDamping (uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res) Set the offset factor for the linear forward speed damping matrix. bool GetOffsetLinearForwardSpeedDamping (uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res) Return the offset factor for the linear forward speed damping matrix. bool SetOffsetNonLinearDamping (uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res) Set the offset factor for the nonlinear damping matrix. bool GetOffsetNonLinearDamping (uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res) Return the offset factor for the nonlinear damping matrix. Protected Functions Name virtual void PublishRestoringForce (gazebo::physics::LinkPtr _link) Publish restoring force. virtual void PublishHydrodynamicWrenches (gazebo::physics::LinkPtr _link) Publish hydrodynamic wrenches. virtual void GenWrenchMsg (ignition::math::Vector3d _force, ignition::math::Vector3d _torque, geometry_msgs::WrenchStamped & _output) Returns the wrench message for debugging topics. virtual void InitDebug (gazebo::physics::LinkPtr _link, gazebo::HydrodynamicModelPtr _hydro) Sets the topics used for publishing the intermediate data during the simulation. virtual void PublishCurrentVelocityMarker () Publishes the current velocity marker. virtual void PublishIsSubmerged () Publishes the state of the vehicle (is submerged) Public Functions Documentation function UnderwaterObjectROSPlugin UnderwaterObjectROSPlugin() Constructor. function ~UnderwaterObjectROSPlugin virtual ~UnderwaterObjectROSPlugin() Destructor. function Load void Load( gazebo::physics::ModelPtr _parent, sdf::ElementPtr _sdf ) Load module and read parameters from SDF. function Init virtual void Init() Initialize Module. function Reset virtual void Reset() Reset Module. function Update virtual void Update( const gazebo::common::UpdateInfo & _info ) Update the simulation state. Parameters : _info Information used in the update event. function UpdateLocalCurrentVelocity void UpdateLocalCurrentVelocity( const geometry_msgs::Vector3::ConstPtr & _msg ) Update the local current velocity, this data will be used only if the useGlobalCurrent flag is set to false. function SetUseGlobalCurrentVel bool SetUseGlobalCurrentVel( uuv_gazebo_ros_plugins_msgs::SetUseGlobalCurrentVel::Request & _req, uuv_gazebo_ros_plugins_msgs::SetUseGlobalCurrentVel::Response & _res ) Set flag to use the global current velocity topic input. function GetModelProperties bool GetModelProperties( uuv_gazebo_ros_plugins_msgs::GetModelProperties::Request & _req, uuv_gazebo_ros_plugins_msgs::GetModelProperties::Response & _res ) Return the model properties, along with parameters from the hydrodynamic and hydrostatic models. function SetScalingAddedMass bool SetScalingAddedMass( uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res ) Set the scaling factor for the added-mass matrix. function GetScalingAddedMass bool GetScalingAddedMass( uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res ) Return current scaling factor for the added-mass matrix. function SetScalingDamping bool SetScalingDamping( uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res ) Set a scaling factor for the overall damping matrix. function GetScalingDamping bool GetScalingDamping( uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res ) Return the scaling factor for the overall damping matrix. function SetScalingVolume bool SetScalingVolume( uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res ) Set scaling factor for the model's volume used for buoyancy force computation. function GetScalingVolume bool GetScalingVolume( uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res ) Get scaling factor for the model's volume used for buoyancy force computation. function SetFluidDensity bool SetFluidDensity( uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res ) Set new fluid density (this will alter the value for the buoyancy force) function GetFluidDensity bool GetFluidDensity( uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res ) Get current value for the fluid density. function SetOffsetVolume bool SetOffsetVolume( uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res ) Set offset factor for the model's volume (this will alter the value for the buoyancy force) function GetOffsetVolume bool GetOffsetVolume( uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res ) Return the offset factor for the model's volume. function SetOffsetAddedMass bool SetOffsetAddedMass( uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res ) Set the offset factor for the added-mass matrix. function GetOffsetAddedMass bool GetOffsetAddedMass( uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res ) Return the offset factor for the added-mass matrix. function SetOffsetLinearDamping bool SetOffsetLinearDamping( uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res ) Set the offset factor for the linear damping matrix. function GetOffsetLinearDamping bool GetOffsetLinearDamping( uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res ) Return the offset factor for the linear damping matrix. function SetOffsetLinearForwardSpeedDamping bool SetOffsetLinearForwardSpeedDamping( uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res ) Set the offset factor for the linear forward speed damping matrix. function GetOffsetLinearForwardSpeedDamping bool GetOffsetLinearForwardSpeedDamping( uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res ) Return the offset factor for the linear forward speed damping matrix. function SetOffsetNonLinearDamping bool SetOffsetNonLinearDamping( uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res ) Set the offset factor for the nonlinear damping matrix. function GetOffsetNonLinearDamping bool GetOffsetNonLinearDamping( uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res ) Return the offset factor for the nonlinear damping matrix. Protected Functions Documentation function PublishRestoringForce virtual void PublishRestoringForce( gazebo::physics::LinkPtr _link ) Publish restoring force. Parameters : _link Pointer to the link where the force information will be extracted from function PublishHydrodynamicWrenches virtual void PublishHydrodynamicWrenches( gazebo::physics::LinkPtr _link ) Publish hydrodynamic wrenches. Parameters : _link Pointer to the link where the force information will be extracted from function GenWrenchMsg virtual void GenWrenchMsg( ignition::math::Vector3d _force, ignition::math::Vector3d _torque, geometry_msgs::WrenchStamped & _output ) Returns the wrench message for debugging topics. Parameters : _force Force vector _torque Torque vector _output Stamped wrench message to be updated function InitDebug virtual void InitDebug( gazebo::physics::LinkPtr _link, gazebo::HydrodynamicModelPtr _hydro ) Sets the topics used for publishing the intermediate data during the simulation. Parameters : _link Pointer to the link _hydro Pointer to the hydrodynamic model function PublishCurrentVelocityMarker virtual void PublishCurrentVelocityMarker() Publishes the current velocity marker. function PublishIsSubmerged virtual void PublishIsSubmerged() Publishes the state of the vehicle (is submerged) Updated on 2022-05-30 at 18:35:13 +0000","title":"uuv_simulator_ros::UnderwaterObjectROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#uuv_simulator_rosunderwaterobjectrosplugin","text":"Inherits from UnderwaterObjectPlugin","title":"uuv_simulator_ros::UnderwaterObjectROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#public-functions","text":"Name UnderwaterObjectROSPlugin () Constructor. virtual ~UnderwaterObjectROSPlugin () Destructor. void Load (gazebo::physics::ModelPtr _parent, sdf::ElementPtr _sdf) Load module and read parameters from SDF. virtual void Init () Initialize Module. virtual void Reset () Reset Module. virtual void Update (const gazebo::common::UpdateInfo & _info) Update the simulation state. void UpdateLocalCurrentVelocity (const geometry_msgs::Vector3::ConstPtr & _msg) Update the local current velocity, this data will be used only if the useGlobalCurrent flag is set to false. bool SetUseGlobalCurrentVel (uuv_gazebo_ros_plugins_msgs::SetUseGlobalCurrentVel::Request & _req, uuv_gazebo_ros_plugins_msgs::SetUseGlobalCurrentVel::Response & _res) Set flag to use the global current velocity topic input. bool GetModelProperties (uuv_gazebo_ros_plugins_msgs::GetModelProperties::Request & _req, uuv_gazebo_ros_plugins_msgs::GetModelProperties::Response & _res) Return the model properties, along with parameters from the hydrodynamic and hydrostatic models. bool SetScalingAddedMass (uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res) Set the scaling factor for the added-mass matrix. bool GetScalingAddedMass (uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res) Return current scaling factor for the added-mass matrix. bool SetScalingDamping (uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res) Set a scaling factor for the overall damping matrix. bool GetScalingDamping (uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res) Return the scaling factor for the overall damping matrix. bool SetScalingVolume (uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res) Set scaling factor for the model's volume used for buoyancy force computation. bool GetScalingVolume (uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res) Get scaling factor for the model's volume used for buoyancy force computation. bool SetFluidDensity (uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res) Set new fluid density (this will alter the value for the buoyancy force) bool GetFluidDensity (uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res) Get current value for the fluid density. bool SetOffsetVolume (uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res) Set offset factor for the model's volume (this will alter the value for the buoyancy force) bool GetOffsetVolume (uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res) Return the offset factor for the model's volume. bool SetOffsetAddedMass (uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res) Set the offset factor for the added-mass matrix. bool GetOffsetAddedMass (uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res) Return the offset factor for the added-mass matrix. bool SetOffsetLinearDamping (uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res) Set the offset factor for the linear damping matrix. bool GetOffsetLinearDamping (uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res) Return the offset factor for the linear damping matrix. bool SetOffsetLinearForwardSpeedDamping (uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res) Set the offset factor for the linear forward speed damping matrix. bool GetOffsetLinearForwardSpeedDamping (uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res) Return the offset factor for the linear forward speed damping matrix. bool SetOffsetNonLinearDamping (uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res) Set the offset factor for the nonlinear damping matrix. bool GetOffsetNonLinearDamping (uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res) Return the offset factor for the nonlinear damping matrix.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#protected-functions","text":"Name virtual void PublishRestoringForce (gazebo::physics::LinkPtr _link) Publish restoring force. virtual void PublishHydrodynamicWrenches (gazebo::physics::LinkPtr _link) Publish hydrodynamic wrenches. virtual void GenWrenchMsg (ignition::math::Vector3d _force, ignition::math::Vector3d _torque, geometry_msgs::WrenchStamped & _output) Returns the wrench message for debugging topics. virtual void InitDebug (gazebo::physics::LinkPtr _link, gazebo::HydrodynamicModelPtr _hydro) Sets the topics used for publishing the intermediate data during the simulation. virtual void PublishCurrentVelocityMarker () Publishes the current velocity marker. virtual void PublishIsSubmerged () Publishes the state of the vehicle (is submerged)","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#function-underwaterobjectrosplugin","text":"UnderwaterObjectROSPlugin() Constructor.","title":"function UnderwaterObjectROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#function-underwaterobjectrosplugin_1","text":"virtual ~UnderwaterObjectROSPlugin() Destructor.","title":"function ~UnderwaterObjectROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#function-load","text":"void Load( gazebo::physics::ModelPtr _parent, sdf::ElementPtr _sdf ) Load module and read parameters from SDF.","title":"function Load"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#function-init","text":"virtual void Init() Initialize Module.","title":"function Init"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#function-reset","text":"virtual void Reset() Reset Module.","title":"function Reset"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#function-update","text":"virtual void Update( const gazebo::common::UpdateInfo & _info ) Update the simulation state. Parameters : _info Information used in the update event.","title":"function Update"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#function-updatelocalcurrentvelocity","text":"void UpdateLocalCurrentVelocity( const geometry_msgs::Vector3::ConstPtr & _msg ) Update the local current velocity, this data will be used only if the useGlobalCurrent flag is set to false.","title":"function UpdateLocalCurrentVelocity"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#function-setuseglobalcurrentvel","text":"bool SetUseGlobalCurrentVel( uuv_gazebo_ros_plugins_msgs::SetUseGlobalCurrentVel::Request & _req, uuv_gazebo_ros_plugins_msgs::SetUseGlobalCurrentVel::Response & _res ) Set flag to use the global current velocity topic input.","title":"function SetUseGlobalCurrentVel"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#function-getmodelproperties","text":"bool GetModelProperties( uuv_gazebo_ros_plugins_msgs::GetModelProperties::Request & _req, uuv_gazebo_ros_plugins_msgs::GetModelProperties::Response & _res ) Return the model properties, along with parameters from the hydrodynamic and hydrostatic models.","title":"function GetModelProperties"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#function-setscalingaddedmass","text":"bool SetScalingAddedMass( uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res ) Set the scaling factor for the added-mass matrix.","title":"function SetScalingAddedMass"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#function-getscalingaddedmass","text":"bool GetScalingAddedMass( uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res ) Return current scaling factor for the added-mass matrix.","title":"function GetScalingAddedMass"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#function-setscalingdamping","text":"bool SetScalingDamping( uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res ) Set a scaling factor for the overall damping matrix.","title":"function SetScalingDamping"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#function-getscalingdamping","text":"bool GetScalingDamping( uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res ) Return the scaling factor for the overall damping matrix.","title":"function GetScalingDamping"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#function-setscalingvolume","text":"bool SetScalingVolume( uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res ) Set scaling factor for the model's volume used for buoyancy force computation.","title":"function SetScalingVolume"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#function-getscalingvolume","text":"bool GetScalingVolume( uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res ) Get scaling factor for the model's volume used for buoyancy force computation.","title":"function GetScalingVolume"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#function-setfluiddensity","text":"bool SetFluidDensity( uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res ) Set new fluid density (this will alter the value for the buoyancy force)","title":"function SetFluidDensity"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#function-getfluiddensity","text":"bool GetFluidDensity( uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res ) Get current value for the fluid density.","title":"function GetFluidDensity"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#function-setoffsetvolume","text":"bool SetOffsetVolume( uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res ) Set offset factor for the model's volume (this will alter the value for the buoyancy force)","title":"function SetOffsetVolume"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#function-getoffsetvolume","text":"bool GetOffsetVolume( uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res ) Return the offset factor for the model's volume.","title":"function GetOffsetVolume"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#function-setoffsetaddedmass","text":"bool SetOffsetAddedMass( uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res ) Set the offset factor for the added-mass matrix.","title":"function SetOffsetAddedMass"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#function-getoffsetaddedmass","text":"bool GetOffsetAddedMass( uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res ) Return the offset factor for the added-mass matrix.","title":"function GetOffsetAddedMass"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#function-setoffsetlineardamping","text":"bool SetOffsetLinearDamping( uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res ) Set the offset factor for the linear damping matrix.","title":"function SetOffsetLinearDamping"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#function-getoffsetlineardamping","text":"bool GetOffsetLinearDamping( uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res ) Return the offset factor for the linear damping matrix.","title":"function GetOffsetLinearDamping"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#function-setoffsetlinearforwardspeeddamping","text":"bool SetOffsetLinearForwardSpeedDamping( uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res ) Set the offset factor for the linear forward speed damping matrix.","title":"function SetOffsetLinearForwardSpeedDamping"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#function-getoffsetlinearforwardspeeddamping","text":"bool GetOffsetLinearForwardSpeedDamping( uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res ) Return the offset factor for the linear forward speed damping matrix.","title":"function GetOffsetLinearForwardSpeedDamping"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#function-setoffsetnonlineardamping","text":"bool SetOffsetNonLinearDamping( uuv_gazebo_ros_plugins_msgs::SetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::SetFloat::Response & _res ) Set the offset factor for the nonlinear damping matrix.","title":"function SetOffsetNonLinearDamping"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#function-getoffsetnonlineardamping","text":"bool GetOffsetNonLinearDamping( uuv_gazebo_ros_plugins_msgs::GetFloat::Request & _req, uuv_gazebo_ros_plugins_msgs::GetFloat::Response & _res ) Return the offset factor for the nonlinear damping matrix.","title":"function GetOffsetNonLinearDamping"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#function-publishrestoringforce","text":"virtual void PublishRestoringForce( gazebo::physics::LinkPtr _link ) Publish restoring force. Parameters : _link Pointer to the link where the force information will be extracted from","title":"function PublishRestoringForce"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#function-publishhydrodynamicwrenches","text":"virtual void PublishHydrodynamicWrenches( gazebo::physics::LinkPtr _link ) Publish hydrodynamic wrenches. Parameters : _link Pointer to the link where the force information will be extracted from","title":"function PublishHydrodynamicWrenches"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#function-genwrenchmsg","text":"virtual void GenWrenchMsg( ignition::math::Vector3d _force, ignition::math::Vector3d _torque, geometry_msgs::WrenchStamped & _output ) Returns the wrench message for debugging topics. Parameters : _force Force vector _torque Torque vector _output Stamped wrench message to be updated","title":"function GenWrenchMsg"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#function-initdebug","text":"virtual void InitDebug( gazebo::physics::LinkPtr _link, gazebo::HydrodynamicModelPtr _hydro ) Sets the topics used for publishing the intermediate data during the simulation. Parameters : _link Pointer to the link _hydro Pointer to the hydrodynamic model","title":"function InitDebug"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#function-publishcurrentvelocitymarker","text":"virtual void PublishCurrentVelocityMarker() Publishes the current velocity marker.","title":"function PublishCurrentVelocityMarker"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterObjectROSPlugin/#function-publishissubmerged","text":"virtual void PublishIsSubmerged() Publishes the state of the vehicle (is submerged) Updated on 2022-05-30 at 18:35:13 +0000","title":"function PublishIsSubmerged"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:13 +0000","title":"Examples"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:13 +0000","title":"Examples"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:13 +0000","title":"Modules"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:13 +0000","title":"Modules"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/","text":"Namespaces namespace gazebo namespace test_default_fossen_vehicle namespace test_sphere_vehicle namespace test_thrusters namespace uuv_gazebo_ros_plugins_msgs::srv namespace uuv_simulator_ros Updated on 2022-05-30 at 18:35:13 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/#namespaces","text":"namespace gazebo namespace test_default_fossen_vehicle namespace test_sphere_vehicle namespace test_thrusters namespace uuv_gazebo_ros_plugins_msgs::srv namespace uuv_simulator_ros Updated on 2022-05-30 at 18:35:13 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespacegazebo/","text":"gazebo More... Classes Name class gazebo::AccelerationsTestPlugin Gazebo model plugin class for underwater objects. class gazebo::CustomBatteryConsumerROSPlugin class gazebo::LinearBatteryROSPlugin class gazebo::ThrusterManagerROSPlugin Functions Name geometry_msgs::Accel accelFromEigen (const Eigen::Vector6d & acc) Eigen::Matrix3d Matrix3ToEigen (const ignition::math::Matrix3d & m) Detailed Description Authors: Andre Potes ( andre.potes@tecnico.ulisboa.pt ) Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Maintained by: Andre Potes ( andre.potes@tecnico.ulisboa.pt ) Last Update: 14/12/2021 License: MIT File: ThrusterManager.hpp Brief: Defines a thruster manager ROS plugin that translates the desired forces for the vehicle thrusters, from the DSOR stack to the UUV simulator Functions Documentation function accelFromEigen geometry_msgs::Accel accelFromEigen( const Eigen::Vector6d & acc ) function Matrix3ToEigen Eigen::Matrix3d Matrix3ToEigen( const ignition::math::Matrix3d & m ) Updated on 2022-05-30 at 18:35:13 +0000","title":"gazebo"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespacegazebo/#gazebo","text":"More...","title":"gazebo"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespacegazebo/#classes","text":"Name class gazebo::AccelerationsTestPlugin Gazebo model plugin class for underwater objects. class gazebo::CustomBatteryConsumerROSPlugin class gazebo::LinearBatteryROSPlugin class gazebo::ThrusterManagerROSPlugin","title":"Classes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespacegazebo/#functions","text":"Name geometry_msgs::Accel accelFromEigen (const Eigen::Vector6d & acc) Eigen::Matrix3d Matrix3ToEigen (const ignition::math::Matrix3d & m)","title":"Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespacegazebo/#detailed-description","text":"Authors: Andre Potes ( andre.potes@tecnico.ulisboa.pt ) Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Maintained by: Andre Potes ( andre.potes@tecnico.ulisboa.pt ) Last Update: 14/12/2021 License: MIT File: ThrusterManager.hpp Brief: Defines a thruster manager ROS plugin that translates the desired forces for the vehicle thrusters, from the DSOR stack to the UUV simulator","title":"Detailed Description"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespacegazebo/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespacegazebo/#function-accelfromeigen","text":"geometry_msgs::Accel accelFromEigen( const Eigen::Vector6d & acc )","title":"function accelFromEigen"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespacegazebo/#function-matrix3toeigen","text":"Eigen::Matrix3d Matrix3ToEigen( const ignition::math::Matrix3d & m ) Updated on 2022-05-30 at 18:35:13 +0000","title":"function Matrix3ToEigen"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespacetest__default__fossen__vehicle/","text":"test_default_fossen_vehicle Classes Name class test_default_fossen_vehicle::TestDefaultFossenVehicle Attributes Name string PKG string NAME Attributes Documentation variable PKG string PKG = 'uuv_gazebo_ros_plugins'; variable NAME string NAME = 'test_default_fossen_vehicle'; Updated on 2022-05-30 at 18:35:13 +0000","title":"test_default_fossen_vehicle"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespacetest__default__fossen__vehicle/#test_default_fossen_vehicle","text":"","title":"test_default_fossen_vehicle"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespacetest__default__fossen__vehicle/#classes","text":"Name class test_default_fossen_vehicle::TestDefaultFossenVehicle","title":"Classes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespacetest__default__fossen__vehicle/#attributes","text":"Name string PKG string NAME","title":"Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespacetest__default__fossen__vehicle/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespacetest__default__fossen__vehicle/#variable-pkg","text":"string PKG = 'uuv_gazebo_ros_plugins';","title":"variable PKG"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespacetest__default__fossen__vehicle/#variable-name","text":"string NAME = 'test_default_fossen_vehicle'; Updated on 2022-05-30 at 18:35:13 +0000","title":"variable NAME"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespacetest__sphere__vehicle/","text":"test_sphere_vehicle Classes Name class test_sphere_vehicle::TestSphereVehicle Attributes Name string PKG string NAME float RADIUS float CD Attributes Documentation variable PKG string PKG = 'uuv_gazebo_ros_plugins'; variable NAME string NAME = 'test_sphere_vehicle'; variable RADIUS float RADIUS = 0.1; variable CD float CD = 0.5; Updated on 2022-05-30 at 18:35:13 +0000","title":"test_sphere_vehicle"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespacetest__sphere__vehicle/#test_sphere_vehicle","text":"","title":"test_sphere_vehicle"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespacetest__sphere__vehicle/#classes","text":"Name class test_sphere_vehicle::TestSphereVehicle","title":"Classes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespacetest__sphere__vehicle/#attributes","text":"Name string PKG string NAME float RADIUS float CD","title":"Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespacetest__sphere__vehicle/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespacetest__sphere__vehicle/#variable-pkg","text":"string PKG = 'uuv_gazebo_ros_plugins';","title":"variable PKG"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespacetest__sphere__vehicle/#variable-name","text":"string NAME = 'test_sphere_vehicle';","title":"variable NAME"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespacetest__sphere__vehicle/#variable-radius","text":"float RADIUS = 0.1;","title":"variable RADIUS"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespacetest__sphere__vehicle/#variable-cd","text":"float CD = 0.5; Updated on 2022-05-30 at 18:35:13 +0000","title":"variable CD"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespacetest__thrusters/","text":"test_thrusters Classes Name class test_thrusters::TestThrusters Attributes Name string PKG string NAME Attributes Documentation variable PKG string PKG = 'uuv_gazebo_ros_plugins'; variable NAME string NAME = 'test_thrusters'; Updated on 2022-05-30 at 18:35:13 +0000","title":"test_thrusters"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespacetest__thrusters/#test_thrusters","text":"","title":"test_thrusters"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespacetest__thrusters/#classes","text":"Name class test_thrusters::TestThrusters","title":"Classes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespacetest__thrusters/#attributes","text":"Name string PKG string NAME","title":"Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespacetest__thrusters/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespacetest__thrusters/#variable-pkg","text":"string PKG = 'uuv_gazebo_ros_plugins';","title":"variable PKG"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespacetest__thrusters/#variable-name","text":"string NAME = 'test_thrusters'; Updated on 2022-05-30 at 18:35:13 +0000","title":"variable NAME"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespaceuuv__gazebo__ros__plugins__msgs_1_1srv/","text":"uuv_gazebo_ros_plugins_msgs::srv Updated on 2022-05-30 at 18:35:13 +0000","title":"uuv_gazebo_ros_plugins_msgs::srv"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespaceuuv__gazebo__ros__plugins__msgs_1_1srv/#uuv_gazebo_ros_plugins_msgssrv","text":"Updated on 2022-05-30 at 18:35:13 +0000","title":"uuv_gazebo_ros_plugins_msgs::srv"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespaceuuv__simulator__ros/","text":"uuv_simulator_ros Classes Name class uuv_simulator_ros::FinROSPlugin class uuv_simulator_ros::JointStatePublisher class uuv_simulator_ros::ThrusterROSPlugin class uuv_simulator_ros::UnderwaterObjectROSPlugin Updated on 2022-05-30 at 18:35:13 +0000","title":"uuv_simulator_ros"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespaceuuv__simulator__ros/#uuv_simulator_ros","text":"","title":"uuv_simulator_ros"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_gazebo_plugins/uuv_gazebo_ros_plugins/Namespaces/namespaceuuv__simulator__ros/#classes","text":"Name class uuv_simulator_ros::FinROSPlugin class uuv_simulator_ros::JointStatePublisher class uuv_simulator_ros::ThrusterROSPlugin class uuv_simulator_ros::UnderwaterObjectROSPlugin Updated on 2022-05-30 at 18:35:13 +0000","title":"Classes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/","text":"Classes class FirstOrderFilter namespace cv namespace gazebo class AltimeterROSPlugin class CPCROSPlugin class DVLROSPlugin class GPSROSPlugin class GazeboRosImageSonar class GstCameraPlugin struct IMUParameters IMUParameters stores all IMU model parameters. A description of these parameters can be found here: https://github.com/ethz-asl/kalibr/wiki/IMU-Noise-Model-and-Intrinsics . class IMUROSPlugin struct MagnetometerParameters class MagnetometerROSPlugin class PoseGTROSPlugin class ROSBaseModelPlugin class ROSBasePlugin class ROSBaseSensorPlugin class RPTROSPlugin class SubseaPressureROSPlugin class UnderwaterCameraROSPlugin class modemPlugin class usblPlugin namespace std namespace test_urdf_files class TestURDFFiles Updated on 2022-05-30 at 18:35:14 +0000","title":"Classes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/#classes","text":"class FirstOrderFilter namespace cv namespace gazebo class AltimeterROSPlugin class CPCROSPlugin class DVLROSPlugin class GPSROSPlugin class GazeboRosImageSonar class GstCameraPlugin struct IMUParameters IMUParameters stores all IMU model parameters. A description of these parameters can be found here: https://github.com/ethz-asl/kalibr/wiki/IMU-Noise-Model-and-Intrinsics . class IMUROSPlugin struct MagnetometerParameters class MagnetometerROSPlugin class PoseGTROSPlugin class ROSBaseModelPlugin class ROSBasePlugin class ROSBaseSensorPlugin class RPTROSPlugin class SubseaPressureROSPlugin class UnderwaterCameraROSPlugin class modemPlugin class usblPlugin namespace std namespace test_urdf_files class TestURDFFiles Updated on 2022-05-30 at 18:35:14 +0000","title":"Classes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classFirstOrderFilter/","text":"FirstOrderFilter More... Public Functions Name FirstOrderFilter (double timeConstantUp, double timeConstantDown, T initialState) T updateFilter (T inputState, double samplingTime) ~FirstOrderFilter () Protected Attributes Name double timeConstantUp_ double timeConstantDown_ T previousState_ Detailed Description template <typename T > class FirstOrderFilter; Public Functions Documentation function FirstOrderFilter inline FirstOrderFilter( double timeConstantUp, double timeConstantDown, T initialState ) function updateFilter inline T updateFilter( T inputState, double samplingTime ) function ~FirstOrderFilter inline ~FirstOrderFilter() Protected Attributes Documentation variable timeConstantUp_ double timeConstantUp_; variable timeConstantDown_ double timeConstantDown_; variable previousState_ T previousState_; Updated on 2022-05-30 at 18:35:14 +0000","title":"FirstOrderFilter"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classFirstOrderFilter/#firstorderfilter","text":"More...","title":"FirstOrderFilter"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classFirstOrderFilter/#public-functions","text":"Name FirstOrderFilter (double timeConstantUp, double timeConstantDown, T initialState) T updateFilter (T inputState, double samplingTime) ~FirstOrderFilter ()","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classFirstOrderFilter/#protected-attributes","text":"Name double timeConstantUp_ double timeConstantDown_ T previousState_","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classFirstOrderFilter/#detailed-description","text":"template <typename T > class FirstOrderFilter;","title":"Detailed Description"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classFirstOrderFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classFirstOrderFilter/#function-firstorderfilter","text":"inline FirstOrderFilter( double timeConstantUp, double timeConstantDown, T initialState )","title":"function FirstOrderFilter"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classFirstOrderFilter/#function-updatefilter","text":"inline T updateFilter( T inputState, double samplingTime )","title":"function updateFilter"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classFirstOrderFilter/#function-firstorderfilter_1","text":"inline ~FirstOrderFilter()","title":"function ~FirstOrderFilter"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classFirstOrderFilter/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classFirstOrderFilter/#variable-timeconstantup_","text":"double timeConstantUp_;","title":"variable timeConstantUp_"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classFirstOrderFilter/#variable-timeconstantdown_","text":"double timeConstantDown_;","title":"variable timeConstantDown_"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classFirstOrderFilter/#variable-previousstate_","text":"T previousState_; Updated on 2022-05-30 at 18:35:14 +0000","title":"variable previousState_"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1AltimeterROSPlugin/","text":"gazebo::AltimeterROSPlugin Inherits from RayPlugin Public Functions Name AltimeterROSPlugin () Constructor. ~AltimeterROSPlugin () Destructor. void Load (sensors::SensorPtr _parent, sdf::ElementPtr _sdf) Load the plugin. Protected Functions Name virtual void OnNewLaserScans () Update the controller. Protected Attributes Name ros::Publisher medusaStackAltimeterPub Additional Measurement ROS topic specific for altimeter msgs into medusa stack. Public Functions Documentation function AltimeterROSPlugin AltimeterROSPlugin() Constructor. function ~AltimeterROSPlugin ~AltimeterROSPlugin() Destructor. function Load void Load( sensors::SensorPtr _parent, sdf::ElementPtr _sdf ) Load the plugin. Parameters : take in SDF root element Protected Functions Documentation function OnNewLaserScans virtual void OnNewLaserScans() Update the controller. Protected Attributes Documentation variable medusaStackAltimeterPub ros::Publisher medusaStackAltimeterPub; Additional Measurement ROS topic specific for altimeter msgs into medusa stack. Updated on 2022-05-30 at 18:35:14 +0000","title":"gazebo::AltimeterROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1AltimeterROSPlugin/#gazeboaltimeterrosplugin","text":"Inherits from RayPlugin","title":"gazebo::AltimeterROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1AltimeterROSPlugin/#public-functions","text":"Name AltimeterROSPlugin () Constructor. ~AltimeterROSPlugin () Destructor. void Load (sensors::SensorPtr _parent, sdf::ElementPtr _sdf) Load the plugin.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1AltimeterROSPlugin/#protected-functions","text":"Name virtual void OnNewLaserScans () Update the controller.","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1AltimeterROSPlugin/#protected-attributes","text":"Name ros::Publisher medusaStackAltimeterPub Additional Measurement ROS topic specific for altimeter msgs into medusa stack.","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1AltimeterROSPlugin/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1AltimeterROSPlugin/#function-altimeterrosplugin","text":"AltimeterROSPlugin() Constructor.","title":"function AltimeterROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1AltimeterROSPlugin/#function-altimeterrosplugin_1","text":"~AltimeterROSPlugin() Destructor.","title":"function ~AltimeterROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1AltimeterROSPlugin/#function-load","text":"void Load( sensors::SensorPtr _parent, sdf::ElementPtr _sdf ) Load the plugin. Parameters : take in SDF root element","title":"function Load"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1AltimeterROSPlugin/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1AltimeterROSPlugin/#function-onnewlaserscans","text":"virtual void OnNewLaserScans() Update the controller.","title":"function OnNewLaserScans"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1AltimeterROSPlugin/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1AltimeterROSPlugin/#variable-medusastackaltimeterpub","text":"ros::Publisher medusaStackAltimeterPub; Additional Measurement ROS topic specific for altimeter msgs into medusa stack. Updated on 2022-05-30 at 18:35:14 +0000","title":"variable medusaStackAltimeterPub"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1CPCROSPlugin/","text":"gazebo::CPCROSPlugin Inherits from gazebo::ROSBaseModelPlugin , gazebo::ROSBasePlugin , ModelPlugin Public Functions Name CPCROSPlugin () Class constructor. virtual ~CPCROSPlugin () Class destructor. virtual void Load (physics::ModelPtr _model, sdf::ElementPtr _sdf) Load the plugin. Protected Functions Name virtual bool OnUpdate (const common::UpdateInfo & _info) Update sensor measurement. virtual void OnPlumeParticlesUpdate (const sensor_msgs::PointCloud::ConstPtr & _msg) Update callback from simulator. Protected Attributes Name ros::Subscriber particlesSub Input topic for the plume particle point cloud. ros::Publisher salinityPub Output topic for salinity measurements based on the particle concentration. bool updatingCloud Flag to ensure the cloud and measurement update don't coincide. double gamma Gamma velocity parameter for the smoothing function. double gain Sensor gain. double smoothingLength ros::Time lastUpdateTimestamp Last update from the point cloud callback. uuv_sensor_ros_plugins_msgs::ChemicalParticleConcentration outputMsg Output measurement topic. uuv_sensor_ros_plugins_msgs::Salinity salinityMsg Output salinity measurement message. double waterSalinityValue double plumeSalinityValue Additional inherited members Public Functions inherited from gazebo::ROSBaseModelPlugin Name ROSBaseModelPlugin () Class constructor. virtual ~ROSBaseModelPlugin () Class destructor. Protected Functions inherited from gazebo::ROSBaseModelPlugin Name void SendLocalNEDTransform () Returns true if the base_link_ned frame exists. Protected Attributes inherited from gazebo::ROSBaseModelPlugin Name physics::ModelPtr model Pointer to the model. physics::LinkPtr link Pointer to the link. bool enableLocalNEDFrame True if a the local NED frame needs to be broadcasted. tf::TransformBroadcaster * tfBroadcaster TF broadcaster for the local NED frame. ignition::math::Pose3d localNEDFrame Pose of the local NED frame wrt link frame. tf::StampedTransform tfLocalNEDFrame Local NED TF frame. Public Functions inherited from gazebo::ROSBasePlugin Name ROSBasePlugin () Class constructor. virtual ~ROSBasePlugin () Class destructor. bool InitBasePlugin (sdf::ElementPtr _sdf) Initialize base plugin. bool AddNoiseModel (std::string _name, double _sigma) Add noise normal distribution to the list. Protected Functions inherited from gazebo::ROSBasePlugin Name bool IsOn () Returns true if the plugin is activated. void PublishState () Publish the current state of the plugin. bool ChangeSensorState (uuv_sensor_ros_plugins_msgs::ChangeSensorState::Request & _req, uuv_sensor_ros_plugins_msgs::ChangeSensorState::Response & _res) Change sensor state (ON/OFF) void GetTFMessage (const tf::tfMessage::ConstPtr & _msg) Callback function for the static TF message. double GetGaussianNoise (double _amp) Returns noise value for a function with zero mean from the default Gaussian noise model. double GetGaussianNoise (std::string _name, double _amp) Returns noise value for a function with zero mean from a Gaussian noise model according to the model name. bool EnableMeasurement (const common::UpdateInfo & _info) const Enables generation of simulated measurement if the timeout since the last update has been reached. void UpdateReferenceFramePose () Updates the pose of the reference frame wrt the world frame. Protected Attributes inherited from gazebo::ROSBasePlugin Name std::string robotNamespace Robot namespace. std::string sensorOutputTopic Name of the sensor's output topic. physics::WorldPtr world Pointer to the world. event::ConnectionPtr updateConnection Pointer to the update event connection. common::Time lastMeasurementTime (Simulation) time when the last sensor measurement was generated. double updateRate Sensor update rate. double noiseSigma Noise standard deviation. double noiseAmp Noise amplitude. bool gazeboMsgEnabled Flag set to true if the Gazebo sensors messages are supposed to be published as well (it can avoid unnecessary overhead in case) the sensor messages needed are only ROS messages. std::default_random_engine rndGen Pseudo random number generator. std::map< std::string, std::normal_distribution< double > > noiseModels Normal distribution describing the noise models. std_msgs::Bool isOn Flag to control the generation of output messages. boost::shared_ptr< ros::NodeHandle > rosNode ROS node handle for communication with ROS. transport::NodePtr gazeboNode Gazebo's node handle for transporting measurement messages. ros::Publisher rosSensorOutputPub Gazebo's publisher for transporting measurement messages. transport::PublisherPtr gazeboSensorOutputPub Gazebo's publisher for transporting measurement messages. ros::ServiceServer changeSensorSrv Service server object. ros::Publisher pluginStatePub ROS publisher for the switchable sensor data. ignition::math::Pose3d referenceFrame Pose of the reference frame wrt world frame. ros::Subscriber tfStaticSub ROS subscriber for the TF static reference frame. std::string referenceFrameID Frame ID of the reference frame. bool isReferenceInit Flag set to true if reference frame initialized. physics::LinkPtr referenceLink Reference link. Public Functions Documentation function CPCROSPlugin CPCROSPlugin() Class constructor. function ~CPCROSPlugin virtual ~CPCROSPlugin() Class destructor. function Load virtual void Load( physics::ModelPtr _model, sdf::ElementPtr _sdf ) Load the plugin. Reimplements : gazebo::ROSBaseModelPlugin::Load Protected Functions Documentation function OnUpdate virtual bool OnUpdate( const common::UpdateInfo & _info ) Update sensor measurement. Reimplements : gazebo::ROSBaseModelPlugin::OnUpdate function OnPlumeParticlesUpdate virtual void OnPlumeParticlesUpdate( const sensor_msgs::PointCloud::ConstPtr & _msg ) Update callback from simulator. Protected Attributes Documentation variable particlesSub ros::Subscriber particlesSub; Input topic for the plume particle point cloud. variable salinityPub ros::Publisher salinityPub; Output topic for salinity measurements based on the particle concentration. variable updatingCloud bool updatingCloud; Flag to ensure the cloud and measurement update don't coincide. variable gamma double gamma; Gamma velocity parameter for the smoothing function. variable gain double gain; Sensor gain. variable smoothingLength double smoothingLength; variable lastUpdateTimestamp ros::Time lastUpdateTimestamp; Last update from the point cloud callback. variable outputMsg uuv_sensor_ros_plugins_msgs::ChemicalParticleConcentration outputMsg; Output measurement topic. variable salinityMsg uuv_sensor_ros_plugins_msgs::Salinity salinityMsg; Output salinity measurement message. variable waterSalinityValue double waterSalinityValue; variable plumeSalinityValue double plumeSalinityValue; Updated on 2022-05-30 at 18:35:14 +0000","title":"gazebo::CPCROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1CPCROSPlugin/#gazebocpcrosplugin","text":"Inherits from gazebo::ROSBaseModelPlugin , gazebo::ROSBasePlugin , ModelPlugin","title":"gazebo::CPCROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1CPCROSPlugin/#public-functions","text":"Name CPCROSPlugin () Class constructor. virtual ~CPCROSPlugin () Class destructor. virtual void Load (physics::ModelPtr _model, sdf::ElementPtr _sdf) Load the plugin.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1CPCROSPlugin/#protected-functions","text":"Name virtual bool OnUpdate (const common::UpdateInfo & _info) Update sensor measurement. virtual void OnPlumeParticlesUpdate (const sensor_msgs::PointCloud::ConstPtr & _msg) Update callback from simulator.","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1CPCROSPlugin/#protected-attributes","text":"Name ros::Subscriber particlesSub Input topic for the plume particle point cloud. ros::Publisher salinityPub Output topic for salinity measurements based on the particle concentration. bool updatingCloud Flag to ensure the cloud and measurement update don't coincide. double gamma Gamma velocity parameter for the smoothing function. double gain Sensor gain. double smoothingLength ros::Time lastUpdateTimestamp Last update from the point cloud callback. uuv_sensor_ros_plugins_msgs::ChemicalParticleConcentration outputMsg Output measurement topic. uuv_sensor_ros_plugins_msgs::Salinity salinityMsg Output salinity measurement message. double waterSalinityValue double plumeSalinityValue","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1CPCROSPlugin/#additional-inherited-members","text":"Public Functions inherited from gazebo::ROSBaseModelPlugin Name ROSBaseModelPlugin () Class constructor. virtual ~ROSBaseModelPlugin () Class destructor. Protected Functions inherited from gazebo::ROSBaseModelPlugin Name void SendLocalNEDTransform () Returns true if the base_link_ned frame exists. Protected Attributes inherited from gazebo::ROSBaseModelPlugin Name physics::ModelPtr model Pointer to the model. physics::LinkPtr link Pointer to the link. bool enableLocalNEDFrame True if a the local NED frame needs to be broadcasted. tf::TransformBroadcaster * tfBroadcaster TF broadcaster for the local NED frame. ignition::math::Pose3d localNEDFrame Pose of the local NED frame wrt link frame. tf::StampedTransform tfLocalNEDFrame Local NED TF frame. Public Functions inherited from gazebo::ROSBasePlugin Name ROSBasePlugin () Class constructor. virtual ~ROSBasePlugin () Class destructor. bool InitBasePlugin (sdf::ElementPtr _sdf) Initialize base plugin. bool AddNoiseModel (std::string _name, double _sigma) Add noise normal distribution to the list. Protected Functions inherited from gazebo::ROSBasePlugin Name bool IsOn () Returns true if the plugin is activated. void PublishState () Publish the current state of the plugin. bool ChangeSensorState (uuv_sensor_ros_plugins_msgs::ChangeSensorState::Request & _req, uuv_sensor_ros_plugins_msgs::ChangeSensorState::Response & _res) Change sensor state (ON/OFF) void GetTFMessage (const tf::tfMessage::ConstPtr & _msg) Callback function for the static TF message. double GetGaussianNoise (double _amp) Returns noise value for a function with zero mean from the default Gaussian noise model. double GetGaussianNoise (std::string _name, double _amp) Returns noise value for a function with zero mean from a Gaussian noise model according to the model name. bool EnableMeasurement (const common::UpdateInfo & _info) const Enables generation of simulated measurement if the timeout since the last update has been reached. void UpdateReferenceFramePose () Updates the pose of the reference frame wrt the world frame. Protected Attributes inherited from gazebo::ROSBasePlugin Name std::string robotNamespace Robot namespace. std::string sensorOutputTopic Name of the sensor's output topic. physics::WorldPtr world Pointer to the world. event::ConnectionPtr updateConnection Pointer to the update event connection. common::Time lastMeasurementTime (Simulation) time when the last sensor measurement was generated. double updateRate Sensor update rate. double noiseSigma Noise standard deviation. double noiseAmp Noise amplitude. bool gazeboMsgEnabled Flag set to true if the Gazebo sensors messages are supposed to be published as well (it can avoid unnecessary overhead in case) the sensor messages needed are only ROS messages. std::default_random_engine rndGen Pseudo random number generator. std::map< std::string, std::normal_distribution< double > > noiseModels Normal distribution describing the noise models. std_msgs::Bool isOn Flag to control the generation of output messages. boost::shared_ptr< ros::NodeHandle > rosNode ROS node handle for communication with ROS. transport::NodePtr gazeboNode Gazebo's node handle for transporting measurement messages. ros::Publisher rosSensorOutputPub Gazebo's publisher for transporting measurement messages. transport::PublisherPtr gazeboSensorOutputPub Gazebo's publisher for transporting measurement messages. ros::ServiceServer changeSensorSrv Service server object. ros::Publisher pluginStatePub ROS publisher for the switchable sensor data. ignition::math::Pose3d referenceFrame Pose of the reference frame wrt world frame. ros::Subscriber tfStaticSub ROS subscriber for the TF static reference frame. std::string referenceFrameID Frame ID of the reference frame. bool isReferenceInit Flag set to true if reference frame initialized. physics::LinkPtr referenceLink Reference link.","title":"Additional inherited members"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1CPCROSPlugin/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1CPCROSPlugin/#function-cpcrosplugin","text":"CPCROSPlugin() Class constructor.","title":"function CPCROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1CPCROSPlugin/#function-cpcrosplugin_1","text":"virtual ~CPCROSPlugin() Class destructor.","title":"function ~CPCROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1CPCROSPlugin/#function-load","text":"virtual void Load( physics::ModelPtr _model, sdf::ElementPtr _sdf ) Load the plugin. Reimplements : gazebo::ROSBaseModelPlugin::Load","title":"function Load"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1CPCROSPlugin/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1CPCROSPlugin/#function-onupdate","text":"virtual bool OnUpdate( const common::UpdateInfo & _info ) Update sensor measurement. Reimplements : gazebo::ROSBaseModelPlugin::OnUpdate","title":"function OnUpdate"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1CPCROSPlugin/#function-onplumeparticlesupdate","text":"virtual void OnPlumeParticlesUpdate( const sensor_msgs::PointCloud::ConstPtr & _msg ) Update callback from simulator.","title":"function OnPlumeParticlesUpdate"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1CPCROSPlugin/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1CPCROSPlugin/#variable-particlessub","text":"ros::Subscriber particlesSub; Input topic for the plume particle point cloud.","title":"variable particlesSub"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1CPCROSPlugin/#variable-salinitypub","text":"ros::Publisher salinityPub; Output topic for salinity measurements based on the particle concentration.","title":"variable salinityPub"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1CPCROSPlugin/#variable-updatingcloud","text":"bool updatingCloud; Flag to ensure the cloud and measurement update don't coincide.","title":"variable updatingCloud"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1CPCROSPlugin/#variable-gamma","text":"double gamma; Gamma velocity parameter for the smoothing function.","title":"variable gamma"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1CPCROSPlugin/#variable-gain","text":"double gain; Sensor gain.","title":"variable gain"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1CPCROSPlugin/#variable-smoothinglength","text":"double smoothingLength;","title":"variable smoothingLength"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1CPCROSPlugin/#variable-lastupdatetimestamp","text":"ros::Time lastUpdateTimestamp; Last update from the point cloud callback.","title":"variable lastUpdateTimestamp"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1CPCROSPlugin/#variable-outputmsg","text":"uuv_sensor_ros_plugins_msgs::ChemicalParticleConcentration outputMsg; Output measurement topic.","title":"variable outputMsg"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1CPCROSPlugin/#variable-salinitymsg","text":"uuv_sensor_ros_plugins_msgs::Salinity salinityMsg; Output salinity measurement message.","title":"variable salinityMsg"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1CPCROSPlugin/#variable-watersalinityvalue","text":"double waterSalinityValue;","title":"variable waterSalinityValue"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1CPCROSPlugin/#variable-plumesalinityvalue","text":"double plumeSalinityValue; Updated on 2022-05-30 at 18:35:14 +0000","title":"variable plumeSalinityValue"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1DVLROSPlugin/","text":"gazebo::DVLROSPlugin Inherits from gazebo::ROSBaseModelPlugin , gazebo::ROSBasePlugin , ModelPlugin Public Functions Name DVLROSPlugin () Class constructor. virtual ~DVLROSPlugin () Class destructor. virtual void Load (physics::ModelPtr _model, sdf::ElementPtr _sdf) Load the plugin. Protected Functions Name virtual bool OnUpdate (const common::UpdateInfo & _info) Update sensor measurement. void OnBeamCallback (const sensor_msgs::RangeConstPtr & _range0, const sensor_msgs::RangeConstPtr & _range1, const sensor_msgs::RangeConstPtr & _range2, const sensor_msgs::RangeConstPtr & _range3) Get beam Range message update. bool UpdateBeamTransforms () Updates the poses of each beam wrt the DVL frame. Protected Attributes Name bool beamTransformsInitialized double altitude Measured altitude in meters. uuv_sensor_ros_plugins_msgs::DVL dvlROSMsg ROS DVL message. std::vector< uuv_sensor_ros_plugins_msgs::DVLBeam > dvlBeamMsgs dsor_msgs::Measurement dvlMeasurementMsg DVL Measurement message (used by the medusa stack) ros::Publisher medusaStackDVLPub Additional Measurement ROS topic specific for DVL msgs into medusa stack. ros::Publisher twistPub ROS publisher for twist data. geometry_msgs::TwistWithCovarianceStamped twistROSMsg Store pose message since many attributes do not change (cov.). std::vector< std::string > beamsLinkNames List of beam links. std::vector< std::string > beamTopics List of beam topics. std::vector< ignition::math::Pose3d > beamPoses List of poses of each beam wrt to the DVL frame. boost::shared_ptr< message_filters::TimeSynchronizer< sensor_msgs::Range, sensor_msgs::Range, sensor_msgs::Range, sensor_msgs::Range > > syncBeamMessages boost::shared_ptr< message_filters::Subscriber< sensor_msgs::Range > > beamSub0 boost::shared_ptr< message_filters::Subscriber< sensor_msgs::Range > > beamSub1 boost::shared_ptr< message_filters::Subscriber< sensor_msgs::Range > > beamSub2 boost::shared_ptr< message_filters::Subscriber< sensor_msgs::Range > > beamSub3 tf::TransformListener transformListener Additional inherited members Public Functions inherited from gazebo::ROSBaseModelPlugin Name ROSBaseModelPlugin () Class constructor. virtual ~ROSBaseModelPlugin () Class destructor. Protected Functions inherited from gazebo::ROSBaseModelPlugin Name void SendLocalNEDTransform () Returns true if the base_link_ned frame exists. Protected Attributes inherited from gazebo::ROSBaseModelPlugin Name physics::ModelPtr model Pointer to the model. physics::LinkPtr link Pointer to the link. bool enableLocalNEDFrame True if a the local NED frame needs to be broadcasted. tf::TransformBroadcaster * tfBroadcaster TF broadcaster for the local NED frame. ignition::math::Pose3d localNEDFrame Pose of the local NED frame wrt link frame. tf::StampedTransform tfLocalNEDFrame Local NED TF frame. Public Functions inherited from gazebo::ROSBasePlugin Name ROSBasePlugin () Class constructor. virtual ~ROSBasePlugin () Class destructor. bool InitBasePlugin (sdf::ElementPtr _sdf) Initialize base plugin. bool AddNoiseModel (std::string _name, double _sigma) Add noise normal distribution to the list. Protected Functions inherited from gazebo::ROSBasePlugin Name bool IsOn () Returns true if the plugin is activated. void PublishState () Publish the current state of the plugin. bool ChangeSensorState (uuv_sensor_ros_plugins_msgs::ChangeSensorState::Request & _req, uuv_sensor_ros_plugins_msgs::ChangeSensorState::Response & _res) Change sensor state (ON/OFF) void GetTFMessage (const tf::tfMessage::ConstPtr & _msg) Callback function for the static TF message. double GetGaussianNoise (double _amp) Returns noise value for a function with zero mean from the default Gaussian noise model. double GetGaussianNoise (std::string _name, double _amp) Returns noise value for a function with zero mean from a Gaussian noise model according to the model name. bool EnableMeasurement (const common::UpdateInfo & _info) const Enables generation of simulated measurement if the timeout since the last update has been reached. void UpdateReferenceFramePose () Updates the pose of the reference frame wrt the world frame. Protected Attributes inherited from gazebo::ROSBasePlugin Name std::string robotNamespace Robot namespace. std::string sensorOutputTopic Name of the sensor's output topic. physics::WorldPtr world Pointer to the world. event::ConnectionPtr updateConnection Pointer to the update event connection. common::Time lastMeasurementTime (Simulation) time when the last sensor measurement was generated. double updateRate Sensor update rate. double noiseSigma Noise standard deviation. double noiseAmp Noise amplitude. bool gazeboMsgEnabled Flag set to true if the Gazebo sensors messages are supposed to be published as well (it can avoid unnecessary overhead in case) the sensor messages needed are only ROS messages. std::default_random_engine rndGen Pseudo random number generator. std::map< std::string, std::normal_distribution< double > > noiseModels Normal distribution describing the noise models. std_msgs::Bool isOn Flag to control the generation of output messages. boost::shared_ptr< ros::NodeHandle > rosNode ROS node handle for communication with ROS. transport::NodePtr gazeboNode Gazebo's node handle for transporting measurement messages. ros::Publisher rosSensorOutputPub Gazebo's publisher for transporting measurement messages. transport::PublisherPtr gazeboSensorOutputPub Gazebo's publisher for transporting measurement messages. ros::ServiceServer changeSensorSrv Service server object. ros::Publisher pluginStatePub ROS publisher for the switchable sensor data. ignition::math::Pose3d referenceFrame Pose of the reference frame wrt world frame. ros::Subscriber tfStaticSub ROS subscriber for the TF static reference frame. std::string referenceFrameID Frame ID of the reference frame. bool isReferenceInit Flag set to true if reference frame initialized. physics::LinkPtr referenceLink Reference link. Public Functions Documentation function DVLROSPlugin DVLROSPlugin() Class constructor. function ~DVLROSPlugin virtual ~DVLROSPlugin() Class destructor. function Load virtual void Load( physics::ModelPtr _model, sdf::ElementPtr _sdf ) Load the plugin. Reimplements : gazebo::ROSBaseModelPlugin::Load Protected Functions Documentation function OnUpdate virtual bool OnUpdate( const common::UpdateInfo & _info ) Update sensor measurement. Reimplements : gazebo::ROSBaseModelPlugin::OnUpdate function OnBeamCallback void OnBeamCallback( const sensor_msgs::RangeConstPtr & _range0, const sensor_msgs::RangeConstPtr & _range1, const sensor_msgs::RangeConstPtr & _range2, const sensor_msgs::RangeConstPtr & _range3 ) Get beam Range message update. function UpdateBeamTransforms bool UpdateBeamTransforms() Updates the poses of each beam wrt the DVL frame. Protected Attributes Documentation variable beamTransformsInitialized bool beamTransformsInitialized; variable altitude double altitude; Measured altitude in meters. variable dvlROSMsg uuv_sensor_ros_plugins_msgs::DVL dvlROSMsg; ROS DVL message. variable dvlBeamMsgs std::vector< uuv_sensor_ros_plugins_msgs::DVLBeam > dvlBeamMsgs; variable dvlMeasurementMsg dsor_msgs::Measurement dvlMeasurementMsg; DVL Measurement message (used by the medusa stack) variable medusaStackDVLPub ros::Publisher medusaStackDVLPub; Additional Measurement ROS topic specific for DVL msgs into medusa stack. variable twistPub ros::Publisher twistPub; ROS publisher for twist data. variable twistROSMsg geometry_msgs::TwistWithCovarianceStamped twistROSMsg; Store pose message since many attributes do not change (cov.). variable beamsLinkNames std::vector< std::string > beamsLinkNames; List of beam links. variable beamTopics std::vector< std::string > beamTopics; List of beam topics. variable beamPoses std::vector< ignition::math::Pose3d > beamPoses; List of poses of each beam wrt to the DVL frame. variable syncBeamMessages boost::shared_ptr< message_filters::TimeSynchronizer< sensor_msgs::Range, sensor_msgs::Range, sensor_msgs::Range, sensor_msgs::Range > > syncBeamMessages; variable beamSub0 boost::shared_ptr< message_filters::Subscriber< sensor_msgs::Range > > beamSub0; variable beamSub1 boost::shared_ptr< message_filters::Subscriber< sensor_msgs::Range > > beamSub1; variable beamSub2 boost::shared_ptr< message_filters::Subscriber< sensor_msgs::Range > > beamSub2; variable beamSub3 boost::shared_ptr< message_filters::Subscriber< sensor_msgs::Range > > beamSub3; variable transformListener tf::TransformListener transformListener; Updated on 2022-05-30 at 18:35:14 +0000","title":"gazebo::DVLROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1DVLROSPlugin/#gazebodvlrosplugin","text":"Inherits from gazebo::ROSBaseModelPlugin , gazebo::ROSBasePlugin , ModelPlugin","title":"gazebo::DVLROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1DVLROSPlugin/#public-functions","text":"Name DVLROSPlugin () Class constructor. virtual ~DVLROSPlugin () Class destructor. virtual void Load (physics::ModelPtr _model, sdf::ElementPtr _sdf) Load the plugin.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1DVLROSPlugin/#protected-functions","text":"Name virtual bool OnUpdate (const common::UpdateInfo & _info) Update sensor measurement. void OnBeamCallback (const sensor_msgs::RangeConstPtr & _range0, const sensor_msgs::RangeConstPtr & _range1, const sensor_msgs::RangeConstPtr & _range2, const sensor_msgs::RangeConstPtr & _range3) Get beam Range message update. bool UpdateBeamTransforms () Updates the poses of each beam wrt the DVL frame.","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1DVLROSPlugin/#protected-attributes","text":"Name bool beamTransformsInitialized double altitude Measured altitude in meters. uuv_sensor_ros_plugins_msgs::DVL dvlROSMsg ROS DVL message. std::vector< uuv_sensor_ros_plugins_msgs::DVLBeam > dvlBeamMsgs dsor_msgs::Measurement dvlMeasurementMsg DVL Measurement message (used by the medusa stack) ros::Publisher medusaStackDVLPub Additional Measurement ROS topic specific for DVL msgs into medusa stack. ros::Publisher twistPub ROS publisher for twist data. geometry_msgs::TwistWithCovarianceStamped twistROSMsg Store pose message since many attributes do not change (cov.). std::vector< std::string > beamsLinkNames List of beam links. std::vector< std::string > beamTopics List of beam topics. std::vector< ignition::math::Pose3d > beamPoses List of poses of each beam wrt to the DVL frame. boost::shared_ptr< message_filters::TimeSynchronizer< sensor_msgs::Range, sensor_msgs::Range, sensor_msgs::Range, sensor_msgs::Range > > syncBeamMessages boost::shared_ptr< message_filters::Subscriber< sensor_msgs::Range > > beamSub0 boost::shared_ptr< message_filters::Subscriber< sensor_msgs::Range > > beamSub1 boost::shared_ptr< message_filters::Subscriber< sensor_msgs::Range > > beamSub2 boost::shared_ptr< message_filters::Subscriber< sensor_msgs::Range > > beamSub3 tf::TransformListener transformListener","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1DVLROSPlugin/#additional-inherited-members","text":"Public Functions inherited from gazebo::ROSBaseModelPlugin Name ROSBaseModelPlugin () Class constructor. virtual ~ROSBaseModelPlugin () Class destructor. Protected Functions inherited from gazebo::ROSBaseModelPlugin Name void SendLocalNEDTransform () Returns true if the base_link_ned frame exists. Protected Attributes inherited from gazebo::ROSBaseModelPlugin Name physics::ModelPtr model Pointer to the model. physics::LinkPtr link Pointer to the link. bool enableLocalNEDFrame True if a the local NED frame needs to be broadcasted. tf::TransformBroadcaster * tfBroadcaster TF broadcaster for the local NED frame. ignition::math::Pose3d localNEDFrame Pose of the local NED frame wrt link frame. tf::StampedTransform tfLocalNEDFrame Local NED TF frame. Public Functions inherited from gazebo::ROSBasePlugin Name ROSBasePlugin () Class constructor. virtual ~ROSBasePlugin () Class destructor. bool InitBasePlugin (sdf::ElementPtr _sdf) Initialize base plugin. bool AddNoiseModel (std::string _name, double _sigma) Add noise normal distribution to the list. Protected Functions inherited from gazebo::ROSBasePlugin Name bool IsOn () Returns true if the plugin is activated. void PublishState () Publish the current state of the plugin. bool ChangeSensorState (uuv_sensor_ros_plugins_msgs::ChangeSensorState::Request & _req, uuv_sensor_ros_plugins_msgs::ChangeSensorState::Response & _res) Change sensor state (ON/OFF) void GetTFMessage (const tf::tfMessage::ConstPtr & _msg) Callback function for the static TF message. double GetGaussianNoise (double _amp) Returns noise value for a function with zero mean from the default Gaussian noise model. double GetGaussianNoise (std::string _name, double _amp) Returns noise value for a function with zero mean from a Gaussian noise model according to the model name. bool EnableMeasurement (const common::UpdateInfo & _info) const Enables generation of simulated measurement if the timeout since the last update has been reached. void UpdateReferenceFramePose () Updates the pose of the reference frame wrt the world frame. Protected Attributes inherited from gazebo::ROSBasePlugin Name std::string robotNamespace Robot namespace. std::string sensorOutputTopic Name of the sensor's output topic. physics::WorldPtr world Pointer to the world. event::ConnectionPtr updateConnection Pointer to the update event connection. common::Time lastMeasurementTime (Simulation) time when the last sensor measurement was generated. double updateRate Sensor update rate. double noiseSigma Noise standard deviation. double noiseAmp Noise amplitude. bool gazeboMsgEnabled Flag set to true if the Gazebo sensors messages are supposed to be published as well (it can avoid unnecessary overhead in case) the sensor messages needed are only ROS messages. std::default_random_engine rndGen Pseudo random number generator. std::map< std::string, std::normal_distribution< double > > noiseModels Normal distribution describing the noise models. std_msgs::Bool isOn Flag to control the generation of output messages. boost::shared_ptr< ros::NodeHandle > rosNode ROS node handle for communication with ROS. transport::NodePtr gazeboNode Gazebo's node handle for transporting measurement messages. ros::Publisher rosSensorOutputPub Gazebo's publisher for transporting measurement messages. transport::PublisherPtr gazeboSensorOutputPub Gazebo's publisher for transporting measurement messages. ros::ServiceServer changeSensorSrv Service server object. ros::Publisher pluginStatePub ROS publisher for the switchable sensor data. ignition::math::Pose3d referenceFrame Pose of the reference frame wrt world frame. ros::Subscriber tfStaticSub ROS subscriber for the TF static reference frame. std::string referenceFrameID Frame ID of the reference frame. bool isReferenceInit Flag set to true if reference frame initialized. physics::LinkPtr referenceLink Reference link.","title":"Additional inherited members"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1DVLROSPlugin/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1DVLROSPlugin/#function-dvlrosplugin","text":"DVLROSPlugin() Class constructor.","title":"function DVLROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1DVLROSPlugin/#function-dvlrosplugin_1","text":"virtual ~DVLROSPlugin() Class destructor.","title":"function ~DVLROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1DVLROSPlugin/#function-load","text":"virtual void Load( physics::ModelPtr _model, sdf::ElementPtr _sdf ) Load the plugin. Reimplements : gazebo::ROSBaseModelPlugin::Load","title":"function Load"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1DVLROSPlugin/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1DVLROSPlugin/#function-onupdate","text":"virtual bool OnUpdate( const common::UpdateInfo & _info ) Update sensor measurement. Reimplements : gazebo::ROSBaseModelPlugin::OnUpdate","title":"function OnUpdate"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1DVLROSPlugin/#function-onbeamcallback","text":"void OnBeamCallback( const sensor_msgs::RangeConstPtr & _range0, const sensor_msgs::RangeConstPtr & _range1, const sensor_msgs::RangeConstPtr & _range2, const sensor_msgs::RangeConstPtr & _range3 ) Get beam Range message update.","title":"function OnBeamCallback"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1DVLROSPlugin/#function-updatebeamtransforms","text":"bool UpdateBeamTransforms() Updates the poses of each beam wrt the DVL frame.","title":"function UpdateBeamTransforms"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1DVLROSPlugin/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1DVLROSPlugin/#variable-beamtransformsinitialized","text":"bool beamTransformsInitialized;","title":"variable beamTransformsInitialized"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1DVLROSPlugin/#variable-altitude","text":"double altitude; Measured altitude in meters.","title":"variable altitude"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1DVLROSPlugin/#variable-dvlrosmsg","text":"uuv_sensor_ros_plugins_msgs::DVL dvlROSMsg; ROS DVL message.","title":"variable dvlROSMsg"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1DVLROSPlugin/#variable-dvlbeammsgs","text":"std::vector< uuv_sensor_ros_plugins_msgs::DVLBeam > dvlBeamMsgs;","title":"variable dvlBeamMsgs"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1DVLROSPlugin/#variable-dvlmeasurementmsg","text":"dsor_msgs::Measurement dvlMeasurementMsg; DVL Measurement message (used by the medusa stack)","title":"variable dvlMeasurementMsg"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1DVLROSPlugin/#variable-medusastackdvlpub","text":"ros::Publisher medusaStackDVLPub; Additional Measurement ROS topic specific for DVL msgs into medusa stack.","title":"variable medusaStackDVLPub"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1DVLROSPlugin/#variable-twistpub","text":"ros::Publisher twistPub; ROS publisher for twist data.","title":"variable twistPub"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1DVLROSPlugin/#variable-twistrosmsg","text":"geometry_msgs::TwistWithCovarianceStamped twistROSMsg; Store pose message since many attributes do not change (cov.).","title":"variable twistROSMsg"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1DVLROSPlugin/#variable-beamslinknames","text":"std::vector< std::string > beamsLinkNames; List of beam links.","title":"variable beamsLinkNames"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1DVLROSPlugin/#variable-beamtopics","text":"std::vector< std::string > beamTopics; List of beam topics.","title":"variable beamTopics"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1DVLROSPlugin/#variable-beamposes","text":"std::vector< ignition::math::Pose3d > beamPoses; List of poses of each beam wrt to the DVL frame.","title":"variable beamPoses"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1DVLROSPlugin/#variable-syncbeammessages","text":"boost::shared_ptr< message_filters::TimeSynchronizer< sensor_msgs::Range, sensor_msgs::Range, sensor_msgs::Range, sensor_msgs::Range > > syncBeamMessages;","title":"variable syncBeamMessages"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1DVLROSPlugin/#variable-beamsub0","text":"boost::shared_ptr< message_filters::Subscriber< sensor_msgs::Range > > beamSub0;","title":"variable beamSub0"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1DVLROSPlugin/#variable-beamsub1","text":"boost::shared_ptr< message_filters::Subscriber< sensor_msgs::Range > > beamSub1;","title":"variable beamSub1"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1DVLROSPlugin/#variable-beamsub2","text":"boost::shared_ptr< message_filters::Subscriber< sensor_msgs::Range > > beamSub2;","title":"variable beamSub2"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1DVLROSPlugin/#variable-beamsub3","text":"boost::shared_ptr< message_filters::Subscriber< sensor_msgs::Range > > beamSub3;","title":"variable beamSub3"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1DVLROSPlugin/#variable-transformlistener","text":"tf::TransformListener transformListener; Updated on 2022-05-30 at 18:35:14 +0000","title":"variable transformListener"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GPSROSPlugin/","text":"gazebo::GPSROSPlugin Inherits from gazebo::ROSBaseSensorPlugin , gazebo::ROSBasePlugin , SensorPlugin Public Functions Name GPSROSPlugin () Class constructor. virtual ~GPSROSPlugin () Class destructor. virtual void Load (sensors::SensorPtr _parent, sdf::ElementPtr _sdf) Load module and read parameters from SDF. bool OnUpdateGPS () Update GPS ROS message. Protected Attributes Name sensors::GpsSensorPtr gazeboGPSSensor Pointer to the parent sensor. sensor_msgs::NavSatFix gpsMessage Output GPS ROS message. Additional inherited members Public Functions inherited from gazebo::ROSBaseSensorPlugin Name ROSBaseSensorPlugin () Class constructor. virtual ~ROSBaseSensorPlugin () Class destructor. Protected Functions inherited from gazebo::ROSBaseSensorPlugin Name virtual bool OnUpdate (const common::UpdateInfo & ) Update callback from simulation. Protected Attributes inherited from gazebo::ROSBaseSensorPlugin Name sensors::SensorPtr parentSensor Pointer to the parent sensor. Public Functions inherited from gazebo::ROSBasePlugin Name ROSBasePlugin () Class constructor. virtual ~ROSBasePlugin () Class destructor. bool InitBasePlugin (sdf::ElementPtr _sdf) Initialize base plugin. virtual bool OnUpdate (const common::UpdateInfo & ) =0 Update callback from simulation. bool AddNoiseModel (std::string _name, double _sigma) Add noise normal distribution to the list. Protected Functions inherited from gazebo::ROSBasePlugin Name bool IsOn () Returns true if the plugin is activated. void PublishState () Publish the current state of the plugin. bool ChangeSensorState (uuv_sensor_ros_plugins_msgs::ChangeSensorState::Request & _req, uuv_sensor_ros_plugins_msgs::ChangeSensorState::Response & _res) Change sensor state (ON/OFF) void GetTFMessage (const tf::tfMessage::ConstPtr & _msg) Callback function for the static TF message. double GetGaussianNoise (double _amp) Returns noise value for a function with zero mean from the default Gaussian noise model. double GetGaussianNoise (std::string _name, double _amp) Returns noise value for a function with zero mean from a Gaussian noise model according to the model name. bool EnableMeasurement (const common::UpdateInfo & _info) const Enables generation of simulated measurement if the timeout since the last update has been reached. void UpdateReferenceFramePose () Updates the pose of the reference frame wrt the world frame. Protected Attributes inherited from gazebo::ROSBasePlugin Name std::string robotNamespace Robot namespace. std::string sensorOutputTopic Name of the sensor's output topic. physics::WorldPtr world Pointer to the world. event::ConnectionPtr updateConnection Pointer to the update event connection. common::Time lastMeasurementTime (Simulation) time when the last sensor measurement was generated. double updateRate Sensor update rate. double noiseSigma Noise standard deviation. double noiseAmp Noise amplitude. bool gazeboMsgEnabled Flag set to true if the Gazebo sensors messages are supposed to be published as well (it can avoid unnecessary overhead in case) the sensor messages needed are only ROS messages. std::default_random_engine rndGen Pseudo random number generator. std::map< std::string, std::normal_distribution< double > > noiseModels Normal distribution describing the noise models. std_msgs::Bool isOn Flag to control the generation of output messages. boost::shared_ptr< ros::NodeHandle > rosNode ROS node handle for communication with ROS. transport::NodePtr gazeboNode Gazebo's node handle for transporting measurement messages. ros::Publisher rosSensorOutputPub Gazebo's publisher for transporting measurement messages. transport::PublisherPtr gazeboSensorOutputPub Gazebo's publisher for transporting measurement messages. ros::ServiceServer changeSensorSrv Service server object. ros::Publisher pluginStatePub ROS publisher for the switchable sensor data. ignition::math::Pose3d referenceFrame Pose of the reference frame wrt world frame. ros::Subscriber tfStaticSub ROS subscriber for the TF static reference frame. std::string referenceFrameID Frame ID of the reference frame. bool isReferenceInit Flag set to true if reference frame initialized. physics::LinkPtr referenceLink Reference link. Public Functions Documentation function GPSROSPlugin GPSROSPlugin() Class constructor. function ~GPSROSPlugin virtual ~GPSROSPlugin() Class destructor. function Load virtual void Load( sensors::SensorPtr _parent, sdf::ElementPtr _sdf ) Load module and read parameters from SDF. Reimplements : gazebo::ROSBaseSensorPlugin::Load function OnUpdateGPS bool OnUpdateGPS() Update GPS ROS message. Protected Attributes Documentation variable gazeboGPSSensor sensors::GpsSensorPtr gazeboGPSSensor; Pointer to the parent sensor. variable gpsMessage sensor_msgs::NavSatFix gpsMessage; Output GPS ROS message. Updated on 2022-05-30 at 18:35:14 +0000","title":"gazebo::GPSROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GPSROSPlugin/#gazebogpsrosplugin","text":"Inherits from gazebo::ROSBaseSensorPlugin , gazebo::ROSBasePlugin , SensorPlugin","title":"gazebo::GPSROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GPSROSPlugin/#public-functions","text":"Name GPSROSPlugin () Class constructor. virtual ~GPSROSPlugin () Class destructor. virtual void Load (sensors::SensorPtr _parent, sdf::ElementPtr _sdf) Load module and read parameters from SDF. bool OnUpdateGPS () Update GPS ROS message.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GPSROSPlugin/#protected-attributes","text":"Name sensors::GpsSensorPtr gazeboGPSSensor Pointer to the parent sensor. sensor_msgs::NavSatFix gpsMessage Output GPS ROS message.","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GPSROSPlugin/#additional-inherited-members","text":"Public Functions inherited from gazebo::ROSBaseSensorPlugin Name ROSBaseSensorPlugin () Class constructor. virtual ~ROSBaseSensorPlugin () Class destructor. Protected Functions inherited from gazebo::ROSBaseSensorPlugin Name virtual bool OnUpdate (const common::UpdateInfo & ) Update callback from simulation. Protected Attributes inherited from gazebo::ROSBaseSensorPlugin Name sensors::SensorPtr parentSensor Pointer to the parent sensor. Public Functions inherited from gazebo::ROSBasePlugin Name ROSBasePlugin () Class constructor. virtual ~ROSBasePlugin () Class destructor. bool InitBasePlugin (sdf::ElementPtr _sdf) Initialize base plugin. virtual bool OnUpdate (const common::UpdateInfo & ) =0 Update callback from simulation. bool AddNoiseModel (std::string _name, double _sigma) Add noise normal distribution to the list. Protected Functions inherited from gazebo::ROSBasePlugin Name bool IsOn () Returns true if the plugin is activated. void PublishState () Publish the current state of the plugin. bool ChangeSensorState (uuv_sensor_ros_plugins_msgs::ChangeSensorState::Request & _req, uuv_sensor_ros_plugins_msgs::ChangeSensorState::Response & _res) Change sensor state (ON/OFF) void GetTFMessage (const tf::tfMessage::ConstPtr & _msg) Callback function for the static TF message. double GetGaussianNoise (double _amp) Returns noise value for a function with zero mean from the default Gaussian noise model. double GetGaussianNoise (std::string _name, double _amp) Returns noise value for a function with zero mean from a Gaussian noise model according to the model name. bool EnableMeasurement (const common::UpdateInfo & _info) const Enables generation of simulated measurement if the timeout since the last update has been reached. void UpdateReferenceFramePose () Updates the pose of the reference frame wrt the world frame. Protected Attributes inherited from gazebo::ROSBasePlugin Name std::string robotNamespace Robot namespace. std::string sensorOutputTopic Name of the sensor's output topic. physics::WorldPtr world Pointer to the world. event::ConnectionPtr updateConnection Pointer to the update event connection. common::Time lastMeasurementTime (Simulation) time when the last sensor measurement was generated. double updateRate Sensor update rate. double noiseSigma Noise standard deviation. double noiseAmp Noise amplitude. bool gazeboMsgEnabled Flag set to true if the Gazebo sensors messages are supposed to be published as well (it can avoid unnecessary overhead in case) the sensor messages needed are only ROS messages. std::default_random_engine rndGen Pseudo random number generator. std::map< std::string, std::normal_distribution< double > > noiseModels Normal distribution describing the noise models. std_msgs::Bool isOn Flag to control the generation of output messages. boost::shared_ptr< ros::NodeHandle > rosNode ROS node handle for communication with ROS. transport::NodePtr gazeboNode Gazebo's node handle for transporting measurement messages. ros::Publisher rosSensorOutputPub Gazebo's publisher for transporting measurement messages. transport::PublisherPtr gazeboSensorOutputPub Gazebo's publisher for transporting measurement messages. ros::ServiceServer changeSensorSrv Service server object. ros::Publisher pluginStatePub ROS publisher for the switchable sensor data. ignition::math::Pose3d referenceFrame Pose of the reference frame wrt world frame. ros::Subscriber tfStaticSub ROS subscriber for the TF static reference frame. std::string referenceFrameID Frame ID of the reference frame. bool isReferenceInit Flag set to true if reference frame initialized. physics::LinkPtr referenceLink Reference link.","title":"Additional inherited members"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GPSROSPlugin/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GPSROSPlugin/#function-gpsrosplugin","text":"GPSROSPlugin() Class constructor.","title":"function GPSROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GPSROSPlugin/#function-gpsrosplugin_1","text":"virtual ~GPSROSPlugin() Class destructor.","title":"function ~GPSROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GPSROSPlugin/#function-load","text":"virtual void Load( sensors::SensorPtr _parent, sdf::ElementPtr _sdf ) Load module and read parameters from SDF. Reimplements : gazebo::ROSBaseSensorPlugin::Load","title":"function Load"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GPSROSPlugin/#function-onupdategps","text":"bool OnUpdateGPS() Update GPS ROS message.","title":"function OnUpdateGPS"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GPSROSPlugin/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GPSROSPlugin/#variable-gazebogpssensor","text":"sensors::GpsSensorPtr gazeboGPSSensor; Pointer to the parent sensor.","title":"variable gazeboGPSSensor"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GPSROSPlugin/#variable-gpsmessage","text":"sensor_msgs::NavSatFix gpsMessage; Output GPS ROS message. Updated on 2022-05-30 at 18:35:14 +0000","title":"variable gpsMessage"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GazeboRosImageSonar/","text":"gazebo::GazeboRosImageSonar Inherits from SensorPlugin, GazeboRosCameraUtils Public Functions Name GazeboRosImageSonar () Constructor. ~GazeboRosImageSonar () Destructor. virtual void Load (sensors::SensorPtr _parent, sdf::ElementPtr _sdf) Load the plugin. virtual void Advertise () Advertise point cloud and depth image. Protected Functions Name virtual void OnNewDepthFrame (const float * _image, unsigned int _width, unsigned int _height, unsigned int _depth, const std::string & _format) Update the controller. virtual void OnNewRGBPointCloud (const float * _pcd, unsigned int _width, unsigned int _height, unsigned int _depth, const std::string & _format) Update the controller. virtual void OnNewImageFrame (const unsigned char * _image, unsigned int _width, unsigned int _height, unsigned int _depth, const std::string & _format) Update the controller. virtual void PublishCameraInfo () Protected Attributes Name ros::Publisher depth_image_camera_info_pub_ unsigned int width unsigned int height unsigned int depth std::string format cv::Mat dist_matrix_ std::vector< std::vector< int > > angle_range_indices_ std::vector< int > angle_nbr_indices_ sensors::DepthCameraSensorPtr parentSensor rendering::DepthCameraPtr depthCamera Public Functions Documentation function GazeboRosImageSonar GazeboRosImageSonar() Constructor. Parameters : parent The parent entity, must be a Model or a Sensor function ~GazeboRosImageSonar ~GazeboRosImageSonar() Destructor. function Load virtual void Load( sensors::SensorPtr _parent, sdf::ElementPtr _sdf ) Load the plugin. Parameters : take in SDF root element function Advertise virtual void Advertise() Advertise point cloud and depth image. Protected Functions Documentation function OnNewDepthFrame virtual void OnNewDepthFrame( const float * _image, unsigned int _width, unsigned int _height, unsigned int _depth, const std::string & _format ) Update the controller. function OnNewRGBPointCloud virtual void OnNewRGBPointCloud( const float * _pcd, unsigned int _width, unsigned int _height, unsigned int _depth, const std::string & _format ) Update the controller. function OnNewImageFrame virtual void OnNewImageFrame( const unsigned char * _image, unsigned int _width, unsigned int _height, unsigned int _depth, const std::string & _format ) Update the controller. function PublishCameraInfo virtual void PublishCameraInfo() Protected Attributes Documentation variable depth_image_camera_info_pub_ ros::Publisher depth_image_camera_info_pub_; variable width unsigned int width; variable height unsigned int height; variable depth unsigned int depth; variable format std::string format; variable dist_matrix_ cv::Mat dist_matrix_; variable angle_range_indices_ std::vector< std::vector< int > > angle_range_indices_; variable angle_nbr_indices_ std::vector< int > angle_nbr_indices_; variable parentSensor sensors::DepthCameraSensorPtr parentSensor; variable depthCamera rendering::DepthCameraPtr depthCamera; Updated on 2022-05-30 at 18:35:14 +0000","title":"gazebo::GazeboRosImageSonar"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GazeboRosImageSonar/#gazebogazeborosimagesonar","text":"Inherits from SensorPlugin, GazeboRosCameraUtils","title":"gazebo::GazeboRosImageSonar"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GazeboRosImageSonar/#public-functions","text":"Name GazeboRosImageSonar () Constructor. ~GazeboRosImageSonar () Destructor. virtual void Load (sensors::SensorPtr _parent, sdf::ElementPtr _sdf) Load the plugin. virtual void Advertise () Advertise point cloud and depth image.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GazeboRosImageSonar/#protected-functions","text":"Name virtual void OnNewDepthFrame (const float * _image, unsigned int _width, unsigned int _height, unsigned int _depth, const std::string & _format) Update the controller. virtual void OnNewRGBPointCloud (const float * _pcd, unsigned int _width, unsigned int _height, unsigned int _depth, const std::string & _format) Update the controller. virtual void OnNewImageFrame (const unsigned char * _image, unsigned int _width, unsigned int _height, unsigned int _depth, const std::string & _format) Update the controller. virtual void PublishCameraInfo ()","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GazeboRosImageSonar/#protected-attributes","text":"Name ros::Publisher depth_image_camera_info_pub_ unsigned int width unsigned int height unsigned int depth std::string format cv::Mat dist_matrix_ std::vector< std::vector< int > > angle_range_indices_ std::vector< int > angle_nbr_indices_ sensors::DepthCameraSensorPtr parentSensor rendering::DepthCameraPtr depthCamera","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GazeboRosImageSonar/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GazeboRosImageSonar/#function-gazeborosimagesonar","text":"GazeboRosImageSonar() Constructor. Parameters : parent The parent entity, must be a Model or a Sensor","title":"function GazeboRosImageSonar"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GazeboRosImageSonar/#function-gazeborosimagesonar_1","text":"~GazeboRosImageSonar() Destructor.","title":"function ~GazeboRosImageSonar"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GazeboRosImageSonar/#function-load","text":"virtual void Load( sensors::SensorPtr _parent, sdf::ElementPtr _sdf ) Load the plugin. Parameters : take in SDF root element","title":"function Load"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GazeboRosImageSonar/#function-advertise","text":"virtual void Advertise() Advertise point cloud and depth image.","title":"function Advertise"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GazeboRosImageSonar/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GazeboRosImageSonar/#function-onnewdepthframe","text":"virtual void OnNewDepthFrame( const float * _image, unsigned int _width, unsigned int _height, unsigned int _depth, const std::string & _format ) Update the controller.","title":"function OnNewDepthFrame"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GazeboRosImageSonar/#function-onnewrgbpointcloud","text":"virtual void OnNewRGBPointCloud( const float * _pcd, unsigned int _width, unsigned int _height, unsigned int _depth, const std::string & _format ) Update the controller.","title":"function OnNewRGBPointCloud"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GazeboRosImageSonar/#function-onnewimageframe","text":"virtual void OnNewImageFrame( const unsigned char * _image, unsigned int _width, unsigned int _height, unsigned int _depth, const std::string & _format ) Update the controller.","title":"function OnNewImageFrame"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GazeboRosImageSonar/#function-publishcamerainfo","text":"virtual void PublishCameraInfo()","title":"function PublishCameraInfo"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GazeboRosImageSonar/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GazeboRosImageSonar/#variable-depth_image_camera_info_pub_","text":"ros::Publisher depth_image_camera_info_pub_;","title":"variable depth_image_camera_info_pub_"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GazeboRosImageSonar/#variable-width","text":"unsigned int width;","title":"variable width"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GazeboRosImageSonar/#variable-height","text":"unsigned int height;","title":"variable height"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GazeboRosImageSonar/#variable-depth","text":"unsigned int depth;","title":"variable depth"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GazeboRosImageSonar/#variable-format","text":"std::string format;","title":"variable format"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GazeboRosImageSonar/#variable-dist_matrix_","text":"cv::Mat dist_matrix_;","title":"variable dist_matrix_"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GazeboRosImageSonar/#variable-angle_range_indices_","text":"std::vector< std::vector< int > > angle_range_indices_;","title":"variable angle_range_indices_"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GazeboRosImageSonar/#variable-angle_nbr_indices_","text":"std::vector< int > angle_nbr_indices_;","title":"variable angle_nbr_indices_"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GazeboRosImageSonar/#variable-parentsensor","text":"sensors::DepthCameraSensorPtr parentSensor;","title":"variable parentSensor"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GazeboRosImageSonar/#variable-depthcamera","text":"rendering::DepthCameraPtr depthCamera; Updated on 2022-05-30 at 18:35:14 +0000","title":"variable depthCamera"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GstCameraPlugin/","text":"gazebo::GstCameraPlugin More... #include <gazebo_gst_camera_plugin.hh> Inherits from SensorPlugin Public Functions Name GstCameraPlugin () virtual ~GstCameraPlugin () virtual void Load (sensors::SensorPtr sensor, sdf::ElementPtr sdf) virtual void OnNewFrame (const unsigned char * image, unsigned int width, unsigned int height, unsigned int depth, const std::string & format) void startGstThread () void stopGstThread () void gstCallback (GstElement * appsrc) void cbVideoStream (const boost::shared_ptr< const msgs::Int > & _msg) Protected Attributes Name unsigned int width unsigned int height unsigned int depth float rate std::string format std::string udpHost int udpPort bool useRtmp std::string rtmpLocation bool useCuda sensors::CameraSensorPtr parentSensor rendering::CameraPtr camera Detailed Description class gazebo::GstCameraPlugin; A Gazebo plugin that can be attached to a camera and then streams the video data using gstreamer. It streams to a configurable UDP IP and UDP Port, defaults are respectively 127.0.0.1 and 5600. Connect to the stream via command line with: gst-launch-1.0 -v udpsrc port=5600 caps='application/x-rtp, media=(string)video, clock-rate=(int)90000, encoding-name=(string)H264' \\ ! rtph264depay ! avdec_h264 ! videoconvert ! autovideosink fps-update-interval=1000 sync=false Public Functions Documentation function GstCameraPlugin GstCameraPlugin() function ~GstCameraPlugin virtual ~GstCameraPlugin() function Load virtual void Load( sensors::SensorPtr sensor, sdf::ElementPtr sdf ) function OnNewFrame virtual void OnNewFrame( const unsigned char * image, unsigned int width, unsigned int height, unsigned int depth, const std::string & format ) function startGstThread void startGstThread() function stopGstThread void stopGstThread() function gstCallback void gstCallback( GstElement * appsrc ) function cbVideoStream void cbVideoStream( const boost::shared_ptr< const msgs::Int > & _msg ) Protected Attributes Documentation variable width unsigned int width; variable height unsigned int height; variable depth unsigned int depth; variable rate float rate; variable format std::string format; variable udpHost std::string udpHost; variable udpPort int udpPort; variable useRtmp bool useRtmp; variable rtmpLocation std::string rtmpLocation; variable useCuda bool useCuda; variable parentSensor sensors::CameraSensorPtr parentSensor; variable camera rendering::CameraPtr camera; Updated on 2022-05-30 at 18:35:14 +0000","title":"gazebo::GstCameraPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GstCameraPlugin/#gazebogstcameraplugin","text":"More... #include <gazebo_gst_camera_plugin.hh> Inherits from SensorPlugin","title":"gazebo::GstCameraPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GstCameraPlugin/#public-functions","text":"Name GstCameraPlugin () virtual ~GstCameraPlugin () virtual void Load (sensors::SensorPtr sensor, sdf::ElementPtr sdf) virtual void OnNewFrame (const unsigned char * image, unsigned int width, unsigned int height, unsigned int depth, const std::string & format) void startGstThread () void stopGstThread () void gstCallback (GstElement * appsrc) void cbVideoStream (const boost::shared_ptr< const msgs::Int > & _msg)","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GstCameraPlugin/#protected-attributes","text":"Name unsigned int width unsigned int height unsigned int depth float rate std::string format std::string udpHost int udpPort bool useRtmp std::string rtmpLocation bool useCuda sensors::CameraSensorPtr parentSensor rendering::CameraPtr camera","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GstCameraPlugin/#detailed-description","text":"class gazebo::GstCameraPlugin; A Gazebo plugin that can be attached to a camera and then streams the video data using gstreamer. It streams to a configurable UDP IP and UDP Port, defaults are respectively 127.0.0.1 and 5600. Connect to the stream via command line with: gst-launch-1.0 -v udpsrc port=5600 caps='application/x-rtp, media=(string)video, clock-rate=(int)90000, encoding-name=(string)H264' \\ ! rtph264depay ! avdec_h264 ! videoconvert ! autovideosink fps-update-interval=1000 sync=false","title":"Detailed Description"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GstCameraPlugin/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GstCameraPlugin/#function-gstcameraplugin","text":"GstCameraPlugin()","title":"function GstCameraPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GstCameraPlugin/#function-gstcameraplugin_1","text":"virtual ~GstCameraPlugin()","title":"function ~GstCameraPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GstCameraPlugin/#function-load","text":"virtual void Load( sensors::SensorPtr sensor, sdf::ElementPtr sdf )","title":"function Load"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GstCameraPlugin/#function-onnewframe","text":"virtual void OnNewFrame( const unsigned char * image, unsigned int width, unsigned int height, unsigned int depth, const std::string & format )","title":"function OnNewFrame"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GstCameraPlugin/#function-startgstthread","text":"void startGstThread()","title":"function startGstThread"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GstCameraPlugin/#function-stopgstthread","text":"void stopGstThread()","title":"function stopGstThread"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GstCameraPlugin/#function-gstcallback","text":"void gstCallback( GstElement * appsrc )","title":"function gstCallback"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GstCameraPlugin/#function-cbvideostream","text":"void cbVideoStream( const boost::shared_ptr< const msgs::Int > & _msg )","title":"function cbVideoStream"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GstCameraPlugin/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GstCameraPlugin/#variable-width","text":"unsigned int width;","title":"variable width"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GstCameraPlugin/#variable-height","text":"unsigned int height;","title":"variable height"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GstCameraPlugin/#variable-depth","text":"unsigned int depth;","title":"variable depth"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GstCameraPlugin/#variable-rate","text":"float rate;","title":"variable rate"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GstCameraPlugin/#variable-format","text":"std::string format;","title":"variable format"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GstCameraPlugin/#variable-udphost","text":"std::string udpHost;","title":"variable udpHost"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GstCameraPlugin/#variable-udpport","text":"int udpPort;","title":"variable udpPort"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GstCameraPlugin/#variable-usertmp","text":"bool useRtmp;","title":"variable useRtmp"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GstCameraPlugin/#variable-rtmplocation","text":"std::string rtmpLocation;","title":"variable rtmpLocation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GstCameraPlugin/#variable-usecuda","text":"bool useCuda;","title":"variable useCuda"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GstCameraPlugin/#variable-parentsensor","text":"sensors::CameraSensorPtr parentSensor;","title":"variable parentSensor"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1GstCameraPlugin/#variable-camera","text":"rendering::CameraPtr camera; Updated on 2022-05-30 at 18:35:14 +0000","title":"variable camera"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1IMUROSPlugin/","text":"gazebo::IMUROSPlugin Inherits from gazebo::ROSBaseModelPlugin , gazebo::ROSBasePlugin , ModelPlugin Public Functions Name IMUROSPlugin () Class constructor. virtual ~IMUROSPlugin () Class destructor. virtual void Load (physics::ModelPtr _model, sdf::ElementPtr _sdf) Load the plugin. Protected Functions Name virtual bool OnUpdate (const common::UpdateInfo & _info) Update sensor measurement. void AddNoise (ignition::math::Vector3d & _linAcc, ignition::math::Vector3d & _angVel, ignition::math::Quaterniond & _orientation, double _dt) Apply and add nosie model to ideal measurements. Protected Attributes Name ignition::math::Vector3d measLinearAcc Last measurement of linear acceleration.. ignition::math::Vector3d measAngularVel Last measurement of angular velocity. ignition::math::Quaterniond measOrientation (Simulation) time when the last sensor measurement was generated. ignition::math::Vector3d gravityWorld Gravity vector wrt. reference frame. ignition::math::Vector3d gyroscopeBias Current (drifting) gyroscope bias. ignition::math::Vector3d accelerometerBias Current (drifting) accelerometer bias. ignition::math::Vector3d gyroscopeTurnOnBias Constant turn-on gyroscope bias. ignition::math::Vector3d accelerometerTurnOnBias Constant turn-on accelerometer bias. IMUParameters imuParameters IMU model parameters. sensor_msgs::Imu imuROSMessage ROS IMU message. dsor_msgs::Measurement imuMeasurementMsg IMU Measurement message (used by the medusa stack) ros::Publisher medusaStackImuPub Additional Measurement ROS topic specific for IMU msgs into stack. Additional inherited members Public Functions inherited from gazebo::ROSBaseModelPlugin Name ROSBaseModelPlugin () Class constructor. virtual ~ROSBaseModelPlugin () Class destructor. Protected Functions inherited from gazebo::ROSBaseModelPlugin Name void SendLocalNEDTransform () Returns true if the base_link_ned frame exists. Protected Attributes inherited from gazebo::ROSBaseModelPlugin Name physics::ModelPtr model Pointer to the model. physics::LinkPtr link Pointer to the link. bool enableLocalNEDFrame True if a the local NED frame needs to be broadcasted. tf::TransformBroadcaster * tfBroadcaster TF broadcaster for the local NED frame. ignition::math::Pose3d localNEDFrame Pose of the local NED frame wrt link frame. tf::StampedTransform tfLocalNEDFrame Local NED TF frame. Public Functions inherited from gazebo::ROSBasePlugin Name ROSBasePlugin () Class constructor. virtual ~ROSBasePlugin () Class destructor. bool InitBasePlugin (sdf::ElementPtr _sdf) Initialize base plugin. bool AddNoiseModel (std::string _name, double _sigma) Add noise normal distribution to the list. Protected Functions inherited from gazebo::ROSBasePlugin Name bool IsOn () Returns true if the plugin is activated. void PublishState () Publish the current state of the plugin. bool ChangeSensorState (uuv_sensor_ros_plugins_msgs::ChangeSensorState::Request & _req, uuv_sensor_ros_plugins_msgs::ChangeSensorState::Response & _res) Change sensor state (ON/OFF) void GetTFMessage (const tf::tfMessage::ConstPtr & _msg) Callback function for the static TF message. double GetGaussianNoise (double _amp) Returns noise value for a function with zero mean from the default Gaussian noise model. double GetGaussianNoise (std::string _name, double _amp) Returns noise value for a function with zero mean from a Gaussian noise model according to the model name. bool EnableMeasurement (const common::UpdateInfo & _info) const Enables generation of simulated measurement if the timeout since the last update has been reached. void UpdateReferenceFramePose () Updates the pose of the reference frame wrt the world frame. Protected Attributes inherited from gazebo::ROSBasePlugin Name std::string robotNamespace Robot namespace. std::string sensorOutputTopic Name of the sensor's output topic. physics::WorldPtr world Pointer to the world. event::ConnectionPtr updateConnection Pointer to the update event connection. common::Time lastMeasurementTime (Simulation) time when the last sensor measurement was generated. double updateRate Sensor update rate. double noiseSigma Noise standard deviation. double noiseAmp Noise amplitude. bool gazeboMsgEnabled Flag set to true if the Gazebo sensors messages are supposed to be published as well (it can avoid unnecessary overhead in case) the sensor messages needed are only ROS messages. std::default_random_engine rndGen Pseudo random number generator. std::map< std::string, std::normal_distribution< double > > noiseModels Normal distribution describing the noise models. std_msgs::Bool isOn Flag to control the generation of output messages. boost::shared_ptr< ros::NodeHandle > rosNode ROS node handle for communication with ROS. transport::NodePtr gazeboNode Gazebo's node handle for transporting measurement messages. ros::Publisher rosSensorOutputPub Gazebo's publisher for transporting measurement messages. transport::PublisherPtr gazeboSensorOutputPub Gazebo's publisher for transporting measurement messages. ros::ServiceServer changeSensorSrv Service server object. ros::Publisher pluginStatePub ROS publisher for the switchable sensor data. ignition::math::Pose3d referenceFrame Pose of the reference frame wrt world frame. ros::Subscriber tfStaticSub ROS subscriber for the TF static reference frame. std::string referenceFrameID Frame ID of the reference frame. bool isReferenceInit Flag set to true if reference frame initialized. physics::LinkPtr referenceLink Reference link. Public Functions Documentation function IMUROSPlugin IMUROSPlugin() Class constructor. function ~IMUROSPlugin virtual ~IMUROSPlugin() Class destructor. function Load virtual void Load( physics::ModelPtr _model, sdf::ElementPtr _sdf ) Load the plugin. Reimplements : gazebo::ROSBaseModelPlugin::Load Protected Functions Documentation function OnUpdate virtual bool OnUpdate( const common::UpdateInfo & _info ) Update sensor measurement. Reimplements : gazebo::ROSBaseModelPlugin::OnUpdate function AddNoise void AddNoise( ignition::math::Vector3d & _linAcc, ignition::math::Vector3d & _angVel, ignition::math::Quaterniond & _orientation, double _dt ) Apply and add nosie model to ideal measurements. Gyroscope Accelerometer Orientation Protected Attributes Documentation variable measLinearAcc ignition::math::Vector3d measLinearAcc; Last measurement of linear acceleration.. variable measAngularVel ignition::math::Vector3d measAngularVel; Last measurement of angular velocity. variable measOrientation ignition::math::Quaterniond measOrientation; (Simulation) time when the last sensor measurement was generated. variable gravityWorld ignition::math::Vector3d gravityWorld; Gravity vector wrt. reference frame. variable gyroscopeBias ignition::math::Vector3d gyroscopeBias; Current (drifting) gyroscope bias. variable accelerometerBias ignition::math::Vector3d accelerometerBias; Current (drifting) accelerometer bias. variable gyroscopeTurnOnBias ignition::math::Vector3d gyroscopeTurnOnBias; Constant turn-on gyroscope bias. variable accelerometerTurnOnBias ignition::math::Vector3d accelerometerTurnOnBias; Constant turn-on accelerometer bias. variable imuParameters IMUParameters imuParameters; IMU model parameters. variable imuROSMessage sensor_msgs::Imu imuROSMessage; ROS IMU message. variable imuMeasurementMsg dsor_msgs::Measurement imuMeasurementMsg; IMU Measurement message (used by the medusa stack) variable medusaStackImuPub ros::Publisher medusaStackImuPub; Additional Measurement ROS topic specific for IMU msgs into stack. Updated on 2022-05-30 at 18:35:14 +0000","title":"gazebo::IMUROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1IMUROSPlugin/#gazeboimurosplugin","text":"Inherits from gazebo::ROSBaseModelPlugin , gazebo::ROSBasePlugin , ModelPlugin","title":"gazebo::IMUROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1IMUROSPlugin/#public-functions","text":"Name IMUROSPlugin () Class constructor. virtual ~IMUROSPlugin () Class destructor. virtual void Load (physics::ModelPtr _model, sdf::ElementPtr _sdf) Load the plugin.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1IMUROSPlugin/#protected-functions","text":"Name virtual bool OnUpdate (const common::UpdateInfo & _info) Update sensor measurement. void AddNoise (ignition::math::Vector3d & _linAcc, ignition::math::Vector3d & _angVel, ignition::math::Quaterniond & _orientation, double _dt) Apply and add nosie model to ideal measurements.","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1IMUROSPlugin/#protected-attributes","text":"Name ignition::math::Vector3d measLinearAcc Last measurement of linear acceleration.. ignition::math::Vector3d measAngularVel Last measurement of angular velocity. ignition::math::Quaterniond measOrientation (Simulation) time when the last sensor measurement was generated. ignition::math::Vector3d gravityWorld Gravity vector wrt. reference frame. ignition::math::Vector3d gyroscopeBias Current (drifting) gyroscope bias. ignition::math::Vector3d accelerometerBias Current (drifting) accelerometer bias. ignition::math::Vector3d gyroscopeTurnOnBias Constant turn-on gyroscope bias. ignition::math::Vector3d accelerometerTurnOnBias Constant turn-on accelerometer bias. IMUParameters imuParameters IMU model parameters. sensor_msgs::Imu imuROSMessage ROS IMU message. dsor_msgs::Measurement imuMeasurementMsg IMU Measurement message (used by the medusa stack) ros::Publisher medusaStackImuPub Additional Measurement ROS topic specific for IMU msgs into stack.","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1IMUROSPlugin/#additional-inherited-members","text":"Public Functions inherited from gazebo::ROSBaseModelPlugin Name ROSBaseModelPlugin () Class constructor. virtual ~ROSBaseModelPlugin () Class destructor. Protected Functions inherited from gazebo::ROSBaseModelPlugin Name void SendLocalNEDTransform () Returns true if the base_link_ned frame exists. Protected Attributes inherited from gazebo::ROSBaseModelPlugin Name physics::ModelPtr model Pointer to the model. physics::LinkPtr link Pointer to the link. bool enableLocalNEDFrame True if a the local NED frame needs to be broadcasted. tf::TransformBroadcaster * tfBroadcaster TF broadcaster for the local NED frame. ignition::math::Pose3d localNEDFrame Pose of the local NED frame wrt link frame. tf::StampedTransform tfLocalNEDFrame Local NED TF frame. Public Functions inherited from gazebo::ROSBasePlugin Name ROSBasePlugin () Class constructor. virtual ~ROSBasePlugin () Class destructor. bool InitBasePlugin (sdf::ElementPtr _sdf) Initialize base plugin. bool AddNoiseModel (std::string _name, double _sigma) Add noise normal distribution to the list. Protected Functions inherited from gazebo::ROSBasePlugin Name bool IsOn () Returns true if the plugin is activated. void PublishState () Publish the current state of the plugin. bool ChangeSensorState (uuv_sensor_ros_plugins_msgs::ChangeSensorState::Request & _req, uuv_sensor_ros_plugins_msgs::ChangeSensorState::Response & _res) Change sensor state (ON/OFF) void GetTFMessage (const tf::tfMessage::ConstPtr & _msg) Callback function for the static TF message. double GetGaussianNoise (double _amp) Returns noise value for a function with zero mean from the default Gaussian noise model. double GetGaussianNoise (std::string _name, double _amp) Returns noise value for a function with zero mean from a Gaussian noise model according to the model name. bool EnableMeasurement (const common::UpdateInfo & _info) const Enables generation of simulated measurement if the timeout since the last update has been reached. void UpdateReferenceFramePose () Updates the pose of the reference frame wrt the world frame. Protected Attributes inherited from gazebo::ROSBasePlugin Name std::string robotNamespace Robot namespace. std::string sensorOutputTopic Name of the sensor's output topic. physics::WorldPtr world Pointer to the world. event::ConnectionPtr updateConnection Pointer to the update event connection. common::Time lastMeasurementTime (Simulation) time when the last sensor measurement was generated. double updateRate Sensor update rate. double noiseSigma Noise standard deviation. double noiseAmp Noise amplitude. bool gazeboMsgEnabled Flag set to true if the Gazebo sensors messages are supposed to be published as well (it can avoid unnecessary overhead in case) the sensor messages needed are only ROS messages. std::default_random_engine rndGen Pseudo random number generator. std::map< std::string, std::normal_distribution< double > > noiseModels Normal distribution describing the noise models. std_msgs::Bool isOn Flag to control the generation of output messages. boost::shared_ptr< ros::NodeHandle > rosNode ROS node handle for communication with ROS. transport::NodePtr gazeboNode Gazebo's node handle for transporting measurement messages. ros::Publisher rosSensorOutputPub Gazebo's publisher for transporting measurement messages. transport::PublisherPtr gazeboSensorOutputPub Gazebo's publisher for transporting measurement messages. ros::ServiceServer changeSensorSrv Service server object. ros::Publisher pluginStatePub ROS publisher for the switchable sensor data. ignition::math::Pose3d referenceFrame Pose of the reference frame wrt world frame. ros::Subscriber tfStaticSub ROS subscriber for the TF static reference frame. std::string referenceFrameID Frame ID of the reference frame. bool isReferenceInit Flag set to true if reference frame initialized. physics::LinkPtr referenceLink Reference link.","title":"Additional inherited members"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1IMUROSPlugin/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1IMUROSPlugin/#function-imurosplugin","text":"IMUROSPlugin() Class constructor.","title":"function IMUROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1IMUROSPlugin/#function-imurosplugin_1","text":"virtual ~IMUROSPlugin() Class destructor.","title":"function ~IMUROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1IMUROSPlugin/#function-load","text":"virtual void Load( physics::ModelPtr _model, sdf::ElementPtr _sdf ) Load the plugin. Reimplements : gazebo::ROSBaseModelPlugin::Load","title":"function Load"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1IMUROSPlugin/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1IMUROSPlugin/#function-onupdate","text":"virtual bool OnUpdate( const common::UpdateInfo & _info ) Update sensor measurement. Reimplements : gazebo::ROSBaseModelPlugin::OnUpdate","title":"function OnUpdate"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1IMUROSPlugin/#function-addnoise","text":"void AddNoise( ignition::math::Vector3d & _linAcc, ignition::math::Vector3d & _angVel, ignition::math::Quaterniond & _orientation, double _dt ) Apply and add nosie model to ideal measurements. Gyroscope Accelerometer Orientation","title":"function AddNoise"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1IMUROSPlugin/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1IMUROSPlugin/#variable-measlinearacc","text":"ignition::math::Vector3d measLinearAcc; Last measurement of linear acceleration..","title":"variable measLinearAcc"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1IMUROSPlugin/#variable-measangularvel","text":"ignition::math::Vector3d measAngularVel; Last measurement of angular velocity.","title":"variable measAngularVel"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1IMUROSPlugin/#variable-measorientation","text":"ignition::math::Quaterniond measOrientation; (Simulation) time when the last sensor measurement was generated.","title":"variable measOrientation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1IMUROSPlugin/#variable-gravityworld","text":"ignition::math::Vector3d gravityWorld; Gravity vector wrt. reference frame.","title":"variable gravityWorld"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1IMUROSPlugin/#variable-gyroscopebias","text":"ignition::math::Vector3d gyroscopeBias; Current (drifting) gyroscope bias.","title":"variable gyroscopeBias"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1IMUROSPlugin/#variable-accelerometerbias","text":"ignition::math::Vector3d accelerometerBias; Current (drifting) accelerometer bias.","title":"variable accelerometerBias"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1IMUROSPlugin/#variable-gyroscopeturnonbias","text":"ignition::math::Vector3d gyroscopeTurnOnBias; Constant turn-on gyroscope bias.","title":"variable gyroscopeTurnOnBias"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1IMUROSPlugin/#variable-accelerometerturnonbias","text":"ignition::math::Vector3d accelerometerTurnOnBias; Constant turn-on accelerometer bias.","title":"variable accelerometerTurnOnBias"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1IMUROSPlugin/#variable-imuparameters","text":"IMUParameters imuParameters; IMU model parameters.","title":"variable imuParameters"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1IMUROSPlugin/#variable-imurosmessage","text":"sensor_msgs::Imu imuROSMessage; ROS IMU message.","title":"variable imuROSMessage"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1IMUROSPlugin/#variable-imumeasurementmsg","text":"dsor_msgs::Measurement imuMeasurementMsg; IMU Measurement message (used by the medusa stack)","title":"variable imuMeasurementMsg"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1IMUROSPlugin/#variable-medusastackimupub","text":"ros::Publisher medusaStackImuPub; Additional Measurement ROS topic specific for IMU msgs into stack. Updated on 2022-05-30 at 18:35:14 +0000","title":"variable medusaStackImuPub"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1MagnetometerROSPlugin/","text":"gazebo::MagnetometerROSPlugin Inherits from gazebo::ROSBaseModelPlugin , gazebo::ROSBasePlugin , ModelPlugin Public Functions Name MagnetometerROSPlugin () Class constructor. virtual ~MagnetometerROSPlugin () Class destructor. virtual void Load (physics::ModelPtr _model, sdf::ElementPtr _sdf) Load the plugin. Protected Functions Name virtual bool OnUpdate (const common::UpdateInfo & _info) Update sensor measurement. Protected Attributes Name MagnetometerParameters parameters Magnetometer configuration parameters: ignition::math::Vector3d magneticFieldWorld Reference magnetic field in world frame: ignition::math::Vector3d turnOnBias Constant turn-on bias [muT]. ignition::math::Vector3d measMagneticField Last measurement of magnetic field. sensor_msgs::MagneticField rosMsg ROS message. Additional inherited members Public Functions inherited from gazebo::ROSBaseModelPlugin Name ROSBaseModelPlugin () Class constructor. virtual ~ROSBaseModelPlugin () Class destructor. Protected Functions inherited from gazebo::ROSBaseModelPlugin Name void SendLocalNEDTransform () Returns true if the base_link_ned frame exists. Protected Attributes inherited from gazebo::ROSBaseModelPlugin Name physics::ModelPtr model Pointer to the model. physics::LinkPtr link Pointer to the link. bool enableLocalNEDFrame True if a the local NED frame needs to be broadcasted. tf::TransformBroadcaster * tfBroadcaster TF broadcaster for the local NED frame. ignition::math::Pose3d localNEDFrame Pose of the local NED frame wrt link frame. tf::StampedTransform tfLocalNEDFrame Local NED TF frame. Public Functions inherited from gazebo::ROSBasePlugin Name ROSBasePlugin () Class constructor. virtual ~ROSBasePlugin () Class destructor. bool InitBasePlugin (sdf::ElementPtr _sdf) Initialize base plugin. bool AddNoiseModel (std::string _name, double _sigma) Add noise normal distribution to the list. Protected Functions inherited from gazebo::ROSBasePlugin Name bool IsOn () Returns true if the plugin is activated. void PublishState () Publish the current state of the plugin. bool ChangeSensorState (uuv_sensor_ros_plugins_msgs::ChangeSensorState::Request & _req, uuv_sensor_ros_plugins_msgs::ChangeSensorState::Response & _res) Change sensor state (ON/OFF) void GetTFMessage (const tf::tfMessage::ConstPtr & _msg) Callback function for the static TF message. double GetGaussianNoise (double _amp) Returns noise value for a function with zero mean from the default Gaussian noise model. double GetGaussianNoise (std::string _name, double _amp) Returns noise value for a function with zero mean from a Gaussian noise model according to the model name. bool EnableMeasurement (const common::UpdateInfo & _info) const Enables generation of simulated measurement if the timeout since the last update has been reached. void UpdateReferenceFramePose () Updates the pose of the reference frame wrt the world frame. Protected Attributes inherited from gazebo::ROSBasePlugin Name std::string robotNamespace Robot namespace. std::string sensorOutputTopic Name of the sensor's output topic. physics::WorldPtr world Pointer to the world. event::ConnectionPtr updateConnection Pointer to the update event connection. common::Time lastMeasurementTime (Simulation) time when the last sensor measurement was generated. double updateRate Sensor update rate. double noiseSigma Noise standard deviation. double noiseAmp Noise amplitude. bool gazeboMsgEnabled Flag set to true if the Gazebo sensors messages are supposed to be published as well (it can avoid unnecessary overhead in case) the sensor messages needed are only ROS messages. std::default_random_engine rndGen Pseudo random number generator. std::map< std::string, std::normal_distribution< double > > noiseModels Normal distribution describing the noise models. std_msgs::Bool isOn Flag to control the generation of output messages. boost::shared_ptr< ros::NodeHandle > rosNode ROS node handle for communication with ROS. transport::NodePtr gazeboNode Gazebo's node handle for transporting measurement messages. ros::Publisher rosSensorOutputPub Gazebo's publisher for transporting measurement messages. transport::PublisherPtr gazeboSensorOutputPub Gazebo's publisher for transporting measurement messages. ros::ServiceServer changeSensorSrv Service server object. ros::Publisher pluginStatePub ROS publisher for the switchable sensor data. ignition::math::Pose3d referenceFrame Pose of the reference frame wrt world frame. ros::Subscriber tfStaticSub ROS subscriber for the TF static reference frame. std::string referenceFrameID Frame ID of the reference frame. bool isReferenceInit Flag set to true if reference frame initialized. physics::LinkPtr referenceLink Reference link. Public Functions Documentation function MagnetometerROSPlugin MagnetometerROSPlugin() Class constructor. function ~MagnetometerROSPlugin virtual ~MagnetometerROSPlugin() Class destructor. function Load virtual void Load( physics::ModelPtr _model, sdf::ElementPtr _sdf ) Load the plugin. Reimplements : gazebo::ROSBaseModelPlugin::Load Protected Functions Documentation function OnUpdate virtual bool OnUpdate( const common::UpdateInfo & _info ) Update sensor measurement. Reimplements : gazebo::ROSBaseModelPlugin::OnUpdate Protected Attributes Documentation variable parameters MagnetometerParameters parameters; Magnetometer configuration parameters: variable magneticFieldWorld ignition::math::Vector3d magneticFieldWorld; Reference magnetic field in world frame: variable turnOnBias ignition::math::Vector3d turnOnBias; Constant turn-on bias [muT]. variable measMagneticField ignition::math::Vector3d measMagneticField; Last measurement of magnetic field. variable rosMsg sensor_msgs::MagneticField rosMsg; ROS message. Updated on 2022-05-30 at 18:35:14 +0000","title":"gazebo::MagnetometerROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1MagnetometerROSPlugin/#gazebomagnetometerrosplugin","text":"Inherits from gazebo::ROSBaseModelPlugin , gazebo::ROSBasePlugin , ModelPlugin","title":"gazebo::MagnetometerROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1MagnetometerROSPlugin/#public-functions","text":"Name MagnetometerROSPlugin () Class constructor. virtual ~MagnetometerROSPlugin () Class destructor. virtual void Load (physics::ModelPtr _model, sdf::ElementPtr _sdf) Load the plugin.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1MagnetometerROSPlugin/#protected-functions","text":"Name virtual bool OnUpdate (const common::UpdateInfo & _info) Update sensor measurement.","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1MagnetometerROSPlugin/#protected-attributes","text":"Name MagnetometerParameters parameters Magnetometer configuration parameters: ignition::math::Vector3d magneticFieldWorld Reference magnetic field in world frame: ignition::math::Vector3d turnOnBias Constant turn-on bias [muT]. ignition::math::Vector3d measMagneticField Last measurement of magnetic field. sensor_msgs::MagneticField rosMsg ROS message.","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1MagnetometerROSPlugin/#additional-inherited-members","text":"Public Functions inherited from gazebo::ROSBaseModelPlugin Name ROSBaseModelPlugin () Class constructor. virtual ~ROSBaseModelPlugin () Class destructor. Protected Functions inherited from gazebo::ROSBaseModelPlugin Name void SendLocalNEDTransform () Returns true if the base_link_ned frame exists. Protected Attributes inherited from gazebo::ROSBaseModelPlugin Name physics::ModelPtr model Pointer to the model. physics::LinkPtr link Pointer to the link. bool enableLocalNEDFrame True if a the local NED frame needs to be broadcasted. tf::TransformBroadcaster * tfBroadcaster TF broadcaster for the local NED frame. ignition::math::Pose3d localNEDFrame Pose of the local NED frame wrt link frame. tf::StampedTransform tfLocalNEDFrame Local NED TF frame. Public Functions inherited from gazebo::ROSBasePlugin Name ROSBasePlugin () Class constructor. virtual ~ROSBasePlugin () Class destructor. bool InitBasePlugin (sdf::ElementPtr _sdf) Initialize base plugin. bool AddNoiseModel (std::string _name, double _sigma) Add noise normal distribution to the list. Protected Functions inherited from gazebo::ROSBasePlugin Name bool IsOn () Returns true if the plugin is activated. void PublishState () Publish the current state of the plugin. bool ChangeSensorState (uuv_sensor_ros_plugins_msgs::ChangeSensorState::Request & _req, uuv_sensor_ros_plugins_msgs::ChangeSensorState::Response & _res) Change sensor state (ON/OFF) void GetTFMessage (const tf::tfMessage::ConstPtr & _msg) Callback function for the static TF message. double GetGaussianNoise (double _amp) Returns noise value for a function with zero mean from the default Gaussian noise model. double GetGaussianNoise (std::string _name, double _amp) Returns noise value for a function with zero mean from a Gaussian noise model according to the model name. bool EnableMeasurement (const common::UpdateInfo & _info) const Enables generation of simulated measurement if the timeout since the last update has been reached. void UpdateReferenceFramePose () Updates the pose of the reference frame wrt the world frame. Protected Attributes inherited from gazebo::ROSBasePlugin Name std::string robotNamespace Robot namespace. std::string sensorOutputTopic Name of the sensor's output topic. physics::WorldPtr world Pointer to the world. event::ConnectionPtr updateConnection Pointer to the update event connection. common::Time lastMeasurementTime (Simulation) time when the last sensor measurement was generated. double updateRate Sensor update rate. double noiseSigma Noise standard deviation. double noiseAmp Noise amplitude. bool gazeboMsgEnabled Flag set to true if the Gazebo sensors messages are supposed to be published as well (it can avoid unnecessary overhead in case) the sensor messages needed are only ROS messages. std::default_random_engine rndGen Pseudo random number generator. std::map< std::string, std::normal_distribution< double > > noiseModels Normal distribution describing the noise models. std_msgs::Bool isOn Flag to control the generation of output messages. boost::shared_ptr< ros::NodeHandle > rosNode ROS node handle for communication with ROS. transport::NodePtr gazeboNode Gazebo's node handle for transporting measurement messages. ros::Publisher rosSensorOutputPub Gazebo's publisher for transporting measurement messages. transport::PublisherPtr gazeboSensorOutputPub Gazebo's publisher for transporting measurement messages. ros::ServiceServer changeSensorSrv Service server object. ros::Publisher pluginStatePub ROS publisher for the switchable sensor data. ignition::math::Pose3d referenceFrame Pose of the reference frame wrt world frame. ros::Subscriber tfStaticSub ROS subscriber for the TF static reference frame. std::string referenceFrameID Frame ID of the reference frame. bool isReferenceInit Flag set to true if reference frame initialized. physics::LinkPtr referenceLink Reference link.","title":"Additional inherited members"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1MagnetometerROSPlugin/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1MagnetometerROSPlugin/#function-magnetometerrosplugin","text":"MagnetometerROSPlugin() Class constructor.","title":"function MagnetometerROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1MagnetometerROSPlugin/#function-magnetometerrosplugin_1","text":"virtual ~MagnetometerROSPlugin() Class destructor.","title":"function ~MagnetometerROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1MagnetometerROSPlugin/#function-load","text":"virtual void Load( physics::ModelPtr _model, sdf::ElementPtr _sdf ) Load the plugin. Reimplements : gazebo::ROSBaseModelPlugin::Load","title":"function Load"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1MagnetometerROSPlugin/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1MagnetometerROSPlugin/#function-onupdate","text":"virtual bool OnUpdate( const common::UpdateInfo & _info ) Update sensor measurement. Reimplements : gazebo::ROSBaseModelPlugin::OnUpdate","title":"function OnUpdate"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1MagnetometerROSPlugin/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1MagnetometerROSPlugin/#variable-parameters","text":"MagnetometerParameters parameters; Magnetometer configuration parameters:","title":"variable parameters"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1MagnetometerROSPlugin/#variable-magneticfieldworld","text":"ignition::math::Vector3d magneticFieldWorld; Reference magnetic field in world frame:","title":"variable magneticFieldWorld"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1MagnetometerROSPlugin/#variable-turnonbias","text":"ignition::math::Vector3d turnOnBias; Constant turn-on bias [muT].","title":"variable turnOnBias"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1MagnetometerROSPlugin/#variable-measmagneticfield","text":"ignition::math::Vector3d measMagneticField; Last measurement of magnetic field.","title":"variable measMagneticField"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1MagnetometerROSPlugin/#variable-rosmsg","text":"sensor_msgs::MagneticField rosMsg; ROS message. Updated on 2022-05-30 at 18:35:14 +0000","title":"variable rosMsg"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1PoseGTROSPlugin/","text":"gazebo::PoseGTROSPlugin Inherits from gazebo::ROSBaseModelPlugin , gazebo::ROSBasePlugin , ModelPlugin Public Functions Name PoseGTROSPlugin () Class constructor. ~PoseGTROSPlugin () Class destructor. virtual void Load (physics::ModelPtr _model, sdf::ElementPtr _sdf) Load the plugin. Protected Functions Name virtual bool OnUpdate (const common::UpdateInfo & _info) Update sensor measurement. void PublishOdomMessage (common::Time _time, ignition::math::Pose3d _pose, ignition::math::Vector3d _linVel, ignition::math::Vector3d _angVel) void UpdateNEDTransform () Protected Attributes Name ros::Publisher nedOdomPub ignition::math::Pose3d offset Pose offset. std::string nedFrameID ignition::math::Pose3d nedTransform bool nedTransformIsInit bool publishNEDOdom tf2_ros::Buffer tfBuffer boost::shared_ptr< tf2_ros::TransformListener > tfListener ignition::math::Vector3d lastLinVel ignition::math::Vector3d lastAngVel ignition::math::Vector3d linAcc ignition::math::Vector3d angAcc ignition::math::Vector3d lastRefLinVel ignition::math::Vector3d lastRefAngVel ignition::math::Vector3d refLinAcc ignition::math::Vector3d refAngAcc Additional inherited members Public Functions inherited from gazebo::ROSBaseModelPlugin Name ROSBaseModelPlugin () Class constructor. virtual ~ROSBaseModelPlugin () Class destructor. Protected Functions inherited from gazebo::ROSBaseModelPlugin Name void SendLocalNEDTransform () Returns true if the base_link_ned frame exists. Protected Attributes inherited from gazebo::ROSBaseModelPlugin Name physics::ModelPtr model Pointer to the model. physics::LinkPtr link Pointer to the link. bool enableLocalNEDFrame True if a the local NED frame needs to be broadcasted. tf::TransformBroadcaster * tfBroadcaster TF broadcaster for the local NED frame. ignition::math::Pose3d localNEDFrame Pose of the local NED frame wrt link frame. tf::StampedTransform tfLocalNEDFrame Local NED TF frame. Public Functions inherited from gazebo::ROSBasePlugin Name ROSBasePlugin () Class constructor. virtual ~ROSBasePlugin () Class destructor. bool InitBasePlugin (sdf::ElementPtr _sdf) Initialize base plugin. bool AddNoiseModel (std::string _name, double _sigma) Add noise normal distribution to the list. Protected Functions inherited from gazebo::ROSBasePlugin Name bool IsOn () Returns true if the plugin is activated. void PublishState () Publish the current state of the plugin. bool ChangeSensorState (uuv_sensor_ros_plugins_msgs::ChangeSensorState::Request & _req, uuv_sensor_ros_plugins_msgs::ChangeSensorState::Response & _res) Change sensor state (ON/OFF) void GetTFMessage (const tf::tfMessage::ConstPtr & _msg) Callback function for the static TF message. double GetGaussianNoise (double _amp) Returns noise value for a function with zero mean from the default Gaussian noise model. double GetGaussianNoise (std::string _name, double _amp) Returns noise value for a function with zero mean from a Gaussian noise model according to the model name. bool EnableMeasurement (const common::UpdateInfo & _info) const Enables generation of simulated measurement if the timeout since the last update has been reached. void UpdateReferenceFramePose () Updates the pose of the reference frame wrt the world frame. Protected Attributes inherited from gazebo::ROSBasePlugin Name std::string robotNamespace Robot namespace. std::string sensorOutputTopic Name of the sensor's output topic. physics::WorldPtr world Pointer to the world. event::ConnectionPtr updateConnection Pointer to the update event connection. common::Time lastMeasurementTime (Simulation) time when the last sensor measurement was generated. double updateRate Sensor update rate. double noiseSigma Noise standard deviation. double noiseAmp Noise amplitude. bool gazeboMsgEnabled Flag set to true if the Gazebo sensors messages are supposed to be published as well (it can avoid unnecessary overhead in case) the sensor messages needed are only ROS messages. std::default_random_engine rndGen Pseudo random number generator. std::map< std::string, std::normal_distribution< double > > noiseModels Normal distribution describing the noise models. std_msgs::Bool isOn Flag to control the generation of output messages. boost::shared_ptr< ros::NodeHandle > rosNode ROS node handle for communication with ROS. transport::NodePtr gazeboNode Gazebo's node handle for transporting measurement messages. ros::Publisher rosSensorOutputPub Gazebo's publisher for transporting measurement messages. transport::PublisherPtr gazeboSensorOutputPub Gazebo's publisher for transporting measurement messages. ros::ServiceServer changeSensorSrv Service server object. ros::Publisher pluginStatePub ROS publisher for the switchable sensor data. ignition::math::Pose3d referenceFrame Pose of the reference frame wrt world frame. ros::Subscriber tfStaticSub ROS subscriber for the TF static reference frame. std::string referenceFrameID Frame ID of the reference frame. bool isReferenceInit Flag set to true if reference frame initialized. physics::LinkPtr referenceLink Reference link. Public Functions Documentation function PoseGTROSPlugin PoseGTROSPlugin() Class constructor. function ~PoseGTROSPlugin ~PoseGTROSPlugin() Class destructor. function Load virtual void Load( physics::ModelPtr _model, sdf::ElementPtr _sdf ) Load the plugin. Reimplements : gazebo::ROSBaseModelPlugin::Load Protected Functions Documentation function OnUpdate virtual bool OnUpdate( const common::UpdateInfo & _info ) Update sensor measurement. Reimplements : gazebo::ROSBaseModelPlugin::OnUpdate function PublishOdomMessage void PublishOdomMessage( common::Time _time, ignition::math::Pose3d _pose, ignition::math::Vector3d _linVel, ignition::math::Vector3d _angVel ) function UpdateNEDTransform void UpdateNEDTransform() Protected Attributes Documentation variable nedOdomPub ros::Publisher nedOdomPub; variable offset ignition::math::Pose3d offset; Pose offset. variable nedFrameID std::string nedFrameID; variable nedTransform ignition::math::Pose3d nedTransform; variable nedTransformIsInit bool nedTransformIsInit; variable publishNEDOdom bool publishNEDOdom; variable tfBuffer tf2_ros::Buffer tfBuffer; variable tfListener boost::shared_ptr< tf2_ros::TransformListener > tfListener; variable lastLinVel ignition::math::Vector3d lastLinVel; variable lastAngVel ignition::math::Vector3d lastAngVel; variable linAcc ignition::math::Vector3d linAcc; variable angAcc ignition::math::Vector3d angAcc; variable lastRefLinVel ignition::math::Vector3d lastRefLinVel; variable lastRefAngVel ignition::math::Vector3d lastRefAngVel; variable refLinAcc ignition::math::Vector3d refLinAcc; variable refAngAcc ignition::math::Vector3d refAngAcc; Updated on 2022-05-30 at 18:35:14 +0000","title":"gazebo::PoseGTROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1PoseGTROSPlugin/#gazeboposegtrosplugin","text":"Inherits from gazebo::ROSBaseModelPlugin , gazebo::ROSBasePlugin , ModelPlugin","title":"gazebo::PoseGTROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1PoseGTROSPlugin/#public-functions","text":"Name PoseGTROSPlugin () Class constructor. ~PoseGTROSPlugin () Class destructor. virtual void Load (physics::ModelPtr _model, sdf::ElementPtr _sdf) Load the plugin.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1PoseGTROSPlugin/#protected-functions","text":"Name virtual bool OnUpdate (const common::UpdateInfo & _info) Update sensor measurement. void PublishOdomMessage (common::Time _time, ignition::math::Pose3d _pose, ignition::math::Vector3d _linVel, ignition::math::Vector3d _angVel) void UpdateNEDTransform ()","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1PoseGTROSPlugin/#protected-attributes","text":"Name ros::Publisher nedOdomPub ignition::math::Pose3d offset Pose offset. std::string nedFrameID ignition::math::Pose3d nedTransform bool nedTransformIsInit bool publishNEDOdom tf2_ros::Buffer tfBuffer boost::shared_ptr< tf2_ros::TransformListener > tfListener ignition::math::Vector3d lastLinVel ignition::math::Vector3d lastAngVel ignition::math::Vector3d linAcc ignition::math::Vector3d angAcc ignition::math::Vector3d lastRefLinVel ignition::math::Vector3d lastRefAngVel ignition::math::Vector3d refLinAcc ignition::math::Vector3d refAngAcc","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1PoseGTROSPlugin/#additional-inherited-members","text":"Public Functions inherited from gazebo::ROSBaseModelPlugin Name ROSBaseModelPlugin () Class constructor. virtual ~ROSBaseModelPlugin () Class destructor. Protected Functions inherited from gazebo::ROSBaseModelPlugin Name void SendLocalNEDTransform () Returns true if the base_link_ned frame exists. Protected Attributes inherited from gazebo::ROSBaseModelPlugin Name physics::ModelPtr model Pointer to the model. physics::LinkPtr link Pointer to the link. bool enableLocalNEDFrame True if a the local NED frame needs to be broadcasted. tf::TransformBroadcaster * tfBroadcaster TF broadcaster for the local NED frame. ignition::math::Pose3d localNEDFrame Pose of the local NED frame wrt link frame. tf::StampedTransform tfLocalNEDFrame Local NED TF frame. Public Functions inherited from gazebo::ROSBasePlugin Name ROSBasePlugin () Class constructor. virtual ~ROSBasePlugin () Class destructor. bool InitBasePlugin (sdf::ElementPtr _sdf) Initialize base plugin. bool AddNoiseModel (std::string _name, double _sigma) Add noise normal distribution to the list. Protected Functions inherited from gazebo::ROSBasePlugin Name bool IsOn () Returns true if the plugin is activated. void PublishState () Publish the current state of the plugin. bool ChangeSensorState (uuv_sensor_ros_plugins_msgs::ChangeSensorState::Request & _req, uuv_sensor_ros_plugins_msgs::ChangeSensorState::Response & _res) Change sensor state (ON/OFF) void GetTFMessage (const tf::tfMessage::ConstPtr & _msg) Callback function for the static TF message. double GetGaussianNoise (double _amp) Returns noise value for a function with zero mean from the default Gaussian noise model. double GetGaussianNoise (std::string _name, double _amp) Returns noise value for a function with zero mean from a Gaussian noise model according to the model name. bool EnableMeasurement (const common::UpdateInfo & _info) const Enables generation of simulated measurement if the timeout since the last update has been reached. void UpdateReferenceFramePose () Updates the pose of the reference frame wrt the world frame. Protected Attributes inherited from gazebo::ROSBasePlugin Name std::string robotNamespace Robot namespace. std::string sensorOutputTopic Name of the sensor's output topic. physics::WorldPtr world Pointer to the world. event::ConnectionPtr updateConnection Pointer to the update event connection. common::Time lastMeasurementTime (Simulation) time when the last sensor measurement was generated. double updateRate Sensor update rate. double noiseSigma Noise standard deviation. double noiseAmp Noise amplitude. bool gazeboMsgEnabled Flag set to true if the Gazebo sensors messages are supposed to be published as well (it can avoid unnecessary overhead in case) the sensor messages needed are only ROS messages. std::default_random_engine rndGen Pseudo random number generator. std::map< std::string, std::normal_distribution< double > > noiseModels Normal distribution describing the noise models. std_msgs::Bool isOn Flag to control the generation of output messages. boost::shared_ptr< ros::NodeHandle > rosNode ROS node handle for communication with ROS. transport::NodePtr gazeboNode Gazebo's node handle for transporting measurement messages. ros::Publisher rosSensorOutputPub Gazebo's publisher for transporting measurement messages. transport::PublisherPtr gazeboSensorOutputPub Gazebo's publisher for transporting measurement messages. ros::ServiceServer changeSensorSrv Service server object. ros::Publisher pluginStatePub ROS publisher for the switchable sensor data. ignition::math::Pose3d referenceFrame Pose of the reference frame wrt world frame. ros::Subscriber tfStaticSub ROS subscriber for the TF static reference frame. std::string referenceFrameID Frame ID of the reference frame. bool isReferenceInit Flag set to true if reference frame initialized. physics::LinkPtr referenceLink Reference link.","title":"Additional inherited members"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1PoseGTROSPlugin/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1PoseGTROSPlugin/#function-posegtrosplugin","text":"PoseGTROSPlugin() Class constructor.","title":"function PoseGTROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1PoseGTROSPlugin/#function-posegtrosplugin_1","text":"~PoseGTROSPlugin() Class destructor.","title":"function ~PoseGTROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1PoseGTROSPlugin/#function-load","text":"virtual void Load( physics::ModelPtr _model, sdf::ElementPtr _sdf ) Load the plugin. Reimplements : gazebo::ROSBaseModelPlugin::Load","title":"function Load"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1PoseGTROSPlugin/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1PoseGTROSPlugin/#function-onupdate","text":"virtual bool OnUpdate( const common::UpdateInfo & _info ) Update sensor measurement. Reimplements : gazebo::ROSBaseModelPlugin::OnUpdate","title":"function OnUpdate"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1PoseGTROSPlugin/#function-publishodommessage","text":"void PublishOdomMessage( common::Time _time, ignition::math::Pose3d _pose, ignition::math::Vector3d _linVel, ignition::math::Vector3d _angVel )","title":"function PublishOdomMessage"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1PoseGTROSPlugin/#function-updatenedtransform","text":"void UpdateNEDTransform()","title":"function UpdateNEDTransform"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1PoseGTROSPlugin/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1PoseGTROSPlugin/#variable-nedodompub","text":"ros::Publisher nedOdomPub;","title":"variable nedOdomPub"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1PoseGTROSPlugin/#variable-offset","text":"ignition::math::Pose3d offset; Pose offset.","title":"variable offset"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1PoseGTROSPlugin/#variable-nedframeid","text":"std::string nedFrameID;","title":"variable nedFrameID"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1PoseGTROSPlugin/#variable-nedtransform","text":"ignition::math::Pose3d nedTransform;","title":"variable nedTransform"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1PoseGTROSPlugin/#variable-nedtransformisinit","text":"bool nedTransformIsInit;","title":"variable nedTransformIsInit"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1PoseGTROSPlugin/#variable-publishnedodom","text":"bool publishNEDOdom;","title":"variable publishNEDOdom"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1PoseGTROSPlugin/#variable-tfbuffer","text":"tf2_ros::Buffer tfBuffer;","title":"variable tfBuffer"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1PoseGTROSPlugin/#variable-tflistener","text":"boost::shared_ptr< tf2_ros::TransformListener > tfListener;","title":"variable tfListener"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1PoseGTROSPlugin/#variable-lastlinvel","text":"ignition::math::Vector3d lastLinVel;","title":"variable lastLinVel"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1PoseGTROSPlugin/#variable-lastangvel","text":"ignition::math::Vector3d lastAngVel;","title":"variable lastAngVel"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1PoseGTROSPlugin/#variable-linacc","text":"ignition::math::Vector3d linAcc;","title":"variable linAcc"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1PoseGTROSPlugin/#variable-angacc","text":"ignition::math::Vector3d angAcc;","title":"variable angAcc"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1PoseGTROSPlugin/#variable-lastreflinvel","text":"ignition::math::Vector3d lastRefLinVel;","title":"variable lastRefLinVel"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1PoseGTROSPlugin/#variable-lastrefangvel","text":"ignition::math::Vector3d lastRefAngVel;","title":"variable lastRefAngVel"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1PoseGTROSPlugin/#variable-reflinacc","text":"ignition::math::Vector3d refLinAcc;","title":"variable refLinAcc"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1PoseGTROSPlugin/#variable-refangacc","text":"ignition::math::Vector3d refAngAcc; Updated on 2022-05-30 at 18:35:14 +0000","title":"variable refAngAcc"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseModelPlugin/","text":"gazebo::ROSBaseModelPlugin Inherits from gazebo::ROSBasePlugin , ModelPlugin Inherited by gazebo::CPCROSPlugin , gazebo::DVLROSPlugin , gazebo::IMUROSPlugin , gazebo::MagnetometerROSPlugin , gazebo::PoseGTROSPlugin , gazebo::RPTROSPlugin , gazebo::SubseaPressureROSPlugin Public Functions Name ROSBaseModelPlugin () Class constructor. virtual ~ROSBaseModelPlugin () Class destructor. Protected Functions Name virtual void Load (physics::ModelPtr _model, sdf::ElementPtr _sdf) Load plugin and its configuration from sdf,. virtual bool OnUpdate (const common::UpdateInfo & ) Update callback from simulation. void SendLocalNEDTransform () Returns true if the base_link_ned frame exists. Protected Attributes Name physics::ModelPtr model Pointer to the model. physics::LinkPtr link Pointer to the link. bool enableLocalNEDFrame True if a the local NED frame needs to be broadcasted. tf::TransformBroadcaster * tfBroadcaster TF broadcaster for the local NED frame. ignition::math::Pose3d localNEDFrame Pose of the local NED frame wrt link frame. tf::StampedTransform tfLocalNEDFrame Local NED TF frame. Additional inherited members Public Functions inherited from gazebo::ROSBasePlugin Name ROSBasePlugin () Class constructor. virtual ~ROSBasePlugin () Class destructor. bool InitBasePlugin (sdf::ElementPtr _sdf) Initialize base plugin. bool AddNoiseModel (std::string _name, double _sigma) Add noise normal distribution to the list. Protected Functions inherited from gazebo::ROSBasePlugin Name bool IsOn () Returns true if the plugin is activated. void PublishState () Publish the current state of the plugin. bool ChangeSensorState (uuv_sensor_ros_plugins_msgs::ChangeSensorState::Request & _req, uuv_sensor_ros_plugins_msgs::ChangeSensorState::Response & _res) Change sensor state (ON/OFF) void GetTFMessage (const tf::tfMessage::ConstPtr & _msg) Callback function for the static TF message. double GetGaussianNoise (double _amp) Returns noise value for a function with zero mean from the default Gaussian noise model. double GetGaussianNoise (std::string _name, double _amp) Returns noise value for a function with zero mean from a Gaussian noise model according to the model name. bool EnableMeasurement (const common::UpdateInfo & _info) const Enables generation of simulated measurement if the timeout since the last update has been reached. void UpdateReferenceFramePose () Updates the pose of the reference frame wrt the world frame. Protected Attributes inherited from gazebo::ROSBasePlugin Name std::string robotNamespace Robot namespace. std::string sensorOutputTopic Name of the sensor's output topic. physics::WorldPtr world Pointer to the world. event::ConnectionPtr updateConnection Pointer to the update event connection. common::Time lastMeasurementTime (Simulation) time when the last sensor measurement was generated. double updateRate Sensor update rate. double noiseSigma Noise standard deviation. double noiseAmp Noise amplitude. bool gazeboMsgEnabled Flag set to true if the Gazebo sensors messages are supposed to be published as well (it can avoid unnecessary overhead in case) the sensor messages needed are only ROS messages. std::default_random_engine rndGen Pseudo random number generator. std::map< std::string, std::normal_distribution< double > > noiseModels Normal distribution describing the noise models. std_msgs::Bool isOn Flag to control the generation of output messages. boost::shared_ptr< ros::NodeHandle > rosNode ROS node handle for communication with ROS. transport::NodePtr gazeboNode Gazebo's node handle for transporting measurement messages. ros::Publisher rosSensorOutputPub Gazebo's publisher for transporting measurement messages. transport::PublisherPtr gazeboSensorOutputPub Gazebo's publisher for transporting measurement messages. ros::ServiceServer changeSensorSrv Service server object. ros::Publisher pluginStatePub ROS publisher for the switchable sensor data. ignition::math::Pose3d referenceFrame Pose of the reference frame wrt world frame. ros::Subscriber tfStaticSub ROS subscriber for the TF static reference frame. std::string referenceFrameID Frame ID of the reference frame. bool isReferenceInit Flag set to true if reference frame initialized. physics::LinkPtr referenceLink Reference link. Public Functions Documentation function ROSBaseModelPlugin ROSBaseModelPlugin() Class constructor. function ~ROSBaseModelPlugin virtual ~ROSBaseModelPlugin() Class destructor. Protected Functions Documentation function Load virtual void Load( physics::ModelPtr _model, sdf::ElementPtr _sdf ) Load plugin and its configuration from sdf,. Reimplemented by : gazebo::SubseaPressureROSPlugin::Load , gazebo::RPTROSPlugin::Load , gazebo::CPCROSPlugin::Load , gazebo::PoseGTROSPlugin::Load , gazebo::DVLROSPlugin::Load , gazebo::MagnetometerROSPlugin::Load , gazebo::IMUROSPlugin::Load function OnUpdate virtual bool OnUpdate( const common::UpdateInfo & ) Update callback from simulation. Reimplements : gazebo::ROSBasePlugin::OnUpdate Reimplemented by : gazebo::SubseaPressureROSPlugin::OnUpdate , gazebo::RPTROSPlugin::OnUpdate , gazebo::CPCROSPlugin::OnUpdate , gazebo::PoseGTROSPlugin::OnUpdate , gazebo::DVLROSPlugin::OnUpdate , gazebo::MagnetometerROSPlugin::OnUpdate , gazebo::IMUROSPlugin::OnUpdate function SendLocalNEDTransform void SendLocalNEDTransform() Returns true if the base_link_ned frame exists. Protected Attributes Documentation variable model physics::ModelPtr model; Pointer to the model. variable link physics::LinkPtr link; Pointer to the link. variable enableLocalNEDFrame bool enableLocalNEDFrame; True if a the local NED frame needs to be broadcasted. variable tfBroadcaster tf::TransformBroadcaster * tfBroadcaster; TF broadcaster for the local NED frame. variable localNEDFrame ignition::math::Pose3d localNEDFrame; Pose of the local NED frame wrt link frame. variable tfLocalNEDFrame tf::StampedTransform tfLocalNEDFrame; Local NED TF frame. Updated on 2022-05-30 at 18:35:14 +0000","title":"gazebo::ROSBaseModelPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseModelPlugin/#gazeborosbasemodelplugin","text":"Inherits from gazebo::ROSBasePlugin , ModelPlugin Inherited by gazebo::CPCROSPlugin , gazebo::DVLROSPlugin , gazebo::IMUROSPlugin , gazebo::MagnetometerROSPlugin , gazebo::PoseGTROSPlugin , gazebo::RPTROSPlugin , gazebo::SubseaPressureROSPlugin","title":"gazebo::ROSBaseModelPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseModelPlugin/#public-functions","text":"Name ROSBaseModelPlugin () Class constructor. virtual ~ROSBaseModelPlugin () Class destructor.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseModelPlugin/#protected-functions","text":"Name virtual void Load (physics::ModelPtr _model, sdf::ElementPtr _sdf) Load plugin and its configuration from sdf,. virtual bool OnUpdate (const common::UpdateInfo & ) Update callback from simulation. void SendLocalNEDTransform () Returns true if the base_link_ned frame exists.","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseModelPlugin/#protected-attributes","text":"Name physics::ModelPtr model Pointer to the model. physics::LinkPtr link Pointer to the link. bool enableLocalNEDFrame True if a the local NED frame needs to be broadcasted. tf::TransformBroadcaster * tfBroadcaster TF broadcaster for the local NED frame. ignition::math::Pose3d localNEDFrame Pose of the local NED frame wrt link frame. tf::StampedTransform tfLocalNEDFrame Local NED TF frame.","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseModelPlugin/#additional-inherited-members","text":"Public Functions inherited from gazebo::ROSBasePlugin Name ROSBasePlugin () Class constructor. virtual ~ROSBasePlugin () Class destructor. bool InitBasePlugin (sdf::ElementPtr _sdf) Initialize base plugin. bool AddNoiseModel (std::string _name, double _sigma) Add noise normal distribution to the list. Protected Functions inherited from gazebo::ROSBasePlugin Name bool IsOn () Returns true if the plugin is activated. void PublishState () Publish the current state of the plugin. bool ChangeSensorState (uuv_sensor_ros_plugins_msgs::ChangeSensorState::Request & _req, uuv_sensor_ros_plugins_msgs::ChangeSensorState::Response & _res) Change sensor state (ON/OFF) void GetTFMessage (const tf::tfMessage::ConstPtr & _msg) Callback function for the static TF message. double GetGaussianNoise (double _amp) Returns noise value for a function with zero mean from the default Gaussian noise model. double GetGaussianNoise (std::string _name, double _amp) Returns noise value for a function with zero mean from a Gaussian noise model according to the model name. bool EnableMeasurement (const common::UpdateInfo & _info) const Enables generation of simulated measurement if the timeout since the last update has been reached. void UpdateReferenceFramePose () Updates the pose of the reference frame wrt the world frame. Protected Attributes inherited from gazebo::ROSBasePlugin Name std::string robotNamespace Robot namespace. std::string sensorOutputTopic Name of the sensor's output topic. physics::WorldPtr world Pointer to the world. event::ConnectionPtr updateConnection Pointer to the update event connection. common::Time lastMeasurementTime (Simulation) time when the last sensor measurement was generated. double updateRate Sensor update rate. double noiseSigma Noise standard deviation. double noiseAmp Noise amplitude. bool gazeboMsgEnabled Flag set to true if the Gazebo sensors messages are supposed to be published as well (it can avoid unnecessary overhead in case) the sensor messages needed are only ROS messages. std::default_random_engine rndGen Pseudo random number generator. std::map< std::string, std::normal_distribution< double > > noiseModels Normal distribution describing the noise models. std_msgs::Bool isOn Flag to control the generation of output messages. boost::shared_ptr< ros::NodeHandle > rosNode ROS node handle for communication with ROS. transport::NodePtr gazeboNode Gazebo's node handle for transporting measurement messages. ros::Publisher rosSensorOutputPub Gazebo's publisher for transporting measurement messages. transport::PublisherPtr gazeboSensorOutputPub Gazebo's publisher for transporting measurement messages. ros::ServiceServer changeSensorSrv Service server object. ros::Publisher pluginStatePub ROS publisher for the switchable sensor data. ignition::math::Pose3d referenceFrame Pose of the reference frame wrt world frame. ros::Subscriber tfStaticSub ROS subscriber for the TF static reference frame. std::string referenceFrameID Frame ID of the reference frame. bool isReferenceInit Flag set to true if reference frame initialized. physics::LinkPtr referenceLink Reference link.","title":"Additional inherited members"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseModelPlugin/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseModelPlugin/#function-rosbasemodelplugin","text":"ROSBaseModelPlugin() Class constructor.","title":"function ROSBaseModelPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseModelPlugin/#function-rosbasemodelplugin_1","text":"virtual ~ROSBaseModelPlugin() Class destructor.","title":"function ~ROSBaseModelPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseModelPlugin/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseModelPlugin/#function-load","text":"virtual void Load( physics::ModelPtr _model, sdf::ElementPtr _sdf ) Load plugin and its configuration from sdf,. Reimplemented by : gazebo::SubseaPressureROSPlugin::Load , gazebo::RPTROSPlugin::Load , gazebo::CPCROSPlugin::Load , gazebo::PoseGTROSPlugin::Load , gazebo::DVLROSPlugin::Load , gazebo::MagnetometerROSPlugin::Load , gazebo::IMUROSPlugin::Load","title":"function Load"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseModelPlugin/#function-onupdate","text":"virtual bool OnUpdate( const common::UpdateInfo & ) Update callback from simulation. Reimplements : gazebo::ROSBasePlugin::OnUpdate Reimplemented by : gazebo::SubseaPressureROSPlugin::OnUpdate , gazebo::RPTROSPlugin::OnUpdate , gazebo::CPCROSPlugin::OnUpdate , gazebo::PoseGTROSPlugin::OnUpdate , gazebo::DVLROSPlugin::OnUpdate , gazebo::MagnetometerROSPlugin::OnUpdate , gazebo::IMUROSPlugin::OnUpdate","title":"function OnUpdate"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseModelPlugin/#function-sendlocalnedtransform","text":"void SendLocalNEDTransform() Returns true if the base_link_ned frame exists.","title":"function SendLocalNEDTransform"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseModelPlugin/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseModelPlugin/#variable-model","text":"physics::ModelPtr model; Pointer to the model.","title":"variable model"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseModelPlugin/#variable-link","text":"physics::LinkPtr link; Pointer to the link.","title":"variable link"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseModelPlugin/#variable-enablelocalnedframe","text":"bool enableLocalNEDFrame; True if a the local NED frame needs to be broadcasted.","title":"variable enableLocalNEDFrame"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseModelPlugin/#variable-tfbroadcaster","text":"tf::TransformBroadcaster * tfBroadcaster; TF broadcaster for the local NED frame.","title":"variable tfBroadcaster"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseModelPlugin/#variable-localnedframe","text":"ignition::math::Pose3d localNEDFrame; Pose of the local NED frame wrt link frame.","title":"variable localNEDFrame"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseModelPlugin/#variable-tflocalnedframe","text":"tf::StampedTransform tfLocalNEDFrame; Local NED TF frame. Updated on 2022-05-30 at 18:35:14 +0000","title":"variable tfLocalNEDFrame"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/","text":"gazebo::ROSBasePlugin Inherited by gazebo::ROSBaseModelPlugin , gazebo::ROSBaseSensorPlugin Public Functions Name ROSBasePlugin () Class constructor. virtual ~ROSBasePlugin () Class destructor. bool InitBasePlugin (sdf::ElementPtr _sdf) Initialize base plugin. virtual bool OnUpdate (const common::UpdateInfo & ) =0 Update callback from simulation. bool AddNoiseModel (std::string _name, double _sigma) Add noise normal distribution to the list. Protected Functions Name bool IsOn () Returns true if the plugin is activated. void PublishState () Publish the current state of the plugin. bool ChangeSensorState (uuv_sensor_ros_plugins_msgs::ChangeSensorState::Request & _req, uuv_sensor_ros_plugins_msgs::ChangeSensorState::Response & _res) Change sensor state (ON/OFF) void GetTFMessage (const tf::tfMessage::ConstPtr & _msg) Callback function for the static TF message. double GetGaussianNoise (double _amp) Returns noise value for a function with zero mean from the default Gaussian noise model. double GetGaussianNoise (std::string _name, double _amp) Returns noise value for a function with zero mean from a Gaussian noise model according to the model name. bool EnableMeasurement (const common::UpdateInfo & _info) const Enables generation of simulated measurement if the timeout since the last update has been reached. void UpdateReferenceFramePose () Updates the pose of the reference frame wrt the world frame. Protected Attributes Name std::string robotNamespace Robot namespace. std::string sensorOutputTopic Name of the sensor's output topic. physics::WorldPtr world Pointer to the world. event::ConnectionPtr updateConnection Pointer to the update event connection. common::Time lastMeasurementTime (Simulation) time when the last sensor measurement was generated. double updateRate Sensor update rate. double noiseSigma Noise standard deviation. double noiseAmp Noise amplitude. bool gazeboMsgEnabled Flag set to true if the Gazebo sensors messages are supposed to be published as well (it can avoid unnecessary overhead in case) the sensor messages needed are only ROS messages. std::default_random_engine rndGen Pseudo random number generator. std::map< std::string, std::normal_distribution< double > > noiseModels Normal distribution describing the noise models. std_msgs::Bool isOn Flag to control the generation of output messages. boost::shared_ptr< ros::NodeHandle > rosNode ROS node handle for communication with ROS. transport::NodePtr gazeboNode Gazebo's node handle for transporting measurement messages. ros::Publisher rosSensorOutputPub Gazebo's publisher for transporting measurement messages. transport::PublisherPtr gazeboSensorOutputPub Gazebo's publisher for transporting measurement messages. ros::ServiceServer changeSensorSrv Service server object. ros::Publisher pluginStatePub ROS publisher for the switchable sensor data. ignition::math::Pose3d referenceFrame Pose of the reference frame wrt world frame. ros::Subscriber tfStaticSub ROS subscriber for the TF static reference frame. std::string referenceFrameID Frame ID of the reference frame. bool isReferenceInit Flag set to true if reference frame initialized. physics::LinkPtr referenceLink Reference link. Public Functions Documentation function ROSBasePlugin ROSBasePlugin() Class constructor. function ~ROSBasePlugin virtual ~ROSBasePlugin() Class destructor. function InitBasePlugin bool InitBasePlugin( sdf::ElementPtr _sdf ) Initialize base plugin. function OnUpdate virtual bool OnUpdate( const common::UpdateInfo & ) =0 Update callback from simulation. Reimplemented by : gazebo::ROSBaseSensorPlugin::OnUpdate , gazebo::ROSBaseModelPlugin::OnUpdate , gazebo::SubseaPressureROSPlugin::OnUpdate , gazebo::RPTROSPlugin::OnUpdate , gazebo::CPCROSPlugin::OnUpdate , gazebo::PoseGTROSPlugin::OnUpdate , gazebo::DVLROSPlugin::OnUpdate , gazebo::MagnetometerROSPlugin::OnUpdate , gazebo::IMUROSPlugin::OnUpdate function AddNoiseModel bool AddNoiseModel( std::string _name, double _sigma ) Add noise normal distribution to the list. Protected Functions Documentation function IsOn bool IsOn() Returns true if the plugin is activated. function PublishState void PublishState() Publish the current state of the plugin. function ChangeSensorState bool ChangeSensorState( uuv_sensor_ros_plugins_msgs::ChangeSensorState::Request & _req, uuv_sensor_ros_plugins_msgs::ChangeSensorState::Response & _res ) Change sensor state (ON/OFF) function GetTFMessage void GetTFMessage( const tf::tfMessage::ConstPtr & _msg ) Callback function for the static TF message. function GetGaussianNoise double GetGaussianNoise( double _amp ) Returns noise value for a function with zero mean from the default Gaussian noise model. function GetGaussianNoise double GetGaussianNoise( std::string _name, double _amp ) Returns noise value for a function with zero mean from a Gaussian noise model according to the model name. function EnableMeasurement bool EnableMeasurement( const common::UpdateInfo & _info ) const Enables generation of simulated measurement if the timeout since the last update has been reached. function UpdateReferenceFramePose void UpdateReferenceFramePose() Updates the pose of the reference frame wrt the world frame. Protected Attributes Documentation variable robotNamespace std::string robotNamespace; Robot namespace. variable sensorOutputTopic std::string sensorOutputTopic; Name of the sensor's output topic. variable world physics::WorldPtr world; Pointer to the world. variable updateConnection event::ConnectionPtr updateConnection; Pointer to the update event connection. variable lastMeasurementTime common::Time lastMeasurementTime; (Simulation) time when the last sensor measurement was generated. variable updateRate double updateRate; Sensor update rate. variable noiseSigma double noiseSigma; Noise standard deviation. variable noiseAmp double noiseAmp; Noise amplitude. variable gazeboMsgEnabled bool gazeboMsgEnabled; Flag set to true if the Gazebo sensors messages are supposed to be published as well (it can avoid unnecessary overhead in case) the sensor messages needed are only ROS messages. variable rndGen std::default_random_engine rndGen; Pseudo random number generator. variable noiseModels std::map< std::string, std::normal_distribution< double > > noiseModels; Normal distribution describing the noise models. variable isOn std_msgs::Bool isOn; Flag to control the generation of output messages. variable rosNode boost::shared_ptr< ros::NodeHandle > rosNode; ROS node handle for communication with ROS. variable gazeboNode transport::NodePtr gazeboNode; Gazebo's node handle for transporting measurement messages. variable rosSensorOutputPub ros::Publisher rosSensorOutputPub; Gazebo's publisher for transporting measurement messages. variable gazeboSensorOutputPub transport::PublisherPtr gazeboSensorOutputPub; Gazebo's publisher for transporting measurement messages. variable changeSensorSrv ros::ServiceServer changeSensorSrv; Service server object. variable pluginStatePub ros::Publisher pluginStatePub; ROS publisher for the switchable sensor data. variable referenceFrame ignition::math::Pose3d referenceFrame; Pose of the reference frame wrt world frame. variable tfStaticSub ros::Subscriber tfStaticSub; ROS subscriber for the TF static reference frame. variable referenceFrameID std::string referenceFrameID; Frame ID of the reference frame. variable isReferenceInit bool isReferenceInit; Flag set to true if reference frame initialized. variable referenceLink physics::LinkPtr referenceLink; Reference link. Updated on 2022-05-30 at 18:35:14 +0000","title":"gazebo::ROSBasePlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#gazeborosbaseplugin","text":"Inherited by gazebo::ROSBaseModelPlugin , gazebo::ROSBaseSensorPlugin","title":"gazebo::ROSBasePlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#public-functions","text":"Name ROSBasePlugin () Class constructor. virtual ~ROSBasePlugin () Class destructor. bool InitBasePlugin (sdf::ElementPtr _sdf) Initialize base plugin. virtual bool OnUpdate (const common::UpdateInfo & ) =0 Update callback from simulation. bool AddNoiseModel (std::string _name, double _sigma) Add noise normal distribution to the list.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#protected-functions","text":"Name bool IsOn () Returns true if the plugin is activated. void PublishState () Publish the current state of the plugin. bool ChangeSensorState (uuv_sensor_ros_plugins_msgs::ChangeSensorState::Request & _req, uuv_sensor_ros_plugins_msgs::ChangeSensorState::Response & _res) Change sensor state (ON/OFF) void GetTFMessage (const tf::tfMessage::ConstPtr & _msg) Callback function for the static TF message. double GetGaussianNoise (double _amp) Returns noise value for a function with zero mean from the default Gaussian noise model. double GetGaussianNoise (std::string _name, double _amp) Returns noise value for a function with zero mean from a Gaussian noise model according to the model name. bool EnableMeasurement (const common::UpdateInfo & _info) const Enables generation of simulated measurement if the timeout since the last update has been reached. void UpdateReferenceFramePose () Updates the pose of the reference frame wrt the world frame.","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#protected-attributes","text":"Name std::string robotNamespace Robot namespace. std::string sensorOutputTopic Name of the sensor's output topic. physics::WorldPtr world Pointer to the world. event::ConnectionPtr updateConnection Pointer to the update event connection. common::Time lastMeasurementTime (Simulation) time when the last sensor measurement was generated. double updateRate Sensor update rate. double noiseSigma Noise standard deviation. double noiseAmp Noise amplitude. bool gazeboMsgEnabled Flag set to true if the Gazebo sensors messages are supposed to be published as well (it can avoid unnecessary overhead in case) the sensor messages needed are only ROS messages. std::default_random_engine rndGen Pseudo random number generator. std::map< std::string, std::normal_distribution< double > > noiseModels Normal distribution describing the noise models. std_msgs::Bool isOn Flag to control the generation of output messages. boost::shared_ptr< ros::NodeHandle > rosNode ROS node handle for communication with ROS. transport::NodePtr gazeboNode Gazebo's node handle for transporting measurement messages. ros::Publisher rosSensorOutputPub Gazebo's publisher for transporting measurement messages. transport::PublisherPtr gazeboSensorOutputPub Gazebo's publisher for transporting measurement messages. ros::ServiceServer changeSensorSrv Service server object. ros::Publisher pluginStatePub ROS publisher for the switchable sensor data. ignition::math::Pose3d referenceFrame Pose of the reference frame wrt world frame. ros::Subscriber tfStaticSub ROS subscriber for the TF static reference frame. std::string referenceFrameID Frame ID of the reference frame. bool isReferenceInit Flag set to true if reference frame initialized. physics::LinkPtr referenceLink Reference link.","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#function-rosbaseplugin","text":"ROSBasePlugin() Class constructor.","title":"function ROSBasePlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#function-rosbaseplugin_1","text":"virtual ~ROSBasePlugin() Class destructor.","title":"function ~ROSBasePlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#function-initbaseplugin","text":"bool InitBasePlugin( sdf::ElementPtr _sdf ) Initialize base plugin.","title":"function InitBasePlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#function-onupdate","text":"virtual bool OnUpdate( const common::UpdateInfo & ) =0 Update callback from simulation. Reimplemented by : gazebo::ROSBaseSensorPlugin::OnUpdate , gazebo::ROSBaseModelPlugin::OnUpdate , gazebo::SubseaPressureROSPlugin::OnUpdate , gazebo::RPTROSPlugin::OnUpdate , gazebo::CPCROSPlugin::OnUpdate , gazebo::PoseGTROSPlugin::OnUpdate , gazebo::DVLROSPlugin::OnUpdate , gazebo::MagnetometerROSPlugin::OnUpdate , gazebo::IMUROSPlugin::OnUpdate","title":"function OnUpdate"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#function-addnoisemodel","text":"bool AddNoiseModel( std::string _name, double _sigma ) Add noise normal distribution to the list.","title":"function AddNoiseModel"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#function-ison","text":"bool IsOn() Returns true if the plugin is activated.","title":"function IsOn"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#function-publishstate","text":"void PublishState() Publish the current state of the plugin.","title":"function PublishState"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#function-changesensorstate","text":"bool ChangeSensorState( uuv_sensor_ros_plugins_msgs::ChangeSensorState::Request & _req, uuv_sensor_ros_plugins_msgs::ChangeSensorState::Response & _res ) Change sensor state (ON/OFF)","title":"function ChangeSensorState"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#function-gettfmessage","text":"void GetTFMessage( const tf::tfMessage::ConstPtr & _msg ) Callback function for the static TF message.","title":"function GetTFMessage"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#function-getgaussiannoise","text":"double GetGaussianNoise( double _amp ) Returns noise value for a function with zero mean from the default Gaussian noise model.","title":"function GetGaussianNoise"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#function-getgaussiannoise_1","text":"double GetGaussianNoise( std::string _name, double _amp ) Returns noise value for a function with zero mean from a Gaussian noise model according to the model name.","title":"function GetGaussianNoise"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#function-enablemeasurement","text":"bool EnableMeasurement( const common::UpdateInfo & _info ) const Enables generation of simulated measurement if the timeout since the last update has been reached.","title":"function EnableMeasurement"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#function-updatereferenceframepose","text":"void UpdateReferenceFramePose() Updates the pose of the reference frame wrt the world frame.","title":"function UpdateReferenceFramePose"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#variable-robotnamespace","text":"std::string robotNamespace; Robot namespace.","title":"variable robotNamespace"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#variable-sensoroutputtopic","text":"std::string sensorOutputTopic; Name of the sensor's output topic.","title":"variable sensorOutputTopic"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#variable-world","text":"physics::WorldPtr world; Pointer to the world.","title":"variable world"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#variable-updateconnection","text":"event::ConnectionPtr updateConnection; Pointer to the update event connection.","title":"variable updateConnection"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#variable-lastmeasurementtime","text":"common::Time lastMeasurementTime; (Simulation) time when the last sensor measurement was generated.","title":"variable lastMeasurementTime"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#variable-updaterate","text":"double updateRate; Sensor update rate.","title":"variable updateRate"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#variable-noisesigma","text":"double noiseSigma; Noise standard deviation.","title":"variable noiseSigma"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#variable-noiseamp","text":"double noiseAmp; Noise amplitude.","title":"variable noiseAmp"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#variable-gazebomsgenabled","text":"bool gazeboMsgEnabled; Flag set to true if the Gazebo sensors messages are supposed to be published as well (it can avoid unnecessary overhead in case) the sensor messages needed are only ROS messages.","title":"variable gazeboMsgEnabled"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#variable-rndgen","text":"std::default_random_engine rndGen; Pseudo random number generator.","title":"variable rndGen"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#variable-noisemodels","text":"std::map< std::string, std::normal_distribution< double > > noiseModels; Normal distribution describing the noise models.","title":"variable noiseModels"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#variable-ison","text":"std_msgs::Bool isOn; Flag to control the generation of output messages.","title":"variable isOn"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#variable-rosnode","text":"boost::shared_ptr< ros::NodeHandle > rosNode; ROS node handle for communication with ROS.","title":"variable rosNode"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#variable-gazebonode","text":"transport::NodePtr gazeboNode; Gazebo's node handle for transporting measurement messages.","title":"variable gazeboNode"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#variable-rossensoroutputpub","text":"ros::Publisher rosSensorOutputPub; Gazebo's publisher for transporting measurement messages.","title":"variable rosSensorOutputPub"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#variable-gazebosensoroutputpub","text":"transport::PublisherPtr gazeboSensorOutputPub; Gazebo's publisher for transporting measurement messages.","title":"variable gazeboSensorOutputPub"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#variable-changesensorsrv","text":"ros::ServiceServer changeSensorSrv; Service server object.","title":"variable changeSensorSrv"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#variable-pluginstatepub","text":"ros::Publisher pluginStatePub; ROS publisher for the switchable sensor data.","title":"variable pluginStatePub"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#variable-referenceframe","text":"ignition::math::Pose3d referenceFrame; Pose of the reference frame wrt world frame.","title":"variable referenceFrame"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#variable-tfstaticsub","text":"ros::Subscriber tfStaticSub; ROS subscriber for the TF static reference frame.","title":"variable tfStaticSub"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#variable-referenceframeid","text":"std::string referenceFrameID; Frame ID of the reference frame.","title":"variable referenceFrameID"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#variable-isreferenceinit","text":"bool isReferenceInit; Flag set to true if reference frame initialized.","title":"variable isReferenceInit"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBasePlugin/#variable-referencelink","text":"physics::LinkPtr referenceLink; Reference link. Updated on 2022-05-30 at 18:35:14 +0000","title":"variable referenceLink"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseSensorPlugin/","text":"gazebo::ROSBaseSensorPlugin Inherits from gazebo::ROSBasePlugin , SensorPlugin Inherited by gazebo::GPSROSPlugin Public Functions Name ROSBaseSensorPlugin () Class constructor. virtual ~ROSBaseSensorPlugin () Class destructor. Protected Functions Name virtual void Load (sensors::SensorPtr _model, sdf::ElementPtr _sdf) Load plugin and its configuration from sdf,. virtual bool OnUpdate (const common::UpdateInfo & ) Update callback from simulation. Protected Attributes Name sensors::SensorPtr parentSensor Pointer to the parent sensor. Additional inherited members Public Functions inherited from gazebo::ROSBasePlugin Name ROSBasePlugin () Class constructor. virtual ~ROSBasePlugin () Class destructor. bool InitBasePlugin (sdf::ElementPtr _sdf) Initialize base plugin. bool AddNoiseModel (std::string _name, double _sigma) Add noise normal distribution to the list. Protected Functions inherited from gazebo::ROSBasePlugin Name bool IsOn () Returns true if the plugin is activated. void PublishState () Publish the current state of the plugin. bool ChangeSensorState (uuv_sensor_ros_plugins_msgs::ChangeSensorState::Request & _req, uuv_sensor_ros_plugins_msgs::ChangeSensorState::Response & _res) Change sensor state (ON/OFF) void GetTFMessage (const tf::tfMessage::ConstPtr & _msg) Callback function for the static TF message. double GetGaussianNoise (double _amp) Returns noise value for a function with zero mean from the default Gaussian noise model. double GetGaussianNoise (std::string _name, double _amp) Returns noise value for a function with zero mean from a Gaussian noise model according to the model name. bool EnableMeasurement (const common::UpdateInfo & _info) const Enables generation of simulated measurement if the timeout since the last update has been reached. void UpdateReferenceFramePose () Updates the pose of the reference frame wrt the world frame. Protected Attributes inherited from gazebo::ROSBasePlugin Name std::string robotNamespace Robot namespace. std::string sensorOutputTopic Name of the sensor's output topic. physics::WorldPtr world Pointer to the world. event::ConnectionPtr updateConnection Pointer to the update event connection. common::Time lastMeasurementTime (Simulation) time when the last sensor measurement was generated. double updateRate Sensor update rate. double noiseSigma Noise standard deviation. double noiseAmp Noise amplitude. bool gazeboMsgEnabled Flag set to true if the Gazebo sensors messages are supposed to be published as well (it can avoid unnecessary overhead in case) the sensor messages needed are only ROS messages. std::default_random_engine rndGen Pseudo random number generator. std::map< std::string, std::normal_distribution< double > > noiseModels Normal distribution describing the noise models. std_msgs::Bool isOn Flag to control the generation of output messages. boost::shared_ptr< ros::NodeHandle > rosNode ROS node handle for communication with ROS. transport::NodePtr gazeboNode Gazebo's node handle for transporting measurement messages. ros::Publisher rosSensorOutputPub Gazebo's publisher for transporting measurement messages. transport::PublisherPtr gazeboSensorOutputPub Gazebo's publisher for transporting measurement messages. ros::ServiceServer changeSensorSrv Service server object. ros::Publisher pluginStatePub ROS publisher for the switchable sensor data. ignition::math::Pose3d referenceFrame Pose of the reference frame wrt world frame. ros::Subscriber tfStaticSub ROS subscriber for the TF static reference frame. std::string referenceFrameID Frame ID of the reference frame. bool isReferenceInit Flag set to true if reference frame initialized. physics::LinkPtr referenceLink Reference link. Public Functions Documentation function ROSBaseSensorPlugin ROSBaseSensorPlugin() Class constructor. function ~ROSBaseSensorPlugin virtual ~ROSBaseSensorPlugin() Class destructor. Protected Functions Documentation function Load virtual void Load( sensors::SensorPtr _model, sdf::ElementPtr _sdf ) Load plugin and its configuration from sdf,. Reimplemented by : gazebo::GPSROSPlugin::Load function OnUpdate virtual bool OnUpdate( const common::UpdateInfo & ) Update callback from simulation. Reimplements : gazebo::ROSBasePlugin::OnUpdate Protected Attributes Documentation variable parentSensor sensors::SensorPtr parentSensor; Pointer to the parent sensor. Updated on 2022-05-30 at 18:35:14 +0000","title":"gazebo::ROSBaseSensorPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseSensorPlugin/#gazeborosbasesensorplugin","text":"Inherits from gazebo::ROSBasePlugin , SensorPlugin Inherited by gazebo::GPSROSPlugin","title":"gazebo::ROSBaseSensorPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseSensorPlugin/#public-functions","text":"Name ROSBaseSensorPlugin () Class constructor. virtual ~ROSBaseSensorPlugin () Class destructor.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseSensorPlugin/#protected-functions","text":"Name virtual void Load (sensors::SensorPtr _model, sdf::ElementPtr _sdf) Load plugin and its configuration from sdf,. virtual bool OnUpdate (const common::UpdateInfo & ) Update callback from simulation.","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseSensorPlugin/#protected-attributes","text":"Name sensors::SensorPtr parentSensor Pointer to the parent sensor.","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseSensorPlugin/#additional-inherited-members","text":"Public Functions inherited from gazebo::ROSBasePlugin Name ROSBasePlugin () Class constructor. virtual ~ROSBasePlugin () Class destructor. bool InitBasePlugin (sdf::ElementPtr _sdf) Initialize base plugin. bool AddNoiseModel (std::string _name, double _sigma) Add noise normal distribution to the list. Protected Functions inherited from gazebo::ROSBasePlugin Name bool IsOn () Returns true if the plugin is activated. void PublishState () Publish the current state of the plugin. bool ChangeSensorState (uuv_sensor_ros_plugins_msgs::ChangeSensorState::Request & _req, uuv_sensor_ros_plugins_msgs::ChangeSensorState::Response & _res) Change sensor state (ON/OFF) void GetTFMessage (const tf::tfMessage::ConstPtr & _msg) Callback function for the static TF message. double GetGaussianNoise (double _amp) Returns noise value for a function with zero mean from the default Gaussian noise model. double GetGaussianNoise (std::string _name, double _amp) Returns noise value for a function with zero mean from a Gaussian noise model according to the model name. bool EnableMeasurement (const common::UpdateInfo & _info) const Enables generation of simulated measurement if the timeout since the last update has been reached. void UpdateReferenceFramePose () Updates the pose of the reference frame wrt the world frame. Protected Attributes inherited from gazebo::ROSBasePlugin Name std::string robotNamespace Robot namespace. std::string sensorOutputTopic Name of the sensor's output topic. physics::WorldPtr world Pointer to the world. event::ConnectionPtr updateConnection Pointer to the update event connection. common::Time lastMeasurementTime (Simulation) time when the last sensor measurement was generated. double updateRate Sensor update rate. double noiseSigma Noise standard deviation. double noiseAmp Noise amplitude. bool gazeboMsgEnabled Flag set to true if the Gazebo sensors messages are supposed to be published as well (it can avoid unnecessary overhead in case) the sensor messages needed are only ROS messages. std::default_random_engine rndGen Pseudo random number generator. std::map< std::string, std::normal_distribution< double > > noiseModels Normal distribution describing the noise models. std_msgs::Bool isOn Flag to control the generation of output messages. boost::shared_ptr< ros::NodeHandle > rosNode ROS node handle for communication with ROS. transport::NodePtr gazeboNode Gazebo's node handle for transporting measurement messages. ros::Publisher rosSensorOutputPub Gazebo's publisher for transporting measurement messages. transport::PublisherPtr gazeboSensorOutputPub Gazebo's publisher for transporting measurement messages. ros::ServiceServer changeSensorSrv Service server object. ros::Publisher pluginStatePub ROS publisher for the switchable sensor data. ignition::math::Pose3d referenceFrame Pose of the reference frame wrt world frame. ros::Subscriber tfStaticSub ROS subscriber for the TF static reference frame. std::string referenceFrameID Frame ID of the reference frame. bool isReferenceInit Flag set to true if reference frame initialized. physics::LinkPtr referenceLink Reference link.","title":"Additional inherited members"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseSensorPlugin/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseSensorPlugin/#function-rosbasesensorplugin","text":"ROSBaseSensorPlugin() Class constructor.","title":"function ROSBaseSensorPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseSensorPlugin/#function-rosbasesensorplugin_1","text":"virtual ~ROSBaseSensorPlugin() Class destructor.","title":"function ~ROSBaseSensorPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseSensorPlugin/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseSensorPlugin/#function-load","text":"virtual void Load( sensors::SensorPtr _model, sdf::ElementPtr _sdf ) Load plugin and its configuration from sdf,. Reimplemented by : gazebo::GPSROSPlugin::Load","title":"function Load"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseSensorPlugin/#function-onupdate","text":"virtual bool OnUpdate( const common::UpdateInfo & ) Update callback from simulation. Reimplements : gazebo::ROSBasePlugin::OnUpdate","title":"function OnUpdate"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseSensorPlugin/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1ROSBaseSensorPlugin/#variable-parentsensor","text":"sensors::SensorPtr parentSensor; Pointer to the parent sensor. Updated on 2022-05-30 at 18:35:14 +0000","title":"variable parentSensor"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1RPTROSPlugin/","text":"gazebo::RPTROSPlugin Inherits from gazebo::ROSBaseModelPlugin , gazebo::ROSBasePlugin , ModelPlugin Public Functions Name RPTROSPlugin () Class constructor. virtual ~RPTROSPlugin () Class destructor. virtual void Load (physics::ModelPtr _model, sdf::ElementPtr _sdf) Load the plugin. Protected Functions Name virtual bool OnUpdate (const common::UpdateInfo & _info) Update sensor measurement. Protected Attributes Name ignition::math::Vector3d position Latest measured position. uuv_sensor_ros_plugins_msgs::PositionWithCovarianceStamped rosMessage Store message since many attributes do not change (cov.). Additional inherited members Public Functions inherited from gazebo::ROSBaseModelPlugin Name ROSBaseModelPlugin () Class constructor. virtual ~ROSBaseModelPlugin () Class destructor. Protected Functions inherited from gazebo::ROSBaseModelPlugin Name void SendLocalNEDTransform () Returns true if the base_link_ned frame exists. Protected Attributes inherited from gazebo::ROSBaseModelPlugin Name physics::ModelPtr model Pointer to the model. physics::LinkPtr link Pointer to the link. bool enableLocalNEDFrame True if a the local NED frame needs to be broadcasted. tf::TransformBroadcaster * tfBroadcaster TF broadcaster for the local NED frame. ignition::math::Pose3d localNEDFrame Pose of the local NED frame wrt link frame. tf::StampedTransform tfLocalNEDFrame Local NED TF frame. Public Functions inherited from gazebo::ROSBasePlugin Name ROSBasePlugin () Class constructor. virtual ~ROSBasePlugin () Class destructor. bool InitBasePlugin (sdf::ElementPtr _sdf) Initialize base plugin. bool AddNoiseModel (std::string _name, double _sigma) Add noise normal distribution to the list. Protected Functions inherited from gazebo::ROSBasePlugin Name bool IsOn () Returns true if the plugin is activated. void PublishState () Publish the current state of the plugin. bool ChangeSensorState (uuv_sensor_ros_plugins_msgs::ChangeSensorState::Request & _req, uuv_sensor_ros_plugins_msgs::ChangeSensorState::Response & _res) Change sensor state (ON/OFF) void GetTFMessage (const tf::tfMessage::ConstPtr & _msg) Callback function for the static TF message. double GetGaussianNoise (double _amp) Returns noise value for a function with zero mean from the default Gaussian noise model. double GetGaussianNoise (std::string _name, double _amp) Returns noise value for a function with zero mean from a Gaussian noise model according to the model name. bool EnableMeasurement (const common::UpdateInfo & _info) const Enables generation of simulated measurement if the timeout since the last update has been reached. void UpdateReferenceFramePose () Updates the pose of the reference frame wrt the world frame. Protected Attributes inherited from gazebo::ROSBasePlugin Name std::string robotNamespace Robot namespace. std::string sensorOutputTopic Name of the sensor's output topic. physics::WorldPtr world Pointer to the world. event::ConnectionPtr updateConnection Pointer to the update event connection. common::Time lastMeasurementTime (Simulation) time when the last sensor measurement was generated. double updateRate Sensor update rate. double noiseSigma Noise standard deviation. double noiseAmp Noise amplitude. bool gazeboMsgEnabled Flag set to true if the Gazebo sensors messages are supposed to be published as well (it can avoid unnecessary overhead in case) the sensor messages needed are only ROS messages. std::default_random_engine rndGen Pseudo random number generator. std::map< std::string, std::normal_distribution< double > > noiseModels Normal distribution describing the noise models. std_msgs::Bool isOn Flag to control the generation of output messages. boost::shared_ptr< ros::NodeHandle > rosNode ROS node handle for communication with ROS. transport::NodePtr gazeboNode Gazebo's node handle for transporting measurement messages. ros::Publisher rosSensorOutputPub Gazebo's publisher for transporting measurement messages. transport::PublisherPtr gazeboSensorOutputPub Gazebo's publisher for transporting measurement messages. ros::ServiceServer changeSensorSrv Service server object. ros::Publisher pluginStatePub ROS publisher for the switchable sensor data. ignition::math::Pose3d referenceFrame Pose of the reference frame wrt world frame. ros::Subscriber tfStaticSub ROS subscriber for the TF static reference frame. std::string referenceFrameID Frame ID of the reference frame. bool isReferenceInit Flag set to true if reference frame initialized. physics::LinkPtr referenceLink Reference link. Public Functions Documentation function RPTROSPlugin RPTROSPlugin() Class constructor. function ~RPTROSPlugin virtual ~RPTROSPlugin() Class destructor. function Load virtual void Load( physics::ModelPtr _model, sdf::ElementPtr _sdf ) Load the plugin. Reimplements : gazebo::ROSBaseModelPlugin::Load Protected Functions Documentation function OnUpdate virtual bool OnUpdate( const common::UpdateInfo & _info ) Update sensor measurement. Reimplements : gazebo::ROSBaseModelPlugin::OnUpdate Protected Attributes Documentation variable position ignition::math::Vector3d position; Latest measured position. variable rosMessage uuv_sensor_ros_plugins_msgs::PositionWithCovarianceStamped rosMessage; Store message since many attributes do not change (cov.). Updated on 2022-05-30 at 18:35:14 +0000","title":"gazebo::RPTROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1RPTROSPlugin/#gazeborptrosplugin","text":"Inherits from gazebo::ROSBaseModelPlugin , gazebo::ROSBasePlugin , ModelPlugin","title":"gazebo::RPTROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1RPTROSPlugin/#public-functions","text":"Name RPTROSPlugin () Class constructor. virtual ~RPTROSPlugin () Class destructor. virtual void Load (physics::ModelPtr _model, sdf::ElementPtr _sdf) Load the plugin.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1RPTROSPlugin/#protected-functions","text":"Name virtual bool OnUpdate (const common::UpdateInfo & _info) Update sensor measurement.","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1RPTROSPlugin/#protected-attributes","text":"Name ignition::math::Vector3d position Latest measured position. uuv_sensor_ros_plugins_msgs::PositionWithCovarianceStamped rosMessage Store message since many attributes do not change (cov.).","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1RPTROSPlugin/#additional-inherited-members","text":"Public Functions inherited from gazebo::ROSBaseModelPlugin Name ROSBaseModelPlugin () Class constructor. virtual ~ROSBaseModelPlugin () Class destructor. Protected Functions inherited from gazebo::ROSBaseModelPlugin Name void SendLocalNEDTransform () Returns true if the base_link_ned frame exists. Protected Attributes inherited from gazebo::ROSBaseModelPlugin Name physics::ModelPtr model Pointer to the model. physics::LinkPtr link Pointer to the link. bool enableLocalNEDFrame True if a the local NED frame needs to be broadcasted. tf::TransformBroadcaster * tfBroadcaster TF broadcaster for the local NED frame. ignition::math::Pose3d localNEDFrame Pose of the local NED frame wrt link frame. tf::StampedTransform tfLocalNEDFrame Local NED TF frame. Public Functions inherited from gazebo::ROSBasePlugin Name ROSBasePlugin () Class constructor. virtual ~ROSBasePlugin () Class destructor. bool InitBasePlugin (sdf::ElementPtr _sdf) Initialize base plugin. bool AddNoiseModel (std::string _name, double _sigma) Add noise normal distribution to the list. Protected Functions inherited from gazebo::ROSBasePlugin Name bool IsOn () Returns true if the plugin is activated. void PublishState () Publish the current state of the plugin. bool ChangeSensorState (uuv_sensor_ros_plugins_msgs::ChangeSensorState::Request & _req, uuv_sensor_ros_plugins_msgs::ChangeSensorState::Response & _res) Change sensor state (ON/OFF) void GetTFMessage (const tf::tfMessage::ConstPtr & _msg) Callback function for the static TF message. double GetGaussianNoise (double _amp) Returns noise value for a function with zero mean from the default Gaussian noise model. double GetGaussianNoise (std::string _name, double _amp) Returns noise value for a function with zero mean from a Gaussian noise model according to the model name. bool EnableMeasurement (const common::UpdateInfo & _info) const Enables generation of simulated measurement if the timeout since the last update has been reached. void UpdateReferenceFramePose () Updates the pose of the reference frame wrt the world frame. Protected Attributes inherited from gazebo::ROSBasePlugin Name std::string robotNamespace Robot namespace. std::string sensorOutputTopic Name of the sensor's output topic. physics::WorldPtr world Pointer to the world. event::ConnectionPtr updateConnection Pointer to the update event connection. common::Time lastMeasurementTime (Simulation) time when the last sensor measurement was generated. double updateRate Sensor update rate. double noiseSigma Noise standard deviation. double noiseAmp Noise amplitude. bool gazeboMsgEnabled Flag set to true if the Gazebo sensors messages are supposed to be published as well (it can avoid unnecessary overhead in case) the sensor messages needed are only ROS messages. std::default_random_engine rndGen Pseudo random number generator. std::map< std::string, std::normal_distribution< double > > noiseModels Normal distribution describing the noise models. std_msgs::Bool isOn Flag to control the generation of output messages. boost::shared_ptr< ros::NodeHandle > rosNode ROS node handle for communication with ROS. transport::NodePtr gazeboNode Gazebo's node handle for transporting measurement messages. ros::Publisher rosSensorOutputPub Gazebo's publisher for transporting measurement messages. transport::PublisherPtr gazeboSensorOutputPub Gazebo's publisher for transporting measurement messages. ros::ServiceServer changeSensorSrv Service server object. ros::Publisher pluginStatePub ROS publisher for the switchable sensor data. ignition::math::Pose3d referenceFrame Pose of the reference frame wrt world frame. ros::Subscriber tfStaticSub ROS subscriber for the TF static reference frame. std::string referenceFrameID Frame ID of the reference frame. bool isReferenceInit Flag set to true if reference frame initialized. physics::LinkPtr referenceLink Reference link.","title":"Additional inherited members"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1RPTROSPlugin/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1RPTROSPlugin/#function-rptrosplugin","text":"RPTROSPlugin() Class constructor.","title":"function RPTROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1RPTROSPlugin/#function-rptrosplugin_1","text":"virtual ~RPTROSPlugin() Class destructor.","title":"function ~RPTROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1RPTROSPlugin/#function-load","text":"virtual void Load( physics::ModelPtr _model, sdf::ElementPtr _sdf ) Load the plugin. Reimplements : gazebo::ROSBaseModelPlugin::Load","title":"function Load"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1RPTROSPlugin/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1RPTROSPlugin/#function-onupdate","text":"virtual bool OnUpdate( const common::UpdateInfo & _info ) Update sensor measurement. Reimplements : gazebo::ROSBaseModelPlugin::OnUpdate","title":"function OnUpdate"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1RPTROSPlugin/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1RPTROSPlugin/#variable-position","text":"ignition::math::Vector3d position; Latest measured position.","title":"variable position"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1RPTROSPlugin/#variable-rosmessage","text":"uuv_sensor_ros_plugins_msgs::PositionWithCovarianceStamped rosMessage; Store message since many attributes do not change (cov.). Updated on 2022-05-30 at 18:35:14 +0000","title":"variable rosMessage"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1SubseaPressureROSPlugin/","text":"gazebo::SubseaPressureROSPlugin Inherits from gazebo::ROSBaseModelPlugin , gazebo::ROSBasePlugin , ModelPlugin Public Functions Name SubseaPressureROSPlugin () Class constructor. ~SubseaPressureROSPlugin () Class destructor. virtual void Load (physics::ModelPtr _model, sdf::ElementPtr _sdf) Load the plugin. Protected Functions Name virtual bool OnUpdate (const common::UpdateInfo & _info) Update sensor measurement. Protected Attributes Name double saturation Sensor saturation (max. value for output pressure in Pa) bool estimateDepth If flag is set to true, estimate depth according to pressure measurement. double standardPressure Standard pressure. double kPaPerM Factor of kPa per meter. dsor_msgs::Measurement depthMeasurementMsg Depth measurement message (used by the medusa stack) ros::Publisher medusaStackDepthPub Additional Measurement ROS topic specific for depth msgs into stack. Additional inherited members Public Functions inherited from gazebo::ROSBaseModelPlugin Name ROSBaseModelPlugin () Class constructor. virtual ~ROSBaseModelPlugin () Class destructor. Protected Functions inherited from gazebo::ROSBaseModelPlugin Name void SendLocalNEDTransform () Returns true if the base_link_ned frame exists. Protected Attributes inherited from gazebo::ROSBaseModelPlugin Name physics::ModelPtr model Pointer to the model. physics::LinkPtr link Pointer to the link. bool enableLocalNEDFrame True if a the local NED frame needs to be broadcasted. tf::TransformBroadcaster * tfBroadcaster TF broadcaster for the local NED frame. ignition::math::Pose3d localNEDFrame Pose of the local NED frame wrt link frame. tf::StampedTransform tfLocalNEDFrame Local NED TF frame. Public Functions inherited from gazebo::ROSBasePlugin Name ROSBasePlugin () Class constructor. virtual ~ROSBasePlugin () Class destructor. bool InitBasePlugin (sdf::ElementPtr _sdf) Initialize base plugin. bool AddNoiseModel (std::string _name, double _sigma) Add noise normal distribution to the list. Protected Functions inherited from gazebo::ROSBasePlugin Name bool IsOn () Returns true if the plugin is activated. void PublishState () Publish the current state of the plugin. bool ChangeSensorState (uuv_sensor_ros_plugins_msgs::ChangeSensorState::Request & _req, uuv_sensor_ros_plugins_msgs::ChangeSensorState::Response & _res) Change sensor state (ON/OFF) void GetTFMessage (const tf::tfMessage::ConstPtr & _msg) Callback function for the static TF message. double GetGaussianNoise (double _amp) Returns noise value for a function with zero mean from the default Gaussian noise model. double GetGaussianNoise (std::string _name, double _amp) Returns noise value for a function with zero mean from a Gaussian noise model according to the model name. bool EnableMeasurement (const common::UpdateInfo & _info) const Enables generation of simulated measurement if the timeout since the last update has been reached. void UpdateReferenceFramePose () Updates the pose of the reference frame wrt the world frame. Protected Attributes inherited from gazebo::ROSBasePlugin Name std::string robotNamespace Robot namespace. std::string sensorOutputTopic Name of the sensor's output topic. physics::WorldPtr world Pointer to the world. event::ConnectionPtr updateConnection Pointer to the update event connection. common::Time lastMeasurementTime (Simulation) time when the last sensor measurement was generated. double updateRate Sensor update rate. double noiseSigma Noise standard deviation. double noiseAmp Noise amplitude. bool gazeboMsgEnabled Flag set to true if the Gazebo sensors messages are supposed to be published as well (it can avoid unnecessary overhead in case) the sensor messages needed are only ROS messages. std::default_random_engine rndGen Pseudo random number generator. std::map< std::string, std::normal_distribution< double > > noiseModels Normal distribution describing the noise models. std_msgs::Bool isOn Flag to control the generation of output messages. boost::shared_ptr< ros::NodeHandle > rosNode ROS node handle for communication with ROS. transport::NodePtr gazeboNode Gazebo's node handle for transporting measurement messages. ros::Publisher rosSensorOutputPub Gazebo's publisher for transporting measurement messages. transport::PublisherPtr gazeboSensorOutputPub Gazebo's publisher for transporting measurement messages. ros::ServiceServer changeSensorSrv Service server object. ros::Publisher pluginStatePub ROS publisher for the switchable sensor data. ignition::math::Pose3d referenceFrame Pose of the reference frame wrt world frame. ros::Subscriber tfStaticSub ROS subscriber for the TF static reference frame. std::string referenceFrameID Frame ID of the reference frame. bool isReferenceInit Flag set to true if reference frame initialized. physics::LinkPtr referenceLink Reference link. Public Functions Documentation function SubseaPressureROSPlugin SubseaPressureROSPlugin() Class constructor. function ~SubseaPressureROSPlugin ~SubseaPressureROSPlugin() Class destructor. function Load virtual void Load( physics::ModelPtr _model, sdf::ElementPtr _sdf ) Load the plugin. Reimplements : gazebo::ROSBaseModelPlugin::Load Protected Functions Documentation function OnUpdate virtual bool OnUpdate( const common::UpdateInfo & _info ) Update sensor measurement. Reimplements : gazebo::ROSBaseModelPlugin::OnUpdate Protected Attributes Documentation variable saturation double saturation; Sensor saturation (max. value for output pressure in Pa) variable estimateDepth bool estimateDepth; If flag is set to true, estimate depth according to pressure measurement. variable standardPressure double standardPressure; Standard pressure. variable kPaPerM double kPaPerM; Factor of kPa per meter. variable depthMeasurementMsg dsor_msgs::Measurement depthMeasurementMsg; Depth measurement message (used by the medusa stack) variable medusaStackDepthPub ros::Publisher medusaStackDepthPub; Additional Measurement ROS topic specific for depth msgs into stack. Updated on 2022-05-30 at 18:35:14 +0000","title":"gazebo::SubseaPressureROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1SubseaPressureROSPlugin/#gazebosubseapressurerosplugin","text":"Inherits from gazebo::ROSBaseModelPlugin , gazebo::ROSBasePlugin , ModelPlugin","title":"gazebo::SubseaPressureROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1SubseaPressureROSPlugin/#public-functions","text":"Name SubseaPressureROSPlugin () Class constructor. ~SubseaPressureROSPlugin () Class destructor. virtual void Load (physics::ModelPtr _model, sdf::ElementPtr _sdf) Load the plugin.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1SubseaPressureROSPlugin/#protected-functions","text":"Name virtual bool OnUpdate (const common::UpdateInfo & _info) Update sensor measurement.","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1SubseaPressureROSPlugin/#protected-attributes","text":"Name double saturation Sensor saturation (max. value for output pressure in Pa) bool estimateDepth If flag is set to true, estimate depth according to pressure measurement. double standardPressure Standard pressure. double kPaPerM Factor of kPa per meter. dsor_msgs::Measurement depthMeasurementMsg Depth measurement message (used by the medusa stack) ros::Publisher medusaStackDepthPub Additional Measurement ROS topic specific for depth msgs into stack.","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1SubseaPressureROSPlugin/#additional-inherited-members","text":"Public Functions inherited from gazebo::ROSBaseModelPlugin Name ROSBaseModelPlugin () Class constructor. virtual ~ROSBaseModelPlugin () Class destructor. Protected Functions inherited from gazebo::ROSBaseModelPlugin Name void SendLocalNEDTransform () Returns true if the base_link_ned frame exists. Protected Attributes inherited from gazebo::ROSBaseModelPlugin Name physics::ModelPtr model Pointer to the model. physics::LinkPtr link Pointer to the link. bool enableLocalNEDFrame True if a the local NED frame needs to be broadcasted. tf::TransformBroadcaster * tfBroadcaster TF broadcaster for the local NED frame. ignition::math::Pose3d localNEDFrame Pose of the local NED frame wrt link frame. tf::StampedTransform tfLocalNEDFrame Local NED TF frame. Public Functions inherited from gazebo::ROSBasePlugin Name ROSBasePlugin () Class constructor. virtual ~ROSBasePlugin () Class destructor. bool InitBasePlugin (sdf::ElementPtr _sdf) Initialize base plugin. bool AddNoiseModel (std::string _name, double _sigma) Add noise normal distribution to the list. Protected Functions inherited from gazebo::ROSBasePlugin Name bool IsOn () Returns true if the plugin is activated. void PublishState () Publish the current state of the plugin. bool ChangeSensorState (uuv_sensor_ros_plugins_msgs::ChangeSensorState::Request & _req, uuv_sensor_ros_plugins_msgs::ChangeSensorState::Response & _res) Change sensor state (ON/OFF) void GetTFMessage (const tf::tfMessage::ConstPtr & _msg) Callback function for the static TF message. double GetGaussianNoise (double _amp) Returns noise value for a function with zero mean from the default Gaussian noise model. double GetGaussianNoise (std::string _name, double _amp) Returns noise value for a function with zero mean from a Gaussian noise model according to the model name. bool EnableMeasurement (const common::UpdateInfo & _info) const Enables generation of simulated measurement if the timeout since the last update has been reached. void UpdateReferenceFramePose () Updates the pose of the reference frame wrt the world frame. Protected Attributes inherited from gazebo::ROSBasePlugin Name std::string robotNamespace Robot namespace. std::string sensorOutputTopic Name of the sensor's output topic. physics::WorldPtr world Pointer to the world. event::ConnectionPtr updateConnection Pointer to the update event connection. common::Time lastMeasurementTime (Simulation) time when the last sensor measurement was generated. double updateRate Sensor update rate. double noiseSigma Noise standard deviation. double noiseAmp Noise amplitude. bool gazeboMsgEnabled Flag set to true if the Gazebo sensors messages are supposed to be published as well (it can avoid unnecessary overhead in case) the sensor messages needed are only ROS messages. std::default_random_engine rndGen Pseudo random number generator. std::map< std::string, std::normal_distribution< double > > noiseModels Normal distribution describing the noise models. std_msgs::Bool isOn Flag to control the generation of output messages. boost::shared_ptr< ros::NodeHandle > rosNode ROS node handle for communication with ROS. transport::NodePtr gazeboNode Gazebo's node handle for transporting measurement messages. ros::Publisher rosSensorOutputPub Gazebo's publisher for transporting measurement messages. transport::PublisherPtr gazeboSensorOutputPub Gazebo's publisher for transporting measurement messages. ros::ServiceServer changeSensorSrv Service server object. ros::Publisher pluginStatePub ROS publisher for the switchable sensor data. ignition::math::Pose3d referenceFrame Pose of the reference frame wrt world frame. ros::Subscriber tfStaticSub ROS subscriber for the TF static reference frame. std::string referenceFrameID Frame ID of the reference frame. bool isReferenceInit Flag set to true if reference frame initialized. physics::LinkPtr referenceLink Reference link.","title":"Additional inherited members"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1SubseaPressureROSPlugin/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1SubseaPressureROSPlugin/#function-subseapressurerosplugin","text":"SubseaPressureROSPlugin() Class constructor.","title":"function SubseaPressureROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1SubseaPressureROSPlugin/#function-subseapressurerosplugin_1","text":"~SubseaPressureROSPlugin() Class destructor.","title":"function ~SubseaPressureROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1SubseaPressureROSPlugin/#function-load","text":"virtual void Load( physics::ModelPtr _model, sdf::ElementPtr _sdf ) Load the plugin. Reimplements : gazebo::ROSBaseModelPlugin::Load","title":"function Load"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1SubseaPressureROSPlugin/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1SubseaPressureROSPlugin/#function-onupdate","text":"virtual bool OnUpdate( const common::UpdateInfo & _info ) Update sensor measurement. Reimplements : gazebo::ROSBaseModelPlugin::OnUpdate","title":"function OnUpdate"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1SubseaPressureROSPlugin/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1SubseaPressureROSPlugin/#variable-saturation","text":"double saturation; Sensor saturation (max. value for output pressure in Pa)","title":"variable saturation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1SubseaPressureROSPlugin/#variable-estimatedepth","text":"bool estimateDepth; If flag is set to true, estimate depth according to pressure measurement.","title":"variable estimateDepth"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1SubseaPressureROSPlugin/#variable-standardpressure","text":"double standardPressure; Standard pressure.","title":"variable standardPressure"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1SubseaPressureROSPlugin/#variable-kpaperm","text":"double kPaPerM; Factor of kPa per meter.","title":"variable kPaPerM"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1SubseaPressureROSPlugin/#variable-depthmeasurementmsg","text":"dsor_msgs::Measurement depthMeasurementMsg; Depth measurement message (used by the medusa stack)","title":"variable depthMeasurementMsg"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1SubseaPressureROSPlugin/#variable-medusastackdepthpub","text":"ros::Publisher medusaStackDepthPub; Additional Measurement ROS topic specific for depth msgs into stack. Updated on 2022-05-30 at 18:35:14 +0000","title":"variable medusaStackDepthPub"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1UnderwaterCameraROSPlugin/","text":"gazebo::UnderwaterCameraROSPlugin Inherits from DepthCameraPlugin, GazeboRosCameraUtils Public Functions Name UnderwaterCameraROSPlugin () Class constructor. virtual ~UnderwaterCameraROSPlugin () Class destructor. void Load (sensors::SensorPtr _sensor, sdf::ElementPtr _sdf) Load plugin and its configuration from sdf. virtual void OnNewDepthFrame (const float * _image, unsigned int _width, unsigned int _height, unsigned int _depth, const std::string & _format) virtual void OnNewRGBPointCloud (const float * _pcd, unsigned int _width, unsigned int _height, unsigned int _depth, const std::string & _format) Update the controller. virtual void OnNewImageFrame (const unsigned char * _image, unsigned int _width, unsigned int _height, unsigned int _depth, const std::string & _format) Protected Functions Name virtual void SimulateUnderwater (const cv::Mat & _inputImage, const cv::Mat & _inputDepth, cv::Mat & _outputImage) Add underwater light damping to image. Protected Attributes Name const float * lastDepth Temporarily store pointer to previous depth image. unsigned char * lastImage Latest simulated image. float * depth2rangeLUT Depth to range lookup table (LUT) float attenuation Attenuation constants per channel (RGB) unsigned char background Background constants per channel (RGB) Public Functions Documentation function UnderwaterCameraROSPlugin UnderwaterCameraROSPlugin() Class constructor. function ~UnderwaterCameraROSPlugin virtual ~UnderwaterCameraROSPlugin() Class destructor. function Load void Load( sensors::SensorPtr _sensor, sdf::ElementPtr _sdf ) Load plugin and its configuration from sdf. function OnNewDepthFrame virtual void OnNewDepthFrame( const float * _image, unsigned int _width, unsigned int _height, unsigned int _depth, const std::string & _format ) function OnNewRGBPointCloud virtual void OnNewRGBPointCloud( const float * _pcd, unsigned int _width, unsigned int _height, unsigned int _depth, const std::string & _format ) Update the controller. function OnNewImageFrame virtual void OnNewImageFrame( const unsigned char * _image, unsigned int _width, unsigned int _height, unsigned int _depth, const std::string & _format ) Protected Functions Documentation function SimulateUnderwater virtual void SimulateUnderwater( const cv::Mat & _inputImage, const cv::Mat & _inputDepth, cv::Mat & _outputImage ) Add underwater light damping to image. Protected Attributes Documentation variable lastDepth const float * lastDepth; Temporarily store pointer to previous depth image. variable lastImage unsigned char * lastImage; Latest simulated image. variable depth2rangeLUT float * depth2rangeLUT; Depth to range lookup table (LUT) variable attenuation float attenuation; Attenuation constants per channel (RGB) variable background unsigned char background; Background constants per channel (RGB) Updated on 2022-05-30 at 18:35:14 +0000","title":"gazebo::UnderwaterCameraROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1UnderwaterCameraROSPlugin/#gazebounderwatercamerarosplugin","text":"Inherits from DepthCameraPlugin, GazeboRosCameraUtils","title":"gazebo::UnderwaterCameraROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1UnderwaterCameraROSPlugin/#public-functions","text":"Name UnderwaterCameraROSPlugin () Class constructor. virtual ~UnderwaterCameraROSPlugin () Class destructor. void Load (sensors::SensorPtr _sensor, sdf::ElementPtr _sdf) Load plugin and its configuration from sdf. virtual void OnNewDepthFrame (const float * _image, unsigned int _width, unsigned int _height, unsigned int _depth, const std::string & _format) virtual void OnNewRGBPointCloud (const float * _pcd, unsigned int _width, unsigned int _height, unsigned int _depth, const std::string & _format) Update the controller. virtual void OnNewImageFrame (const unsigned char * _image, unsigned int _width, unsigned int _height, unsigned int _depth, const std::string & _format)","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1UnderwaterCameraROSPlugin/#protected-functions","text":"Name virtual void SimulateUnderwater (const cv::Mat & _inputImage, const cv::Mat & _inputDepth, cv::Mat & _outputImage) Add underwater light damping to image.","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1UnderwaterCameraROSPlugin/#protected-attributes","text":"Name const float * lastDepth Temporarily store pointer to previous depth image. unsigned char * lastImage Latest simulated image. float * depth2rangeLUT Depth to range lookup table (LUT) float attenuation Attenuation constants per channel (RGB) unsigned char background Background constants per channel (RGB)","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1UnderwaterCameraROSPlugin/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1UnderwaterCameraROSPlugin/#function-underwatercamerarosplugin","text":"UnderwaterCameraROSPlugin() Class constructor.","title":"function UnderwaterCameraROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1UnderwaterCameraROSPlugin/#function-underwatercamerarosplugin_1","text":"virtual ~UnderwaterCameraROSPlugin() Class destructor.","title":"function ~UnderwaterCameraROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1UnderwaterCameraROSPlugin/#function-load","text":"void Load( sensors::SensorPtr _sensor, sdf::ElementPtr _sdf ) Load plugin and its configuration from sdf.","title":"function Load"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1UnderwaterCameraROSPlugin/#function-onnewdepthframe","text":"virtual void OnNewDepthFrame( const float * _image, unsigned int _width, unsigned int _height, unsigned int _depth, const std::string & _format )","title":"function OnNewDepthFrame"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1UnderwaterCameraROSPlugin/#function-onnewrgbpointcloud","text":"virtual void OnNewRGBPointCloud( const float * _pcd, unsigned int _width, unsigned int _height, unsigned int _depth, const std::string & _format ) Update the controller.","title":"function OnNewRGBPointCloud"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1UnderwaterCameraROSPlugin/#function-onnewimageframe","text":"virtual void OnNewImageFrame( const unsigned char * _image, unsigned int _width, unsigned int _height, unsigned int _depth, const std::string & _format )","title":"function OnNewImageFrame"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1UnderwaterCameraROSPlugin/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1UnderwaterCameraROSPlugin/#function-simulateunderwater","text":"virtual void SimulateUnderwater( const cv::Mat & _inputImage, const cv::Mat & _inputDepth, cv::Mat & _outputImage ) Add underwater light damping to image.","title":"function SimulateUnderwater"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1UnderwaterCameraROSPlugin/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1UnderwaterCameraROSPlugin/#variable-lastdepth","text":"const float * lastDepth; Temporarily store pointer to previous depth image.","title":"variable lastDepth"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1UnderwaterCameraROSPlugin/#variable-lastimage","text":"unsigned char * lastImage; Latest simulated image.","title":"variable lastImage"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1UnderwaterCameraROSPlugin/#variable-depth2rangelut","text":"float * depth2rangeLUT; Depth to range lookup table (LUT)","title":"variable depth2rangeLUT"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1UnderwaterCameraROSPlugin/#variable-attenuation","text":"float attenuation; Attenuation constants per channel (RGB)","title":"variable attenuation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1UnderwaterCameraROSPlugin/#variable-background","text":"unsigned char background; Background constants per channel (RGB) Updated on 2022-05-30 at 18:35:14 +0000","title":"variable background"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1modemPlugin/","text":"gazebo::modemPlugin Inherits from ModelPlugin Public Functions Name modemPlugin () ~modemPlugin () void Load (physics::ModelPtr _model, sdf::ElementPtr _sdf) void iisRosCallback (uuv_sensor_ros_plugins_msgs::modemLocationConstPtr modem_position) void cisRosCallback (uuv_sensor_ros_plugins_msgs::modemLocationConstPtr modem_position) void payloadToTransmitCallback (const std_msgs::StringConstPtr & payload) void queueThread () void publishPosition (double & bearing, double & range, double & elevation) void calcuateRelativePose (ignition::math::Vector3d position, double & bearing, double & range, double & elevation) Public Functions Documentation function modemPlugin modemPlugin() function ~modemPlugin ~modemPlugin() function Load void Load( physics::ModelPtr _model, sdf::ElementPtr _sdf ) function iisRosCallback void iisRosCallback( uuv_sensor_ros_plugins_msgs::modemLocationConstPtr modem_position ) function cisRosCallback void cisRosCallback( uuv_sensor_ros_plugins_msgs::modemLocationConstPtr modem_position ) function payloadToTransmitCallback void payloadToTransmitCallback( const std_msgs::StringConstPtr & payload ) function queueThread void queueThread() function publishPosition void publishPosition( double & bearing, double & range, double & elevation ) function calcuateRelativePose void calcuateRelativePose( ignition::math::Vector3d position, double & bearing, double & range, double & elevation ) Updated on 2022-05-30 at 18:35:14 +0000","title":"gazebo::modemPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1modemPlugin/#gazebomodemplugin","text":"Inherits from ModelPlugin","title":"gazebo::modemPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1modemPlugin/#public-functions","text":"Name modemPlugin () ~modemPlugin () void Load (physics::ModelPtr _model, sdf::ElementPtr _sdf) void iisRosCallback (uuv_sensor_ros_plugins_msgs::modemLocationConstPtr modem_position) void cisRosCallback (uuv_sensor_ros_plugins_msgs::modemLocationConstPtr modem_position) void payloadToTransmitCallback (const std_msgs::StringConstPtr & payload) void queueThread () void publishPosition (double & bearing, double & range, double & elevation) void calcuateRelativePose (ignition::math::Vector3d position, double & bearing, double & range, double & elevation)","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1modemPlugin/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1modemPlugin/#function-modemplugin","text":"modemPlugin()","title":"function modemPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1modemPlugin/#function-modemplugin_1","text":"~modemPlugin()","title":"function ~modemPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1modemPlugin/#function-load","text":"void Load( physics::ModelPtr _model, sdf::ElementPtr _sdf )","title":"function Load"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1modemPlugin/#function-iisroscallback","text":"void iisRosCallback( uuv_sensor_ros_plugins_msgs::modemLocationConstPtr modem_position )","title":"function iisRosCallback"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1modemPlugin/#function-cisroscallback","text":"void cisRosCallback( uuv_sensor_ros_plugins_msgs::modemLocationConstPtr modem_position )","title":"function cisRosCallback"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1modemPlugin/#function-payloadtotransmitcallback","text":"void payloadToTransmitCallback( const std_msgs::StringConstPtr & payload )","title":"function payloadToTransmitCallback"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1modemPlugin/#function-queuethread","text":"void queueThread()","title":"function queueThread"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1modemPlugin/#function-publishposition","text":"void publishPosition( double & bearing, double & range, double & elevation )","title":"function publishPosition"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1modemPlugin/#function-calcuaterelativepose","text":"void calcuateRelativePose( ignition::math::Vector3d position, double & bearing, double & range, double & elevation ) Updated on 2022-05-30 at 18:35:14 +0000","title":"function calcuateRelativePose"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1usblPlugin/","text":"gazebo::usblPlugin Inherits from ModelPlugin Public Functions Name usblPlugin () ~usblPlugin () void Load (physics::ModelPtr _model, sdf::ElementPtr _sdf) void sendPing (const ros::TimerEvent & ) void channelSwitchCallback (const std_msgs::StringConstPtr & msg) void interrogationModeRosCallback (const std_msgs::StringConstPtr & msg) void receiveModemPoseCallback (uuv_sensor_ros_plugins_msgs::modemLocationConstPtr modem_position) void publishPosition (double & bearing, double & range, double & elevation) void calcuateRelativePose (ignition::math::Vector3d position, double & bearing, double & range, double & elevation) void payloadToTransmitCallback (const std_msgs::StringConstPtr & payload) void enablePingerCallback (const std_msgs::BoolConstPtr & msg) void queueThread () int getIndex (std::string elem) Public Attributes Name std::string m_namespace std::string m_usblDevice std::string m_usblID std::string m_modemAttachedObject std::string m_usblAttachedObject std::string m_channel std::string m_interrogationMode std::string m_pingerScheduler Public Functions Documentation function usblPlugin usblPlugin() function ~usblPlugin ~usblPlugin() function Load void Load( physics::ModelPtr _model, sdf::ElementPtr _sdf ) SDF PARAMETERS function sendPing void sendPing( const ros::TimerEvent & ) function channelSwitchCallback void channelSwitchCallback( const std_msgs::StringConstPtr & msg ) function interrogationModeRosCallback void interrogationModeRosCallback( const std_msgs::StringConstPtr & msg ) function receiveModemPoseCallback void receiveModemPoseCallback( uuv_sensor_ros_plugins_msgs::modemLocationConstPtr modem_position ) function publishPosition void publishPosition( double & bearing, double & range, double & elevation ) function calcuateRelativePose void calcuateRelativePose( ignition::math::Vector3d position, double & bearing, double & range, double & elevation ) function payloadToTransmitCallback void payloadToTransmitCallback( const std_msgs::StringConstPtr & payload ) function enablePingerCallback void enablePingerCallback( const std_msgs::BoolConstPtr & msg ) function queueThread void queueThread() function getIndex int getIndex( std::string elem ) Public Attributes Documentation variable m_namespace std::string m_namespace; variable m_usblDevice std::string m_usblDevice; variable m_usblID std::string m_usblID; variable m_modemAttachedObject std::string m_modemAttachedObject; variable m_usblAttachedObject std::string m_usblAttachedObject; variable m_channel std::string m_channel = \"1\"; variable m_interrogationMode std::string m_interrogationMode; variable m_pingerScheduler std::string m_pingerScheduler = \"1\"; Updated on 2022-05-30 at 18:35:14 +0000","title":"gazebo::usblPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1usblPlugin/#gazebousblplugin","text":"Inherits from ModelPlugin","title":"gazebo::usblPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1usblPlugin/#public-functions","text":"Name usblPlugin () ~usblPlugin () void Load (physics::ModelPtr _model, sdf::ElementPtr _sdf) void sendPing (const ros::TimerEvent & ) void channelSwitchCallback (const std_msgs::StringConstPtr & msg) void interrogationModeRosCallback (const std_msgs::StringConstPtr & msg) void receiveModemPoseCallback (uuv_sensor_ros_plugins_msgs::modemLocationConstPtr modem_position) void publishPosition (double & bearing, double & range, double & elevation) void calcuateRelativePose (ignition::math::Vector3d position, double & bearing, double & range, double & elevation) void payloadToTransmitCallback (const std_msgs::StringConstPtr & payload) void enablePingerCallback (const std_msgs::BoolConstPtr & msg) void queueThread () int getIndex (std::string elem)","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1usblPlugin/#public-attributes","text":"Name std::string m_namespace std::string m_usblDevice std::string m_usblID std::string m_modemAttachedObject std::string m_usblAttachedObject std::string m_channel std::string m_interrogationMode std::string m_pingerScheduler","title":"Public Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1usblPlugin/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1usblPlugin/#function-usblplugin","text":"usblPlugin()","title":"function usblPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1usblPlugin/#function-usblplugin_1","text":"~usblPlugin()","title":"function ~usblPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1usblPlugin/#function-load","text":"void Load( physics::ModelPtr _model, sdf::ElementPtr _sdf ) SDF PARAMETERS","title":"function Load"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1usblPlugin/#function-sendping","text":"void sendPing( const ros::TimerEvent & )","title":"function sendPing"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1usblPlugin/#function-channelswitchcallback","text":"void channelSwitchCallback( const std_msgs::StringConstPtr & msg )","title":"function channelSwitchCallback"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1usblPlugin/#function-interrogationmoderoscallback","text":"void interrogationModeRosCallback( const std_msgs::StringConstPtr & msg )","title":"function interrogationModeRosCallback"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1usblPlugin/#function-receivemodemposecallback","text":"void receiveModemPoseCallback( uuv_sensor_ros_plugins_msgs::modemLocationConstPtr modem_position )","title":"function receiveModemPoseCallback"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1usblPlugin/#function-publishposition","text":"void publishPosition( double & bearing, double & range, double & elevation )","title":"function publishPosition"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1usblPlugin/#function-calcuaterelativepose","text":"void calcuateRelativePose( ignition::math::Vector3d position, double & bearing, double & range, double & elevation )","title":"function calcuateRelativePose"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1usblPlugin/#function-payloadtotransmitcallback","text":"void payloadToTransmitCallback( const std_msgs::StringConstPtr & payload )","title":"function payloadToTransmitCallback"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1usblPlugin/#function-enablepingercallback","text":"void enablePingerCallback( const std_msgs::BoolConstPtr & msg )","title":"function enablePingerCallback"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1usblPlugin/#function-queuethread","text":"void queueThread()","title":"function queueThread"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1usblPlugin/#function-getindex","text":"int getIndex( std::string elem )","title":"function getIndex"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1usblPlugin/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1usblPlugin/#variable-m_namespace","text":"std::string m_namespace;","title":"variable m_namespace"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1usblPlugin/#variable-m_usbldevice","text":"std::string m_usblDevice;","title":"variable m_usblDevice"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1usblPlugin/#variable-m_usblid","text":"std::string m_usblID;","title":"variable m_usblID"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1usblPlugin/#variable-m_modemattachedobject","text":"std::string m_modemAttachedObject;","title":"variable m_modemAttachedObject"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1usblPlugin/#variable-m_usblattachedobject","text":"std::string m_usblAttachedObject;","title":"variable m_usblAttachedObject"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1usblPlugin/#variable-m_channel","text":"std::string m_channel = \"1\";","title":"variable m_channel"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1usblPlugin/#variable-m_interrogationmode","text":"std::string m_interrogationMode;","title":"variable m_interrogationMode"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classgazebo_1_1usblPlugin/#variable-m_pingerscheduler","text":"std::string m_pingerScheduler = \"1\"; Updated on 2022-05-30 at 18:35:14 +0000","title":"variable m_pingerScheduler"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classtest__urdf__files_1_1TestURDFFiles/","text":"test_urdf_files::TestURDFFiles Inherits from TestCase Public Functions Name def test_xacro (self self) Public Functions Documentation function test_xacro def test_xacro( self self ) Updated on 2022-05-30 at 18:35:14 +0000","title":"test_urdf_files::TestURDFFiles"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classtest__urdf__files_1_1TestURDFFiles/#test_urdf_filestesturdffiles","text":"Inherits from TestCase","title":"test_urdf_files::TestURDFFiles"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classtest__urdf__files_1_1TestURDFFiles/#public-functions","text":"Name def test_xacro (self self)","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classtest__urdf__files_1_1TestURDFFiles/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/classtest__urdf__files_1_1TestURDFFiles/#function-test_xacro","text":"def test_xacro( self self ) Updated on 2022-05-30 at 18:35:14 +0000","title":"function test_xacro"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/structgazebo_1_1IMUParameters/","text":"title: gazebo::IMUParameters summary: IMUParameters stores all IMU model parameters. A description of these parameters can be found here: https://github.com/ethz-asl/kalibr/wiki/IMU-Noise-Model-and-Intrinsics. gazebo::IMUParameters IMUParameters stores all IMU model parameters. A description of these parameters can be found here: https://github.com/ethz-asl/kalibr/wiki/IMU-Noise-Model-and-Intrinsics . #include <IMUROSPlugin.hh> Public Functions Name IMUParameters () Constructor. Public Attributes Name double gyroscopeNoiseDensity Gyroscope noise density (two-sided spectrum) [rad/s/sqrt(Hz)]. double gyroscopeRandomWalk Gyroscope bias random walk [rad/s/s/sqrt(Hz)]. double gyroscopeBiasCorrelationTime Gyroscope bias correlation time constant [s]. double gyroscopeTurnOnBiasSigma Gyroscope turn on bias standard deviation [rad/s]. double accelerometerNoiseDensity Accelerometer noise density (two-sided spectrum) [m/s^2/sqrt(Hz)]. double accelerometerRandomWalk Accelerometer bias random walk. [m/s^2/s/sqrt(Hz)]. double accelerometerBiasCorrelationTime Accelerometer bias correlation time constant [s]. double accelerometerTurnOnBiasSigma Accelerometer turn on bias standard deviation [m/s^2]. double orientationNoise Standard deviation of orientation noise per axis [rad]. Public Functions Documentation function IMUParameters inline IMUParameters() Constructor. Public Attributes Documentation variable gyroscopeNoiseDensity double gyroscopeNoiseDensity; Gyroscope noise density (two-sided spectrum) [rad/s/sqrt(Hz)]. variable gyroscopeRandomWalk double gyroscopeRandomWalk; Gyroscope bias random walk [rad/s/s/sqrt(Hz)]. variable gyroscopeBiasCorrelationTime double gyroscopeBiasCorrelationTime; Gyroscope bias correlation time constant [s]. variable gyroscopeTurnOnBiasSigma double gyroscopeTurnOnBiasSigma; Gyroscope turn on bias standard deviation [rad/s]. variable accelerometerNoiseDensity double accelerometerNoiseDensity; Accelerometer noise density (two-sided spectrum) [m/s^2/sqrt(Hz)]. variable accelerometerRandomWalk double accelerometerRandomWalk; Accelerometer bias random walk. [m/s^2/s/sqrt(Hz)]. variable accelerometerBiasCorrelationTime double accelerometerBiasCorrelationTime; Accelerometer bias correlation time constant [s]. variable accelerometerTurnOnBiasSigma double accelerometerTurnOnBiasSigma; Accelerometer turn on bias standard deviation [m/s^2]. variable orientationNoise double orientationNoise; Standard deviation of orientation noise per axis [rad]. Updated on 2022-05-30 at 18:35:14 +0000","title":"structgazebo 1 1IMUParameters"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/structgazebo_1_1IMUParameters/#gazeboimuparameters","text":"IMUParameters stores all IMU model parameters. A description of these parameters can be found here: https://github.com/ethz-asl/kalibr/wiki/IMU-Noise-Model-and-Intrinsics . #include <IMUROSPlugin.hh>","title":"gazebo::IMUParameters"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/structgazebo_1_1IMUParameters/#public-functions","text":"Name IMUParameters () Constructor.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/structgazebo_1_1IMUParameters/#public-attributes","text":"Name double gyroscopeNoiseDensity Gyroscope noise density (two-sided spectrum) [rad/s/sqrt(Hz)]. double gyroscopeRandomWalk Gyroscope bias random walk [rad/s/s/sqrt(Hz)]. double gyroscopeBiasCorrelationTime Gyroscope bias correlation time constant [s]. double gyroscopeTurnOnBiasSigma Gyroscope turn on bias standard deviation [rad/s]. double accelerometerNoiseDensity Accelerometer noise density (two-sided spectrum) [m/s^2/sqrt(Hz)]. double accelerometerRandomWalk Accelerometer bias random walk. [m/s^2/s/sqrt(Hz)]. double accelerometerBiasCorrelationTime Accelerometer bias correlation time constant [s]. double accelerometerTurnOnBiasSigma Accelerometer turn on bias standard deviation [m/s^2]. double orientationNoise Standard deviation of orientation noise per axis [rad].","title":"Public Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/structgazebo_1_1IMUParameters/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/structgazebo_1_1IMUParameters/#function-imuparameters","text":"inline IMUParameters() Constructor.","title":"function IMUParameters"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/structgazebo_1_1IMUParameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/structgazebo_1_1IMUParameters/#variable-gyroscopenoisedensity","text":"double gyroscopeNoiseDensity; Gyroscope noise density (two-sided spectrum) [rad/s/sqrt(Hz)].","title":"variable gyroscopeNoiseDensity"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/structgazebo_1_1IMUParameters/#variable-gyroscoperandomwalk","text":"double gyroscopeRandomWalk; Gyroscope bias random walk [rad/s/s/sqrt(Hz)].","title":"variable gyroscopeRandomWalk"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/structgazebo_1_1IMUParameters/#variable-gyroscopebiascorrelationtime","text":"double gyroscopeBiasCorrelationTime; Gyroscope bias correlation time constant [s].","title":"variable gyroscopeBiasCorrelationTime"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/structgazebo_1_1IMUParameters/#variable-gyroscopeturnonbiassigma","text":"double gyroscopeTurnOnBiasSigma; Gyroscope turn on bias standard deviation [rad/s].","title":"variable gyroscopeTurnOnBiasSigma"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/structgazebo_1_1IMUParameters/#variable-accelerometernoisedensity","text":"double accelerometerNoiseDensity; Accelerometer noise density (two-sided spectrum) [m/s^2/sqrt(Hz)].","title":"variable accelerometerNoiseDensity"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/structgazebo_1_1IMUParameters/#variable-accelerometerrandomwalk","text":"double accelerometerRandomWalk; Accelerometer bias random walk. [m/s^2/s/sqrt(Hz)].","title":"variable accelerometerRandomWalk"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/structgazebo_1_1IMUParameters/#variable-accelerometerbiascorrelationtime","text":"double accelerometerBiasCorrelationTime; Accelerometer bias correlation time constant [s].","title":"variable accelerometerBiasCorrelationTime"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/structgazebo_1_1IMUParameters/#variable-accelerometerturnonbiassigma","text":"double accelerometerTurnOnBiasSigma; Accelerometer turn on bias standard deviation [m/s^2].","title":"variable accelerometerTurnOnBiasSigma"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/structgazebo_1_1IMUParameters/#variable-orientationnoise","text":"double orientationNoise; Standard deviation of orientation noise per axis [rad]. Updated on 2022-05-30 at 18:35:14 +0000","title":"variable orientationNoise"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/structgazebo_1_1MagnetometerParameters/","text":"gazebo::MagnetometerParameters Public Attributes Name double intensity Intensity of reference earth magnetic field [muT]. double heading Heading angle of reference earth magnetic field [rad]. double declination Declination of reference earth magnetic field [rad]. double inclination Inclination of reference earth magnetic field [rad]. double noiseXY Discrete-time standard dev. of output noise in xy-axis [muT]. double noiseZ Discrete-time standard dev. of output noise in z-axis [muT]. double turnOnBias Standard deviation of constant systematic offset of measurements [muT]. Public Attributes Documentation variable intensity double intensity; Intensity of reference earth magnetic field [muT]. variable heading double heading; Heading angle of reference earth magnetic field [rad]. variable declination double declination; Declination of reference earth magnetic field [rad]. variable inclination double inclination; Inclination of reference earth magnetic field [rad]. variable noiseXY double noiseXY; Discrete-time standard dev. of output noise in xy-axis [muT]. variable noiseZ double noiseZ; Discrete-time standard dev. of output noise in z-axis [muT]. variable turnOnBias double turnOnBias; Standard deviation of constant systematic offset of measurements [muT]. Updated on 2022-05-30 at 18:35:14 +0000","title":"gazebo::MagnetometerParameters"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/structgazebo_1_1MagnetometerParameters/#gazebomagnetometerparameters","text":"","title":"gazebo::MagnetometerParameters"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/structgazebo_1_1MagnetometerParameters/#public-attributes","text":"Name double intensity Intensity of reference earth magnetic field [muT]. double heading Heading angle of reference earth magnetic field [rad]. double declination Declination of reference earth magnetic field [rad]. double inclination Inclination of reference earth magnetic field [rad]. double noiseXY Discrete-time standard dev. of output noise in xy-axis [muT]. double noiseZ Discrete-time standard dev. of output noise in z-axis [muT]. double turnOnBias Standard deviation of constant systematic offset of measurements [muT].","title":"Public Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/structgazebo_1_1MagnetometerParameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/structgazebo_1_1MagnetometerParameters/#variable-intensity","text":"double intensity; Intensity of reference earth magnetic field [muT].","title":"variable intensity"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/structgazebo_1_1MagnetometerParameters/#variable-heading","text":"double heading; Heading angle of reference earth magnetic field [rad].","title":"variable heading"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/structgazebo_1_1MagnetometerParameters/#variable-declination","text":"double declination; Declination of reference earth magnetic field [rad].","title":"variable declination"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/structgazebo_1_1MagnetometerParameters/#variable-inclination","text":"double inclination; Inclination of reference earth magnetic field [rad].","title":"variable inclination"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/structgazebo_1_1MagnetometerParameters/#variable-noisexy","text":"double noiseXY; Discrete-time standard dev. of output noise in xy-axis [muT].","title":"variable noiseXY"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/structgazebo_1_1MagnetometerParameters/#variable-noisez","text":"double noiseZ; Discrete-time standard dev. of output noise in z-axis [muT].","title":"variable noiseZ"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Classes/structgazebo_1_1MagnetometerParameters/#variable-turnonbias","text":"double turnOnBias; Standard deviation of constant systematic offset of measurements [muT]. Updated on 2022-05-30 at 18:35:14 +0000","title":"variable turnOnBias"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:14 +0000","title":"Examples"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:14 +0000","title":"Examples"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:14 +0000","title":"Modules"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:14 +0000","title":"Modules"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Namespaces/","text":"Namespaces namespace cv namespace gazebo namespace std namespace test_urdf_files Updated on 2022-05-30 at 18:35:14 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Namespaces/#namespaces","text":"namespace cv namespace gazebo namespace std namespace test_urdf_files Updated on 2022-05-30 at 18:35:14 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Namespaces/namespacecv/","text":"cv Updated on 2022-05-30 at 18:35:14 +0000","title":"cv"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Namespaces/namespacecv/#cv","text":"Updated on 2022-05-30 at 18:35:14 +0000","title":"cv"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Namespaces/namespacegazebo/","text":"gazebo More... Classes Name class gazebo::AltimeterROSPlugin class gazebo::CPCROSPlugin class gazebo::DVLROSPlugin class gazebo::GazeboRosImageSonar class gazebo::GPSROSPlugin class gazebo::GstCameraPlugin struct gazebo::IMUParameters IMUParameters stores all IMU model parameters. A description of these parameters can be found here: https://github.com/ethz-asl/kalibr/wiki/IMU-Noise-Model-and-Intrinsics . class gazebo::IMUROSPlugin struct gazebo::MagnetometerParameters class gazebo::MagnetometerROSPlugin class gazebo::modemPlugin class gazebo::PoseGTROSPlugin class gazebo::ROSBaseModelPlugin class gazebo::ROSBasePlugin class gazebo::ROSBaseSensorPlugin class gazebo::RPTROSPlugin class gazebo::SubseaPressureROSPlugin class gazebo::UnderwaterCameraROSPlugin class gazebo::usblPlugin Functions Name template <class T > bool GetSDFParam (sdf::ElementPtr sdf, const std::string & name, T & param, const T & default_value, const bool & verbose =false) Obtains a parameter from sdf. Detailed Description Author : Jose Capriles. Jose Capriles, Bence Magyar. Functions Documentation function GetSDFParam template <class T > bool GetSDFParam( sdf::ElementPtr sdf, const std::string & name, T & param, const T & default_value, const bool & verbose =false ) Obtains a parameter from sdf. Parameters : sdf Pointer to the sdf object. name Name of the parameter. param Param Variable to write the parameter to. default_value Default value, if the parameter not available. verbose If true, gzerror if the parameter is not available. Updated on 2022-05-30 at 18:35:14 +0000","title":"gazebo"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Namespaces/namespacegazebo/#gazebo","text":"More...","title":"gazebo"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Namespaces/namespacegazebo/#classes","text":"Name class gazebo::AltimeterROSPlugin class gazebo::CPCROSPlugin class gazebo::DVLROSPlugin class gazebo::GazeboRosImageSonar class gazebo::GPSROSPlugin class gazebo::GstCameraPlugin struct gazebo::IMUParameters IMUParameters stores all IMU model parameters. A description of these parameters can be found here: https://github.com/ethz-asl/kalibr/wiki/IMU-Noise-Model-and-Intrinsics . class gazebo::IMUROSPlugin struct gazebo::MagnetometerParameters class gazebo::MagnetometerROSPlugin class gazebo::modemPlugin class gazebo::PoseGTROSPlugin class gazebo::ROSBaseModelPlugin class gazebo::ROSBasePlugin class gazebo::ROSBaseSensorPlugin class gazebo::RPTROSPlugin class gazebo::SubseaPressureROSPlugin class gazebo::UnderwaterCameraROSPlugin class gazebo::usblPlugin","title":"Classes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Namespaces/namespacegazebo/#functions","text":"Name template <class T > bool GetSDFParam (sdf::ElementPtr sdf, const std::string & name, T & param, const T & default_value, const bool & verbose =false) Obtains a parameter from sdf.","title":"Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Namespaces/namespacegazebo/#detailed-description","text":"Author : Jose Capriles. Jose Capriles, Bence Magyar.","title":"Detailed Description"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Namespaces/namespacegazebo/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Namespaces/namespacegazebo/#function-getsdfparam","text":"template <class T > bool GetSDFParam( sdf::ElementPtr sdf, const std::string & name, T & param, const T & default_value, const bool & verbose =false ) Obtains a parameter from sdf. Parameters : sdf Pointer to the sdf object. name Name of the parameter. param Param Variable to write the parameter to. default_value Default value, if the parameter not available. verbose If true, gzerror if the parameter is not available. Updated on 2022-05-30 at 18:35:14 +0000","title":"function GetSDFParam"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Namespaces/namespacestd/","text":"std Updated on 2022-05-30 at 18:35:14 +0000","title":"std"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Namespaces/namespacestd/#std","text":"Updated on 2022-05-30 at 18:35:14 +0000","title":"std"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Namespaces/namespacetest__urdf__files/","text":"test_urdf_files Classes Name class test_urdf_files::TestURDFFiles Functions Name def call_xacro (xml_file xml_file) Attributes Name string PKG string NAME Functions Documentation function call_xacro def call_xacro( xml_file xml_file ) Attributes Documentation variable PKG string PKG = 'uuv_sensor_ros_plugins'; variable NAME string NAME = 'test_urdf_files'; Updated on 2022-05-30 at 18:35:14 +0000","title":"test_urdf_files"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Namespaces/namespacetest__urdf__files/#test_urdf_files","text":"","title":"test_urdf_files"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Namespaces/namespacetest__urdf__files/#classes","text":"Name class test_urdf_files::TestURDFFiles","title":"Classes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Namespaces/namespacetest__urdf__files/#functions","text":"Name def call_xacro (xml_file xml_file)","title":"Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Namespaces/namespacetest__urdf__files/#attributes","text":"Name string PKG string NAME","title":"Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Namespaces/namespacetest__urdf__files/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Namespaces/namespacetest__urdf__files/#function-call_xacro","text":"def call_xacro( xml_file xml_file )","title":"function call_xacro"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Namespaces/namespacetest__urdf__files/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Namespaces/namespacetest__urdf__files/#variable-pkg","text":"string PKG = 'uuv_sensor_ros_plugins';","title":"variable PKG"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_sensor_plugins/uuv_sensor_ros_plugins/Namespaces/namespacetest__urdf__files/#variable-name","text":"string NAME = 'test_urdf_files'; Updated on 2022-05-30 at 18:35:14 +0000","title":"variable NAME"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/","text":"Classes namespace gazebo class GaussMarkovProcess Implementation of a Gauss-Markov process to model the current velocity and direction according to [1] [1] Fossen, Thor I. Handbook of marine craft hydrodynamics and motion control. John Wiley & Sons, 2011. class UnderwaterCurrentPlugin Class for the underwater current plugin TODO: Add option to make the underwater current also a function of depth to comply with DNV. Updated on 2022-05-30 at 18:35:14 +0000","title":"Classes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/#classes","text":"namespace gazebo class GaussMarkovProcess Implementation of a Gauss-Markov process to model the current velocity and direction according to [1] [1] Fossen, Thor I. Handbook of marine craft hydrodynamics and motion control. John Wiley & Sons, 2011. class UnderwaterCurrentPlugin Class for the underwater current plugin TODO: Add option to make the underwater current also a function of depth to comply with DNV. Updated on 2022-05-30 at 18:35:14 +0000","title":"Classes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1GaussMarkovProcess/","text":"gazebo::GaussMarkovProcess Implementation of a Gauss-Markov process to model the current velocity and direction according to [1] [1] Fossen, Thor I. Handbook of marine craft hydrodynamics and motion control. John Wiley & Sons, 2011. #include <GaussMarkovProcess.hh> Public Functions Name GaussMarkovProcess () Class constructor. void Reset () Resets the process parameters. bool SetModel (double _mean, double _min, double _max, double _mu =0, double _noise =0) Sets all the necessary parameters for the computation. bool SetMean (double _mean) Set mean process value. double Update (double _time) Update function for a new time stamp. void Print () Print current model paramters. Public Attributes Name double var Process variable. double mean Mean process value. double min Minimum limit for the process variable. double max Maximum limit for the process variable. double mu Process constant, if zero, process becomes a random walk. double noiseAmp Gaussian white noise amplitude. double lastUpdate Timestamp for the last update. Public Functions Documentation function GaussMarkovProcess GaussMarkovProcess() Class constructor. function Reset void Reset() Resets the process parameters. function SetModel bool SetModel( double _mean, double _min, double _max, double _mu =0, double _noise =0 ) Sets all the necessary parameters for the computation. Parameters : _mean Mean value _min Minimum limit _max Maximum limit _mu Process constant _noise Amplitude for the Gaussian white noise Return : True, if all parameters were valid function SetMean bool SetMean( double _mean ) Set mean process value. Parameters : _mean New mean value Return : True, if value inside the limit range function Update double Update( double _time ) Update function for a new time stamp. Parameters : _time Current time stamp function Print void Print() Print current model paramters. Public Attributes Documentation variable var double var; Process variable. variable mean double mean; Mean process value. variable min double min; Minimum limit for the process variable. variable max double max; Maximum limit for the process variable. variable mu double mu; Process constant, if zero, process becomes a random walk. variable noiseAmp double noiseAmp; Gaussian white noise amplitude. variable lastUpdate double lastUpdate; Timestamp for the last update. Updated on 2022-05-30 at 18:35:14 +0000","title":"gazebo::GaussMarkovProcess"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1GaussMarkovProcess/#gazebogaussmarkovprocess","text":"Implementation of a Gauss-Markov process to model the current velocity and direction according to [1] [1] Fossen, Thor I. Handbook of marine craft hydrodynamics and motion control. John Wiley & Sons, 2011. #include <GaussMarkovProcess.hh>","title":"gazebo::GaussMarkovProcess"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1GaussMarkovProcess/#public-functions","text":"Name GaussMarkovProcess () Class constructor. void Reset () Resets the process parameters. bool SetModel (double _mean, double _min, double _max, double _mu =0, double _noise =0) Sets all the necessary parameters for the computation. bool SetMean (double _mean) Set mean process value. double Update (double _time) Update function for a new time stamp. void Print () Print current model paramters.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1GaussMarkovProcess/#public-attributes","text":"Name double var Process variable. double mean Mean process value. double min Minimum limit for the process variable. double max Maximum limit for the process variable. double mu Process constant, if zero, process becomes a random walk. double noiseAmp Gaussian white noise amplitude. double lastUpdate Timestamp for the last update.","title":"Public Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1GaussMarkovProcess/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1GaussMarkovProcess/#function-gaussmarkovprocess","text":"GaussMarkovProcess() Class constructor.","title":"function GaussMarkovProcess"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1GaussMarkovProcess/#function-reset","text":"void Reset() Resets the process parameters.","title":"function Reset"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1GaussMarkovProcess/#function-setmodel","text":"bool SetModel( double _mean, double _min, double _max, double _mu =0, double _noise =0 ) Sets all the necessary parameters for the computation. Parameters : _mean Mean value _min Minimum limit _max Maximum limit _mu Process constant _noise Amplitude for the Gaussian white noise Return : True, if all parameters were valid","title":"function SetModel"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1GaussMarkovProcess/#function-setmean","text":"bool SetMean( double _mean ) Set mean process value. Parameters : _mean New mean value Return : True, if value inside the limit range","title":"function SetMean"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1GaussMarkovProcess/#function-update","text":"double Update( double _time ) Update function for a new time stamp. Parameters : _time Current time stamp","title":"function Update"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1GaussMarkovProcess/#function-print","text":"void Print() Print current model paramters.","title":"function Print"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1GaussMarkovProcess/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1GaussMarkovProcess/#variable-var","text":"double var; Process variable.","title":"variable var"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1GaussMarkovProcess/#variable-mean","text":"double mean; Mean process value.","title":"variable mean"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1GaussMarkovProcess/#variable-min","text":"double min; Minimum limit for the process variable.","title":"variable min"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1GaussMarkovProcess/#variable-max","text":"double max; Maximum limit for the process variable.","title":"variable max"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1GaussMarkovProcess/#variable-mu","text":"double mu; Process constant, if zero, process becomes a random walk.","title":"variable mu"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1GaussMarkovProcess/#variable-noiseamp","text":"double noiseAmp; Gaussian white noise amplitude.","title":"variable noiseAmp"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1GaussMarkovProcess/#variable-lastupdate","text":"double lastUpdate; Timestamp for the last update. Updated on 2022-05-30 at 18:35:14 +0000","title":"variable lastUpdate"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1UnderwaterCurrentPlugin/","text":"title: gazebo::UnderwaterCurrentPlugin summary: Class for the underwater current plugin TODO: Add option to make the underwater current also a function of depth to comply with DNV. gazebo::UnderwaterCurrentPlugin Class for the underwater current plugin TODO: Add option to make the underwater current also a function of depth to comply with DNV. #include <UnderwaterCurrentPlugin.hh> Inherits from WorldPlugin Public Functions Name UnderwaterCurrentPlugin () Class constructor. virtual ~UnderwaterCurrentPlugin () Class destructor. virtual void Load (physics::WorldPtr _world, sdf::ElementPtr _sdf) virtual void Init () void Update (const common::UpdateInfo & _info) Update the simulation state. Protected Functions Name void PublishCurrentVelocity () Publish current velocity and the pose of its frame. Protected Attributes Name event::ConnectionPtr updateConnection Update event. physics::WorldPtr world Pointer to world. sdf::ElementPtr sdf Pointer to sdf. bool hasSurface True if the sea surface is present. transport::NodePtr node Pointer to a node for communication. std::map< std::string, transport::PublisherPtr > publishers Map of publishers. std::string currentVelocityTopic Current velocity topic. std::string ns Namespace for topics and services. GaussMarkovProcess currentVelModel Gauss-Markov process instance for the current velocity. GaussMarkovProcess currentHorzAngleModel Gauss-Markov process instance for horizontal angle model. GaussMarkovProcess currentVertAngleModel Gauss-Markov process instance for vertical angle model. common::Time lastUpdate Last update time stamp. ignition::math::Vector3d currentVelocity Current linear velocity vector. Public Functions Documentation function UnderwaterCurrentPlugin UnderwaterCurrentPlugin() Class constructor. function ~UnderwaterCurrentPlugin virtual ~UnderwaterCurrentPlugin() Class destructor. function Load virtual void Load( physics::WorldPtr _world, sdf::ElementPtr _sdf ) function Init virtual void Init() function Update void Update( const common::UpdateInfo & _info ) Update the simulation state. Parameters : _info Information used in the update event. Protected Functions Documentation function PublishCurrentVelocity void PublishCurrentVelocity() Publish current velocity and the pose of its frame. Protected Attributes Documentation variable updateConnection event::ConnectionPtr updateConnection; Update event. variable world physics::WorldPtr world; Pointer to world. variable sdf sdf::ElementPtr sdf; Pointer to sdf. variable hasSurface bool hasSurface; True if the sea surface is present. variable node transport::NodePtr node; Pointer to a node for communication. variable publishers std::map< std::string, transport::PublisherPtr > publishers; Map of publishers. variable currentVelocityTopic std::string currentVelocityTopic; Current velocity topic. variable ns std::string ns; Namespace for topics and services. variable currentVelModel GaussMarkovProcess currentVelModel; Gauss-Markov process instance for the current velocity. variable currentHorzAngleModel GaussMarkovProcess currentHorzAngleModel; Gauss-Markov process instance for horizontal angle model. variable currentVertAngleModel GaussMarkovProcess currentVertAngleModel; Gauss-Markov process instance for vertical angle model. variable lastUpdate common::Time lastUpdate; Last update time stamp. variable currentVelocity ignition::math::Vector3d currentVelocity; Current linear velocity vector. Updated on 2022-05-30 at 18:35:14 +0000","title":"classgazebo 1 1UnderwaterCurrentPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1UnderwaterCurrentPlugin/#gazebounderwatercurrentplugin","text":"Class for the underwater current plugin TODO: Add option to make the underwater current also a function of depth to comply with DNV. #include <UnderwaterCurrentPlugin.hh> Inherits from WorldPlugin","title":"gazebo::UnderwaterCurrentPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1UnderwaterCurrentPlugin/#public-functions","text":"Name UnderwaterCurrentPlugin () Class constructor. virtual ~UnderwaterCurrentPlugin () Class destructor. virtual void Load (physics::WorldPtr _world, sdf::ElementPtr _sdf) virtual void Init () void Update (const common::UpdateInfo & _info) Update the simulation state.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1UnderwaterCurrentPlugin/#protected-functions","text":"Name void PublishCurrentVelocity () Publish current velocity and the pose of its frame.","title":"Protected Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1UnderwaterCurrentPlugin/#protected-attributes","text":"Name event::ConnectionPtr updateConnection Update event. physics::WorldPtr world Pointer to world. sdf::ElementPtr sdf Pointer to sdf. bool hasSurface True if the sea surface is present. transport::NodePtr node Pointer to a node for communication. std::map< std::string, transport::PublisherPtr > publishers Map of publishers. std::string currentVelocityTopic Current velocity topic. std::string ns Namespace for topics and services. GaussMarkovProcess currentVelModel Gauss-Markov process instance for the current velocity. GaussMarkovProcess currentHorzAngleModel Gauss-Markov process instance for horizontal angle model. GaussMarkovProcess currentVertAngleModel Gauss-Markov process instance for vertical angle model. common::Time lastUpdate Last update time stamp. ignition::math::Vector3d currentVelocity Current linear velocity vector.","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1UnderwaterCurrentPlugin/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1UnderwaterCurrentPlugin/#function-underwatercurrentplugin","text":"UnderwaterCurrentPlugin() Class constructor.","title":"function UnderwaterCurrentPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1UnderwaterCurrentPlugin/#function-underwatercurrentplugin_1","text":"virtual ~UnderwaterCurrentPlugin() Class destructor.","title":"function ~UnderwaterCurrentPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1UnderwaterCurrentPlugin/#function-load","text":"virtual void Load( physics::WorldPtr _world, sdf::ElementPtr _sdf )","title":"function Load"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1UnderwaterCurrentPlugin/#function-init","text":"virtual void Init()","title":"function Init"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1UnderwaterCurrentPlugin/#function-update","text":"void Update( const common::UpdateInfo & _info ) Update the simulation state. Parameters : _info Information used in the update event.","title":"function Update"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1UnderwaterCurrentPlugin/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1UnderwaterCurrentPlugin/#function-publishcurrentvelocity","text":"void PublishCurrentVelocity() Publish current velocity and the pose of its frame.","title":"function PublishCurrentVelocity"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1UnderwaterCurrentPlugin/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1UnderwaterCurrentPlugin/#variable-updateconnection","text":"event::ConnectionPtr updateConnection; Update event.","title":"variable updateConnection"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1UnderwaterCurrentPlugin/#variable-world","text":"physics::WorldPtr world; Pointer to world.","title":"variable world"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1UnderwaterCurrentPlugin/#variable-sdf","text":"sdf::ElementPtr sdf; Pointer to sdf.","title":"variable sdf"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1UnderwaterCurrentPlugin/#variable-hassurface","text":"bool hasSurface; True if the sea surface is present.","title":"variable hasSurface"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1UnderwaterCurrentPlugin/#variable-node","text":"transport::NodePtr node; Pointer to a node for communication.","title":"variable node"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1UnderwaterCurrentPlugin/#variable-publishers","text":"std::map< std::string, transport::PublisherPtr > publishers; Map of publishers.","title":"variable publishers"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1UnderwaterCurrentPlugin/#variable-currentvelocitytopic","text":"std::string currentVelocityTopic; Current velocity topic.","title":"variable currentVelocityTopic"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1UnderwaterCurrentPlugin/#variable-ns","text":"std::string ns; Namespace for topics and services.","title":"variable ns"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1UnderwaterCurrentPlugin/#variable-currentvelmodel","text":"GaussMarkovProcess currentVelModel; Gauss-Markov process instance for the current velocity.","title":"variable currentVelModel"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1UnderwaterCurrentPlugin/#variable-currenthorzanglemodel","text":"GaussMarkovProcess currentHorzAngleModel; Gauss-Markov process instance for horizontal angle model.","title":"variable currentHorzAngleModel"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1UnderwaterCurrentPlugin/#variable-currentvertanglemodel","text":"GaussMarkovProcess currentVertAngleModel; Gauss-Markov process instance for vertical angle model.","title":"variable currentVertAngleModel"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1UnderwaterCurrentPlugin/#variable-lastupdate","text":"common::Time lastUpdate; Last update time stamp.","title":"variable lastUpdate"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Classes/classgazebo_1_1UnderwaterCurrentPlugin/#variable-currentvelocity","text":"ignition::math::Vector3d currentVelocity; Current linear velocity vector. Updated on 2022-05-30 at 18:35:14 +0000","title":"variable currentVelocity"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:14 +0000","title":"Examples"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:14 +0000","title":"Examples"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:14 +0000","title":"Modules"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:14 +0000","title":"Modules"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Namespaces/","text":"Namespaces namespace gazebo Updated on 2022-05-30 at 18:35:14 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Namespaces/#namespaces","text":"namespace gazebo Updated on 2022-05-30 at 18:35:14 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Namespaces/namespacegazebo/","text":"gazebo Classes Name class gazebo::GaussMarkovProcess Implementation of a Gauss-Markov process to model the current velocity and direction according to [1] [1] Fossen, Thor I. Handbook of marine craft hydrodynamics and motion control. John Wiley & Sons, 2011. class gazebo::UnderwaterCurrentPlugin Class for the underwater current plugin TODO: Add option to make the underwater current also a function of depth to comply with DNV. Updated on 2022-05-30 at 18:35:14 +0000","title":"gazebo"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Namespaces/namespacegazebo/#gazebo","text":"","title":"gazebo"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_plugins/Namespaces/namespacegazebo/#classes","text":"Name class gazebo::GaussMarkovProcess Implementation of a Gauss-Markov process to model the current velocity and direction according to [1] [1] Fossen, Thor I. Handbook of marine craft hydrodynamics and motion control. John Wiley & Sons, 2011. class gazebo::UnderwaterCurrentPlugin Class for the underwater current plugin TODO: Add option to make the underwater current also a function of depth to comply with DNV. Updated on 2022-05-30 at 18:35:14 +0000","title":"Classes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/","text":"Classes namespace gazebo class SphericalCoordinatesROSInterfacePlugin namespace uuv_simulator_ros class UnderwaterCurrentROSPlugin Updated on 2022-05-30 at 18:35:14 +0000","title":"Classes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/#classes","text":"namespace gazebo class SphericalCoordinatesROSInterfacePlugin namespace uuv_simulator_ros class UnderwaterCurrentROSPlugin Updated on 2022-05-30 at 18:35:14 +0000","title":"Classes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/classgazebo_1_1SphericalCoordinatesROSInterfacePlugin/","text":"gazebo::SphericalCoordinatesROSInterfacePlugin Inherits from WorldPlugin Public Functions Name SphericalCoordinatesROSInterfacePlugin () Constructor. virtual ~SphericalCoordinatesROSInterfacePlugin () Destructor. void Load (physics::WorldPtr _world, sdf::ElementPtr _sdf) Load module and read parameters from SDF. bool GetOriginSphericalCoord (uuv_world_ros_plugins_msgs::GetOriginSphericalCoord::Request & _req, uuv_world_ros_plugins_msgs::GetOriginSphericalCoord::Response & _res) Service call that returns the origin in WGS84 standard. bool SetOriginSphericalCoord (uuv_world_ros_plugins_msgs::SetOriginSphericalCoord::Request & _req, uuv_world_ros_plugins_msgs::SetOriginSphericalCoord::Response & _res) Service call that returns the origin in WGS84 standard. bool TransformToSphericalCoord (uuv_world_ros_plugins_msgs::TransformToSphericalCoord::Request & _req, uuv_world_ros_plugins_msgs::TransformToSphericalCoord::Response & _res) Service call to transform from Cartesian to spherical coordinates. bool TransformFromSphericalCoord (uuv_world_ros_plugins_msgs::TransformFromSphericalCoord::Request & _req, uuv_world_ros_plugins_msgs::TransformFromSphericalCoord::Response & _res) Service call to transform from spherical to Cartesian coordinates. Protected Attributes Name boost::scoped_ptr< ros::NodeHandle > rosNode Pointer to this ROS node's handle. event::ConnectionPtr rosPublishConnection Connection for callbacks on update world. physics::WorldPtr world Pointer to world. std::map< std::string, ros::ServiceServer > worldServices All underwater world services. Public Functions Documentation function SphericalCoordinatesROSInterfacePlugin SphericalCoordinatesROSInterfacePlugin() Constructor. function ~SphericalCoordinatesROSInterfacePlugin virtual ~SphericalCoordinatesROSInterfacePlugin() Destructor. function Load void Load( physics::WorldPtr _world, sdf::ElementPtr _sdf ) Load module and read parameters from SDF. function GetOriginSphericalCoord bool GetOriginSphericalCoord( uuv_world_ros_plugins_msgs::GetOriginSphericalCoord::Request & _req, uuv_world_ros_plugins_msgs::GetOriginSphericalCoord::Response & _res ) Service call that returns the origin in WGS84 standard. function SetOriginSphericalCoord bool SetOriginSphericalCoord( uuv_world_ros_plugins_msgs::SetOriginSphericalCoord::Request & _req, uuv_world_ros_plugins_msgs::SetOriginSphericalCoord::Response & _res ) Service call that returns the origin in WGS84 standard. function TransformToSphericalCoord bool TransformToSphericalCoord( uuv_world_ros_plugins_msgs::TransformToSphericalCoord::Request & _req, uuv_world_ros_plugins_msgs::TransformToSphericalCoord::Response & _res ) Service call to transform from Cartesian to spherical coordinates. function TransformFromSphericalCoord bool TransformFromSphericalCoord( uuv_world_ros_plugins_msgs::TransformFromSphericalCoord::Request & _req, uuv_world_ros_plugins_msgs::TransformFromSphericalCoord::Response & _res ) Service call to transform from spherical to Cartesian coordinates. Protected Attributes Documentation variable rosNode boost::scoped_ptr< ros::NodeHandle > rosNode; Pointer to this ROS node's handle. variable rosPublishConnection event::ConnectionPtr rosPublishConnection; Connection for callbacks on update world. variable world physics::WorldPtr world; Pointer to world. variable worldServices std::map< std::string, ros::ServiceServer > worldServices; All underwater world services. Updated on 2022-05-30 at 18:35:14 +0000","title":"gazebo::SphericalCoordinatesROSInterfacePlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/classgazebo_1_1SphericalCoordinatesROSInterfacePlugin/#gazebosphericalcoordinatesrosinterfaceplugin","text":"Inherits from WorldPlugin","title":"gazebo::SphericalCoordinatesROSInterfacePlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/classgazebo_1_1SphericalCoordinatesROSInterfacePlugin/#public-functions","text":"Name SphericalCoordinatesROSInterfacePlugin () Constructor. virtual ~SphericalCoordinatesROSInterfacePlugin () Destructor. void Load (physics::WorldPtr _world, sdf::ElementPtr _sdf) Load module and read parameters from SDF. bool GetOriginSphericalCoord (uuv_world_ros_plugins_msgs::GetOriginSphericalCoord::Request & _req, uuv_world_ros_plugins_msgs::GetOriginSphericalCoord::Response & _res) Service call that returns the origin in WGS84 standard. bool SetOriginSphericalCoord (uuv_world_ros_plugins_msgs::SetOriginSphericalCoord::Request & _req, uuv_world_ros_plugins_msgs::SetOriginSphericalCoord::Response & _res) Service call that returns the origin in WGS84 standard. bool TransformToSphericalCoord (uuv_world_ros_plugins_msgs::TransformToSphericalCoord::Request & _req, uuv_world_ros_plugins_msgs::TransformToSphericalCoord::Response & _res) Service call to transform from Cartesian to spherical coordinates. bool TransformFromSphericalCoord (uuv_world_ros_plugins_msgs::TransformFromSphericalCoord::Request & _req, uuv_world_ros_plugins_msgs::TransformFromSphericalCoord::Response & _res) Service call to transform from spherical to Cartesian coordinates.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/classgazebo_1_1SphericalCoordinatesROSInterfacePlugin/#protected-attributes","text":"Name boost::scoped_ptr< ros::NodeHandle > rosNode Pointer to this ROS node's handle. event::ConnectionPtr rosPublishConnection Connection for callbacks on update world. physics::WorldPtr world Pointer to world. std::map< std::string, ros::ServiceServer > worldServices All underwater world services.","title":"Protected Attributes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/classgazebo_1_1SphericalCoordinatesROSInterfacePlugin/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/classgazebo_1_1SphericalCoordinatesROSInterfacePlugin/#function-sphericalcoordinatesrosinterfaceplugin","text":"SphericalCoordinatesROSInterfacePlugin() Constructor.","title":"function SphericalCoordinatesROSInterfacePlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/classgazebo_1_1SphericalCoordinatesROSInterfacePlugin/#function-sphericalcoordinatesrosinterfaceplugin_1","text":"virtual ~SphericalCoordinatesROSInterfacePlugin() Destructor.","title":"function ~SphericalCoordinatesROSInterfacePlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/classgazebo_1_1SphericalCoordinatesROSInterfacePlugin/#function-load","text":"void Load( physics::WorldPtr _world, sdf::ElementPtr _sdf ) Load module and read parameters from SDF.","title":"function Load"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/classgazebo_1_1SphericalCoordinatesROSInterfacePlugin/#function-getoriginsphericalcoord","text":"bool GetOriginSphericalCoord( uuv_world_ros_plugins_msgs::GetOriginSphericalCoord::Request & _req, uuv_world_ros_plugins_msgs::GetOriginSphericalCoord::Response & _res ) Service call that returns the origin in WGS84 standard.","title":"function GetOriginSphericalCoord"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/classgazebo_1_1SphericalCoordinatesROSInterfacePlugin/#function-setoriginsphericalcoord","text":"bool SetOriginSphericalCoord( uuv_world_ros_plugins_msgs::SetOriginSphericalCoord::Request & _req, uuv_world_ros_plugins_msgs::SetOriginSphericalCoord::Response & _res ) Service call that returns the origin in WGS84 standard.","title":"function SetOriginSphericalCoord"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/classgazebo_1_1SphericalCoordinatesROSInterfacePlugin/#function-transformtosphericalcoord","text":"bool TransformToSphericalCoord( uuv_world_ros_plugins_msgs::TransformToSphericalCoord::Request & _req, uuv_world_ros_plugins_msgs::TransformToSphericalCoord::Response & _res ) Service call to transform from Cartesian to spherical coordinates.","title":"function TransformToSphericalCoord"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/classgazebo_1_1SphericalCoordinatesROSInterfacePlugin/#function-transformfromsphericalcoord","text":"bool TransformFromSphericalCoord( uuv_world_ros_plugins_msgs::TransformFromSphericalCoord::Request & _req, uuv_world_ros_plugins_msgs::TransformFromSphericalCoord::Response & _res ) Service call to transform from spherical to Cartesian coordinates.","title":"function TransformFromSphericalCoord"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/classgazebo_1_1SphericalCoordinatesROSInterfacePlugin/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/classgazebo_1_1SphericalCoordinatesROSInterfacePlugin/#variable-rosnode","text":"boost::scoped_ptr< ros::NodeHandle > rosNode; Pointer to this ROS node's handle.","title":"variable rosNode"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/classgazebo_1_1SphericalCoordinatesROSInterfacePlugin/#variable-rospublishconnection","text":"event::ConnectionPtr rosPublishConnection; Connection for callbacks on update world.","title":"variable rosPublishConnection"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/classgazebo_1_1SphericalCoordinatesROSInterfacePlugin/#variable-world","text":"physics::WorldPtr world; Pointer to world.","title":"variable world"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/classgazebo_1_1SphericalCoordinatesROSInterfacePlugin/#variable-worldservices","text":"std::map< std::string, ros::ServiceServer > worldServices; All underwater world services. Updated on 2022-05-30 at 18:35:14 +0000","title":"variable worldServices"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterCurrentROSPlugin/","text":"uuv_simulator_ros::UnderwaterCurrentROSPlugin Inherits from UnderwaterCurrentPlugin Public Functions Name UnderwaterCurrentROSPlugin () Class constructor. virtual ~UnderwaterCurrentROSPlugin () Class destructor. void Load (gazebo::physics::WorldPtr _world, sdf::ElementPtr _sdf) Load module and read parameters from SDF. bool UpdateCurrentVelocityModel (uuv_world_ros_plugins_msgs::SetCurrentModel::Request & _req, uuv_world_ros_plugins_msgs::SetCurrentModel::Response & _res) Service call to update the parameters for the velocity Gauss-Markov process model. bool UpdateCurrentHorzAngleModel (uuv_world_ros_plugins_msgs::SetCurrentModel::Request & _req, uuv_world_ros_plugins_msgs::SetCurrentModel::Response & _res) Service call to update the parameters for the horizontal angle Gauss-Markov process model. bool UpdateCurrentVertAngleModel (uuv_world_ros_plugins_msgs::SetCurrentModel::Request & _req, uuv_world_ros_plugins_msgs::SetCurrentModel::Response & _res) Service call to update the parameters for the vertical angle Gauss-Markov process model. bool GetCurrentVelocityModel (uuv_world_ros_plugins_msgs::GetCurrentModel::Request & _req, uuv_world_ros_plugins_msgs::GetCurrentModel::Response & _res) Service call to read the parameters for the velocity Gauss-Markov process model. bool GetCurrentHorzAngleModel (uuv_world_ros_plugins_msgs::GetCurrentModel::Request & _req, uuv_world_ros_plugins_msgs::GetCurrentModel::Response & _res) Service call to read the parameters for the horizontal angle Gauss-Markov process model. bool GetCurrentVertAngleModel (uuv_world_ros_plugins_msgs::GetCurrentModel::Request & _req, uuv_world_ros_plugins_msgs::GetCurrentModel::Response & _res) Service call to read the parameters for the vertical angle Gauss-Markov process model. bool UpdateCurrentVelocity (uuv_world_ros_plugins_msgs::SetCurrentVelocity::Request & _req, uuv_world_ros_plugins_msgs::SetCurrentVelocity::Response & _res) Service call to update the mean value of the flow velocity. bool UpdateHorzAngle (uuv_world_ros_plugins_msgs::SetCurrentDirection::Request & _req, uuv_world_ros_plugins_msgs::SetCurrentDirection::Response & _res) Service call to update the mean value of the horizontal angle. bool UpdateVertAngle (uuv_world_ros_plugins_msgs::SetCurrentDirection::Request & _req, uuv_world_ros_plugins_msgs::SetCurrentDirection::Response & _res) Service call to update the mean value of the vertical angle. Public Functions Documentation function UnderwaterCurrentROSPlugin UnderwaterCurrentROSPlugin() Class constructor. function ~UnderwaterCurrentROSPlugin virtual ~UnderwaterCurrentROSPlugin() Class destructor. function Load void Load( gazebo::physics::WorldPtr _world, sdf::ElementPtr _sdf ) Load module and read parameters from SDF. function UpdateCurrentVelocityModel bool UpdateCurrentVelocityModel( uuv_world_ros_plugins_msgs::SetCurrentModel::Request & _req, uuv_world_ros_plugins_msgs::SetCurrentModel::Response & _res ) Service call to update the parameters for the velocity Gauss-Markov process model. function UpdateCurrentHorzAngleModel bool UpdateCurrentHorzAngleModel( uuv_world_ros_plugins_msgs::SetCurrentModel::Request & _req, uuv_world_ros_plugins_msgs::SetCurrentModel::Response & _res ) Service call to update the parameters for the horizontal angle Gauss-Markov process model. function UpdateCurrentVertAngleModel bool UpdateCurrentVertAngleModel( uuv_world_ros_plugins_msgs::SetCurrentModel::Request & _req, uuv_world_ros_plugins_msgs::SetCurrentModel::Response & _res ) Service call to update the parameters for the vertical angle Gauss-Markov process model. function GetCurrentVelocityModel bool GetCurrentVelocityModel( uuv_world_ros_plugins_msgs::GetCurrentModel::Request & _req, uuv_world_ros_plugins_msgs::GetCurrentModel::Response & _res ) Service call to read the parameters for the velocity Gauss-Markov process model. function GetCurrentHorzAngleModel bool GetCurrentHorzAngleModel( uuv_world_ros_plugins_msgs::GetCurrentModel::Request & _req, uuv_world_ros_plugins_msgs::GetCurrentModel::Response & _res ) Service call to read the parameters for the horizontal angle Gauss-Markov process model. function GetCurrentVertAngleModel bool GetCurrentVertAngleModel( uuv_world_ros_plugins_msgs::GetCurrentModel::Request & _req, uuv_world_ros_plugins_msgs::GetCurrentModel::Response & _res ) Service call to read the parameters for the vertical angle Gauss-Markov process model. function UpdateCurrentVelocity bool UpdateCurrentVelocity( uuv_world_ros_plugins_msgs::SetCurrentVelocity::Request & _req, uuv_world_ros_plugins_msgs::SetCurrentVelocity::Response & _res ) Service call to update the mean value of the flow velocity. function UpdateHorzAngle bool UpdateHorzAngle( uuv_world_ros_plugins_msgs::SetCurrentDirection::Request & _req, uuv_world_ros_plugins_msgs::SetCurrentDirection::Response & _res ) Service call to update the mean value of the horizontal angle. function UpdateVertAngle bool UpdateVertAngle( uuv_world_ros_plugins_msgs::SetCurrentDirection::Request & _req, uuv_world_ros_plugins_msgs::SetCurrentDirection::Response & _res ) Service call to update the mean value of the vertical angle. Updated on 2022-05-30 at 18:35:14 +0000","title":"uuv_simulator_ros::UnderwaterCurrentROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterCurrentROSPlugin/#uuv_simulator_rosunderwatercurrentrosplugin","text":"Inherits from UnderwaterCurrentPlugin","title":"uuv_simulator_ros::UnderwaterCurrentROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterCurrentROSPlugin/#public-functions","text":"Name UnderwaterCurrentROSPlugin () Class constructor. virtual ~UnderwaterCurrentROSPlugin () Class destructor. void Load (gazebo::physics::WorldPtr _world, sdf::ElementPtr _sdf) Load module and read parameters from SDF. bool UpdateCurrentVelocityModel (uuv_world_ros_plugins_msgs::SetCurrentModel::Request & _req, uuv_world_ros_plugins_msgs::SetCurrentModel::Response & _res) Service call to update the parameters for the velocity Gauss-Markov process model. bool UpdateCurrentHorzAngleModel (uuv_world_ros_plugins_msgs::SetCurrentModel::Request & _req, uuv_world_ros_plugins_msgs::SetCurrentModel::Response & _res) Service call to update the parameters for the horizontal angle Gauss-Markov process model. bool UpdateCurrentVertAngleModel (uuv_world_ros_plugins_msgs::SetCurrentModel::Request & _req, uuv_world_ros_plugins_msgs::SetCurrentModel::Response & _res) Service call to update the parameters for the vertical angle Gauss-Markov process model. bool GetCurrentVelocityModel (uuv_world_ros_plugins_msgs::GetCurrentModel::Request & _req, uuv_world_ros_plugins_msgs::GetCurrentModel::Response & _res) Service call to read the parameters for the velocity Gauss-Markov process model. bool GetCurrentHorzAngleModel (uuv_world_ros_plugins_msgs::GetCurrentModel::Request & _req, uuv_world_ros_plugins_msgs::GetCurrentModel::Response & _res) Service call to read the parameters for the horizontal angle Gauss-Markov process model. bool GetCurrentVertAngleModel (uuv_world_ros_plugins_msgs::GetCurrentModel::Request & _req, uuv_world_ros_plugins_msgs::GetCurrentModel::Response & _res) Service call to read the parameters for the vertical angle Gauss-Markov process model. bool UpdateCurrentVelocity (uuv_world_ros_plugins_msgs::SetCurrentVelocity::Request & _req, uuv_world_ros_plugins_msgs::SetCurrentVelocity::Response & _res) Service call to update the mean value of the flow velocity. bool UpdateHorzAngle (uuv_world_ros_plugins_msgs::SetCurrentDirection::Request & _req, uuv_world_ros_plugins_msgs::SetCurrentDirection::Response & _res) Service call to update the mean value of the horizontal angle. bool UpdateVertAngle (uuv_world_ros_plugins_msgs::SetCurrentDirection::Request & _req, uuv_world_ros_plugins_msgs::SetCurrentDirection::Response & _res) Service call to update the mean value of the vertical angle.","title":"Public Functions"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterCurrentROSPlugin/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterCurrentROSPlugin/#function-underwatercurrentrosplugin","text":"UnderwaterCurrentROSPlugin() Class constructor.","title":"function UnderwaterCurrentROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterCurrentROSPlugin/#function-underwatercurrentrosplugin_1","text":"virtual ~UnderwaterCurrentROSPlugin() Class destructor.","title":"function ~UnderwaterCurrentROSPlugin"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterCurrentROSPlugin/#function-load","text":"void Load( gazebo::physics::WorldPtr _world, sdf::ElementPtr _sdf ) Load module and read parameters from SDF.","title":"function Load"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterCurrentROSPlugin/#function-updatecurrentvelocitymodel","text":"bool UpdateCurrentVelocityModel( uuv_world_ros_plugins_msgs::SetCurrentModel::Request & _req, uuv_world_ros_plugins_msgs::SetCurrentModel::Response & _res ) Service call to update the parameters for the velocity Gauss-Markov process model.","title":"function UpdateCurrentVelocityModel"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterCurrentROSPlugin/#function-updatecurrenthorzanglemodel","text":"bool UpdateCurrentHorzAngleModel( uuv_world_ros_plugins_msgs::SetCurrentModel::Request & _req, uuv_world_ros_plugins_msgs::SetCurrentModel::Response & _res ) Service call to update the parameters for the horizontal angle Gauss-Markov process model.","title":"function UpdateCurrentHorzAngleModel"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterCurrentROSPlugin/#function-updatecurrentvertanglemodel","text":"bool UpdateCurrentVertAngleModel( uuv_world_ros_plugins_msgs::SetCurrentModel::Request & _req, uuv_world_ros_plugins_msgs::SetCurrentModel::Response & _res ) Service call to update the parameters for the vertical angle Gauss-Markov process model.","title":"function UpdateCurrentVertAngleModel"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterCurrentROSPlugin/#function-getcurrentvelocitymodel","text":"bool GetCurrentVelocityModel( uuv_world_ros_plugins_msgs::GetCurrentModel::Request & _req, uuv_world_ros_plugins_msgs::GetCurrentModel::Response & _res ) Service call to read the parameters for the velocity Gauss-Markov process model.","title":"function GetCurrentVelocityModel"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterCurrentROSPlugin/#function-getcurrenthorzanglemodel","text":"bool GetCurrentHorzAngleModel( uuv_world_ros_plugins_msgs::GetCurrentModel::Request & _req, uuv_world_ros_plugins_msgs::GetCurrentModel::Response & _res ) Service call to read the parameters for the horizontal angle Gauss-Markov process model.","title":"function GetCurrentHorzAngleModel"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterCurrentROSPlugin/#function-getcurrentvertanglemodel","text":"bool GetCurrentVertAngleModel( uuv_world_ros_plugins_msgs::GetCurrentModel::Request & _req, uuv_world_ros_plugins_msgs::GetCurrentModel::Response & _res ) Service call to read the parameters for the vertical angle Gauss-Markov process model.","title":"function GetCurrentVertAngleModel"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterCurrentROSPlugin/#function-updatecurrentvelocity","text":"bool UpdateCurrentVelocity( uuv_world_ros_plugins_msgs::SetCurrentVelocity::Request & _req, uuv_world_ros_plugins_msgs::SetCurrentVelocity::Response & _res ) Service call to update the mean value of the flow velocity.","title":"function UpdateCurrentVelocity"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterCurrentROSPlugin/#function-updatehorzangle","text":"bool UpdateHorzAngle( uuv_world_ros_plugins_msgs::SetCurrentDirection::Request & _req, uuv_world_ros_plugins_msgs::SetCurrentDirection::Response & _res ) Service call to update the mean value of the horizontal angle.","title":"function UpdateHorzAngle"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Classes/classuuv__simulator__ros_1_1UnderwaterCurrentROSPlugin/#function-updatevertangle","text":"bool UpdateVertAngle( uuv_world_ros_plugins_msgs::SetCurrentDirection::Request & _req, uuv_world_ros_plugins_msgs::SetCurrentDirection::Response & _res ) Service call to update the mean value of the vertical angle. Updated on 2022-05-30 at 18:35:14 +0000","title":"function UpdateVertAngle"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Examples/","text":"Examples Updated on 2022-05-30 at 18:35:14 +0000","title":"Examples"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Examples/#examples","text":"Updated on 2022-05-30 at 18:35:14 +0000","title":"Examples"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Modules/","text":"Modules Updated on 2022-05-30 at 18:35:14 +0000","title":"Modules"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Modules/#modules","text":"Updated on 2022-05-30 at 18:35:14 +0000","title":"Modules"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Namespaces/","text":"Namespaces namespace gazebo namespace uuv_simulator_ros Updated on 2022-05-30 at 18:35:14 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Namespaces/#namespaces","text":"namespace gazebo namespace uuv_simulator_ros Updated on 2022-05-30 at 18:35:14 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Namespaces/namespacegazebo/","text":"gazebo Classes Name class gazebo::SphericalCoordinatesROSInterfacePlugin Updated on 2022-05-30 at 18:35:14 +0000","title":"gazebo"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Namespaces/namespacegazebo/#gazebo","text":"","title":"gazebo"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Namespaces/namespacegazebo/#classes","text":"Name class gazebo::SphericalCoordinatesROSInterfacePlugin Updated on 2022-05-30 at 18:35:14 +0000","title":"Classes"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Namespaces/namespaceuuv__simulator__ros/","text":"uuv_simulator_ros Classes Name class uuv_simulator_ros::UnderwaterCurrentROSPlugin Updated on 2022-05-30 at 18:35:14 +0000","title":"uuv_simulator_ros"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Namespaces/namespaceuuv__simulator__ros/#uuv_simulator_ros","text":"","title":"uuv_simulator_ros"},{"location":"api/markdown/medusa_gazebo/uuv_simulator/uuv_world_plugins/uuv_world_ros_plugins/Namespaces/namespaceuuv__simulator__ros/#classes","text":"Name class uuv_simulator_ros::UnderwaterCurrentROSPlugin Updated on 2022-05-30 at 18:35:14 +0000","title":"Classes"},{"location":"auv-simulation/","text":"","title":"Reference"},{"location":"bluerov-regular/","text":"","title":"Overview"},{"location":"bringup-system/","text":"","title":"Reference"},{"location":"comms-ros-messages/","text":"","title":"Reference"},{"location":"console-path-parser/","text":"Console path parser package Console path parser is a ROS package written in C++ responsible for parsing a mission/path string from an external source to a format that can be interpreted by the path following algorithms of the Medusa Vx stack. Rationale Mission/path string format The format of the mission for a single vehicle comes from the console in a string like the following: #Version 3 #Xrefpoint Yrefpoint UTM Zone 491890.163 4290832.905 29S # LINE xInit yInit xEnd yEnd velocity <nVehicle> <gamma> <user data> # ARC xInit yInit xCenter yCenter xEnd yEnd velocity adirection radius <nVehicle> <gamma> <user data> # POINT xInit yInit radius velocity heading time <nVehicle> <gamma> <user data> # DEPTH depth time <nVehicle> <gamma> <user data> # ALT altitude time <nVehicle> <gamma> <user data> Example of lawn mower maneuver for a single vehicle # Mission from vehicle -1 LINE -20.26 -20.26 -20.26 10.13 0.30 -1 ARC -20.26 10.13 -10.13 10.13 0.00 10.13 0.30 -1 10.13 -1 LINE 0.00 10.13 0.00 -10.13 0.30 -1 ARC 0.00 -10.13 10.13 -10.13 20.26 -10.13 0.30 1 10.13 -1 LINE 20.26 -10.13 20.26 20.26 0.30 -1 For case where cooperative path following is desired the mission is adapted as seen in the example bellow: #Version 3 #Xrefpoint Yrefpoint UTM Zone 491854.338 4290819.848 29S # FORMATION ID1 x_dist y_dist ID2 x_dist y_dist ID3 x_dist y_dist FORMATION 1 0 -3 2 0 0 3 0 3 # LINE xInit yInit xEnd yEnd velocity <nVehicle> <gamma> <user data> # ARC xInit yInit xCenter yCenter xEnd yEnd velocity adirection radius <nVehicle> <gamma> <user data> # POINT xInit yInit radius velocity heading time <nVehicle> <gamma> <user data> # DEPTH depth time <nVehicle> <gamma> <user data> # ALT altitude time <nVehicle> <gamma> <user data> # Mission from vehicle -1 LINE -24.57 -24.57 -24.57 12.29 0.30 -1 ARC -24.57 12.29 -12.29 12.29 0.00 12.29 0.30 -1 12.29 -1 LINE 0.00 12.29 0.00 -12.29 0.30 -1 ARC 0.00 -12.29 12.29 -12.29 24.57 -12.29 0.30 1 12.29 -1 LINE 24.57 -12.29 24.57 24.57 0.30 -1 Note that the only difference is the addition of a FORMATION line. Console path parser will read this information and save in a vector of sections ( Mission ). The section structure can be seen below. Path following sections format SECTION() { Type = 0; # Line / Arc / Point / Depth / ALT xi = 0; # initial x of section yi = 0; # initial y of section xc = -1; # x of center of arc (-1 if line or point) yc = -1; # y of center of arc (-1 if line or point) xe = 0; # ending x of section ye = 0; # ending y of section velocity = 0; # velocity desired of the vehicle adirection = 0; # -1 if vehicle is turning clockwise, -1 otherwise (only applied to arcs) radius = 0; # radius of the arc heading = -1; time = -1; nVehicle = -1; Gamma_s = 0; # Starting gamma (not normalized) Gamma_e = 0, # Ending gamma (not normalized) depth = 0.0; } The console path parser will then publish the first section (topic /path_section ) of the vector while subscribing to the topic /Gamma which contains a the value of the parameter gamma (see path following theory) not normalized. When the received gamma surpasses the ending gamma ( Gamma_e ) of the section, it will then update its section and publish it. It will do this process for the amount of sections in Mission . Note that /Gamma is being published by the path following node, where there is a conversion of the gamma from normalized to not normalized. Package Content Code documentation source Using console path parser Examples Requirements Yebisu - creates the mission to be parsed console_server - receives the mission and sends it here folder to save path - ex: ROS_BAG_FOLDER/paths_from_console path following algorithms - receive sections of the mission","title":"Reference"},{"location":"console-path-parser/#console-path-parser-package","text":"Console path parser is a ROS package written in C++ responsible for parsing a mission/path string from an external source to a format that can be interpreted by the path following algorithms of the Medusa Vx stack.","title":"Console path parser package"},{"location":"console-path-parser/#rationale","text":"","title":"Rationale"},{"location":"console-path-parser/#missionpath-string-format","text":"The format of the mission for a single vehicle comes from the console in a string like the following: #Version 3 #Xrefpoint Yrefpoint UTM Zone 491890.163 4290832.905 29S # LINE xInit yInit xEnd yEnd velocity <nVehicle> <gamma> <user data> # ARC xInit yInit xCenter yCenter xEnd yEnd velocity adirection radius <nVehicle> <gamma> <user data> # POINT xInit yInit radius velocity heading time <nVehicle> <gamma> <user data> # DEPTH depth time <nVehicle> <gamma> <user data> # ALT altitude time <nVehicle> <gamma> <user data> Example of lawn mower maneuver for a single vehicle # Mission from vehicle -1 LINE -20.26 -20.26 -20.26 10.13 0.30 -1 ARC -20.26 10.13 -10.13 10.13 0.00 10.13 0.30 -1 10.13 -1 LINE 0.00 10.13 0.00 -10.13 0.30 -1 ARC 0.00 -10.13 10.13 -10.13 20.26 -10.13 0.30 1 10.13 -1 LINE 20.26 -10.13 20.26 20.26 0.30 -1 For case where cooperative path following is desired the mission is adapted as seen in the example bellow: #Version 3 #Xrefpoint Yrefpoint UTM Zone 491854.338 4290819.848 29S # FORMATION ID1 x_dist y_dist ID2 x_dist y_dist ID3 x_dist y_dist FORMATION 1 0 -3 2 0 0 3 0 3 # LINE xInit yInit xEnd yEnd velocity <nVehicle> <gamma> <user data> # ARC xInit yInit xCenter yCenter xEnd yEnd velocity adirection radius <nVehicle> <gamma> <user data> # POINT xInit yInit radius velocity heading time <nVehicle> <gamma> <user data> # DEPTH depth time <nVehicle> <gamma> <user data> # ALT altitude time <nVehicle> <gamma> <user data> # Mission from vehicle -1 LINE -24.57 -24.57 -24.57 12.29 0.30 -1 ARC -24.57 12.29 -12.29 12.29 0.00 12.29 0.30 -1 12.29 -1 LINE 0.00 12.29 0.00 -12.29 0.30 -1 ARC 0.00 -12.29 12.29 -12.29 24.57 -12.29 0.30 1 12.29 -1 LINE 24.57 -12.29 24.57 24.57 0.30 -1 Note that the only difference is the addition of a FORMATION line. Console path parser will read this information and save in a vector of sections ( Mission ). The section structure can be seen below.","title":"Mission/path string format"},{"location":"console-path-parser/#path-following-sections-format","text":"SECTION() { Type = 0; # Line / Arc / Point / Depth / ALT xi = 0; # initial x of section yi = 0; # initial y of section xc = -1; # x of center of arc (-1 if line or point) yc = -1; # y of center of arc (-1 if line or point) xe = 0; # ending x of section ye = 0; # ending y of section velocity = 0; # velocity desired of the vehicle adirection = 0; # -1 if vehicle is turning clockwise, -1 otherwise (only applied to arcs) radius = 0; # radius of the arc heading = -1; time = -1; nVehicle = -1; Gamma_s = 0; # Starting gamma (not normalized) Gamma_e = 0, # Ending gamma (not normalized) depth = 0.0; } The console path parser will then publish the first section (topic /path_section ) of the vector while subscribing to the topic /Gamma which contains a the value of the parameter gamma (see path following theory) not normalized. When the received gamma surpasses the ending gamma ( Gamma_e ) of the section, it will then update its section and publish it. It will do this process for the amount of sections in Mission . Note that /Gamma is being published by the path following node, where there is a conversion of the gamma from normalized to not normalized.","title":"Path following sections format"},{"location":"console-path-parser/#package-content","text":"","title":"Package Content"},{"location":"console-path-parser/#code-documentation","text":"source","title":"Code documentation"},{"location":"console-path-parser/#using-console-path-parser","text":"Examples","title":"Using console path parser"},{"location":"console-path-parser/#requirements","text":"Yebisu - creates the mission to be parsed console_server - receives the mission and sends it here folder to save path - ex: ROS_BAG_FOLDER/paths_from_console path following algorithms - receive sections of the mission","title":"Requirements"},{"location":"console-path-parser/configuration/medusaVxConfig/","text":"medusa_vx config - console_path_parser Run This package is launched with medusa stack ex: roslaunch medusa_bringup medusa_bringup.launch name:= mvector docks:=missions Please check if console_path_parser is set to true in the vehicle configurations. For this, please check the following block in medusa_bringup/config/docks/mvector/process.yaml file: - name: 'addons' launch_on_startup: true delay_before_start: 0.0 cmd: 'roslaunch medusa_bringup addons.launch' args: - aggregator:= true - **console_path_parser:= true** - console_server:= true - wifi_acoustic_safety:= true - rosbridge_server:= false Launch file You have a main launch ( medusa_bringup.launch ) that calls a node ( medusa_bringup_node ) responsible to manage all the processes in a proecss.yaml file. The node while running is responsible to launch a subset of other launch files located at /medusa_bringup/launch/dev_launch . Among the exisitng ones, here the focus is in the addons.launch where console_path_parser is present. Looking in some detail to the file we point out the key points: <arg name=\"name\" /> <arg name=\"mission\" default=\"example\" /> <arg name=\"wifi_acoustic_safety\" default=\"false\" /> <!-- safety features --> **<arg name=\"console_path_parser\" default=\"false\" />** <arg name=\"http_server\" default=\"false\" /> <arg name=\"aggregator\" default=\"false\" /> <arg name=\"rosbridge_server\" default=\"false\" /> <arg name=\"websocket_port\" default=\"9090\" /> <!-- arg to use in http--> By default all the nodes in the medusa_addons package are set to false and won't run if you don't change the corresponding boolean in the process.yaml like in the previous section. <group ns=\"addons\"> Every addon is part of the group addons , which means that topics will be someting like /addons/node/some_topic , here /addons/console_path_parser/some_topic . <!-- ############################ --> <!-- Console Path Parser --> <!-- ############################ --> <group if=\"$(arg console_path_parser)\"> <node pkg=\"console_path_parser\" type=\"console_path_parser_node\" name=\"console_path_parser\" respawn=\"false\" output=\"screen\"> <param name=\"path_folder\" value=\"$(env ROS_BAG_FOLDER)/paths_from_console\"/> </node> </group As you can see the if guarantees that the node only starts if in the process.yaml , console_path_parsert is set to true. Configurations Configuration is divided between two files. The first one, medusa_bringup/config/dev_configs/ros.yaml , is responsible with ros node items (frequency and topics names). Below, the section of console_path_parser : addons/console_path_parser: node_frequency: 5 topics: subscribers: Mission_String: /addons/Mission_String state: /nav/filter/state flag: /Flag gamma: /controls/gamma #ID: /ID publishers: Path_Section: /addons/path_section Formation: /addons/formation biased_formation: /addons/biased_formation WPRef: /addons/WPRef DepthRef: /ref/depth AltRef: /ref/altitude FullMission: /addons/full_mission The second file, /medusa_bringup/config/mission/vehicle/addons.yaml , accommodates items more related with the node inner-workings. Below, the section of console_path_parser : *file, ex: /medusa_bringup/config/docks/mvector/addons.yaml console_path_parser: path_folder: \"../paths_from_console\" vehicle_id: 3","title":"medusa_vx config - console_path_parser"},{"location":"console-path-parser/configuration/medusaVxConfig/#medusa_vx-config-console_path_parser","text":"","title":"medusa_vx config - console_path_parser"},{"location":"console-path-parser/configuration/medusaVxConfig/#run","text":"This package is launched with medusa stack ex: roslaunch medusa_bringup medusa_bringup.launch name:= mvector docks:=missions Please check if console_path_parser is set to true in the vehicle configurations. For this, please check the following block in medusa_bringup/config/docks/mvector/process.yaml file: - name: 'addons' launch_on_startup: true delay_before_start: 0.0 cmd: 'roslaunch medusa_bringup addons.launch' args: - aggregator:= true - **console_path_parser:= true** - console_server:= true - wifi_acoustic_safety:= true - rosbridge_server:= false","title":"Run"},{"location":"console-path-parser/configuration/medusaVxConfig/#launch-file","text":"You have a main launch ( medusa_bringup.launch ) that calls a node ( medusa_bringup_node ) responsible to manage all the processes in a proecss.yaml file. The node while running is responsible to launch a subset of other launch files located at /medusa_bringup/launch/dev_launch . Among the exisitng ones, here the focus is in the addons.launch where console_path_parser is present. Looking in some detail to the file we point out the key points: <arg name=\"name\" /> <arg name=\"mission\" default=\"example\" /> <arg name=\"wifi_acoustic_safety\" default=\"false\" /> <!-- safety features --> **<arg name=\"console_path_parser\" default=\"false\" />** <arg name=\"http_server\" default=\"false\" /> <arg name=\"aggregator\" default=\"false\" /> <arg name=\"rosbridge_server\" default=\"false\" /> <arg name=\"websocket_port\" default=\"9090\" /> <!-- arg to use in http--> By default all the nodes in the medusa_addons package are set to false and won't run if you don't change the corresponding boolean in the process.yaml like in the previous section. <group ns=\"addons\"> Every addon is part of the group addons , which means that topics will be someting like /addons/node/some_topic , here /addons/console_path_parser/some_topic . <!-- ############################ --> <!-- Console Path Parser --> <!-- ############################ --> <group if=\"$(arg console_path_parser)\"> <node pkg=\"console_path_parser\" type=\"console_path_parser_node\" name=\"console_path_parser\" respawn=\"false\" output=\"screen\"> <param name=\"path_folder\" value=\"$(env ROS_BAG_FOLDER)/paths_from_console\"/> </node> </group As you can see the if guarantees that the node only starts if in the process.yaml , console_path_parsert is set to true.","title":"Launch file"},{"location":"console-path-parser/configuration/medusaVxConfig/#configurations","text":"Configuration is divided between two files. The first one, medusa_bringup/config/dev_configs/ros.yaml , is responsible with ros node items (frequency and topics names). Below, the section of console_path_parser : addons/console_path_parser: node_frequency: 5 topics: subscribers: Mission_String: /addons/Mission_String state: /nav/filter/state flag: /Flag gamma: /controls/gamma #ID: /ID publishers: Path_Section: /addons/path_section Formation: /addons/formation biased_formation: /addons/biased_formation WPRef: /addons/WPRef DepthRef: /ref/depth AltRef: /ref/altitude FullMission: /addons/full_mission The second file, /medusa_bringup/config/mission/vehicle/addons.yaml , accommodates items more related with the node inner-workings. Below, the section of console_path_parser : *file, ex: /medusa_bringup/config/docks/mvector/addons.yaml console_path_parser: path_folder: \"../paths_from_console\" vehicle_id: 3","title":"Configurations"},{"location":"console-path-parser/configuration/soloPackageConfig/","text":"Solo Package - console_path_parser Run roslaunch console_path_parser console_path_parser.launch Launch file launch/console_path_parser.launch <?xml version=\"1.0\"?> <launch> <!-- small description about your node --> <!--<node pkg=\"my_package_name\" type=\"my_node_name\" name=\"my_node_name\" respawn=\"false\" output=\"screen\" args=\"$(find console_path_parser)/config/my_arg_file.yaml\"/>--> <node pkg=\"console_path_parser\" type=\"console_path_parser_node\" name=\"console_path_parser\" respawn=\"false\" output=\"screen\"> <rosparam command=\"load\" file=\"$(find console_path_parser)/config/config_console_path_parser.yaml\"/> <param name=\"path_folder\" value=\"$(env ROS_BAG_FOLDER)/paths_from_console\"/> <remap from=\"ID\" to=\"ID_Comms\"/> </node> </launch> Configurations node_frequency: 5 path_folder: \"../paths_from_console\" vehicle_id: 1 topics: subscribers: Mission_String: /Mission_String state: /nav_filter/state flag: /Flag gamma: /Gamma ID: /ID publishers: Path_Section: /Path_Section Formation: /Formation biased_formation: /biased_formation WPRef: /WPRef DepthRef: /ref/depth AltRef: /ref/altitude FullMission: /FullMission","title":"Solo Package - console_path_parser"},{"location":"console-path-parser/configuration/soloPackageConfig/#solo-package-console_path_parser","text":"","title":"Solo Package - console_path_parser"},{"location":"console-path-parser/configuration/soloPackageConfig/#run","text":"roslaunch console_path_parser console_path_parser.launch","title":"Run"},{"location":"console-path-parser/configuration/soloPackageConfig/#launch-file","text":"launch/console_path_parser.launch <?xml version=\"1.0\"?> <launch> <!-- small description about your node --> <!--<node pkg=\"my_package_name\" type=\"my_node_name\" name=\"my_node_name\" respawn=\"false\" output=\"screen\" args=\"$(find console_path_parser)/config/my_arg_file.yaml\"/>--> <node pkg=\"console_path_parser\" type=\"console_path_parser_node\" name=\"console_path_parser\" respawn=\"false\" output=\"screen\"> <rosparam command=\"load\" file=\"$(find console_path_parser)/config/config_console_path_parser.yaml\"/> <param name=\"path_folder\" value=\"$(env ROS_BAG_FOLDER)/paths_from_console\"/> <remap from=\"ID\" to=\"ID_Comms\"/> </node> </launch>","title":"Launch file"},{"location":"console-path-parser/configuration/soloPackageConfig/#configurations","text":"node_frequency: 5 path_folder: \"../paths_from_console\" vehicle_id: 1 topics: subscribers: Mission_String: /Mission_String state: /nav_filter/state flag: /Flag gamma: /Gamma ID: /ID publishers: Path_Section: /Path_Section Formation: /Formation biased_formation: /biased_formation WPRef: /WPRef DepthRef: /ref/depth AltRef: /ref/altitude FullMission: /FullMission","title":"Configurations"},{"location":"cooperative-path-following/","text":"Cooperative Path Following Documentation A package that implements the controller responsible for synchronizing the path following controllers between multiple vehicles in a network. Authors: - Marcelo Jacinto - Jo\u00e3o Quintas - Jo\u00e3o Cruz - Hung Tuan Maintainer: Marcelo Jacinto Email: marcelo.jacinto@tecnico.ulisboa.pt Creation Date: April/2021 Version: 1.0.0 Last Update: April/2021 Cooperative Path Following (CPF) This controllers are only responsible for computing the correction speed for the path following virtual target and when to send information to other vehicles. The general idea is shown in the image bellow. In order to provide a structured way to provide several different implementations of the Cooperative Controller, the following class structured was adopted: - CPFControl - Abstract class every CPF controller should inherit from - EventTriggered - A class that implement CPF with event triggered communications In the image bellow we see the idea in a more graphical way. The cooperative abstract class ( CPFControl ) requris every class that inherits it to provide an implementation for the methods: - coordinationController - the cooperative control law - updateVehicleInformation - method to receive relevant data from the vehicles and store it a way relevant for the type of CPF in use - publishCurrentGamma - method that should return true if we should publish the current vehicle's gamma (virtual target) value to the network. All the other methos are auxiliar and already implemented. See picture bellow for a more in-depth overview. Since that for now we only have one algorithm implement, there is still no service provided to switch between algorithms. Maybe in the future it will make sense and we follow an approach similar to the one used in the path following package. For now we provide the services: - Start - Stop - ChangeTopology - to change the adjency matrix of the network, in order to simulated vehicles losing connection to each other The default configurations for this node can be found in the next figure.","title":"Reference"},{"location":"cooperative-path-following/#cooperative-path-following-documentation","text":"A package that implements the controller responsible for synchronizing the path following controllers between multiple vehicles in a network. Authors: - Marcelo Jacinto - Jo\u00e3o Quintas - Jo\u00e3o Cruz - Hung Tuan Maintainer: Marcelo Jacinto Email: marcelo.jacinto@tecnico.ulisboa.pt Creation Date: April/2021 Version: 1.0.0 Last Update: April/2021","title":"Cooperative Path Following Documentation"},{"location":"cooperative-path-following/#cooperative-path-following-cpf","text":"This controllers are only responsible for computing the correction speed for the path following virtual target and when to send information to other vehicles. The general idea is shown in the image bellow. In order to provide a structured way to provide several different implementations of the Cooperative Controller, the following class structured was adopted: - CPFControl - Abstract class every CPF controller should inherit from - EventTriggered - A class that implement CPF with event triggered communications In the image bellow we see the idea in a more graphical way. The cooperative abstract class ( CPFControl ) requris every class that inherits it to provide an implementation for the methods: - coordinationController - the cooperative control law - updateVehicleInformation - method to receive relevant data from the vehicles and store it a way relevant for the type of CPF in use - publishCurrentGamma - method that should return true if we should publish the current vehicle's gamma (virtual target) value to the network. All the other methos are auxiliar and already implemented. See picture bellow for a more in-depth overview. Since that for now we only have one algorithm implement, there is still no service provided to switch between algorithms. Maybe in the future it will make sense and we follow an approach similar to the one used in the path following package. For now we provide the services: - Start - Stop - ChangeTopology - to change the adjency matrix of the network, in order to simulated vehicles losing connection to each other The default configurations for this node can be found in the next figure.","title":"Cooperative Path Following (CPF)"},{"location":"cpf-gamma/","text":"","title":"Reference"},{"location":"data-serializer/","text":"","title":"Reference"},{"location":"dsor-paths/","text":"Dsor Paths Documentation A package that implements the equations of paths parameterized by a path parameter (gamma). By default we provide several path sections, from arcs to bernoulli lemnicaste. Authors: - Marcelo Jacinto - Jo\u00e3o Quintas - Jo\u00e3o Cruz - Hung Tuan Maintainer: Marcelo Jacinto Email: marcelo.jacinto@tecnico.ulisboa.pt Creation Date: April/2021 Version: 1.0.0 Last Update: April/2021 Path Sections We start by providing a set of sections. Each section inherits the class PathSection . As we see, every section, even though different is implemented in the same structured manner. The number of sections implemented will grow with time. To see all path available check the provided classes API. Here is an example of some of them provided (see image bellow). The goal is for you to keep building on top of this library and add your own costume sections. But how is a path section made? Well you are only required to be able to implement the path position, it's derivative and second derivative given the path parameter (gamma). The rest is done for you (but of course you can always override default implementations). In the image bellow we can check an example of this. For example, in the Line implementation we are only required to implement the functions: - eq_pd(gamma) - path equation (evaluated at gamma) - eq_d_pd(gamma) - derivative of the path equation (evaluated at gamma) - eq_dd_pd(gamma) - second derivative of the path equation (evaluated at gamma) But since the curvature is constant for a line, there is no need to compute it using the standard way for a line. We can just override the standard implementation and just return 0. The same applies to the getClosestPointGamma method. The default implementation uses an iterative method to compute this point in the path (gradient descent). But, for a line we have a closed form solution. This is why we override the function and implement a better solution that exists for this kind of section (see image bellow). In addition you must specify what are the bounds of your section. By default it is [-infinity, +infinity] but that might not make sense for your section. Furthermore, you must also define if you section can be composed or not. These parameters should be setup in the constructor of your path section. See Arc2D section for a detailed example . But, once again, what does this it mean for a section to be able to be composed? Well when you define a section you must also pass to the constructor of PathSection whether you allow this section to be used with more sections or not. For example, for a Line and an Arc it makes sense for them to be composed (in order to generate paths like lawnmowers). On the other hand it makes no sense for a Bernoulli to be composed with other sections, as it is a closed shape in which bounds vary from [-inf, inf]. Speed Sections Similar to the path sections we also implement speed sections. By default the speed sections are even simpler to implement (but we only provide constant speeds). Feel free to add more types of speed profiles! For an example on how to implement one, check the class API. Putting sections together In order to glue the sections together we provide the class Path . This class basically stores a vector of sections (if the first section added can be composed ). This class also stores a vector of speed sections. The number of speeds asked to the path must be the same or lower than the number of path sections. What does this mean in practise? Well, if you add a line section, only then you can add a speed section (or not - speed sections are optional). Let's imagine we add a line and an arc. We can then add a 2 speed sections or 1. By default, if you only add one, the speed that will be desired after the first section finishes is given by the default value specificied in the speed section. The goal of this class is that all the dirty logic and abstraction is already provided to the developer. Therefore, people only have to focus on implementing costume sections for their algorithms to follow. In the image bellow, we can see all the API provided by the Path class. In practise, users do not need to worry about this path. As long as new sections inherit SpeedSection or PathSection they will work with the path class. How to interface this library with ROS The introduced library is completely independent from ROS. Therefore, in order to interface the library with ROS we use services . For every path section and speed section we create a ROS Service . For example, for a Bernouli we provide a service of the type /SpawnBernoulli . The same applies for lines, arcs,... (see image bellow) To create a service is almost the same as creating a message in ROS. Here is an example for a SpawnBernoulli.srv : float64 radius float64 center_x float64 center_y float64 z --- bool success In the service callback implementation we just receive the data necessary to initialize the section and create a new object of that section. Afterward we just need to call the method to add that section to the path and voila! It's done! By the way, all of this is done in the PathServices.cpp and PathNode.h . See the image bellow for a concrete example. Modes of operation Since some path following algorithms require us to use the cloest point of the vehicle in the path, we need to be able to compute this. Therefore we implement the getClosestPointGamma(coordinate) method. This method is supposed to receive the coordinates of the vehicle and give the gamma of the path that encodes the closest point. With that gamma value we can compute anything. Modes of operation: - Listen to a gamma (default) - Closest Point To change between modes we provide a service /SetMode . To reset the path we also provide the service /ResetPath . When we reset the path all the section that are inside are clean (both speed and path sections). In addition the mode of operation is also reset to its default value (listen to gamma) and publish the data. Data published by the ROS node In order to publish all the relevant data from a path evaluated at a specific value of gamma we provide a new ROS message - PathData.msg : Header header float64[3] pd # Path position float64[3] d_pd # First derivative float64[3] dd_pd # Second derivative float64 curvature float64 tangent float64 derivative_norm float64 vd # Desired speed for gamma float64 d_vd # Desired accel. for gamma float64 vehicle_speed # Desired vehicle speed float64 gamma_min # Min gamma of the path float64 gamma_max # Max gamma of the path","title":"Reference"},{"location":"dsor-paths/#dsor-paths-documentation","text":"A package that implements the equations of paths parameterized by a path parameter (gamma). By default we provide several path sections, from arcs to bernoulli lemnicaste. Authors: - Marcelo Jacinto - Jo\u00e3o Quintas - Jo\u00e3o Cruz - Hung Tuan Maintainer: Marcelo Jacinto Email: marcelo.jacinto@tecnico.ulisboa.pt Creation Date: April/2021 Version: 1.0.0 Last Update: April/2021","title":"Dsor Paths Documentation"},{"location":"dsor-paths/#path-sections","text":"We start by providing a set of sections. Each section inherits the class PathSection . As we see, every section, even though different is implemented in the same structured manner. The number of sections implemented will grow with time. To see all path available check the provided classes API. Here is an example of some of them provided (see image bellow). The goal is for you to keep building on top of this library and add your own costume sections. But how is a path section made? Well you are only required to be able to implement the path position, it's derivative and second derivative given the path parameter (gamma). The rest is done for you (but of course you can always override default implementations). In the image bellow we can check an example of this. For example, in the Line implementation we are only required to implement the functions: - eq_pd(gamma) - path equation (evaluated at gamma) - eq_d_pd(gamma) - derivative of the path equation (evaluated at gamma) - eq_dd_pd(gamma) - second derivative of the path equation (evaluated at gamma) But since the curvature is constant for a line, there is no need to compute it using the standard way for a line. We can just override the standard implementation and just return 0. The same applies to the getClosestPointGamma method. The default implementation uses an iterative method to compute this point in the path (gradient descent). But, for a line we have a closed form solution. This is why we override the function and implement a better solution that exists for this kind of section (see image bellow). In addition you must specify what are the bounds of your section. By default it is [-infinity, +infinity] but that might not make sense for your section. Furthermore, you must also define if you section can be composed or not. These parameters should be setup in the constructor of your path section. See Arc2D section for a detailed example . But, once again, what does this it mean for a section to be able to be composed? Well when you define a section you must also pass to the constructor of PathSection whether you allow this section to be used with more sections or not. For example, for a Line and an Arc it makes sense for them to be composed (in order to generate paths like lawnmowers). On the other hand it makes no sense for a Bernoulli to be composed with other sections, as it is a closed shape in which bounds vary from [-inf, inf].","title":"Path Sections"},{"location":"dsor-paths/#speed-sections","text":"Similar to the path sections we also implement speed sections. By default the speed sections are even simpler to implement (but we only provide constant speeds). Feel free to add more types of speed profiles! For an example on how to implement one, check the class API.","title":"Speed Sections"},{"location":"dsor-paths/#putting-sections-together","text":"In order to glue the sections together we provide the class Path . This class basically stores a vector of sections (if the first section added can be composed ). This class also stores a vector of speed sections. The number of speeds asked to the path must be the same or lower than the number of path sections. What does this mean in practise? Well, if you add a line section, only then you can add a speed section (or not - speed sections are optional). Let's imagine we add a line and an arc. We can then add a 2 speed sections or 1. By default, if you only add one, the speed that will be desired after the first section finishes is given by the default value specificied in the speed section. The goal of this class is that all the dirty logic and abstraction is already provided to the developer. Therefore, people only have to focus on implementing costume sections for their algorithms to follow. In the image bellow, we can see all the API provided by the Path class. In practise, users do not need to worry about this path. As long as new sections inherit SpeedSection or PathSection they will work with the path class.","title":"Putting sections together"},{"location":"dsor-paths/#how-to-interface-this-library-with-ros","text":"The introduced library is completely independent from ROS. Therefore, in order to interface the library with ROS we use services . For every path section and speed section we create a ROS Service . For example, for a Bernouli we provide a service of the type /SpawnBernoulli . The same applies for lines, arcs,... (see image bellow) To create a service is almost the same as creating a message in ROS. Here is an example for a SpawnBernoulli.srv : float64 radius float64 center_x float64 center_y float64 z --- bool success In the service callback implementation we just receive the data necessary to initialize the section and create a new object of that section. Afterward we just need to call the method to add that section to the path and voila! It's done! By the way, all of this is done in the PathServices.cpp and PathNode.h . See the image bellow for a concrete example.","title":"How to interface this library with ROS"},{"location":"dsor-paths/#modes-of-operation","text":"Since some path following algorithms require us to use the cloest point of the vehicle in the path, we need to be able to compute this. Therefore we implement the getClosestPointGamma(coordinate) method. This method is supposed to receive the coordinates of the vehicle and give the gamma of the path that encodes the closest point. With that gamma value we can compute anything. Modes of operation: - Listen to a gamma (default) - Closest Point To change between modes we provide a service /SetMode . To reset the path we also provide the service /ResetPath . When we reset the path all the section that are inside are clean (both speed and path sections). In addition the mode of operation is also reset to its default value (listen to gamma) and publish the data.","title":"Modes of operation"},{"location":"dsor-paths/#data-published-by-the-ros-node","text":"In order to publish all the relevant data from a path evaluated at a specific value of gamma we provide a new ROS message - PathData.msg : Header header float64[3] pd # Path position float64[3] d_pd # First derivative float64[3] dd_pd # Second derivative float64 curvature float64 tangent float64 derivative_norm float64 vd # Desired speed for gamma float64 d_vd # Desired accel. for gamma float64 vehicle_speed # Desired vehicle speed float64 gamma_min # Min gamma of the path float64 gamma_max # Max gamma of the path","title":"Data published by the ROS node"},{"location":"dsor-ros-messages/","text":"DSOR Messages","title":"Reference"},{"location":"dsor-utility-functions/","text":"Math TODO - create documentation for this API Rotations TODO - create documentation for this API Frames This library implements a set of templates to convert between ENU frame and NED frames, both for angles expressed in the inertial frame and in the body frame of a vehicle. Conventions on quaternion rotations between frames In ROS a quaternion expresses a rotation of the body frame of the vehicle (which is ENU, i.e. ENU_base_link) with respect to (w.r.t) the inertial frame of reference in ENU (i.e. ENU_inertial_frame). Note that in ENU_base_link, the X-axis comes out of the front of the vehicle and a Z-axis that goes \"out of the vehicle in upwards direction\". On the other hand, in marine and aerial vehicles it is typical to consider a body frame which is expressed in NED_base_link, where the X-axis also comes out of the front of the vehicle but the Z-axis goes \"out of the vehicle in downwards direction\", according to the following figure (adapted from PX4 website). Therefore, according to the literature, a quaternion should express a rotation of the body frame of the vehicle (which is NED, i.e. NED_base_link) with respect to (w.r.t) the inertial frame of reference in NED (i.e. NED_inertial_frame). From the Figure it is trivial to conclude that rotating ENU_base_link <-> NED_base_link is different then rotating ENU_inertial_frame <-> NED_inertial_frame. This comes from the fact that in the body frame, both ENU and NED conventions arbitrate that the X axis comes forwards of the vehicle (this axis does not change), while in the inertial frame you can see from the figure above that it does change. Now that we have explained both the rotations in the body and inertial frames, let's see how to perform them: Inertial Frame 1.1) To convert a rotation expressed in ENU to a rotation expressed in NED, we must apply the following rotation (using Z-Y-X convention): - Rotate 90\u00ba about Z-axis - Rotate 0\u00ba about Y-axis - Rotate 180\u00ba about X-axis 1.2) To convert a rotation expressed in NED to a rotation expressed in ENU, we must apply the following rotation (using Z-Y-X convention): - Rotate -90\u00ba about Z-axis - Rotate 180\u00ba about Y-axis - Rotate 0\u00ba about X-axis Body Frame (a.k.a ROS base_link) 2.1) To convert a rotation expressed in the ENU body frame (ROS base_link) to a rotation expressed in NED body frame (the typical body frame adopted for aerial and marine crafts), we must apply the following rotation (using Z-Y-X convention): - Rotate 0\u00ba about Z-axis - Rotate 0\u00ba about Y-axis - Rotate 180\u00ba about X-axis 2.2) To convert a rotation expressed in the NED body frame (the typical body frame adopted for aerial and marine crafts) to a rotation expressed in the ENU body frame (ROS base_link), we must apply the following rotation (using Z-Y-X convention): - Rotate 0\u00ba about Z-axis - Rotate 0\u00ba about Y-axis - Rotate -180\u00ba about X-axis Given this knowledge, we can now convert a ROS quaternion/rotation expressed in ENU_inertial_frame w.r.t. ENU_base_link to a \"regular\" quaternion expressed in NED_inertial_frame w.r.t. NED_base_link. ROS -> \"regular\" - State: rotation in ENU w.r.t. ENU_base_link - Action: Apply body frame rotation (operation 2.1) - State: rotation in ENU w.r.t. NED_base_link - Action: Apply inertial frame rotation (operation 1.1) - State: rotation in NED w.r.t. NED_base_link \"regular\" -> ROS - State: rotation in NED w.r.t. NED_base_link - Action: Apply body frame rotation (operation 2.2) - State: rotation in NED w.r.t. ENU_base_link - Action: Apply inertial frame rotation (operation 1.2) - State: rotation in ENU w.r.t. ENU_base_link Transform vectors and covariances between frames For vectors w.r.t body or inertial frames expressed in ENU (Forward, Left, Up) , the transformation to express them in NED (Forward, Right, Down) depends on their respective frame of reference. To transform vectors w.r.t the body-frame the conversion is quite simple and only requires us to: - apply an 180\u00ba rotation around X (Forward) axis To transform vectors w.r.t the inertial-frame the conversion is different and is made in the following way: - Switch XY axis - Invert the Z axis Regarding coordinate frame conversion for covariance matrices, the principle is similar, however, the computations are slightly different as shown on the following image. Spherical Coordinates TODO - create documentation for this API","title":"Reference"},{"location":"dsor-utility-functions/#math","text":"TODO - create documentation for this API","title":"Math"},{"location":"dsor-utility-functions/#rotations","text":"TODO - create documentation for this API","title":"Rotations"},{"location":"dsor-utility-functions/#frames","text":"This library implements a set of templates to convert between ENU frame and NED frames, both for angles expressed in the inertial frame and in the body frame of a vehicle.","title":"Frames"},{"location":"dsor-utility-functions/#conventions-on-quaternion-rotations-between-frames","text":"In ROS a quaternion expresses a rotation of the body frame of the vehicle (which is ENU, i.e. ENU_base_link) with respect to (w.r.t) the inertial frame of reference in ENU (i.e. ENU_inertial_frame). Note that in ENU_base_link, the X-axis comes out of the front of the vehicle and a Z-axis that goes \"out of the vehicle in upwards direction\". On the other hand, in marine and aerial vehicles it is typical to consider a body frame which is expressed in NED_base_link, where the X-axis also comes out of the front of the vehicle but the Z-axis goes \"out of the vehicle in downwards direction\", according to the following figure (adapted from PX4 website). Therefore, according to the literature, a quaternion should express a rotation of the body frame of the vehicle (which is NED, i.e. NED_base_link) with respect to (w.r.t) the inertial frame of reference in NED (i.e. NED_inertial_frame). From the Figure it is trivial to conclude that rotating ENU_base_link <-> NED_base_link is different then rotating ENU_inertial_frame <-> NED_inertial_frame. This comes from the fact that in the body frame, both ENU and NED conventions arbitrate that the X axis comes forwards of the vehicle (this axis does not change), while in the inertial frame you can see from the figure above that it does change. Now that we have explained both the rotations in the body and inertial frames, let's see how to perform them: Inertial Frame 1.1) To convert a rotation expressed in ENU to a rotation expressed in NED, we must apply the following rotation (using Z-Y-X convention): - Rotate 90\u00ba about Z-axis - Rotate 0\u00ba about Y-axis - Rotate 180\u00ba about X-axis 1.2) To convert a rotation expressed in NED to a rotation expressed in ENU, we must apply the following rotation (using Z-Y-X convention): - Rotate -90\u00ba about Z-axis - Rotate 180\u00ba about Y-axis - Rotate 0\u00ba about X-axis Body Frame (a.k.a ROS base_link) 2.1) To convert a rotation expressed in the ENU body frame (ROS base_link) to a rotation expressed in NED body frame (the typical body frame adopted for aerial and marine crafts), we must apply the following rotation (using Z-Y-X convention): - Rotate 0\u00ba about Z-axis - Rotate 0\u00ba about Y-axis - Rotate 180\u00ba about X-axis 2.2) To convert a rotation expressed in the NED body frame (the typical body frame adopted for aerial and marine crafts) to a rotation expressed in the ENU body frame (ROS base_link), we must apply the following rotation (using Z-Y-X convention): - Rotate 0\u00ba about Z-axis - Rotate 0\u00ba about Y-axis - Rotate -180\u00ba about X-axis Given this knowledge, we can now convert a ROS quaternion/rotation expressed in ENU_inertial_frame w.r.t. ENU_base_link to a \"regular\" quaternion expressed in NED_inertial_frame w.r.t. NED_base_link. ROS -> \"regular\" - State: rotation in ENU w.r.t. ENU_base_link - Action: Apply body frame rotation (operation 2.1) - State: rotation in ENU w.r.t. NED_base_link - Action: Apply inertial frame rotation (operation 1.1) - State: rotation in NED w.r.t. NED_base_link \"regular\" -> ROS - State: rotation in NED w.r.t. NED_base_link - Action: Apply body frame rotation (operation 2.2) - State: rotation in NED w.r.t. ENU_base_link - Action: Apply inertial frame rotation (operation 1.2) - State: rotation in ENU w.r.t. ENU_base_link","title":"Conventions on quaternion rotations between frames"},{"location":"dsor-utility-functions/#transform-vectors-and-covariances-between-frames","text":"For vectors w.r.t body or inertial frames expressed in ENU (Forward, Left, Up) , the transformation to express them in NED (Forward, Right, Down) depends on their respective frame of reference. To transform vectors w.r.t the body-frame the conversion is quite simple and only requires us to: - apply an 180\u00ba rotation around X (Forward) axis To transform vectors w.r.t the inertial-frame the conversion is different and is made in the following way: - Switch XY axis - Invert the Z axis Regarding coordinate frame conversion for covariance matrices, the principle is similar, however, the computations are slightly different as shown on the following image.","title":"Transform vectors and covariances between frames"},{"location":"dsor-utility-functions/#spherical-coordinates","text":"TODO - create documentation for this API","title":"Spherical Coordinates"},{"location":"evo-tools/","text":"","title":"Reference"},{"location":"http-server/","text":"http_server package http_server is a ROS package written in Python responsible for exchaning information between a web console (Yebisu) and a vehicle. Rationale A vehicle runs an http server and is responsible to send and read http requests. It also creates a simple html web page displaying relevant vehicle information. NOTE: More details later, maybe the stack will move to rosbridge. Package Content Code documentation source Using http_server Examples Requirements http server web console (Yebisu)","title":"Reference"},{"location":"http-server/#http_server-package","text":"http_server is a ROS package written in Python responsible for exchaning information between a web console (Yebisu) and a vehicle.","title":"http_server package"},{"location":"http-server/#rationale","text":"A vehicle runs an http server and is responsible to send and read http requests. It also creates a simple html web page displaying relevant vehicle information. NOTE: More details later, maybe the stack will move to rosbridge.","title":"Rationale"},{"location":"http-server/#package-content","text":"","title":"Package Content"},{"location":"http-server/#code-documentation","text":"source","title":"Code documentation"},{"location":"http-server/#using-http_server","text":"Examples","title":"Using http_server"},{"location":"http-server/#requirements","text":"http server web console (Yebisu)","title":"Requirements"},{"location":"http-server/configuration/medusaVxConfig/","text":"medusa_vx config - http_server Run Vehicle Side This package is launched with medusa stack ex: roslaunch medusa_bringup medusa_bringup.launch name:= mvector docks:=missions Please check if console_server is set to true in the vehicle configurations. For this, please check the following block in medusa_bringup/config/docks/mvector/process.yaml file: - name: 'addons' launch_on_startup: true delay_before_start: 0.0 cmd: 'roslaunch medusa_bringup addons.launch' args: - aggregator:= true - console_path_parser:= true - **console_server:= true** - wifi_acoustic_safety:= true - rosbridge_server:= false Launch file You have a main launch ( medusa_bringup.launch ) that calls a node ( medusa_bringup_node ) responsible to manage all the processes in a proecss.yaml file. The node while running is responsible to launch a subset of other launch files located at /medusa_bringup/launch/dev_launch . Among the exisitng ones, here the focus is in the addons.launch where console_server is present. Looking in some detail to the file we point out the key points: <arg name=\"name\" /> <arg name=\"mission\" default=\"example\" /> **<arg name=\"wifi_acoustic_safety\" default=\"false\" />** <!-- safety features --> <arg name=\"console_path_parser\" default=\"false\" /> <arg name=\"console_server\" default=\"false\" /> <arg name=\"aggregator\" default=\"false\" /> <arg name=\"rosbridge_server\" default=\"false\" /> <arg name=\"websocket_port\" default=\"9090\" /> <!-- arg to use in http--> By default all the nodes in the medusa_addons package are set to false and won't run if you don't change the corresponding boolean in the process.yaml like in the previous section. <group ns=\"addons\"> Every addon is part of the group addons , which means that almost all topics will be someting like /addons/node/some_topic , here /addons/http_server/some_topic . <!-- ############################ --> <!-- HTTP Server for Console --> <!-- ############################ --> <group if=\"$(arg console_server)\"> <node pkg=\"http_server\" type=\"console.py\" name=\"console_server\" args=\"console\" output=\"screen\"> <param name=\"Mission_Folder\" value=\"$(find http_server)/../../Missions_FOLDER\" /> <param name=\"pages_folder\" value=\"$(find http_server)/pages/\" /> </node> </group> As you can see the if guarantees that the node only starts if in the process.yaml , console_server is set to true. Configurations Note that some configurations, in this case, are set in the launch file: <param name=\"Mission_Folder\" value=\"$(find http_server)/../../Missions_FOLDER\" /> <param name=\"pages_folder\" value=\"$(find http_server)/pages/\" /> Other configurations are at /medusa_bringup/config/mission/vehicle/addons.yaml : *file, ex: /medusa_bringup/config/docks/mvector/addons.yaml console_server: PORT: 7080 ROOT_NAMESPACE: true","title":"medusa_vx config - http_server"},{"location":"http-server/configuration/medusaVxConfig/#medusa_vx-config-http_server","text":"","title":"medusa_vx config - http_server"},{"location":"http-server/configuration/medusaVxConfig/#run","text":"","title":"Run"},{"location":"http-server/configuration/medusaVxConfig/#vehicle-side","text":"This package is launched with medusa stack ex: roslaunch medusa_bringup medusa_bringup.launch name:= mvector docks:=missions Please check if console_server is set to true in the vehicle configurations. For this, please check the following block in medusa_bringup/config/docks/mvector/process.yaml file: - name: 'addons' launch_on_startup: true delay_before_start: 0.0 cmd: 'roslaunch medusa_bringup addons.launch' args: - aggregator:= true - console_path_parser:= true - **console_server:= true** - wifi_acoustic_safety:= true - rosbridge_server:= false","title":"Vehicle Side"},{"location":"http-server/configuration/medusaVxConfig/#launch-file","text":"You have a main launch ( medusa_bringup.launch ) that calls a node ( medusa_bringup_node ) responsible to manage all the processes in a proecss.yaml file. The node while running is responsible to launch a subset of other launch files located at /medusa_bringup/launch/dev_launch . Among the exisitng ones, here the focus is in the addons.launch where console_server is present. Looking in some detail to the file we point out the key points: <arg name=\"name\" /> <arg name=\"mission\" default=\"example\" /> **<arg name=\"wifi_acoustic_safety\" default=\"false\" />** <!-- safety features --> <arg name=\"console_path_parser\" default=\"false\" /> <arg name=\"console_server\" default=\"false\" /> <arg name=\"aggregator\" default=\"false\" /> <arg name=\"rosbridge_server\" default=\"false\" /> <arg name=\"websocket_port\" default=\"9090\" /> <!-- arg to use in http--> By default all the nodes in the medusa_addons package are set to false and won't run if you don't change the corresponding boolean in the process.yaml like in the previous section. <group ns=\"addons\"> Every addon is part of the group addons , which means that almost all topics will be someting like /addons/node/some_topic , here /addons/http_server/some_topic . <!-- ############################ --> <!-- HTTP Server for Console --> <!-- ############################ --> <group if=\"$(arg console_server)\"> <node pkg=\"http_server\" type=\"console.py\" name=\"console_server\" args=\"console\" output=\"screen\"> <param name=\"Mission_Folder\" value=\"$(find http_server)/../../Missions_FOLDER\" /> <param name=\"pages_folder\" value=\"$(find http_server)/pages/\" /> </node> </group> As you can see the if guarantees that the node only starts if in the process.yaml , console_server is set to true.","title":"Launch file"},{"location":"http-server/configuration/medusaVxConfig/#configurations","text":"Note that some configurations, in this case, are set in the launch file: <param name=\"Mission_Folder\" value=\"$(find http_server)/../../Missions_FOLDER\" /> <param name=\"pages_folder\" value=\"$(find http_server)/pages/\" /> Other configurations are at /medusa_bringup/config/mission/vehicle/addons.yaml : *file, ex: /medusa_bringup/config/docks/mvector/addons.yaml console_server: PORT: 7080 ROOT_NAMESPACE: true","title":"Configurations"},{"location":"interrogation-scheme/","text":"","title":"Reference"},{"location":"medusa-diagnostics-library/","text":"Medusa Gimmicks Library Description Collection of methods to ease the use of ROS diagnostics package. Important Sources The library was built following the steps in this link Also an important note about implementing template methods here . Basically this avoids linking errors with the library. How to use the library in a new node CmakeLists.txt Add library to find package find_package(catkin REQUIRED COMPONENTS roscpp medusa_diagnostics_lirabry ) package.xml Add the following <depend>medusa_diagnostics_lirabry</depend> Include the library in your new node #include <medusa_diagnostics_library/MedusaDiagnostics.h> Use in your code MedusaDiagnostics::method_to_use(...) Package Content Code documentation source","title":"Reference"},{"location":"medusa-diagnostics-library/#medusa-gimmicks-library","text":"","title":"Medusa Gimmicks Library"},{"location":"medusa-diagnostics-library/#description","text":"Collection of methods to ease the use of ROS diagnostics package.","title":"Description"},{"location":"medusa-diagnostics-library/#important-sources","text":"The library was built following the steps in this link Also an important note about implementing template methods here . Basically this avoids linking errors with the library.","title":"Important Sources"},{"location":"medusa-diagnostics-library/#how-to-use-the-library-in-a-new-node","text":"","title":"How to use the library in a new node"},{"location":"medusa-diagnostics-library/#cmakeliststxt","text":"Add library to find package find_package(catkin REQUIRED COMPONENTS roscpp medusa_diagnostics_lirabry )","title":"CmakeLists.txt"},{"location":"medusa-diagnostics-library/#packagexml","text":"Add the following <depend>medusa_diagnostics_lirabry</depend>","title":"package.xml"},{"location":"medusa-diagnostics-library/#include-the-library-in-your-new-node","text":"#include <medusa_diagnostics_library/MedusaDiagnostics.h>","title":"Include the library in your new node"},{"location":"medusa-diagnostics-library/#use-in-your-code","text":"MedusaDiagnostics::method_to_use(...)","title":"Use in your code"},{"location":"medusa-diagnostics-library/#package-content","text":"","title":"Package Content"},{"location":"medusa-diagnostics-library/#code-documentation","text":"source","title":"Code documentation"},{"location":"medusa-gazebo-bringup/","text":"","title":"Overview"},{"location":"medusa-gimmicks-library/","text":"Medusa Gimmicks Library Description Collection of methods to be used by several nodes in the Medusa stack. Important Sources The library was built following the steps in this link Also an important note about implementing template methods here . Basically this avoids linking errors with the library. How to use the library in a new package/node CmakeLists.txt Add library to find package find_package(catkin REQUIRED COMPONENTS roscpp medusa_gimmicks_lirabry ) package.xml Add the following <depend>medusa_gimmicks_lirabry</depend> Include the library in your new node #include <medusa_gimmicks_library/MedusaGimmicks.h> Use in your code MedusaGimmicks::method_to_use(...) Package Content Code documentation source","title":"Reference"},{"location":"medusa-gimmicks-library/#medusa-gimmicks-library","text":"","title":"Medusa Gimmicks Library"},{"location":"medusa-gimmicks-library/#description","text":"Collection of methods to be used by several nodes in the Medusa stack.","title":"Description"},{"location":"medusa-gimmicks-library/#important-sources","text":"The library was built following the steps in this link Also an important note about implementing template methods here . Basically this avoids linking errors with the library.","title":"Important Sources"},{"location":"medusa-gimmicks-library/#how-to-use-the-library-in-a-new-packagenode","text":"","title":"How to use the library in a new package/node"},{"location":"medusa-gimmicks-library/#cmakeliststxt","text":"Add library to find package find_package(catkin REQUIRED COMPONENTS roscpp medusa_gimmicks_lirabry )","title":"CmakeLists.txt"},{"location":"medusa-gimmicks-library/#packagexml","text":"Add the following <depend>medusa_gimmicks_lirabry</depend>","title":"package.xml"},{"location":"medusa-gimmicks-library/#include-the-library-in-your-new-node","text":"#include <medusa_gimmicks_library/MedusaGimmicks.h>","title":"Include the library in your new node"},{"location":"medusa-gimmicks-library/#use-in-your-code","text":"MedusaGimmicks::method_to_use(...)","title":"Use in your code"},{"location":"medusa-gimmicks-library/#package-content","text":"","title":"Package Content"},{"location":"medusa-gimmicks-library/#code-documentation","text":"source","title":"Code documentation"},{"location":"medusa-navigation/overview/","text":"Description medusa_nav is a meta-package to house all the software packages required to construct a navigation system for an unmanned underwater vehicle. This package has the following features Deploy vehicle state estimation node for dead-reckoning Deploy vehicle state estimation node with position fixes from one or multiple sources Implement Single-beacon and USBL range based navigation algorithm Convert WGS84 input in to UTM NED in Convert State in to State in Convert State in to State in Implements tools and techniques used in geophysical navigation. Getting Started Prerequisite Information Before getting started, the reader is recommended to get familiarized with the following concepts - Kalman and Extended Kalman Filter - Range based navigation techniques such as Single-beacon (EKF) and USBL - Reference Frames and Transformations - ROS and Linux operations - Key Libraries include TF2, Geographic Lib, Eigen Conventions Assume that the best practices laid down by P\u00e9ter Fankhauser, ANYbotics are followed unless other stated. Deviations - AUV World reference frame is North-East-Down - Input Angles are in Radians, Output Angles are in Degrees - Following coordinate frames are used - base_link: Body-fixed rigid frame attached to the COM of the vehicle - odom: World-fixed frame where position evolves smoothly, without discrete jumps but with drifts. - map : World-fixed frame where position evolves with discrete jumps, but with little drifts. Inspirations Work done in this package draws heavily from the following two packages - medusa-ros/medusa_control/filters_medusa - cra-ros-pkg/robot_localization ! Follow the Guidelines and Development Lifecycle defined for medusa_vx stack Project Directory sensor_fusion A general-purpose kalman filter for vehicle state estimation. For documentation, refer the links below - Readme.md - Developer Notes - Theory nav_tools Contains handy tools used to convert measurements and state messages. Also contains range-based measurement nodes. medusa_gn Geo-physical navigation","title":"Overview"},{"location":"medusa-navigation/overview/#description","text":"medusa_nav is a meta-package to house all the software packages required to construct a navigation system for an unmanned underwater vehicle. This package has the following features Deploy vehicle state estimation node for dead-reckoning Deploy vehicle state estimation node with position fixes from one or multiple sources Implement Single-beacon and USBL range based navigation algorithm Convert WGS84 input in to UTM NED in Convert State in to State in Convert State in to State in Implements tools and techniques used in geophysical navigation.","title":"Description"},{"location":"medusa-navigation/overview/#getting-started","text":"","title":"Getting Started"},{"location":"medusa-navigation/overview/#prerequisite-information","text":"Before getting started, the reader is recommended to get familiarized with the following concepts - Kalman and Extended Kalman Filter - Range based navigation techniques such as Single-beacon (EKF) and USBL - Reference Frames and Transformations - ROS and Linux operations - Key Libraries include TF2, Geographic Lib, Eigen","title":"Prerequisite Information"},{"location":"medusa-navigation/overview/#conventions","text":"Assume that the best practices laid down by P\u00e9ter Fankhauser, ANYbotics are followed unless other stated. Deviations - AUV World reference frame is North-East-Down - Input Angles are in Radians, Output Angles are in Degrees - Following coordinate frames are used - base_link: Body-fixed rigid frame attached to the COM of the vehicle - odom: World-fixed frame where position evolves smoothly, without discrete jumps but with drifts. - map : World-fixed frame where position evolves with discrete jumps, but with little drifts.","title":"Conventions"},{"location":"medusa-navigation/overview/#inspirations","text":"Work done in this package draws heavily from the following two packages - medusa-ros/medusa_control/filters_medusa - cra-ros-pkg/robot_localization ! Follow the Guidelines and Development Lifecycle defined for medusa_vx stack","title":"Inspirations"},{"location":"medusa-navigation/overview/#project-directory","text":"","title":"Project Directory"},{"location":"medusa-navigation/overview/#sensor_fusion","text":"A general-purpose kalman filter for vehicle state estimation. For documentation, refer the links below - Readme.md - Developer Notes - Theory","title":"sensor_fusion"},{"location":"medusa-navigation/overview/#nav_tools","text":"Contains handy tools used to convert measurements and state messages. Also contains range-based measurement nodes.","title":"nav_tools"},{"location":"medusa-navigation/overview/#medusa_gn","text":"Geo-physical navigation","title":"medusa_gn"},{"location":"medusa-ros-messages/","text":"Medusa messages stack mDummy.msg -> Messages with an m are used in all vehicles dDummy.msg -> Messages with a d are only used in Delfim","title":"Reference"},{"location":"medusa-ros-messages/#medusa-messages-stack","text":"mDummy.msg -> Messages with an m are used in all vehicles dDummy.msg -> Messages with a d are only used in Delfim","title":"Medusa messages stack"},{"location":"medusa-scripts/","text":"","title":"Reference"},{"location":"medusa-simulation-bringup-system/","text":"","title":"Overview"},{"location":"medusa-worlds/","text":"","title":"Overview"},{"location":"nav-tools/nav_tools/","text":"Nav tools Project Description This package contains tools to convert msgs between data types. Currently, it also houses range-based positioning tools. This package has the following highlights Convert data in WGS84 from sensor_msgs::NavSatFix to data in UTM NED & medusa_msgs::Measurement Convert state from auv_msgs::NavigationStatus to medusa_msgs::mState Convert state from auv_msgs::NavigationStatus to nav_msgs::Odometry Convert Ranges from single-beacon to position update using EKF Convert Georeferenced USBL position fix to position update Getting Started Installation Pkg nav_tools comes as part of the medusa_vx stack. Gnss2Utm This node converts data in WGS84 from sensor_msgs::NavSatFix to UTM NED medusa_msgs::Measurement format Configuration This section explains how to write the node configuration file. A sample is given below node_frequency: 10 topics: subscribers: [ \"/measurement/gnss\" ] publishers: [ \"/measurement/position\" ] ROS Node Parameters node_frequency : parameter of type double Define the node output frequency topics/subscribers : parameter of type string[1] Defines the input topic to receive position in Lat/Lon, WGS84 format. topics/publishers : parameters of type string[1] Defines topic to output position in UTM NED Launching the Nodes An example launch file is provided below where nav_tools/gnss2utm node is being launched. <?xml version=\"1.0\"?> <launch> <node pkg=\"nav_tools\" type=\"gnss_to_utm\" name=\"gnss2utm\" respawn=\"true\" output=\"screen\"> <rosparam command=\"load\" file=\"$(find nav_tools)/config/gnss2utm.yaml\"/> </node> </launch> AuvState2mState This node converts state in auv_msgs::NavigationStatus to state in medusa_msgs::mState . Also need inside_pressure data for mState. Configuration This section explains how to write the node configuration file. A sample is given below node_frequency: 10 topics: subscribers: [ \"/nav/filter/state\", \"/drivers/inside_pressure/data\" ] publishers: [ \"/State\" ] node_frequency : node output frequency topics/subscribers: parameter of type string[2] topic[1] - state: receives state of type auv_msgs::NavigationStatu topic[2] - inside_pressure: receives inside_pressure data topics/publishers: parameter of type string[1] topic[1] - state: publishes state of type medusa_msgs::mState Launching the Nodes An example launch file is provided below where nav_tools/auvstate2mstate node is being launched. <?xml version=\"1.0\"?> <launch> <node pkg=\"nav_tools\" type=\"auvstate_to_mstate\" name=\"auvstate2mstate\" respawn=\"true\" output=\"screen\"> <rosparam command=\"load\" file=\"$(find nav_tools)/config/auvstate2mstate.yaml\"/> </node> </launch> AuvState2Odom This node converts state in auv_msgs::NavigationStatus to nav_msgs::Odometry . Configuration This section explains how to write the node configuration file. A sample is given below node_frequency: 10 topics: subscribers: [ \"/nav_filter/state\" ] publishers: [ \"/nav_filter/state_odom\" ] node_frequency : node output frequency topics/subscribers: parameter of type string[1] receives state of type auv_msgs::NavigationStatus topics/publishers: parameter of type string[1] publishes state of type nav_msgs::Odometry Launching the Nodes An example launch file is provided below where nav_tools/auvstate2odom node is being launched. <?xml version=\"1.0\"?> <launch> <node pkg=\"nav_tools\" type=\"auvstate_to_odom\" name=\"auvstate2odom\" respawn=\"true\" output=\"screen\"> <rosparam command=\"load\" file=\"$(find nav_tools)/config/auvstate2odom.yaml\"/> </node> </launch> Usbl2Pos This node takes in georeferences usbl position fix and converts it to position updates of the filter. It can be deployed in two ways Scenario 1: Inverted-USBL In this scenario, the underwater vehicle localizes itself with respect to an anchor, whose precise global position is known. The usbl onboard the vehicle receives the georeferenced position of the anchor and the usbl-fix. The vehicle uses these two information to estimate its position using simple geometry. Scenario 2: Tracking with USBL In this scenario, the anchor, whose precise global position is known, tracks underwater vehicles using USBL fixes. The anchor receives the usbl-fix of the underwater vehicle and uses its own position to estimate the position of the underwater vehicle. Configuration node_frequency: 10 topics: subscribers: [ \"/acomms/measurement/usbl_fix\", \"/acomms/convert/state\" ] publishers: [ \"/measurement/position\" ] t_sync: 2 fix_type: false meas_noise: 0.001 node_frequency : node output frequency topics/subscribers: parameter of type string[2] defines the input topics - usblfix topic to receive USBL position fixes in medusa_msgs::mUSBLFix state topic to receive the state of the vehicle or anchor state in auv_msgs::NavigationStatus t_sync: parameter of type double time (secs) after which \"Range Only\" and \"Bearing/Elevation\" medusa_msgs::mUSBLFix fixes go out of sync fix_type: parameter of type bool if set false, vehicle acts as an achor, estimates other vehicles position i.e. scenario 1 if set true, vehicle estimates its position with respect to an anchor i.e. scenario 2 Launching the Nodes An example launch file is provided below where nav_tools/usblfix2pos node is being launched. <?xml version=\"1.0\"?> <launch> <node pkg=\"nav_tools\" type=\"usblfix_to_pos\" name=\"usblfix2pos\" respawn=\"true\" output=\"screen\"> <rosparam command=\"load\" file=\"$(find nav_tools)/config/usblfix2pos.yaml\"/> </node> </launch> Range2Pos This node converts ranges from a single beacon to a position measurement using an Extended Kalman Filter. Configuration This section explains how to write the node configuration file. A sample is given below node_frequency: 10 t_sync: 2 topics: subscribers: [ \"/sensors/usbl\", \"/nav/filter/state\" ] publishers: [ \"/measurement/position\" ] beacon: position: [4290771, 491886] node_frequency : node output frequency topics/subscribers: parameter of type string[3] Defines the input topics - range topic to receive range only USBL fixes in medusa_msgs::mUSBLFix state topic to receive state from navigation system in auv_msgs::NavigationStatus beacon topic to receive beacon state topics/publishers: parameter of type string[1] publishes position update of type medusa_msgs::Measurement beacon/position : State of stationary beacon position in UTM NED Launching the Nodes An example launch file is provided below where nav_tools/auvstate2mstate node is being launched. <?xml version=\"1.0\"?> <launch> <node pkg=\"nav_tools\" type=\"usblfix_to_pos\" name=\"range2pos\" respawn=\"true\" output=\"screen\"> <rosparam command=\"load\" file=\"$(find nav_tools)/config/range2pos.yaml\"/> </node> </launch>","title":"Overview"},{"location":"nav-tools/nav_tools/#nav-tools","text":"","title":"Nav tools"},{"location":"nav-tools/nav_tools/#project-description","text":"This package contains tools to convert msgs between data types. Currently, it also houses range-based positioning tools. This package has the following highlights Convert data in WGS84 from sensor_msgs::NavSatFix to data in UTM NED & medusa_msgs::Measurement Convert state from auv_msgs::NavigationStatus to medusa_msgs::mState Convert state from auv_msgs::NavigationStatus to nav_msgs::Odometry Convert Ranges from single-beacon to position update using EKF Convert Georeferenced USBL position fix to position update","title":"Project Description"},{"location":"nav-tools/nav_tools/#getting-started","text":"","title":"Getting Started"},{"location":"nav-tools/nav_tools/#installation","text":"Pkg nav_tools comes as part of the medusa_vx stack.","title":"Installation"},{"location":"nav-tools/nav_tools/#gnss2utm","text":"This node converts data in WGS84 from sensor_msgs::NavSatFix to UTM NED medusa_msgs::Measurement format","title":"Gnss2Utm"},{"location":"nav-tools/nav_tools/#configuration","text":"This section explains how to write the node configuration file. A sample is given below node_frequency: 10 topics: subscribers: [ \"/measurement/gnss\" ] publishers: [ \"/measurement/position\" ] ROS Node Parameters node_frequency : parameter of type double Define the node output frequency topics/subscribers : parameter of type string[1] Defines the input topic to receive position in Lat/Lon, WGS84 format. topics/publishers : parameters of type string[1] Defines topic to output position in UTM NED","title":"Configuration"},{"location":"nav-tools/nav_tools/#launching-the-nodes","text":"An example launch file is provided below where nav_tools/gnss2utm node is being launched. <?xml version=\"1.0\"?> <launch> <node pkg=\"nav_tools\" type=\"gnss_to_utm\" name=\"gnss2utm\" respawn=\"true\" output=\"screen\"> <rosparam command=\"load\" file=\"$(find nav_tools)/config/gnss2utm.yaml\"/> </node> </launch>","title":"Launching the Nodes"},{"location":"nav-tools/nav_tools/#auvstate2mstate","text":"This node converts state in auv_msgs::NavigationStatus to state in medusa_msgs::mState . Also need inside_pressure data for mState.","title":"AuvState2mState"},{"location":"nav-tools/nav_tools/#configuration_1","text":"This section explains how to write the node configuration file. A sample is given below node_frequency: 10 topics: subscribers: [ \"/nav/filter/state\", \"/drivers/inside_pressure/data\" ] publishers: [ \"/State\" ] node_frequency : node output frequency topics/subscribers: parameter of type string[2] topic[1] - state: receives state of type auv_msgs::NavigationStatu topic[2] - inside_pressure: receives inside_pressure data topics/publishers: parameter of type string[1] topic[1] - state: publishes state of type medusa_msgs::mState","title":"Configuration"},{"location":"nav-tools/nav_tools/#launching-the-nodes_1","text":"An example launch file is provided below where nav_tools/auvstate2mstate node is being launched. <?xml version=\"1.0\"?> <launch> <node pkg=\"nav_tools\" type=\"auvstate_to_mstate\" name=\"auvstate2mstate\" respawn=\"true\" output=\"screen\"> <rosparam command=\"load\" file=\"$(find nav_tools)/config/auvstate2mstate.yaml\"/> </node> </launch>","title":"Launching the Nodes"},{"location":"nav-tools/nav_tools/#auvstate2odom","text":"This node converts state in auv_msgs::NavigationStatus to nav_msgs::Odometry .","title":"AuvState2Odom"},{"location":"nav-tools/nav_tools/#configuration_2","text":"This section explains how to write the node configuration file. A sample is given below node_frequency: 10 topics: subscribers: [ \"/nav_filter/state\" ] publishers: [ \"/nav_filter/state_odom\" ] node_frequency : node output frequency topics/subscribers: parameter of type string[1] receives state of type auv_msgs::NavigationStatus topics/publishers: parameter of type string[1] publishes state of type nav_msgs::Odometry","title":"Configuration"},{"location":"nav-tools/nav_tools/#launching-the-nodes_2","text":"An example launch file is provided below where nav_tools/auvstate2odom node is being launched. <?xml version=\"1.0\"?> <launch> <node pkg=\"nav_tools\" type=\"auvstate_to_odom\" name=\"auvstate2odom\" respawn=\"true\" output=\"screen\"> <rosparam command=\"load\" file=\"$(find nav_tools)/config/auvstate2odom.yaml\"/> </node> </launch>","title":"Launching the Nodes"},{"location":"nav-tools/nav_tools/#usbl2pos","text":"This node takes in georeferences usbl position fix and converts it to position updates of the filter. It can be deployed in two ways Scenario 1: Inverted-USBL In this scenario, the underwater vehicle localizes itself with respect to an anchor, whose precise global position is known. The usbl onboard the vehicle receives the georeferenced position of the anchor and the usbl-fix. The vehicle uses these two information to estimate its position using simple geometry. Scenario 2: Tracking with USBL In this scenario, the anchor, whose precise global position is known, tracks underwater vehicles using USBL fixes. The anchor receives the usbl-fix of the underwater vehicle and uses its own position to estimate the position of the underwater vehicle.","title":"Usbl2Pos"},{"location":"nav-tools/nav_tools/#configuration_3","text":"node_frequency: 10 topics: subscribers: [ \"/acomms/measurement/usbl_fix\", \"/acomms/convert/state\" ] publishers: [ \"/measurement/position\" ] t_sync: 2 fix_type: false meas_noise: 0.001 node_frequency : node output frequency topics/subscribers: parameter of type string[2] defines the input topics - usblfix topic to receive USBL position fixes in medusa_msgs::mUSBLFix state topic to receive the state of the vehicle or anchor state in auv_msgs::NavigationStatus t_sync: parameter of type double time (secs) after which \"Range Only\" and \"Bearing/Elevation\" medusa_msgs::mUSBLFix fixes go out of sync fix_type: parameter of type bool if set false, vehicle acts as an achor, estimates other vehicles position i.e. scenario 1 if set true, vehicle estimates its position with respect to an anchor i.e. scenario 2","title":"Configuration"},{"location":"nav-tools/nav_tools/#launching-the-nodes_3","text":"An example launch file is provided below where nav_tools/usblfix2pos node is being launched. <?xml version=\"1.0\"?> <launch> <node pkg=\"nav_tools\" type=\"usblfix_to_pos\" name=\"usblfix2pos\" respawn=\"true\" output=\"screen\"> <rosparam command=\"load\" file=\"$(find nav_tools)/config/usblfix2pos.yaml\"/> </node> </launch>","title":"Launching the Nodes"},{"location":"nav-tools/nav_tools/#range2pos","text":"This node converts ranges from a single beacon to a position measurement using an Extended Kalman Filter.","title":"Range2Pos"},{"location":"nav-tools/nav_tools/#configuration_4","text":"This section explains how to write the node configuration file. A sample is given below node_frequency: 10 t_sync: 2 topics: subscribers: [ \"/sensors/usbl\", \"/nav/filter/state\" ] publishers: [ \"/measurement/position\" ] beacon: position: [4290771, 491886] node_frequency : node output frequency topics/subscribers: parameter of type string[3] Defines the input topics - range topic to receive range only USBL fixes in medusa_msgs::mUSBLFix state topic to receive state from navigation system in auv_msgs::NavigationStatus beacon topic to receive beacon state topics/publishers: parameter of type string[1] publishes position update of type medusa_msgs::Measurement beacon/position : State of stationary beacon position in UTM NED","title":"Configuration"},{"location":"nav-tools/nav_tools/#launching-the-nodes_4","text":"An example launch file is provided below where nav_tools/auvstate2mstate node is being launched. <?xml version=\"1.0\"?> <launch> <node pkg=\"nav_tools\" type=\"usblfix_to_pos\" name=\"range2pos\" respawn=\"true\" output=\"screen\"> <rosparam command=\"load\" file=\"$(find nav_tools)/config/range2pos.yaml\"/> </node> </launch>","title":"Launching the Nodes"},{"location":"open-loop-control/","text":"","title":"Reference"},{"location":"pages/Acknowledgments/","text":"The Medusa project results from the work and dedication of many. Share the love \u2764\ufe0f with the following members that came before you did! Active Developers Jo\u00e3o Quintas jquintas@gmail.com Marcelo Jacinto marcelo.jacinto@tecnico.ulisboa.pt David Souto david.souto@tecnico.ulisboa.pt Andr\u00e9 Potes andre.potes@tecnico.ulisboa.pt Francisco Rego ffcrego@gmail.com David Cabecinhas dcabecinhas@isr.tecnico.ulisboa.pt We also welcome the new members to the DSOR team Eduardo Cunha Daniel Rosa Previous contributors which left us with some precious legacy Jo\u00e3o Cruz Hung Tuan Shubham Garg Jorge Ribeiro Miguel Ribeiro Henrique Silva Jo\u00e3o Botelho Filipa Almeida Omnipresent members Prof. Ant\u00f3nio Pascoal Prof. Carlos Silvestre Prof. Rita Cunha Prof. Bruno Guerreiro Prof. Pedro Batista Lu\u00eds Sebasti\u00e3o Manuel Rufino Pedro Gois Helena Santana And never forget, we stand on the shoulders of giants!","title":"Acknowledgments"},{"location":"pages/Acknowledgments/#active-developers","text":"Jo\u00e3o Quintas jquintas@gmail.com Marcelo Jacinto marcelo.jacinto@tecnico.ulisboa.pt David Souto david.souto@tecnico.ulisboa.pt Andr\u00e9 Potes andre.potes@tecnico.ulisboa.pt Francisco Rego ffcrego@gmail.com David Cabecinhas dcabecinhas@isr.tecnico.ulisboa.pt","title":"Active Developers"},{"location":"pages/Acknowledgments/#we-also-welcome-the-new-members-to-the-dsor-team","text":"Eduardo Cunha Daniel Rosa","title":"We also welcome the new members to the DSOR team"},{"location":"pages/Acknowledgments/#previous-contributors-which-left-us-with-some-precious-legacy","text":"Jo\u00e3o Cruz Hung Tuan Shubham Garg Jorge Ribeiro Miguel Ribeiro Henrique Silva Jo\u00e3o Botelho Filipa Almeida","title":"Previous contributors which left us with some precious legacy"},{"location":"pages/Acknowledgments/#omnipresent-members","text":"Prof. Ant\u00f3nio Pascoal Prof. Carlos Silvestre Prof. Rita Cunha Prof. Bruno Guerreiro Prof. Pedro Batista Lu\u00eds Sebasti\u00e3o Manuel Rufino Pedro Gois Helena Santana And never forget, we stand on the shoulders of giants!","title":"Omnipresent members"},{"location":"pages/CHANGELOG/","text":"Changelog v1.1 First version of medusa_base repository with automatic documentation generation","title":"Changelog"},{"location":"pages/CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"pages/CHANGELOG/#v11","text":"First version of medusa_base repository with automatic documentation generation","title":"v1.1"},{"location":"pages/CODE_OF_CONDUCT/","text":"Contributor Covenant Code of Conduct Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at jquintas@gmail.com. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Code of Conduct"},{"location":"pages/CODE_OF_CONDUCT/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"pages/CODE_OF_CONDUCT/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"pages/CODE_OF_CONDUCT/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"pages/CODE_OF_CONDUCT/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"pages/CODE_OF_CONDUCT/#scope","text":"This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"pages/CODE_OF_CONDUCT/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at jquintas@gmail.com. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"pages/CODE_OF_CONDUCT/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Attribution"},{"location":"pages/CONTRIBUTING/","text":"TODO","title":"Contributing"},{"location":"pages/CONTRIBUTING/#todo","text":"","title":"TODO"},{"location":"pages/LICENSE/","text":"MIT License Copyright (c) 2022 dsor-isr Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"pages/get_started/Build-the-Code/","text":"","title":"Build the Code"},{"location":"pages/get_started/Install-Guide/","text":"1. Ubuntu and ROS installation: 1. Install Ubuntu 20.04LTS (https://releases.ubuntu.com/20.04) 2. Install ROS 1 Noetic (http://wiki.ros.org/noetic/Installation/Ubuntu) 3. Add the following Functions and Alias to your .bashrc file, to make development easier \ud83e\udd13 1. Create a file to store the latest catkin workspace (if it does not exist) and put in the first line the default name, i.e. catkin_ws ``` if [ ! -f ~/.catkin_ws_config ]; then touch ~/.catkin_ws_config && echo catkin_ws > ~/.catkin_ws_config ;fi ``` 2. Set the variable CATKIN_PACKAGE with the workspace in the catkin_ws_config file ``` export CATKIN_PACKAGE=$(head -n 1 ~/.catkin_ws_config) ``` 3. Function to update the default catkin workspace variable and store the last setting in the file ``` set_catkin_ws_function() { #set CATKIN_PACKAGE according the an input parameter export CATKIN_PACKAGE=catkin_ws_$1 echo CATKIN_PACKAGE = ${CATKIN_PACKAGE} # save into a hidden file the catkin workspace setting echo $CATKIN_PACKAGE > ~/.catkin_ws_config source ~/.bashrc } ``` 4. This is required (to source the ROS and medusa files) ``` source /opt/ros/noetic/setup.bash export CATKIN_ROOT=${HOME}/<path_to_workspace> export ROS_WORKSPACE=${CATKIN_ROOT}/${CATKIN_PACKAGE} export MEDUSA_SCRIPTS=$(find ${ROS_WORKSPACE}/src/ -type d -iname medusa_scripts | head -n 1) source ${MEDUSA_SCRIPTS}/medusa_easy_alias/medusa_permanent_alias/alias.sh ``` NOTE: replace /<path_to_workspace> with the folder where you put you catkin_ws inside (for example /dsor ). If you put in your home folder, then this variable should be left empty! Create a catkin_ws directory 2. Downloading the repository: Start by cloning the repository with git clone --recursive https://github.com/dsor-isr/medusa_base . If the repository was cloned non-recursively previously, use git submodule update --init to clone the necessary submodules. 3. Configuring the dependencies: Run the installation bash script using ./","title":"Install Guide"},{"location":"pages/get_started/Repository-Structure/","text":"","title":"Repository Structure"},{"location":"path-following/","text":"Path Following Documentation A package that implements the differente path following algorithm described in the literature. By default we provide several algorithms, from Line of Sight (LOS-Fossen) to more sophisticated ones such as Lapierre. Authors: - Marcelo Jacinto - Jo\u00e3o Quintas - Jo\u00e3o Cruz - Hung Tuan Maintainer: Marcelo Jacinto Email: marcelo.jacinto@tecnico.ulisboa.pt Creation Date: April/2021 Version: 1.0.0 Last Update: April/2021 Path Following We start by providing a set of path following algorithms. Each algorithm inherits the class PathFollowing . As we see, every algorithm, even though different is implemented in the same structured manner. Some control surge and yaw . Others control yaw rate and other control sway . Some use the closest point to the path in the computations, and some use an adptive virtual target . The number of algorithms implemented is expected to grow with time. To see all the current path following algorithms implemented check the provided classes API. Here is an example of some of them provided (see image bellow). In order to implement a path following algorithm must implement the method callPFController where the actual control law implementation is done. The publish method serves the purpose of publishing the relevant control signals to the relevant topics (received in the constructor of the concrete path following we are implementing - more on that later). The start , stop and reset methods are auxiliar and their names I believe are self explanatory. The setPFgains is used to receive a vector of gains and map to controller gains (which might be different for each controller). Bellow we show a particular example applied to the Aguiar controller. The constructor of this clas receives the controller gains and the 3 publishers: - A surge publisher - A yaw rate publisher - A rabbit publisher (virtual target) The reason we pass ROS publishers or services as arguments (and we are not able to provide the same level of abstraction as in paths) is that every controller migh publish different kinds of references signals. On the paths class the published data is all the same. In Aguiar's case, since the mode of operation required for the path is the default (given a gamma, publish path data), we only need to publish at start (in start method) the initial gamma (in order to initiate the loop in which the path sends us data back). For example, in Fossen's case, since the mode of operation is closest point, we need to receive in the constructor the service used to change the mode of operatin of the path (and call it in the start method). I invite you to checkout the start method in these 2 implementations to understand the conceptual differences. How to interface with ROS We have already got a glimpse on how to interface with ROS. We pass as arguments to the constructor of the class the publishers that we need. Similar to the paths class, we also have services to change between controllers. One service for each controller. Furthermore we also develop one callback for each service (see image bellow). In order to implement a service we can use the picture bellow as a blueprint. It is almost always the same. We only need to: clear the previous control define a set of publishers save the publisher into the publisher vector (this step is import as this vector is cleared every time we change between controllers). The old publishers are de-registered we read the controller gains from the parameter server instantiate the controller node we desired return success! Bellow we provide a sample implementation applied to the case of Brevik algorithm.","title":"Reference"},{"location":"path-following/#path-following-documentation","text":"A package that implements the differente path following algorithm described in the literature. By default we provide several algorithms, from Line of Sight (LOS-Fossen) to more sophisticated ones such as Lapierre. Authors: - Marcelo Jacinto - Jo\u00e3o Quintas - Jo\u00e3o Cruz - Hung Tuan Maintainer: Marcelo Jacinto Email: marcelo.jacinto@tecnico.ulisboa.pt Creation Date: April/2021 Version: 1.0.0 Last Update: April/2021","title":"Path Following Documentation"},{"location":"path-following/#path-following","text":"We start by providing a set of path following algorithms. Each algorithm inherits the class PathFollowing . As we see, every algorithm, even though different is implemented in the same structured manner. Some control surge and yaw . Others control yaw rate and other control sway . Some use the closest point to the path in the computations, and some use an adptive virtual target . The number of algorithms implemented is expected to grow with time. To see all the current path following algorithms implemented check the provided classes API. Here is an example of some of them provided (see image bellow). In order to implement a path following algorithm must implement the method callPFController where the actual control law implementation is done. The publish method serves the purpose of publishing the relevant control signals to the relevant topics (received in the constructor of the concrete path following we are implementing - more on that later). The start , stop and reset methods are auxiliar and their names I believe are self explanatory. The setPFgains is used to receive a vector of gains and map to controller gains (which might be different for each controller). Bellow we show a particular example applied to the Aguiar controller. The constructor of this clas receives the controller gains and the 3 publishers: - A surge publisher - A yaw rate publisher - A rabbit publisher (virtual target) The reason we pass ROS publishers or services as arguments (and we are not able to provide the same level of abstraction as in paths) is that every controller migh publish different kinds of references signals. On the paths class the published data is all the same. In Aguiar's case, since the mode of operation required for the path is the default (given a gamma, publish path data), we only need to publish at start (in start method) the initial gamma (in order to initiate the loop in which the path sends us data back). For example, in Fossen's case, since the mode of operation is closest point, we need to receive in the constructor the service used to change the mode of operatin of the path (and call it in the start method). I invite you to checkout the start method in these 2 implementations to understand the conceptual differences.","title":"Path Following"},{"location":"path-following/#how-to-interface-with-ros","text":"We have already got a glimpse on how to interface with ROS. We pass as arguments to the constructor of the class the publishers that we need. Similar to the paths class, we also have services to change between controllers. One service for each controller. Furthermore we also develop one callback for each service (see image bellow). In order to implement a service we can use the picture bellow as a blueprint. It is almost always the same. We only need to: clear the previous control define a set of publishers save the publisher into the publisher vector (this step is import as this vector is cleared every time we change between controllers). The old publishers are de-registered we read the controller gains from the parameter server instantiate the controller node we desired return success! Bellow we provide a sample implementation applied to the case of Brevik algorithm.","title":"How to interface with ROS"},{"location":"pid-inner-loops/innerloops/","text":"Inner Loops Sources From\\ dos Santos Ribeiro, Jorge Miguel. \"Motion control of single and multiple autonomous marine vehicles.\" PhD diss., MS thesis, Dept. Elect. Comput. Eng., Inst. Superior T\u00e9cnico, Lisbon, Portugal, 2011. Resendes Maia, Ana Cristina. \"Sensor-Based Formation Control of Autonomous Robotic Vehicles.\" PhD diss., MS thesis, Dept. Elect. Comput. Eng., Inst. Superior T\u00e9cnico, Lisbon, Portugal, 2013. P. C. Abreu et al., \"The MEDUSA class of autonomous marine vehicles and their role in EU projects,\" OCEANS 2016 - Shanghai, Shanghai, 2016, pp. 1-10. Description Speed Controller Theory The speed controller is a PI controller responsible to compute a common mode command for the two longitudinal thrusters as \\[ CM = -k_p \\tilde{u} - k_i \\int_0^t \\tilde{u} (\\tau) d\\tau, \\] \\[ \\tilde{u} = \\hat{u}-u_d \\] where \\(\\hat{u}\\) is the estimate and \\(u_d\\) is the reference to be tracked. In code * Reference \\(u_d\\) is limited between [-0.5; 1.2] (m/s) * Aceleration of the reference is limited to 0.04 (m/s^2). * Common Mode is saturated between [-40; 60]. Heading Controller Theory The Heading controller is a PID responsible to compute a differential mode for the two longitudinal thrusters. \\[ DM = k_p\\tilde{\\psi} - k_d\\dot{\\tilde{\\psi}} +k_i\\int_0^t\\tilde{\\psi}(\\tau)d\\tau, \\] \\[ \\tilde{\\psi} = \\hat{\\psi}-\\psi_d \\] where \\(\\hat{\\psi}\\) is the estimate and \\(\\psi_d\\) is the reference to be tracked. In code * Saturating the Reference Derivative: Since the vehicle can not do more that 25 degrees per sec, the yaw rate given by the previous reference and the new reference is limited by 5 (ts=0.2). In mathematical terms, \\[ \\dot{\\tilde{\\psi}} = \\dot{\\hat{\\psi}} - \\dot{\\psi}_d \\] \\[ \\dot{\\psi}_d = (\\psi_{d|k}-\\psi_{d|k-1})/t_s,\\quad \\dot{\\psi} \\in [-5;5] \\] Not integrating if the error is too big: If \\(|\\tilde{\\psi}|\\) > 20 then there is no integration. Reducing the surge speed if the yaw err is big: If \\(|\\tilde{\\psi}| \\in [20;90]\\) , u_ref_gain is given by: \\[ u\\_ref\\_gain = (\\sin(-|\\frac{\\tilde{\\psi}}{90-20}| + \\frac{90}{90-20} - 90) + 1) *0.5/2.0 + 0.5 \\] This component will be multiplied by the reference going into the speed controller. Note: If \\(\\tilde{\\psi}\\) is below 20 the gain is 1 and if it is above 90 the gain is 0.5. The diffential mode is saturated between [-(80*80);(80*80)], and in case a saturation occurs the integration component is reverted to the old value (it is not updated). Heading Rate Controller Theory The heading rate controller is a PI with feedforward responsible to compute a differential mode for the longitudinal thrusters. $$ DM = k_{f}\\dot{\\psi_d} + k_p\\dot{\\tilde{\\psi}}-k_i\\int_0^t\\dot{\\tilde{\\psi}}(\\tau)d\\tau, $$ In code * The error \\(\\tilde{\\psi}\\) is saturated between [-20;20]. * The diffential mode is saturated between [-(80*80);(80*80)], and in case a saturation occurs the integration is is reverted to the old value (it is not updated). Z Controller Theory The Z controller is a PID with feedforward acceleration controller responsible to compute a common mode for the vertical thrusters. \\[ CM_{vertical} = k_p\\tilde{z} + k_d\\dot{\\tilde{z}} +k_i\\int_0^t\\tilde{z}(\\tau)d\\tau + \\frac{\\ddot{\\tilde{z}}_d - \\alpha\\dot{z} - \\beta\\dot{z}|\\dot{z}|}{\\gamma}, \\] In code * If depth references exist then it will work as a depth controller, otherwise if altitude references exist it will work as a altitude controller. * Safety features: Depth If the water column minus the depth reference is smaller than our minimum altitude reference then it automatically goes to altitude control with a reference of our minimum altitude. It goes back to depth control when the water column minus the reference is bigger than 2m. * Safety features: Altitude Limitates to our minimum altitude reference If the water column minus the altitude reference is bigger than our maximum depth then it is limited by that value. * Pre filter: Reference Rate saturation: the reference is saturated taking into account the maximum reference rate (0.2*Ts). Calculation of: \\[ \\ddot{\\tilde{z}}_d = \\omega _n^2*(\\tilde{z}_d - \\tilde{z}_{d|k-1}) - 2\\xi\\omega_n*\\ddot{\\tilde{z}}_{d|k-1} \\] \\[ \\dot{\\tilde{z}}_d = \\ddot{\\tilde{z}}_d + \\ddot{\\tilde{z}}_d t_s \\] \\[ \\tilde{z}_{d} = \\tilde{z}_{d|k-1} + \\dot{\\tilde{z}}_d t_s \\] CM is saturated between [-60,60]. Roll Controller - NOT BEING USED The roll controller is a PD responsible to return a differential mode for the vertical thrusters. If roll is bigger than 60 degrees then the controller will stop. Note: The CM and DM are defined as a percentage of the maximum RPM: $$ CM = \\frac{Left\\ RPM (\\%) + right\\ RPM (\\%)}{2} $$ \\[ DM = \\frac{Left\\ RPM (\\%) - right\\ RPM (\\%)}{2} \\] Code description Controller_interface Every controller inherits a ControllerInterface Class (controller_interface.c/h) composed by the following atributes: kp_ - proporcional gain ki_ - integral gain kd_ - integral gain ref_old_ - old reference qsi_old_ - saves the integration value and the following methods: int execute([arguments]); - executes the pid controll void reset(); - resets the filter In this interface, a Saturation struct was created to ease the operation of saturation. Basically, it is only necessary to create a Saturation object in the controller constructor defining the minimum and maximum value. To saturate a value we just need to call the function {clip} from the Saturation object. Innerloops main loop In the innerloops::timerCallback we find the logic to apply these controllers; 1 - If a yaw reference exists, the heading controller will compute a DM for the horizontal thrusters. otherwise if a yaw rate ref exists the heading controller will be reset and the yaw rate controller will compute the DM. If none of the above cases happen it will check if we have an open loop value for DM otherwise it will reset the heading controller and the heading rate controller. 2 - If a speed reference exists, the speed controller will multiply it by the u_ref_gain (see heading controller) to compute a Common Mode for the longitudinal thrusters. Otherwise it will check if we have an open loop value for CM. If none of the above occur, the speed controller is reset. 3 - If in full power up, the vertical Common Mode will be equal to -60. Else it will check if we have a depth reference to compute de CM. After that it will check if we have a open loop CM and only then will it check if we have a altitude reference. If none of the above occur, the filter is reset. 4 - Roll is actuated in open loop. 5 - Saturating common mode: the horizontal common mode is saturated between [-(60*60);(60*60)].","title":"Overview"},{"location":"pid-inner-loops/innerloops/#inner-loops","text":"","title":"Inner Loops"},{"location":"pid-inner-loops/innerloops/#sources","text":"From\\ dos Santos Ribeiro, Jorge Miguel. \"Motion control of single and multiple autonomous marine vehicles.\" PhD diss., MS thesis, Dept. Elect. Comput. Eng., Inst. Superior T\u00e9cnico, Lisbon, Portugal, 2011. Resendes Maia, Ana Cristina. \"Sensor-Based Formation Control of Autonomous Robotic Vehicles.\" PhD diss., MS thesis, Dept. Elect. Comput. Eng., Inst. Superior T\u00e9cnico, Lisbon, Portugal, 2013. P. C. Abreu et al., \"The MEDUSA class of autonomous marine vehicles and their role in EU projects,\" OCEANS 2016 - Shanghai, Shanghai, 2016, pp. 1-10.","title":"Sources"},{"location":"pid-inner-loops/innerloops/#description","text":"","title":"Description"},{"location":"pid-inner-loops/innerloops/#speed-controller","text":"Theory The speed controller is a PI controller responsible to compute a common mode command for the two longitudinal thrusters as \\[ CM = -k_p \\tilde{u} - k_i \\int_0^t \\tilde{u} (\\tau) d\\tau, \\] \\[ \\tilde{u} = \\hat{u}-u_d \\] where \\(\\hat{u}\\) is the estimate and \\(u_d\\) is the reference to be tracked. In code * Reference \\(u_d\\) is limited between [-0.5; 1.2] (m/s) * Aceleration of the reference is limited to 0.04 (m/s^2). * Common Mode is saturated between [-40; 60].","title":"Speed Controller"},{"location":"pid-inner-loops/innerloops/#heading-controller","text":"Theory The Heading controller is a PID responsible to compute a differential mode for the two longitudinal thrusters. \\[ DM = k_p\\tilde{\\psi} - k_d\\dot{\\tilde{\\psi}} +k_i\\int_0^t\\tilde{\\psi}(\\tau)d\\tau, \\] \\[ \\tilde{\\psi} = \\hat{\\psi}-\\psi_d \\] where \\(\\hat{\\psi}\\) is the estimate and \\(\\psi_d\\) is the reference to be tracked. In code * Saturating the Reference Derivative: Since the vehicle can not do more that 25 degrees per sec, the yaw rate given by the previous reference and the new reference is limited by 5 (ts=0.2). In mathematical terms, \\[ \\dot{\\tilde{\\psi}} = \\dot{\\hat{\\psi}} - \\dot{\\psi}_d \\] \\[ \\dot{\\psi}_d = (\\psi_{d|k}-\\psi_{d|k-1})/t_s,\\quad \\dot{\\psi} \\in [-5;5] \\] Not integrating if the error is too big: If \\(|\\tilde{\\psi}|\\) > 20 then there is no integration. Reducing the surge speed if the yaw err is big: If \\(|\\tilde{\\psi}| \\in [20;90]\\) , u_ref_gain is given by: \\[ u\\_ref\\_gain = (\\sin(-|\\frac{\\tilde{\\psi}}{90-20}| + \\frac{90}{90-20} - 90) + 1) *0.5/2.0 + 0.5 \\] This component will be multiplied by the reference going into the speed controller. Note: If \\(\\tilde{\\psi}\\) is below 20 the gain is 1 and if it is above 90 the gain is 0.5. The diffential mode is saturated between [-(80*80);(80*80)], and in case a saturation occurs the integration component is reverted to the old value (it is not updated).","title":"Heading Controller"},{"location":"pid-inner-loops/innerloops/#heading-rate-controller","text":"Theory The heading rate controller is a PI with feedforward responsible to compute a differential mode for the longitudinal thrusters. $$ DM = k_{f}\\dot{\\psi_d} + k_p\\dot{\\tilde{\\psi}}-k_i\\int_0^t\\dot{\\tilde{\\psi}}(\\tau)d\\tau, $$ In code * The error \\(\\tilde{\\psi}\\) is saturated between [-20;20]. * The diffential mode is saturated between [-(80*80);(80*80)], and in case a saturation occurs the integration is is reverted to the old value (it is not updated).","title":"Heading Rate Controller"},{"location":"pid-inner-loops/innerloops/#z-controller","text":"Theory The Z controller is a PID with feedforward acceleration controller responsible to compute a common mode for the vertical thrusters. \\[ CM_{vertical} = k_p\\tilde{z} + k_d\\dot{\\tilde{z}} +k_i\\int_0^t\\tilde{z}(\\tau)d\\tau + \\frac{\\ddot{\\tilde{z}}_d - \\alpha\\dot{z} - \\beta\\dot{z}|\\dot{z}|}{\\gamma}, \\] In code * If depth references exist then it will work as a depth controller, otherwise if altitude references exist it will work as a altitude controller. * Safety features: Depth If the water column minus the depth reference is smaller than our minimum altitude reference then it automatically goes to altitude control with a reference of our minimum altitude. It goes back to depth control when the water column minus the reference is bigger than 2m. * Safety features: Altitude Limitates to our minimum altitude reference If the water column minus the altitude reference is bigger than our maximum depth then it is limited by that value. * Pre filter: Reference Rate saturation: the reference is saturated taking into account the maximum reference rate (0.2*Ts). Calculation of: \\[ \\ddot{\\tilde{z}}_d = \\omega _n^2*(\\tilde{z}_d - \\tilde{z}_{d|k-1}) - 2\\xi\\omega_n*\\ddot{\\tilde{z}}_{d|k-1} \\] \\[ \\dot{\\tilde{z}}_d = \\ddot{\\tilde{z}}_d + \\ddot{\\tilde{z}}_d t_s \\] \\[ \\tilde{z}_{d} = \\tilde{z}_{d|k-1} + \\dot{\\tilde{z}}_d t_s \\] CM is saturated between [-60,60].","title":"Z Controller"},{"location":"pid-inner-loops/innerloops/#roll-controller-not-being-used","text":"The roll controller is a PD responsible to return a differential mode for the vertical thrusters. If roll is bigger than 60 degrees then the controller will stop.","title":"Roll Controller - NOT BEING USED"},{"location":"pid-inner-loops/innerloops/#note","text":"The CM and DM are defined as a percentage of the maximum RPM: $$ CM = \\frac{Left\\ RPM (\\%) + right\\ RPM (\\%)}{2} $$ \\[ DM = \\frac{Left\\ RPM (\\%) - right\\ RPM (\\%)}{2} \\]","title":"Note:"},{"location":"pid-inner-loops/innerloops/#code-description","text":"","title":"Code description"},{"location":"pid-inner-loops/innerloops/#controller_interface","text":"Every controller inherits a ControllerInterface Class (controller_interface.c/h) composed by the following atributes: kp_ - proporcional gain ki_ - integral gain kd_ - integral gain ref_old_ - old reference qsi_old_ - saves the integration value and the following methods: int execute([arguments]); - executes the pid controll void reset(); - resets the filter In this interface, a Saturation struct was created to ease the operation of saturation. Basically, it is only necessary to create a Saturation object in the controller constructor defining the minimum and maximum value. To saturate a value we just need to call the function {clip} from the Saturation object.","title":"Controller_interface"},{"location":"pid-inner-loops/innerloops/#innerloops-main-loop","text":"In the innerloops::timerCallback we find the logic to apply these controllers; 1 - If a yaw reference exists, the heading controller will compute a DM for the horizontal thrusters. otherwise if a yaw rate ref exists the heading controller will be reset and the yaw rate controller will compute the DM. If none of the above cases happen it will check if we have an open loop value for DM otherwise it will reset the heading controller and the heading rate controller. 2 - If a speed reference exists, the speed controller will multiply it by the u_ref_gain (see heading controller) to compute a Common Mode for the longitudinal thrusters. Otherwise it will check if we have an open loop value for CM. If none of the above occur, the speed controller is reset. 3 - If in full power up, the vertical Common Mode will be equal to -60. Else it will check if we have a depth reference to compute de CM. After that it will check if we have a open loop CM and only then will it check if we have a altitude reference. If none of the above occur, the filter is reset. 4 - Roll is actuated in open loop. 5 - Saturating common mode: the horizontal common mode is saturated between [-(60*60);(60*60)].","title":"Innerloops main loop"},{"location":"remote-controller/","text":"","title":"Reference"},{"location":"safety-feature/","text":"safety_feature package safety_feature is a ROS package written in C++ that works as an communication watchdog. Rationale The package checks if the vehicle has some kind of communication channel, wifi or acoustic. In the absence of any communication link the thrusters are stopped. In more detail, we always check for wifi communication in surface vehicles. In the case of AUV, we need to have at least one surface vehicle that communicates via acoustic with the ones underwater. In the situation we lost wifi connection with the surface, this one is responsible to send an acoustic abort to the the underwater vehicles. NOTE: This package will need a major review later. The amount of if's else's is beyond normal. Package Content Code documentation source Using safety_feature Examples Requirements","title":"Reference"},{"location":"safety-feature/#safety_feature-package","text":"safety_feature is a ROS package written in C++ that works as an communication watchdog.","title":"safety_feature package"},{"location":"safety-feature/#rationale","text":"The package checks if the vehicle has some kind of communication channel, wifi or acoustic. In the absence of any communication link the thrusters are stopped. In more detail, we always check for wifi communication in surface vehicles. In the case of AUV, we need to have at least one surface vehicle that communicates via acoustic with the ones underwater. In the situation we lost wifi connection with the surface, this one is responsible to send an acoustic abort to the the underwater vehicles. NOTE: This package will need a major review later. The amount of if's else's is beyond normal.","title":"Rationale"},{"location":"safety-feature/#package-content","text":"","title":"Package Content"},{"location":"safety-feature/#code-documentation","text":"source","title":"Code documentation"},{"location":"safety-feature/#using-safety_feature","text":"Examples","title":"Using safety_feature"},{"location":"safety-feature/#requirements","text":"","title":"Requirements"},{"location":"safety-feature/configurations/medusaVxConfig/","text":"medusa_vx config - wifi_acoustic_safety Run Vehicle Side This package is launched with medusa stack ex: roslaunch medusa_bringup medusa_bringup.launch name:= mvector docks:=missions Please check if wifi_acoustic_safety is set to true in the vehicle configurations. For this, please check the following block in medusa_bringup/config/docks/mvector/process.yaml file: - name: 'addons' launch_on_startup: true delay_before_start: 0.0 cmd: 'roslaunch medusa_bringup addons.launch' args: - aggregator:= true - console_path_parser:= true - console_server:= true - **wifi_acoustic_safety:= true** - rosbridge_server:= false Launch file You have a main launch ( medusa_bringup.launch ) that calls a node ( medusa_bringup_node ) responsible to manage all the processes in a proecss.yaml file. The node while running is responsible to launch a subset of other launch files located at /medusa_bringup/launch/dev_launch . Among the exisitng ones, here the focus is in the addons.launch where wifi_acoustic_safety is present. Looking in some detail to the file we point out the key points: <arg name=\"name\" /> <arg name=\"mission\" default=\"example\" /> **<arg name=\"wifi_acoustic_safety\" default=\"false\" />** <!-- safety features --> <arg name=\"console_path_parser\" default=\"false\" /> <arg name=\"http_server\" default=\"false\" /> <arg name=\"aggregator\" default=\"false\" /> <arg name=\"rosbridge_server\" default=\"false\" /> <arg name=\"websocket_port\" default=\"9090\" /> <!-- arg to use in http--> By default all the nodes in the medusa_addons package are set to false and won't run if you don't change the corresponding boolean in the process.yaml like in the previous section. <group ns=\"addons\"> Every addon is part of the group addons , which means that almost all topics will be someting like /addons/node/some_topic , here /addons/wifi_acoustic_safety/some_topic . <!-- ############################ --> <!-- Acoustic Safety --> <!-- ############################ --> <group if=\"$(arg wifi_acoustic_safety)\"> <node pkg=\"safety_feature\" type=\"wifi_acoustic_safety\" name=\"wifi_acoustic_safety\" output=\"screen\"> <param name=\"name\" value=\"$(arg name)\" /> <param name=\"surface_vehicle\" value=\"dummy\"/> </node> </group>p As you can see the if guarantees that the node only starts if in the process.yaml , wifi_acoustic_safety is set to true. Configurations Configuration is divided between two files. The first one, medusa_bringup/config/mission/vehicle.yaml .Below, the section of wifi_acoustic_safety , for the docks mission and mvector vehicle: wifi_acoustic_safety: SAFETY_PORT: 10111 RATE: 1.0 The second file, /medusa_bringup/config/mission/vehicle/common.yaml , accommodates the delay times for wifi and acoustic. Below, the important parameter for of wifi_acoustic_safety : *file, ex: /medusa_bringup/config/docks/mvector/common.yaml safety_features: max_depth: 5.0 # [m] min_altitude: 1.0 # [m] min_altitude_ref: 1.5 # [m] **wifi_timeout: 10.0 # [s]** **acoustic_timeout: 15.0 # [s]** Client Side In a console pc please run: rosrun safety_feature SafetyFeatureCLT ip_vehicle or catkin_ws/src/medusa_vx/medusa_addons/safety_feature/src/Client/SafetyFeatureCLT ip_vehicle ex: mvector rosrun safety_feature SafetyFeatureCLT 192.168.1.33 This will guarantee that the safety is disable(0), as soon you losse connection with vehicle it will enable safety(1) and thrusters will stop.","title":"medusa_vx config - wifi_acoustic_safety"},{"location":"safety-feature/configurations/medusaVxConfig/#medusa_vx-config-wifi_acoustic_safety","text":"","title":"medusa_vx config - wifi_acoustic_safety"},{"location":"safety-feature/configurations/medusaVxConfig/#run","text":"","title":"Run"},{"location":"safety-feature/configurations/medusaVxConfig/#vehicle-side","text":"This package is launched with medusa stack ex: roslaunch medusa_bringup medusa_bringup.launch name:= mvector docks:=missions Please check if wifi_acoustic_safety is set to true in the vehicle configurations. For this, please check the following block in medusa_bringup/config/docks/mvector/process.yaml file: - name: 'addons' launch_on_startup: true delay_before_start: 0.0 cmd: 'roslaunch medusa_bringup addons.launch' args: - aggregator:= true - console_path_parser:= true - console_server:= true - **wifi_acoustic_safety:= true** - rosbridge_server:= false","title":"Vehicle Side"},{"location":"safety-feature/configurations/medusaVxConfig/#launch-file","text":"You have a main launch ( medusa_bringup.launch ) that calls a node ( medusa_bringup_node ) responsible to manage all the processes in a proecss.yaml file. The node while running is responsible to launch a subset of other launch files located at /medusa_bringup/launch/dev_launch . Among the exisitng ones, here the focus is in the addons.launch where wifi_acoustic_safety is present. Looking in some detail to the file we point out the key points: <arg name=\"name\" /> <arg name=\"mission\" default=\"example\" /> **<arg name=\"wifi_acoustic_safety\" default=\"false\" />** <!-- safety features --> <arg name=\"console_path_parser\" default=\"false\" /> <arg name=\"http_server\" default=\"false\" /> <arg name=\"aggregator\" default=\"false\" /> <arg name=\"rosbridge_server\" default=\"false\" /> <arg name=\"websocket_port\" default=\"9090\" /> <!-- arg to use in http--> By default all the nodes in the medusa_addons package are set to false and won't run if you don't change the corresponding boolean in the process.yaml like in the previous section. <group ns=\"addons\"> Every addon is part of the group addons , which means that almost all topics will be someting like /addons/node/some_topic , here /addons/wifi_acoustic_safety/some_topic . <!-- ############################ --> <!-- Acoustic Safety --> <!-- ############################ --> <group if=\"$(arg wifi_acoustic_safety)\"> <node pkg=\"safety_feature\" type=\"wifi_acoustic_safety\" name=\"wifi_acoustic_safety\" output=\"screen\"> <param name=\"name\" value=\"$(arg name)\" /> <param name=\"surface_vehicle\" value=\"dummy\"/> </node> </group>p As you can see the if guarantees that the node only starts if in the process.yaml , wifi_acoustic_safety is set to true.","title":"Launch file"},{"location":"safety-feature/configurations/medusaVxConfig/#configurations","text":"Configuration is divided between two files. The first one, medusa_bringup/config/mission/vehicle.yaml .Below, the section of wifi_acoustic_safety , for the docks mission and mvector vehicle: wifi_acoustic_safety: SAFETY_PORT: 10111 RATE: 1.0 The second file, /medusa_bringup/config/mission/vehicle/common.yaml , accommodates the delay times for wifi and acoustic. Below, the important parameter for of wifi_acoustic_safety : *file, ex: /medusa_bringup/config/docks/mvector/common.yaml safety_features: max_depth: 5.0 # [m] min_altitude: 1.0 # [m] min_altitude_ref: 1.5 # [m] **wifi_timeout: 10.0 # [s]** **acoustic_timeout: 15.0 # [s]**","title":"Configurations"},{"location":"safety-feature/configurations/medusaVxConfig/#client-side","text":"In a console pc please run: rosrun safety_feature SafetyFeatureCLT ip_vehicle or catkin_ws/src/medusa_vx/medusa_addons/safety_feature/src/Client/SafetyFeatureCLT ip_vehicle ex: mvector rosrun safety_feature SafetyFeatureCLT 192.168.1.33 This will guarantee that the safety is disable(0), as soon you losse connection with vehicle it will enable safety(1) and thrusters will stop.","title":"Client Side"},{"location":"sensor-fusion-kalman-filter/developer_notes/","text":"Developer Notes Project Directory . \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 config \u2502 \u251c\u2500\u2500 map.yaml \u2502 \u2514\u2500\u2500 odom.yaml \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 figs \u2502 \u251c\u2500\u2500 readme.md \u2502 \u251c\u2500\u2500 theory.md \u2502 \u2514\u2500\u2500 developernotes.md \u251c\u2500\u2500 include \u2502 \u251c\u2500\u2500 algorithms \u2502 \u2502 \u251c\u2500\u2500 HorizontalFilter.h \u2502 \u2502 \u251c\u2500\u2500 RotationalFilter.h \u2502 \u2502 \u2514\u2500\u2500 VerticalFilter.h \u2502 \u2514\u2500\u2500 ros \u2502 \u2514\u2500\u2500 FiltersNode.h \u251c\u2500\u2500 launch \u2502 \u2514\u2500\u2500 sensor_fusion.launch \u251c\u2500\u2500 package.xml \u251c\u2500\u2500 scripts \u2502 \u2514\u2500\u2500 filtersScript \u251c\u2500\u2500 src \u2502 \u251c\u2500\u2500 algorithms \u2502 \u2502 \u251c\u2500\u2500 HorizontalFilter.cpp \u2502 \u2502 \u251c\u2500\u2500 RotationalFilter.cpp \u2502 \u2502 \u2514\u2500\u2500 VerticalFilter.cpp \u2502 \u2514\u2500\u2500 ros \u2502 \u2514\u2500\u2500 FiltersNode.cpp \u2514\u2500\u2500 test \u2514\u2500\u2500 filters_test.cpp Pkg sensor_fusion follows the code methodology adapated for the medusa_vx stack and hence seperates the code into algorithm and node class. The \"algorithm\" section implements the kalman filter based sensor fusion and the \"node\" section implements all things required for integration with ROS. config : contains sample config files for and filters docs : contains documentation for the pkg include : contains header files class and node class launch : contains sample launch files src : contains the main code for algorithm and node class Pkg contains no scripts or tests yet. Algorithm Class This class implements a generic kalman based sensor fusion system which fuses input from an arbitary number of sources to estimate the state of a vehicle. To make things simpler, the kalman filter is divided into three seperate filters which estimate the horizontal, vertical and rotational state respectively. HorizontalFilter.h & HorizontalFilter.cpp Time-delayed Kalman-Filter to estimate position (x, y), velocity (vx, vy), acceleration (ax, ay) and currents (cx, cy) Dynamic model: Constant Acceleration measCallback() : Receives measurements in the horizontal plane addMeasurement() : Adds valid measurements to a measurement list forwardPropagation() : Estimates and updates the state vector from the point of time when the measurement was received. predict() : Predict Stage of the Kalman Filter update() : Update Stage of the Kalman Filter configure() : public method Configure the filter using loaded parameters getEstimate() : public method Returns the latest state estimate VerticalFilter.h & VerticalFilter.cpp Kalman-Filter to estimate position (z), Altitude, velocity (vz) and Bouyancy (B) Dynamic model: ? RotationalFilter.h & RotationalFilter.cpp Kalman-filter to estimate rotation (r, p, h) and rotation rate (vr, vp, vh) Measurements can be treated as inputs which bypasses the whole filter Estimates from individual filters are fused inside the node class to produce the net result. ROS Class This class implements ROS functionalities that are Parameters : Used to configure the three filters Publishers : state_pub : Publishes state estimate Subscribers : measCallback(medusa_msgs::Measurements) : Multiple topics use a single generic callback which processes, transforms and distributes the input to the three algorithm classes. Timers : stateTimerCallback() : Gets the latest state estimate from all three algorithm class listTimerCallback() : Clears the previous measurements from the list in HorizontalFilter","title":"Developer Notes"},{"location":"sensor-fusion-kalman-filter/developer_notes/#developer-notes","text":"","title":"Developer Notes"},{"location":"sensor-fusion-kalman-filter/developer_notes/#project-directory","text":". \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 config \u2502 \u251c\u2500\u2500 map.yaml \u2502 \u2514\u2500\u2500 odom.yaml \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 figs \u2502 \u251c\u2500\u2500 readme.md \u2502 \u251c\u2500\u2500 theory.md \u2502 \u2514\u2500\u2500 developernotes.md \u251c\u2500\u2500 include \u2502 \u251c\u2500\u2500 algorithms \u2502 \u2502 \u251c\u2500\u2500 HorizontalFilter.h \u2502 \u2502 \u251c\u2500\u2500 RotationalFilter.h \u2502 \u2502 \u2514\u2500\u2500 VerticalFilter.h \u2502 \u2514\u2500\u2500 ros \u2502 \u2514\u2500\u2500 FiltersNode.h \u251c\u2500\u2500 launch \u2502 \u2514\u2500\u2500 sensor_fusion.launch \u251c\u2500\u2500 package.xml \u251c\u2500\u2500 scripts \u2502 \u2514\u2500\u2500 filtersScript \u251c\u2500\u2500 src \u2502 \u251c\u2500\u2500 algorithms \u2502 \u2502 \u251c\u2500\u2500 HorizontalFilter.cpp \u2502 \u2502 \u251c\u2500\u2500 RotationalFilter.cpp \u2502 \u2502 \u2514\u2500\u2500 VerticalFilter.cpp \u2502 \u2514\u2500\u2500 ros \u2502 \u2514\u2500\u2500 FiltersNode.cpp \u2514\u2500\u2500 test \u2514\u2500\u2500 filters_test.cpp Pkg sensor_fusion follows the code methodology adapated for the medusa_vx stack and hence seperates the code into algorithm and node class. The \"algorithm\" section implements the kalman filter based sensor fusion and the \"node\" section implements all things required for integration with ROS. config : contains sample config files for and filters docs : contains documentation for the pkg include : contains header files class and node class launch : contains sample launch files src : contains the main code for algorithm and node class Pkg contains no scripts or tests yet.","title":"Project Directory"},{"location":"sensor-fusion-kalman-filter/developer_notes/#algorithm-class","text":"This class implements a generic kalman based sensor fusion system which fuses input from an arbitary number of sources to estimate the state of a vehicle. To make things simpler, the kalman filter is divided into three seperate filters which estimate the horizontal, vertical and rotational state respectively. HorizontalFilter.h & HorizontalFilter.cpp Time-delayed Kalman-Filter to estimate position (x, y), velocity (vx, vy), acceleration (ax, ay) and currents (cx, cy) Dynamic model: Constant Acceleration measCallback() : Receives measurements in the horizontal plane addMeasurement() : Adds valid measurements to a measurement list forwardPropagation() : Estimates and updates the state vector from the point of time when the measurement was received. predict() : Predict Stage of the Kalman Filter update() : Update Stage of the Kalman Filter configure() : public method Configure the filter using loaded parameters getEstimate() : public method Returns the latest state estimate VerticalFilter.h & VerticalFilter.cpp Kalman-Filter to estimate position (z), Altitude, velocity (vz) and Bouyancy (B) Dynamic model: ? RotationalFilter.h & RotationalFilter.cpp Kalman-filter to estimate rotation (r, p, h) and rotation rate (vr, vp, vh) Measurements can be treated as inputs which bypasses the whole filter Estimates from individual filters are fused inside the node class to produce the net result.","title":"Algorithm Class"},{"location":"sensor-fusion-kalman-filter/developer_notes/#ros-class","text":"This class implements ROS functionalities that are Parameters : Used to configure the three filters Publishers : state_pub : Publishes state estimate Subscribers : measCallback(medusa_msgs::Measurements) : Multiple topics use a single generic callback which processes, transforms and distributes the input to the three algorithm classes. Timers : stateTimerCallback() : Gets the latest state estimate from all three algorithm class listTimerCallback() : Clears the previous measurements from the list in HorizontalFilter","title":"ROS Class"},{"location":"sensor-fusion-kalman-filter/theory/","text":"Theory Kalman filter A Kalman filter, also known as Linear Quadratic Estimator (LQE) uses a series of noisy measurements to produce estimates of unknown state variables. A Kalman filter provides an optimum solution to many tracking and data prediction tasks and finds excellent use in control, navigation and guidance. The algorithm works in a two-step process. In the \"predict\" step, the Kalman filter looks one-step forward in time to predict the estimates of the current state vector and state covariance using an inner dynamic model. In the second step, known as \"update\", a \"kalman gain matrix\" is calculated using the state covariances and measurement covariance. This matrix is then used to update the state of the vehicle as shown below. One key advantage of Kalman filter is that it can run efficiently in real-time. For a more comprehensive literature on the subject, the reader is recommended to consult [1]. Consult [2] for an excellent introductory article on KFs. Predict Let xkxk be the state vector and PkPk be the state covariance. The state equation is written as \\[ \\hat{x}_{k|k-1} = A_k \\hat{x}_{k-1|k-1} + B_k u_k + w_k \\\\ \\\\ P_{k|k-1} = A_k P_{k-1|k-1} A_k^T + Q_k \\] where, \\(A_k\\) = State Transition Matrix \\(B_k\\) = Control-Input Model \\(u_k\\) = Input Vector \\(w_k\\) = Zero-mean Gaussian Process Noise \\(Q_k\\) = Covariance of the Process Noise Update Let \\(\\tilde{y_k}\\) be the innovation factor vector, i.e. the difference between the predicted state output and the measured state output. \\[ \\tilde{y} = z_k - C_k\\hat{x}_{k|k-1} \\\\ \\\\ S_k = C_k P_{k|k-1} C_k^T + R_k \\\\ \\\\ K_k = P_{k|k-1} C_k^T S_k^{-1} \\\\ \\\\ \\hat{x}_{k|k} = \\hat{x}_{k|k-1} + K_k \\tilde{y}_k \\\\ \\\\ P_{k|k-1} = (1 - k_k C_k)P_{k|k-1} \\] where, \\(z_k\\) = Measurement Vector \\(C_k\\) = Observation Matrix \\(R_k\\) = Measurement Covariance \\(S_k\\) = Innovation Covariance \\(K_l\\) = Kalman Gain Matrix The variables \\(z_k\\) , \\(C_k\\) , \\(R_k\\) are derived from the incoming measurement. Filter Model Horizontal filter \\[ x = \\begin{bmatrix} x \\\\ y \\\\ \\dot{x} \\\\ \\dot{y} \\\\ \\ddot{x} \\\\ \\ddot{y} \\\\ \\dot{x_c} \\\\ \\dot{x_y} \\end{bmatrix}, \\] \\[ A_k = \\begin{bmatrix} 1 & 0 & \\delta t & 0 & 0.5 \\delta t^2 & 0 & 0 & 0\\\\ 0 & 1 & 0 & \\delta t & 0 & 0.5 \\delta t^2 & 0 & 0\\\\ 0 & 0 & 1 & 0 & \\delta t & 0 & 0 & 0\\\\ 0 & 0 & 0 & 1 & 0 & \\delta t & 0 & 0\\\\ 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\\\ 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\\\ 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\\\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\\\ \\end{bmatrix}, \\] \\[ B_k = \\begin{bmatrix} 0 \\end{bmatrix}, w_k = \\begin{bmatrix} 0 \\end{bmatrix} \\] where \\(\\delta_t\\) = predict_period Vertical Filter \\[ x = \\begin{bmatrix} z \\\\ \\dot{z} \\\\ A \\\\ B \\end{bmatrix}, \\] \\[ A_k = \\begin{bmatrix} 1 & \\delta t & 0 & 0 \\\\ 0 & 1 + \\alpha\\delta{t} & 0 & \\delta{t} \\\\ 0 & -\\delta{t} & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\\\ \\end{bmatrix}, \\] \\[ B_k = \\begin{bmatrix} 0 \\end{bmatrix}, \\] \\[ w_k = \\begin{bmatrix} 0 \\end{bmatrix} \\] where, \\(\\delta_t\\) = predict period \\(A\\) = altitude \\(B\\) = buoyancy Rotation Filter \\[ x = \\begin{bmatrix} \\psi \\\\ \\theta \\\\ \\gamma \\\\ \\dot{\\psi} \\\\ \\dot{\\theta} \\\\ \\dot{\\gamma} \\end{bmatrix}, \\] \\[ A_k = \\begin{bmatrix} 1 & 0 & 0 & \\delta{t} & 0 & 0 \\\\ 0 & 1 & 0 & 0 & \\delta{t} & 0 \\\\ 0 & 0 & 1 & 0 & 0 & \\delta{t} \\\\ 0 & 0 & 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 1 \\\\ \\end{bmatrix}, \\] \\[ B_k = \\begin{bmatrix} 0 \\end{bmatrix}, \\] \\[ w_k = \\begin{bmatrix} 0 \\end{bmatrix} \\] where \\(\\delta_t\\) = predict_period Outlier Detection \\[ e_n = \\tilde{y}_k^T S_k^{-1} \\tilde{y}_k \\] \\[ e_n < th_{outlier} \\] where \\(e_n\\) = normalized error \\(th_{outlier}\\) = threshold outlier rejection parameter References Rhudy, Matthew & Salguero, Roger & Holappa, Keaton. (2017). A Kalman Filtering Tutorial for Undergraduate Students. International Journal of Computer Science & Engineering Survey. 08. 01-18. 10.5121/ijcses.2017.8101. https://towardsdatascience.com/kalman-filter-an-algorithm-for-making-sense-from-the-insights-of-various-sensors-fused-together-ddf67597f35e","title":"Theory"},{"location":"sensor-fusion-kalman-filter/theory/#theory","text":"","title":"Theory"},{"location":"sensor-fusion-kalman-filter/theory/#kalman-filter","text":"A Kalman filter, also known as Linear Quadratic Estimator (LQE) uses a series of noisy measurements to produce estimates of unknown state variables. A Kalman filter provides an optimum solution to many tracking and data prediction tasks and finds excellent use in control, navigation and guidance. The algorithm works in a two-step process. In the \"predict\" step, the Kalman filter looks one-step forward in time to predict the estimates of the current state vector and state covariance using an inner dynamic model. In the second step, known as \"update\", a \"kalman gain matrix\" is calculated using the state covariances and measurement covariance. This matrix is then used to update the state of the vehicle as shown below. One key advantage of Kalman filter is that it can run efficiently in real-time. For a more comprehensive literature on the subject, the reader is recommended to consult [1]. Consult [2] for an excellent introductory article on KFs. Predict Let xkxk be the state vector and PkPk be the state covariance. The state equation is written as \\[ \\hat{x}_{k|k-1} = A_k \\hat{x}_{k-1|k-1} + B_k u_k + w_k \\\\ \\\\ P_{k|k-1} = A_k P_{k-1|k-1} A_k^T + Q_k \\] where, \\(A_k\\) = State Transition Matrix \\(B_k\\) = Control-Input Model \\(u_k\\) = Input Vector \\(w_k\\) = Zero-mean Gaussian Process Noise \\(Q_k\\) = Covariance of the Process Noise Update Let \\(\\tilde{y_k}\\) be the innovation factor vector, i.e. the difference between the predicted state output and the measured state output. \\[ \\tilde{y} = z_k - C_k\\hat{x}_{k|k-1} \\\\ \\\\ S_k = C_k P_{k|k-1} C_k^T + R_k \\\\ \\\\ K_k = P_{k|k-1} C_k^T S_k^{-1} \\\\ \\\\ \\hat{x}_{k|k} = \\hat{x}_{k|k-1} + K_k \\tilde{y}_k \\\\ \\\\ P_{k|k-1} = (1 - k_k C_k)P_{k|k-1} \\] where, \\(z_k\\) = Measurement Vector \\(C_k\\) = Observation Matrix \\(R_k\\) = Measurement Covariance \\(S_k\\) = Innovation Covariance \\(K_l\\) = Kalman Gain Matrix The variables \\(z_k\\) , \\(C_k\\) , \\(R_k\\) are derived from the incoming measurement. Filter Model Horizontal filter \\[ x = \\begin{bmatrix} x \\\\ y \\\\ \\dot{x} \\\\ \\dot{y} \\\\ \\ddot{x} \\\\ \\ddot{y} \\\\ \\dot{x_c} \\\\ \\dot{x_y} \\end{bmatrix}, \\] \\[ A_k = \\begin{bmatrix} 1 & 0 & \\delta t & 0 & 0.5 \\delta t^2 & 0 & 0 & 0\\\\ 0 & 1 & 0 & \\delta t & 0 & 0.5 \\delta t^2 & 0 & 0\\\\ 0 & 0 & 1 & 0 & \\delta t & 0 & 0 & 0\\\\ 0 & 0 & 0 & 1 & 0 & \\delta t & 0 & 0\\\\ 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\\\ 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\\\ 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\\\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\\\ \\end{bmatrix}, \\] \\[ B_k = \\begin{bmatrix} 0 \\end{bmatrix}, w_k = \\begin{bmatrix} 0 \\end{bmatrix} \\] where \\(\\delta_t\\) = predict_period Vertical Filter \\[ x = \\begin{bmatrix} z \\\\ \\dot{z} \\\\ A \\\\ B \\end{bmatrix}, \\] \\[ A_k = \\begin{bmatrix} 1 & \\delta t & 0 & 0 \\\\ 0 & 1 + \\alpha\\delta{t} & 0 & \\delta{t} \\\\ 0 & -\\delta{t} & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\\\ \\end{bmatrix}, \\] \\[ B_k = \\begin{bmatrix} 0 \\end{bmatrix}, \\] \\[ w_k = \\begin{bmatrix} 0 \\end{bmatrix} \\] where, \\(\\delta_t\\) = predict period \\(A\\) = altitude \\(B\\) = buoyancy Rotation Filter \\[ x = \\begin{bmatrix} \\psi \\\\ \\theta \\\\ \\gamma \\\\ \\dot{\\psi} \\\\ \\dot{\\theta} \\\\ \\dot{\\gamma} \\end{bmatrix}, \\] \\[ A_k = \\begin{bmatrix} 1 & 0 & 0 & \\delta{t} & 0 & 0 \\\\ 0 & 1 & 0 & 0 & \\delta{t} & 0 \\\\ 0 & 0 & 1 & 0 & 0 & \\delta{t} \\\\ 0 & 0 & 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 1 \\\\ \\end{bmatrix}, \\] \\[ B_k = \\begin{bmatrix} 0 \\end{bmatrix}, \\] \\[ w_k = \\begin{bmatrix} 0 \\end{bmatrix} \\] where \\(\\delta_t\\) = predict_period Outlier Detection \\[ e_n = \\tilde{y}_k^T S_k^{-1} \\tilde{y}_k \\] \\[ e_n < th_{outlier} \\] where \\(e_n\\) = normalized error \\(th_{outlier}\\) = threshold outlier rejection parameter","title":"Kalman filter"},{"location":"sensor-fusion-kalman-filter/theory/#references","text":"Rhudy, Matthew & Salguero, Roger & Holappa, Keaton. (2017). A Kalman Filtering Tutorial for Undergraduate Students. International Journal of Computer Science & Engineering Survey. 08. 01-18. 10.5121/ijcses.2017.8101. https://towardsdatascience.com/kalman-filter-an-algorithm-for-making-sense-from-the-insights-of-various-sensors-fused-together-ddf67597f35e","title":"References"},{"location":"sensor-fusion-kalman-filter/user_guide/","text":"User-Guide Getting Started Installation Pkg sensor_fusion comes as part of the medusa_vx stack. Configuration This section explains how to write the node configuration file. A sample is given below ROS Node Parameters node_frequency: 10 # ROS node output rate topics: subscribers: [ # std::string containing topics < reset, position, velocity, orientation> \"reset\", \"/measurement/position\", \"/measurement/velocity\", \"/measurement/orientation\" ] publishers: [ # std::string containing topics <state, debug> \"state\", \"debug\" ] Class Node Parameters tf: # TF publishers broadcast: true # flag to publish node TF frames frames: [ # std::string containing frame <base_link, odom, map, world> \"base_link\", \"odom\", \"map\", \"map\" ] kalman_filter: config: [0.1, 5.0, 16] # predict period, save measurement interval, outlier rejection threshold reject_counter: [8, 5, 12, 3, 3, 3] # outlier reject counters for position, velocity, angle, angle rate, acceleration, altitude process_covariance: [0.03, 0.015, 0.85, 1.2, 0.9, 0.12] # process noise for position, velocity, angles, angle rate, acceleration, altitude vertical_drag: [-0.1287, -0.4097, -0.013] # alpha, beta, bouyancy bypass_ahrs: false # Set True to treat AHRS as input initialize: # Define initialization condition trigger: false # Set true to initialize at start meas: # If trigger is set to true, define initial position and state. If it is set to false, define initial state except position frame_id: \"gnss\" # If trigger is set to false, define measurement frame used for initialization value: [0, 0, 0, # Position - x, y, z 0, 0, 0, # Velocity - vx, vy, vz 0, 0, 0, # Orientation - r, p, h 0, 0, 0, # Orientation Rate - dr, dp, vh 0, 0, 0] # Acceleration & Altitude - ax, ay, A noise: [1000, 1000, 1000, # If trigger is set to true, define initial position and state covariance. 0.1 , 0.1 , 0.1 , # If trigger is set to false, define initial state covariance except position 1 , 1 , 1 , # Array format is same as above 0.1 , 0.1 , 0.1 , 0.01, 0.01, 1000] sensors: # Define sensors as input here. Any sensor frame ids not defined here will be ignored by the filter - frame_id: \"gnss\" # Example Sensor 1: Sat Nav Input config: [true, true, false, # frame_id takes in the frame_id associated with the input measurement false, false, false, # Config is a 15-state bool array that defines the input measurement false, false, false, # The number of inputs should be equal to the no of \"true\" flags in the config array false, false, false, # For sensor providing position (x, y) input, config has two flags triggered as shown false, false, false] # noise: [0.5, 0.5, 0.0, # Noise if an optional 15-state double array that overrides incoming measurement noise 0.0, 0.0, 0.0, # Filter will always take 0.5 as measurement noise during update stage of the kalman filter here 0.0, 0.0, 0.0, # 0.0, 0.0, 0.0, 0.0, 0.0, 0.0] - frame_id: \"dvl_bt\" # Example Sensor 2: DVL Bottom Track config: [false, false, false, # Sensor updates inertial position of the vehicle true, true, false, # For sensor providing velocity (vx, vy) input, config has two flags triggered as shown false, false, false, # Filter takes in noise measurement from the input, ignore the input if there is none false, false, false, false, false, false] - frame_id: \"depth\" # Example Sensor 3: Depth Sensor config: [false, false, true, # Sensor updates depth of the vehicle false, false, false, # For sensor providing Depth (z) input, config has one flag triggered as shown false, false, false, false, false, false, false, false, false] noise: [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0] - frame_id: \"ahrs\" # Example Sensor 4: AHRS Sensor config: [false, false, false, # Sensor updates inertial position of the vehicle false, false, false, # For sensor providing rotation (r, p, h, vr, vp, vh) input, config has 6 flags triggered as shown true, true, true, true, true, true, false, false, false] noise: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0] Config Breakdown ROS Node Parameters** Name Type Function node_frequency int Filter output frequency topics/subscribers string[4] Input topics for reset, position, velocity and orientation topics/publishers string[2] Output topics for state estimate and debug info Remarks - position, velocity, orientation topics subscribe to input of type medusa_msgs::Measurement - state topic publishes state estimate in auv_msgs::NavigationStatus - topic debug publishes debug information in std::string Class Parameters TF Name Type Function tf/broadcast bool Flag to trigger state broadcast to ros::tfs tf/frames string[4] Frame names from base_link, odom, map and world frame Remarks - If dead reckoning is not needed, set odom frame as \"null\" - If tf/broadcast flag is set to true while odom frame is not set, filter will publish the tf tree as: base_link -> map -> world - If tf/broadcast flag is set to true while odom frame is set, filter will publish the tf tree as: base_link -> odom -> map -> world Kalman Parameters Name Type Function kalman_filter/config double[3] Set parameters for predict period, save measurement interval, outlier rejection threshold kalman_filter/reject_counter int[6] Set outlier reject counters for position, velocity, angle, angle rate, acceleration and altitude kalman_filter/process_covariance double[6] Set process noise for position, velocity, angles, angle rate, acceleration and altitude kalman_filter/vertical_drag double[3] Set alpha, beta, bouyancy for vertical filter kalman_filter/bypass_ahrs bool Trigger to treat AHRS as an Input Remarks - predict period defines the frequency of kalman filter predicts stage - save measurement interval sets the interval over which measurements are rejected by the filter. If no input is received for more than twice this interval, filter resets. - outlier rejection threshold sets the threshold for outlier measurement rejection. - reject counter defines the no of measurements to reject before accepting outliers as the input Initialization Parameters `` Defines the initial covariance of the state vector Defines the drag parameters used in the state model of vertical filter. Flag to treat inputs to the rotation filter as input. If set to true, any input sent to the node bypasses the filter and is output directly. Initialization Parameters Name Type Function kalman_filter/initialize/. ./trigger bool Flag to trigger initialization at startup ./meas/frame_id string Sensor frame to initialize filter with ./meas/value double[15] Defines the initial state of the vessel ./meas/noise bool[15] Defines the initial state covariance Remarks - If trigger is set to false, filter will initialize horizontal position with a measurement with frame ./meas/frame_id . The rest is set by the ./meas Sensor Input Input sensors to the filter are described as a list of type <XmlRpc::XmlRpcValue> . Any number of sensors may be defined following the format described below. Name Type Function kalman_filter/sensors/. - frame_id, config, noise frame_id string Defines the name of the sensor frame. config bool[15] Defines the observation matrix of the kalman filter noise (optional) double[15] Defines the noise associated with the measurement. Remarks - Each sensor to the filter must have a unique frame_id and a static TF to base_link associated with it. - Incoming measurement must always contain the same no of inputs, as described in the observation matrix. - If the noise in input measurement is zero or invalid, filter will ignore the measurement. Launching the Nodes An example launch file is provided below where two sensor_fusion/sensor_fusion nodes are being launched, named filter and filter_dr. <?xml version=\"1.0\"?> <launch> <env name=\"ROSCONSOLE_FORMAT\" value=\"[${severity}] [${time}]: ${node}: ${message}\"/> <!-- ######################## --> <!-- Parameters and Arguments --> <!-- ######################## --> <arg name=\"map\" default=\"map\" /> <!-- name of config file for node ~filter --> <arg name=\"odom\" default=\"odom\" /> <!-- name of config file for node ~filter_dr --> <group ns=\"nav\"> <!-- ############################ --> <!-- filters_dr: Estimates the position of the vehicle in <odom> frame. --> <!-- ############################ --> <node pkg=\"sensor_fusion\" type=\"sensor_fusion\" name=\"filter_dr\" respawn=\"false\"> <rosparam command=\"load\" file=\"$(find medusa_bringup)/config/$(arg odom).yaml\" /> </node> <!-- ############################ --> <!-- filters: Estimates the position of the vehicle in <map> frame. --> <!-- ############################ --> <node pkg=\"sensor_fusion\" type=\"sensor_fusion\" name=\"filter\" respawn=\"false\" output=\"screen\"> <rosparam command=\"load\" file=\"$(find medusa_bringup)/config/$(arg map).yaml\" /> </node> </group> </launch>","title":"Overview"},{"location":"sensor-fusion-kalman-filter/user_guide/#user-guide","text":"","title":"User-Guide"},{"location":"sensor-fusion-kalman-filter/user_guide/#getting-started","text":"","title":"Getting Started"},{"location":"sensor-fusion-kalman-filter/user_guide/#installation","text":"Pkg sensor_fusion comes as part of the medusa_vx stack.","title":"Installation"},{"location":"sensor-fusion-kalman-filter/user_guide/#configuration","text":"This section explains how to write the node configuration file. A sample is given below","title":"Configuration"},{"location":"sensor-fusion-kalman-filter/user_guide/#ros-node-parameters","text":"node_frequency: 10 # ROS node output rate topics: subscribers: [ # std::string containing topics < reset, position, velocity, orientation> \"reset\", \"/measurement/position\", \"/measurement/velocity\", \"/measurement/orientation\" ] publishers: [ # std::string containing topics <state, debug> \"state\", \"debug\" ]","title":"ROS Node Parameters"},{"location":"sensor-fusion-kalman-filter/user_guide/#class-node-parameters","text":"tf: # TF publishers broadcast: true # flag to publish node TF frames frames: [ # std::string containing frame <base_link, odom, map, world> \"base_link\", \"odom\", \"map\", \"map\" ] kalman_filter: config: [0.1, 5.0, 16] # predict period, save measurement interval, outlier rejection threshold reject_counter: [8, 5, 12, 3, 3, 3] # outlier reject counters for position, velocity, angle, angle rate, acceleration, altitude process_covariance: [0.03, 0.015, 0.85, 1.2, 0.9, 0.12] # process noise for position, velocity, angles, angle rate, acceleration, altitude vertical_drag: [-0.1287, -0.4097, -0.013] # alpha, beta, bouyancy bypass_ahrs: false # Set True to treat AHRS as input initialize: # Define initialization condition trigger: false # Set true to initialize at start meas: # If trigger is set to true, define initial position and state. If it is set to false, define initial state except position frame_id: \"gnss\" # If trigger is set to false, define measurement frame used for initialization value: [0, 0, 0, # Position - x, y, z 0, 0, 0, # Velocity - vx, vy, vz 0, 0, 0, # Orientation - r, p, h 0, 0, 0, # Orientation Rate - dr, dp, vh 0, 0, 0] # Acceleration & Altitude - ax, ay, A noise: [1000, 1000, 1000, # If trigger is set to true, define initial position and state covariance. 0.1 , 0.1 , 0.1 , # If trigger is set to false, define initial state covariance except position 1 , 1 , 1 , # Array format is same as above 0.1 , 0.1 , 0.1 , 0.01, 0.01, 1000] sensors: # Define sensors as input here. Any sensor frame ids not defined here will be ignored by the filter - frame_id: \"gnss\" # Example Sensor 1: Sat Nav Input config: [true, true, false, # frame_id takes in the frame_id associated with the input measurement false, false, false, # Config is a 15-state bool array that defines the input measurement false, false, false, # The number of inputs should be equal to the no of \"true\" flags in the config array false, false, false, # For sensor providing position (x, y) input, config has two flags triggered as shown false, false, false] # noise: [0.5, 0.5, 0.0, # Noise if an optional 15-state double array that overrides incoming measurement noise 0.0, 0.0, 0.0, # Filter will always take 0.5 as measurement noise during update stage of the kalman filter here 0.0, 0.0, 0.0, # 0.0, 0.0, 0.0, 0.0, 0.0, 0.0] - frame_id: \"dvl_bt\" # Example Sensor 2: DVL Bottom Track config: [false, false, false, # Sensor updates inertial position of the vehicle true, true, false, # For sensor providing velocity (vx, vy) input, config has two flags triggered as shown false, false, false, # Filter takes in noise measurement from the input, ignore the input if there is none false, false, false, false, false, false] - frame_id: \"depth\" # Example Sensor 3: Depth Sensor config: [false, false, true, # Sensor updates depth of the vehicle false, false, false, # For sensor providing Depth (z) input, config has one flag triggered as shown false, false, false, false, false, false, false, false, false] noise: [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0] - frame_id: \"ahrs\" # Example Sensor 4: AHRS Sensor config: [false, false, false, # Sensor updates inertial position of the vehicle false, false, false, # For sensor providing rotation (r, p, h, vr, vp, vh) input, config has 6 flags triggered as shown true, true, true, true, true, true, false, false, false] noise: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0]","title":"Class Node Parameters"},{"location":"sensor-fusion-kalman-filter/user_guide/#config-breakdown","text":"","title":"Config Breakdown"},{"location":"sensor-fusion-kalman-filter/user_guide/#ros-node-parameters_1","text":"Name Type Function node_frequency int Filter output frequency topics/subscribers string[4] Input topics for reset, position, velocity and orientation topics/publishers string[2] Output topics for state estimate and debug info Remarks - position, velocity, orientation topics subscribe to input of type medusa_msgs::Measurement - state topic publishes state estimate in auv_msgs::NavigationStatus - topic debug publishes debug information in std::string","title":"ROS Node Parameters**"},{"location":"sensor-fusion-kalman-filter/user_guide/#class-parameters","text":"TF Name Type Function tf/broadcast bool Flag to trigger state broadcast to ros::tfs tf/frames string[4] Frame names from base_link, odom, map and world frame Remarks - If dead reckoning is not needed, set odom frame as \"null\" - If tf/broadcast flag is set to true while odom frame is not set, filter will publish the tf tree as: base_link -> map -> world - If tf/broadcast flag is set to true while odom frame is set, filter will publish the tf tree as: base_link -> odom -> map -> world Kalman Parameters Name Type Function kalman_filter/config double[3] Set parameters for predict period, save measurement interval, outlier rejection threshold kalman_filter/reject_counter int[6] Set outlier reject counters for position, velocity, angle, angle rate, acceleration and altitude kalman_filter/process_covariance double[6] Set process noise for position, velocity, angles, angle rate, acceleration and altitude kalman_filter/vertical_drag double[3] Set alpha, beta, bouyancy for vertical filter kalman_filter/bypass_ahrs bool Trigger to treat AHRS as an Input Remarks - predict period defines the frequency of kalman filter predicts stage - save measurement interval sets the interval over which measurements are rejected by the filter. If no input is received for more than twice this interval, filter resets. - outlier rejection threshold sets the threshold for outlier measurement rejection. - reject counter defines the no of measurements to reject before accepting outliers as the input Initialization Parameters `` Defines the initial covariance of the state vector Defines the drag parameters used in the state model of vertical filter. Flag to treat inputs to the rotation filter as input. If set to true, any input sent to the node bypasses the filter and is output directly. Initialization Parameters Name Type Function kalman_filter/initialize/. ./trigger bool Flag to trigger initialization at startup ./meas/frame_id string Sensor frame to initialize filter with ./meas/value double[15] Defines the initial state of the vessel ./meas/noise bool[15] Defines the initial state covariance Remarks - If trigger is set to false, filter will initialize horizontal position with a measurement with frame ./meas/frame_id . The rest is set by the ./meas Sensor Input Input sensors to the filter are described as a list of type <XmlRpc::XmlRpcValue> . Any number of sensors may be defined following the format described below. Name Type Function kalman_filter/sensors/. - frame_id, config, noise frame_id string Defines the name of the sensor frame. config bool[15] Defines the observation matrix of the kalman filter noise (optional) double[15] Defines the noise associated with the measurement. Remarks - Each sensor to the filter must have a unique frame_id and a static TF to base_link associated with it. - Incoming measurement must always contain the same no of inputs, as described in the observation matrix. - If the noise in input measurement is zero or invalid, filter will ignore the measurement.","title":"Class Parameters"},{"location":"sensor-fusion-kalman-filter/user_guide/#launching-the-nodes","text":"An example launch file is provided below where two sensor_fusion/sensor_fusion nodes are being launched, named filter and filter_dr. <?xml version=\"1.0\"?> <launch> <env name=\"ROSCONSOLE_FORMAT\" value=\"[${severity}] [${time}]: ${node}: ${message}\"/> <!-- ######################## --> <!-- Parameters and Arguments --> <!-- ######################## --> <arg name=\"map\" default=\"map\" /> <!-- name of config file for node ~filter --> <arg name=\"odom\" default=\"odom\" /> <!-- name of config file for node ~filter_dr --> <group ns=\"nav\"> <!-- ############################ --> <!-- filters_dr: Estimates the position of the vehicle in <odom> frame. --> <!-- ############################ --> <node pkg=\"sensor_fusion\" type=\"sensor_fusion\" name=\"filter_dr\" respawn=\"false\"> <rosparam command=\"load\" file=\"$(find medusa_bringup)/config/$(arg odom).yaml\" /> </node> <!-- ############################ --> <!-- filters: Estimates the position of the vehicle in <map> frame. --> <!-- ############################ --> <node pkg=\"sensor_fusion\" type=\"sensor_fusion\" name=\"filter\" respawn=\"false\" output=\"screen\"> <rosparam command=\"load\" file=\"$(find medusa_bringup)/config/$(arg map).yaml\" /> </node> </group> </launch>","title":"Launching the Nodes"},{"location":"sensors-simulation/sensor_sim/","text":"Sensor Sim: readme.md Project Description This package implements basic sensor models for an underwater/surface vehicles. It has the following features - Simulate GPS, Depth, DVL (Bottom Track and Water Track), Altitude, AHRS, Ranges - Control Gaussian Noise and Measurement Noise - Control Sensor Publish Frequency - Publish State output of the dynamic model in auv_msgs::NavigationStatus format Getting Started Installation Pkg sensor_sim comes as part of the medusa_vx stack. Configuration This section explains how to write the node configuration file. Sample are given below topics: subscribers: [ \"/dynamics_sim/position\"] publishers : [ \"/measurement/position\", \"/measurement/velocity\", \"/measurement/orientation\", \"/sensors/gnss\", \"/sensors/range\", \"/sim/dynamics/model\", \"/diagnostics/thrusterStatus\" ] water_column: 100 sensors: - type : \"GNSS\" frame_id : \"gnss\" frequency: 1.0 count : 500 noise : 0.0 variance : 0.03 debug : false - type : \"DVL_BT\" frame_id : \"dvl_bt\" frequency: 5.0 noise : 0.015 variance : 0.001 altitude : 30.0 debug : true - type : \"DVL_WT\" frame_id : \"dvl_wt\" frequency: 5.0 noise : 0.01 variance : 0.0 altitude : 110.0 - type : \"AHRS\" frame_id : \"ahrs\" frequency: 10.0 noise : [0, 0] variance : 0.000001 - type : \"DEPTH\" frame_id : \"depth\" frequency: 10.0 noise : 0.01 variance : 0.005 - type : \"ALTIMETER\" frame_id : \"altimeter\" frequency: 5.0 noise : 0.1 variance : 0.1 - type : \"MODEL\" frequency: 10.0 topics/publishers: parameter of type string[7] Defines the output topics - [position, velocity, orientation, gnss, range, model, thruster] position topic is used to publish DEPTH & ALTIMETER measurements of type medusa_msgs::Measurement velocity topic is used to publish DVL_BT, DVL_WT measurements of type medusa_msgs::Measurement orientation topic is used to publish AHRS measurements of type medusa_msgs::Measurement gnss topic is used for GNSS measurements in WGS84 of type sensor_msgs::NavSatFix range topic is used for single beacon measurements of type medusa_msgs::mUSBLFix topics/subscribers: parameter of type string[1] position topic to receive the dynamic state of the vehicle in nav_msgs::Odometry water_column : Length of water column (We assume that water column is constant) sensors : Sensors to be simulated are described as a list of type . Any number of sensors may be defined following the format described below. type: parameter of type string Defines the type of sensor to be simulated. Current available sensors are \"GNSS\", \"DVL_WT\", \"DVL_BT\", \"AHRS\", \"DEPTH\", \"ALTIMETER\", \"RANGE\", \"MODEL\" frame_id: parameter of type string Frame id of the simulated sensor, must be unique frequency: parameter of type double Controls how often the sensor publishes data count: parameter of type int Sensor stops publishing after this many outputs Put 0 for infinite noise: parameter of type double gaussian noise added to the sensor variance: parameter of type double In addition to the gaussian noise, a constant value is added while publishing the sensor value and variance. Its main purpose is to easily tune the measurement noise being fed to the filter This value has no effect while adding noise to the sensor! Launching the Node An example launch file is provided below where sensor_sim/sensor_sim . <?xml version=\"1.0\"?> <launch> <arg name=\"name\" default=\"myellow\"/> <node pkg=\"sensor_sim\" type=\"sensor_sim\" name=\"sensor_sim\" respawn=\"false\" output=\"screen\"> <rosparam command=\"load\" file=\"$(find sensor_sim)/config/sensors.yaml\"/> </node> </launch>","title":"Overview"},{"location":"sensors-simulation/sensor_sim/#sensor-sim-readmemd","text":"","title":"Sensor Sim: readme.md"},{"location":"sensors-simulation/sensor_sim/#project-description","text":"This package implements basic sensor models for an underwater/surface vehicles. It has the following features - Simulate GPS, Depth, DVL (Bottom Track and Water Track), Altitude, AHRS, Ranges - Control Gaussian Noise and Measurement Noise - Control Sensor Publish Frequency - Publish State output of the dynamic model in auv_msgs::NavigationStatus format","title":"Project Description"},{"location":"sensors-simulation/sensor_sim/#getting-started","text":"","title":"Getting Started"},{"location":"sensors-simulation/sensor_sim/#installation","text":"Pkg sensor_sim comes as part of the medusa_vx stack.","title":"Installation"},{"location":"sensors-simulation/sensor_sim/#configuration","text":"This section explains how to write the node configuration file. Sample are given below topics: subscribers: [ \"/dynamics_sim/position\"] publishers : [ \"/measurement/position\", \"/measurement/velocity\", \"/measurement/orientation\", \"/sensors/gnss\", \"/sensors/range\", \"/sim/dynamics/model\", \"/diagnostics/thrusterStatus\" ] water_column: 100 sensors: - type : \"GNSS\" frame_id : \"gnss\" frequency: 1.0 count : 500 noise : 0.0 variance : 0.03 debug : false - type : \"DVL_BT\" frame_id : \"dvl_bt\" frequency: 5.0 noise : 0.015 variance : 0.001 altitude : 30.0 debug : true - type : \"DVL_WT\" frame_id : \"dvl_wt\" frequency: 5.0 noise : 0.01 variance : 0.0 altitude : 110.0 - type : \"AHRS\" frame_id : \"ahrs\" frequency: 10.0 noise : [0, 0] variance : 0.000001 - type : \"DEPTH\" frame_id : \"depth\" frequency: 10.0 noise : 0.01 variance : 0.005 - type : \"ALTIMETER\" frame_id : \"altimeter\" frequency: 5.0 noise : 0.1 variance : 0.1 - type : \"MODEL\" frequency: 10.0 topics/publishers: parameter of type string[7] Defines the output topics - [position, velocity, orientation, gnss, range, model, thruster] position topic is used to publish DEPTH & ALTIMETER measurements of type medusa_msgs::Measurement velocity topic is used to publish DVL_BT, DVL_WT measurements of type medusa_msgs::Measurement orientation topic is used to publish AHRS measurements of type medusa_msgs::Measurement gnss topic is used for GNSS measurements in WGS84 of type sensor_msgs::NavSatFix range topic is used for single beacon measurements of type medusa_msgs::mUSBLFix topics/subscribers: parameter of type string[1] position topic to receive the dynamic state of the vehicle in nav_msgs::Odometry water_column : Length of water column (We assume that water column is constant) sensors : Sensors to be simulated are described as a list of type . Any number of sensors may be defined following the format described below. type: parameter of type string Defines the type of sensor to be simulated. Current available sensors are \"GNSS\", \"DVL_WT\", \"DVL_BT\", \"AHRS\", \"DEPTH\", \"ALTIMETER\", \"RANGE\", \"MODEL\" frame_id: parameter of type string Frame id of the simulated sensor, must be unique frequency: parameter of type double Controls how often the sensor publishes data count: parameter of type int Sensor stops publishing after this many outputs Put 0 for infinite noise: parameter of type double gaussian noise added to the sensor variance: parameter of type double In addition to the gaussian noise, a constant value is added while publishing the sensor value and variance. Its main purpose is to easily tune the measurement noise being fed to the filter This value has no effect while adding noise to the sensor!","title":"Configuration"},{"location":"sensors-simulation/sensor_sim/#launching-the-node","text":"An example launch file is provided below where sensor_sim/sensor_sim . <?xml version=\"1.0\"?> <launch> <arg name=\"name\" default=\"myellow\"/> <node pkg=\"sensor_sim\" type=\"sensor_sim\" name=\"sensor_sim\" respawn=\"false\" output=\"screen\"> <rosparam command=\"load\" file=\"$(find sensor_sim)/config/sensors.yaml\"/> </node> </launch>","title":"Launching the Node"},{"location":"simple-bringup-system/","text":"","title":"Overview"},{"location":"static-thruster-allocation/","text":"","title":"Reference"},{"location":"status-aggregator/","text":"status_aggregator package status_aggregator is a ROS package responsible for aggregating diagnostic status messages of the system and publish them on the /diagnostics_agg topic. Important Sources By far the best explanation about ROS diagnostics, kudos to Nick Lamprianidis. source 01 source 02 Rationale ROS diagnostics is a tool to monitor your system. In a nutshell, status messages of the system are published on the /diagnostics topic and are then categorized and published for easy monitoring on the /diagnostics_agg topic. As you can guess, two separate components are needed for the final result: updater and aggregator . The former publishes diagnostic status messages on the /diagnostics topic, using tasks . While the latter subscribes the /diagnostics topic, aggregates and categorize the diagnostic status messages and publishes the results on the /diagnostics_agg topic, using analyzers . Updater and task A robot system pocesses multiple updaters , which are generally associated to some device (computer, motors, sensors, batteries). Each updater gets the relevant status information of a device through tasks , that function as an interface between an updater and a device. The sequence of operations is as follows: * Device send data into a task; * Updater forwards a status message to the task; * Task populates status message; When the update receives all the status messages from all the tasks it manages, it publishes them to the /diagnostics topic. The information by now has no hierarchy, difficulting the monotorization of the data. NOTE: In our stack we discarded the use of the tasks, and directly populate the statuses messages in the devices. Here is where Aggregator plays an important role. Example updater Aggregator and analyzer Aggregator comes to fathom out the messy output of the updaters . Basically it collects, categorizes, and groups the status messages from all the updaters of the system. It does so by using analyzers . Each status message received by the aggregator is forward to all of the analyzers it manages. The status messages are only analyzed if its name matches some criteria of one of the analyzers . The aggregator is then responsible to request a report from each analyzer and publish it on the /diagnostics_add topic. The report is just a list of status messages, one for each status item that the analyzer is responsible for, and one for the parent level that summarizes the state of its children statuses. Exmple aggregator Package Content Code documentation source Using status_aggregator Examples Requirements ROS diagnostics Information on /diagnostics topic","title":"Reference"},{"location":"status-aggregator/#status_aggregator-package","text":"status_aggregator is a ROS package responsible for aggregating diagnostic status messages of the system and publish them on the /diagnostics_agg topic.","title":"status_aggregator package"},{"location":"status-aggregator/#important-sources","text":"By far the best explanation about ROS diagnostics, kudos to Nick Lamprianidis. source 01 source 02","title":"Important Sources"},{"location":"status-aggregator/#rationale","text":"ROS diagnostics is a tool to monitor your system. In a nutshell, status messages of the system are published on the /diagnostics topic and are then categorized and published for easy monitoring on the /diagnostics_agg topic. As you can guess, two separate components are needed for the final result: updater and aggregator . The former publishes diagnostic status messages on the /diagnostics topic, using tasks . While the latter subscribes the /diagnostics topic, aggregates and categorize the diagnostic status messages and publishes the results on the /diagnostics_agg topic, using analyzers .","title":"Rationale"},{"location":"status-aggregator/#updater-and-task","text":"A robot system pocesses multiple updaters , which are generally associated to some device (computer, motors, sensors, batteries). Each updater gets the relevant status information of a device through tasks , that function as an interface between an updater and a device. The sequence of operations is as follows: * Device send data into a task; * Updater forwards a status message to the task; * Task populates status message; When the update receives all the status messages from all the tasks it manages, it publishes them to the /diagnostics topic. The information by now has no hierarchy, difficulting the monotorization of the data. NOTE: In our stack we discarded the use of the tasks, and directly populate the statuses messages in the devices. Here is where Aggregator plays an important role. Example updater","title":"Updater and task"},{"location":"status-aggregator/#aggregator-and-analyzer","text":"Aggregator comes to fathom out the messy output of the updaters . Basically it collects, categorizes, and groups the status messages from all the updaters of the system. It does so by using analyzers . Each status message received by the aggregator is forward to all of the analyzers it manages. The status messages are only analyzed if its name matches some criteria of one of the analyzers . The aggregator is then responsible to request a report from each analyzer and publish it on the /diagnostics_add topic. The report is just a list of status messages, one for each status item that the analyzer is responsible for, and one for the parent level that summarizes the state of its children statuses. Exmple aggregator","title":"Aggregator and analyzer"},{"location":"status-aggregator/#package-content","text":"","title":"Package Content"},{"location":"status-aggregator/#code-documentation","text":"source","title":"Code documentation"},{"location":"status-aggregator/#using-status_aggregator","text":"Examples","title":"Using status_aggregator"},{"location":"status-aggregator/#requirements","text":"ROS diagnostics Information on /diagnostics topic","title":"Requirements"},{"location":"status-aggregator/configurations/aggregator_example/","text":"Aggregator Example For the aggregator present some hierarchy, you have to specify a yaml file with the analyzers. /status_aggregator/config/mvector pub_rate: 2.0 analyzers: sensors: type: diagnostic_aggregator/StatusAnalyzer path: Sensors analyzers: leaks: type: diagnostic_aggregator/GenericAnalyzer path: Leaks contains: Leaks pressure: type: diagnostic_aggregator/GenericAnalyzer path: Pressure contains: Pressure temp: type: diagnostic_aggregator/GenericAnalyzer path: Temperature contains: Temperature imu: type: diagnostic_aggregator/GenericAnalyzer path: IMU contains: IMU gps: type: diagnostic_aggregator/GenericAnalyzer path: GPS contains: GPS altimeter: type: diagnostic_aggregator/GenericAnalyzer path: Altimeter contains: Altimeter depth_cell: type: diagnostic_aggregator/GenericAnalyzer path: DepthCell contains: DepthCell dvl: type: diagnostic_aggregator/GenericAnalyzer path: DVL contains: DVL actuators: type: diagnostic_aggregator/StatusAnalyzer path: Actuators analyzers: thruster_0: type: diagnostic_aggregator/GenericAnalyzer path: Thruster0 contains: Thruster0 thruster_1: type: diagnostic_aggregator/GenericAnalyzer path: Thruster1 contains: Thruster1 thruster_3: type: diagnostic_aggregator/GenericAnalyzer path: Thruster3 contains: Thruster3 thruster_2: type: diagnostic_aggregator/GenericAnalyzer path: Thruster2 contains: Thruster2 thruster_4: type: diagnostic_aggregator/GenericAnalyzer path: Thruster4 contains: Thruster4 thruster_5: type: diagnostic_aggregator/GenericAnalyzer path: Thruster5 contains: Thruster5 power_system: type: diagnostic_aggregator/StatusAnalyzer path: Power System analyzers: batmonit: type: diagnostic_aggregator/GenericAnalyzer path: Batmonit contains: Batmonit This yaml file can have 3 parameters: The pub_rate which is the frequency at which the aggregator publishes to the /diagnostics_agg topic. The base_path (and a secret one, path) which adds an additional root level in the hierarchy (e.g. /MyRobot/Sensors/IMU/\u2026). But it\u2019s useless, since there can only be one aggregator in the system, and so the separation between different robots cannot happen at this level. Thus, you can simply ignore it! The analyzers which is a list of\u2026 you guessed it, analyzers. The analyzers have a type, a name (a.k.a. path), and several options for matching criteria. The type can be GenericAnalyzer which does a grouping of status items based on their name or StatusAnalyzer which does a categorization of analyzers (e.g. Sensors/..., Actuators/..., Power System/...). Now, comes the interesting part. What if we want to react to an error? We\u2019ll have to write an analyzer that does this. But we won\u2019t just write an analyzer. Since the categorization offered by the default analyzers is always relevant, we\u2019ll extend the generic or group analyzers so that we maintain their functionality. The analyzers have two methods that can be of interest: The analyze method which can be useful for processing the data of a status message before we store it. The report method which can be used to make a decision based on the status messages to be reported by the analyzer. In the accompanying code, there are two analyzers. One is based on the GroupAnalyzer and the other is based on the GenericAnalyzer . They both rely on the report method. They look at the reported statuses by their parent class and they publish a message if a condition is met. The StatusAnalyzer finds a group (/Sensors, /Actuator, or Power System) status and reacts when its level transitions from OK to something else. The GenericAnalyzer is the default one, but you can have specific ones for your needs. Any required parameters are provided in the yaml file. Extending an analyzer First make a analyzer_plugins.xml file, like the following: <library path=\"lib/libstatus_aggregator_analyzers\"> <class name=\"diagnostic_aggregator/StatusAnalyzer\" type=\"diagnostic_aggregator::StatusAnalyzer\" base_class_type=\"diagnostic_aggregator::Analyzer\"> <description> StatusAnalyzer is a diagnostic analyzer for a group of devices (sensors, actuators, power system). </description> </class> </library> In the include file ( include/status_aggregator_ros/StatusAnalyzer.h ) you should inherit the base class AnalyzerGroup and override the methods init() and report() : class StatusAnalyzer : public AnalyzerGroup { public: StatusAnalyzer(); bool init(const std::string base_path, const ros::NodeHandle &n) override; std::vector<diagnostic_msgs::DiagnosticStatusPtr> report() override; In the cpp file ( src/status_aggregator_ros/StatusAnalyzer.cpp ) change the methods accordingly your needs.","title":"Aggregator Example"},{"location":"status-aggregator/configurations/aggregator_example/#aggregator-example","text":"For the aggregator present some hierarchy, you have to specify a yaml file with the analyzers. /status_aggregator/config/mvector pub_rate: 2.0 analyzers: sensors: type: diagnostic_aggregator/StatusAnalyzer path: Sensors analyzers: leaks: type: diagnostic_aggregator/GenericAnalyzer path: Leaks contains: Leaks pressure: type: diagnostic_aggregator/GenericAnalyzer path: Pressure contains: Pressure temp: type: diagnostic_aggregator/GenericAnalyzer path: Temperature contains: Temperature imu: type: diagnostic_aggregator/GenericAnalyzer path: IMU contains: IMU gps: type: diagnostic_aggregator/GenericAnalyzer path: GPS contains: GPS altimeter: type: diagnostic_aggregator/GenericAnalyzer path: Altimeter contains: Altimeter depth_cell: type: diagnostic_aggregator/GenericAnalyzer path: DepthCell contains: DepthCell dvl: type: diagnostic_aggregator/GenericAnalyzer path: DVL contains: DVL actuators: type: diagnostic_aggregator/StatusAnalyzer path: Actuators analyzers: thruster_0: type: diagnostic_aggregator/GenericAnalyzer path: Thruster0 contains: Thruster0 thruster_1: type: diagnostic_aggregator/GenericAnalyzer path: Thruster1 contains: Thruster1 thruster_3: type: diagnostic_aggregator/GenericAnalyzer path: Thruster3 contains: Thruster3 thruster_2: type: diagnostic_aggregator/GenericAnalyzer path: Thruster2 contains: Thruster2 thruster_4: type: diagnostic_aggregator/GenericAnalyzer path: Thruster4 contains: Thruster4 thruster_5: type: diagnostic_aggregator/GenericAnalyzer path: Thruster5 contains: Thruster5 power_system: type: diagnostic_aggregator/StatusAnalyzer path: Power System analyzers: batmonit: type: diagnostic_aggregator/GenericAnalyzer path: Batmonit contains: Batmonit This yaml file can have 3 parameters: The pub_rate which is the frequency at which the aggregator publishes to the /diagnostics_agg topic. The base_path (and a secret one, path) which adds an additional root level in the hierarchy (e.g. /MyRobot/Sensors/IMU/\u2026). But it\u2019s useless, since there can only be one aggregator in the system, and so the separation between different robots cannot happen at this level. Thus, you can simply ignore it! The analyzers which is a list of\u2026 you guessed it, analyzers. The analyzers have a type, a name (a.k.a. path), and several options for matching criteria. The type can be GenericAnalyzer which does a grouping of status items based on their name or StatusAnalyzer which does a categorization of analyzers (e.g. Sensors/..., Actuators/..., Power System/...). Now, comes the interesting part. What if we want to react to an error? We\u2019ll have to write an analyzer that does this. But we won\u2019t just write an analyzer. Since the categorization offered by the default analyzers is always relevant, we\u2019ll extend the generic or group analyzers so that we maintain their functionality. The analyzers have two methods that can be of interest: The analyze method which can be useful for processing the data of a status message before we store it. The report method which can be used to make a decision based on the status messages to be reported by the analyzer. In the accompanying code, there are two analyzers. One is based on the GroupAnalyzer and the other is based on the GenericAnalyzer . They both rely on the report method. They look at the reported statuses by their parent class and they publish a message if a condition is met. The StatusAnalyzer finds a group (/Sensors, /Actuator, or Power System) status and reacts when its level transitions from OK to something else. The GenericAnalyzer is the default one, but you can have specific ones for your needs. Any required parameters are provided in the yaml file.","title":"Aggregator Example"},{"location":"status-aggregator/configurations/aggregator_example/#extending-an-analyzer","text":"First make a analyzer_plugins.xml file, like the following: <library path=\"lib/libstatus_aggregator_analyzers\"> <class name=\"diagnostic_aggregator/StatusAnalyzer\" type=\"diagnostic_aggregator::StatusAnalyzer\" base_class_type=\"diagnostic_aggregator::Analyzer\"> <description> StatusAnalyzer is a diagnostic analyzer for a group of devices (sensors, actuators, power system). </description> </class> </library> In the include file ( include/status_aggregator_ros/StatusAnalyzer.h ) you should inherit the base class AnalyzerGroup and override the methods init() and report() : class StatusAnalyzer : public AnalyzerGroup { public: StatusAnalyzer(); bool init(const std::string base_path, const ros::NodeHandle &n) override; std::vector<diagnostic_msgs::DiagnosticStatusPtr> report() override; In the cpp file ( src/status_aggregator_ros/StatusAnalyzer.cpp ) change the methods accordingly your needs.","title":"Extending an analyzer"},{"location":"status-aggregator/configurations/medusaVxConfig/","text":"medusa_vx config - status_aggregator Run This package is launched with medusa stack. ex: roslaunch medusa_bringup medusa_bringup.launch name:= mvector docks:=missions Please check if aggregator is set to true in the vehicle configurations. For this, please check the following block in medusa_bringup/config/docks/mvector/process.yaml file: - name: 'addons' launch_on_startup: true delay_before_start: 0.0 cmd: 'roslaunch medusa_bringup addons.launch' args: - **aggregator:= true** - console_path_parser:= true - console_server:= true - wifi_acoustic_safety:= true - rosbridge_server:= false Launch file You have a main launch ( medusa_bringup.launch ) that calls a node ( medusa_bringup_node ) responsible to manage all the processes in a proecss.yaml file. The node while running is responsible to launch a subset of other launch files located at /medusa_bringup/launch/dev_launch . Among the exisitng ones, here the focus is in the addons.launch where aggregator is present. Looking in some detail to the file we point out the key points: <arg name=\"name\" /> <arg name=\"mission\" default=\"example\" /> <arg name=\"wifi_acoustic_safety\" default=\"false\" /> <!-- safety features --> **<arg name=\"console_path_parser\" default=\"false\" />** <arg name=\"http_server\" default=\"false\" /> <arg name=\"aggregator\" default=\"false\" /> <arg name=\"rosbridge_server\" default=\"false\" /> <arg name=\"websocket_port\" default=\"9090\" /> <!-- arg to use in http--> By default all the nodes in the medusa_addons package are set to false and won't run if you don't change the corresponding boolean in the process.yaml like in the previous section. <group ns=\"addons\"> Every addon is part of the group addons , which means that topics will be someting like /addons/node/some_topic , here /addons/aggregator/some_topic . <group if=\"$(arg aggregator)\"> <node pkg=\"diagnostic_aggregator\" type=\"aggregator_node\" name=\"aggregator\" output=\"screen\" /> </group> As you can see the if guarantees that the node only starts if in the process.yaml , aggregator is set to true. Configurations Configuration is divided between two files. The first one, medusa_bringup/config/dev_configs/ros.yaml , is responsible with ros node items (frequency and topics names). Below, the section of console_path_parser : addons/aggregator: pub_rate: 2.0 The second file, /medusa_bringup/config/mission/vehicle/addons.yaml , accommodates items more related with the node inner-workings. Below, the section of aggregator : *file, ex: /medusa_bringup/config/docks/mvector/addons.yaml aggregator: analyzers: sensors: type: diagnostic_aggregator/StatusAnalyzer path: Sensors analyzers: leaks: type: diagnostic_aggregator/GenericAnalyzer path: Leaks contains: Leaks pressure: type: diagnostic_aggregator/GenericAnalyzer path: Pressure contains: Pressure temp: type: diagnostic_aggregator/GenericAnalyzer path: Temperature contains: Temperature imu: type: diagnostic_aggregator/GenericAnalyzer path: IMU contains: IMU gps: type: diagnostic_aggregator/GenericAnalyzer path: GPS contains: GPS altimeter: type: diagnostic_aggregator/GenericAnalyzer path: Altimeter contains: Altimeter depth_cell: type: diagnostic_aggregator/GenericAnalyzer path: DepthCell contains: DepthCell actuators: type: diagnostic_aggregator/StatusAnalyzer path: Actuators analyzers: thruster_0: type: diagnostic_aggregator/GenericAnalyzer path: Thruster0 contains: Thruster0 thruster_1: type: diagnostic_aggregator/GenericAnalyzer path: Thruster1 contains: Thruster1 thruster_2: type: diagnostic_aggregator/GenericAnalyzer path: Thruster2 contains: Thruster2 thruster_3: type: diagnostic_aggregator/GenericAnalyzer path: Thruster3 contains: Thruster3 thruster_4: type: diagnostic_aggregator/GenericAnalyzer path: Thruster4 contains: Thruster4 thruster_5: type: diagnostic_aggregator/GenericAnalyzer path: Thruster5 contains: Thruster5 power_system: type: diagnostic_aggregator/StatusAnalyzer path: Power System analyzers: batmonit: type: diagnostic_aggregator/GenericAnalyzer path: Batmonit contains: Batmonit","title":"medusa_vx config - status_aggregator"},{"location":"status-aggregator/configurations/medusaVxConfig/#medusa_vx-config-status_aggregator","text":"","title":"medusa_vx config - status_aggregator"},{"location":"status-aggregator/configurations/medusaVxConfig/#run","text":"This package is launched with medusa stack. ex: roslaunch medusa_bringup medusa_bringup.launch name:= mvector docks:=missions Please check if aggregator is set to true in the vehicle configurations. For this, please check the following block in medusa_bringup/config/docks/mvector/process.yaml file: - name: 'addons' launch_on_startup: true delay_before_start: 0.0 cmd: 'roslaunch medusa_bringup addons.launch' args: - **aggregator:= true** - console_path_parser:= true - console_server:= true - wifi_acoustic_safety:= true - rosbridge_server:= false","title":"Run"},{"location":"status-aggregator/configurations/medusaVxConfig/#launch-file","text":"You have a main launch ( medusa_bringup.launch ) that calls a node ( medusa_bringup_node ) responsible to manage all the processes in a proecss.yaml file. The node while running is responsible to launch a subset of other launch files located at /medusa_bringup/launch/dev_launch . Among the exisitng ones, here the focus is in the addons.launch where aggregator is present. Looking in some detail to the file we point out the key points: <arg name=\"name\" /> <arg name=\"mission\" default=\"example\" /> <arg name=\"wifi_acoustic_safety\" default=\"false\" /> <!-- safety features --> **<arg name=\"console_path_parser\" default=\"false\" />** <arg name=\"http_server\" default=\"false\" /> <arg name=\"aggregator\" default=\"false\" /> <arg name=\"rosbridge_server\" default=\"false\" /> <arg name=\"websocket_port\" default=\"9090\" /> <!-- arg to use in http--> By default all the nodes in the medusa_addons package are set to false and won't run if you don't change the corresponding boolean in the process.yaml like in the previous section. <group ns=\"addons\"> Every addon is part of the group addons , which means that topics will be someting like /addons/node/some_topic , here /addons/aggregator/some_topic . <group if=\"$(arg aggregator)\"> <node pkg=\"diagnostic_aggregator\" type=\"aggregator_node\" name=\"aggregator\" output=\"screen\" /> </group> As you can see the if guarantees that the node only starts if in the process.yaml , aggregator is set to true.","title":"Launch file"},{"location":"status-aggregator/configurations/medusaVxConfig/#configurations","text":"Configuration is divided between two files. The first one, medusa_bringup/config/dev_configs/ros.yaml , is responsible with ros node items (frequency and topics names). Below, the section of console_path_parser : addons/aggregator: pub_rate: 2.0 The second file, /medusa_bringup/config/mission/vehicle/addons.yaml , accommodates items more related with the node inner-workings. Below, the section of aggregator : *file, ex: /medusa_bringup/config/docks/mvector/addons.yaml aggregator: analyzers: sensors: type: diagnostic_aggregator/StatusAnalyzer path: Sensors analyzers: leaks: type: diagnostic_aggregator/GenericAnalyzer path: Leaks contains: Leaks pressure: type: diagnostic_aggregator/GenericAnalyzer path: Pressure contains: Pressure temp: type: diagnostic_aggregator/GenericAnalyzer path: Temperature contains: Temperature imu: type: diagnostic_aggregator/GenericAnalyzer path: IMU contains: IMU gps: type: diagnostic_aggregator/GenericAnalyzer path: GPS contains: GPS altimeter: type: diagnostic_aggregator/GenericAnalyzer path: Altimeter contains: Altimeter depth_cell: type: diagnostic_aggregator/GenericAnalyzer path: DepthCell contains: DepthCell actuators: type: diagnostic_aggregator/StatusAnalyzer path: Actuators analyzers: thruster_0: type: diagnostic_aggregator/GenericAnalyzer path: Thruster0 contains: Thruster0 thruster_1: type: diagnostic_aggregator/GenericAnalyzer path: Thruster1 contains: Thruster1 thruster_2: type: diagnostic_aggregator/GenericAnalyzer path: Thruster2 contains: Thruster2 thruster_3: type: diagnostic_aggregator/GenericAnalyzer path: Thruster3 contains: Thruster3 thruster_4: type: diagnostic_aggregator/GenericAnalyzer path: Thruster4 contains: Thruster4 thruster_5: type: diagnostic_aggregator/GenericAnalyzer path: Thruster5 contains: Thruster5 power_system: type: diagnostic_aggregator/StatusAnalyzer path: Power System analyzers: batmonit: type: diagnostic_aggregator/GenericAnalyzer path: Batmonit contains: Batmonit","title":"Configurations"},{"location":"status-aggregator/configurations/updater_example/","text":"Updater example To use ROS diagnostics add the following to CMakeLists.txt: find_package(catkin REQUIRED COMPONENTS std_msgs medusa_msgs roscpp **diagnostic_msgs** serial_lib nmea_msgs medusa_gimmicks_library **medusa_diagnostics_library** ) and in package.xml guarantee the following two dependencies: <depend>diagnostic_msgs</depend> <depend>medusa_diagnostics_library</depend> Code use In some header file please include the following: #include <diagnostic_msgs/KeyValue.h> #include <diagnostic_msgs/DiagnosticArray.h> #include <diagnostic_msgs/DiagnosticStatus.h> #include <medusa_diagnostics_library/MedusaDiagnostics.h> Below you can find an example, with two different key values(pressure and temperature), the status message is directly populated in the driver node: void ImsNode::reportingPressure(const medusa_msgs::Pressure &msg) { //** Instantiate diagnostic message diagnostic_msgs::DiagnosticArray diag_msg; diag_msg.header.stamp = msg.header.stamp; diag_msg.status.push_back(MedusaDiagnostics::setDiagnosisMsg(diagnostic_msgs::DiagnosticStatus::OK, \"/Sensors/Pressure\", \"IMS Pressure Good.\", \"IMS Board\")); diag_msg.status.push_back(MedusaDiagnostics::setDiagnosisMsg(diagnostic_msgs::DiagnosticStatus::OK, \"/Sensors/Temperature\", \"IMS Temperature Good.\", \"IMS Board\")); // +.+ Check pressure bounds if (MedusaDiagnostics::checkLowerBound(msg.pressure, p_min_pressure_) || MedusaDiagnostics::checkUpperBound(msg.pressure, p_max_pressure_)) MedusaDiagnostics::errorLevel(&diag_msg, ros::this_node::getName() + \": Pressure out of bounds\", 0); // +.+ Check temperature bounds if (MedusaDiagnostics::checkLowerBound(msg.temperature, p_min_temp_) || MedusaDiagnostics::checkUpperBound(msg.temperature, p_max_temp_)) MedusaDiagnostics::errorLevel(&diag_msg, ros::this_node::getName() + \": Temperature out of bounds\", 1); // +.+ Pressure and temperature key values MedusaDiagnostics::addKeyValue(&diag_msg, \"Pressure\", boost::str(boost::format(\"%.0f\") % (msg.pressure)), 0); MedusaDiagnostics::addKeyValue(&diag_msg, \"Temperature\", boost::str(boost::format(\"%.0f\") % (msg.temperature)), 1); diagnostics_pub_.publish(diag_msg); } where: diagnostics_pub_ = nh_.advertise<diagnostic_msgs::DiagnosticArray>(\"/diagnostics\", 100);","title":"Updater example"},{"location":"status-aggregator/configurations/updater_example/#updater-example","text":"To use ROS diagnostics add the following to CMakeLists.txt: find_package(catkin REQUIRED COMPONENTS std_msgs medusa_msgs roscpp **diagnostic_msgs** serial_lib nmea_msgs medusa_gimmicks_library **medusa_diagnostics_library** ) and in package.xml guarantee the following two dependencies: <depend>diagnostic_msgs</depend> <depend>medusa_diagnostics_library</depend>","title":"Updater example"},{"location":"status-aggregator/configurations/updater_example/#code-use","text":"In some header file please include the following: #include <diagnostic_msgs/KeyValue.h> #include <diagnostic_msgs/DiagnosticArray.h> #include <diagnostic_msgs/DiagnosticStatus.h> #include <medusa_diagnostics_library/MedusaDiagnostics.h> Below you can find an example, with two different key values(pressure and temperature), the status message is directly populated in the driver node: void ImsNode::reportingPressure(const medusa_msgs::Pressure &msg) { //** Instantiate diagnostic message diagnostic_msgs::DiagnosticArray diag_msg; diag_msg.header.stamp = msg.header.stamp; diag_msg.status.push_back(MedusaDiagnostics::setDiagnosisMsg(diagnostic_msgs::DiagnosticStatus::OK, \"/Sensors/Pressure\", \"IMS Pressure Good.\", \"IMS Board\")); diag_msg.status.push_back(MedusaDiagnostics::setDiagnosisMsg(diagnostic_msgs::DiagnosticStatus::OK, \"/Sensors/Temperature\", \"IMS Temperature Good.\", \"IMS Board\")); // +.+ Check pressure bounds if (MedusaDiagnostics::checkLowerBound(msg.pressure, p_min_pressure_) || MedusaDiagnostics::checkUpperBound(msg.pressure, p_max_pressure_)) MedusaDiagnostics::errorLevel(&diag_msg, ros::this_node::getName() + \": Pressure out of bounds\", 0); // +.+ Check temperature bounds if (MedusaDiagnostics::checkLowerBound(msg.temperature, p_min_temp_) || MedusaDiagnostics::checkUpperBound(msg.temperature, p_max_temp_)) MedusaDiagnostics::errorLevel(&diag_msg, ros::this_node::getName() + \": Temperature out of bounds\", 1); // +.+ Pressure and temperature key values MedusaDiagnostics::addKeyValue(&diag_msg, \"Pressure\", boost::str(boost::format(\"%.0f\") % (msg.pressure)), 0); MedusaDiagnostics::addKeyValue(&diag_msg, \"Temperature\", boost::str(boost::format(\"%.0f\") % (msg.temperature)), 1); diagnostics_pub_.publish(diag_msg); } where: diagnostics_pub_ = nh_.advertise<diagnostic_msgs::DiagnosticArray>(\"/diagnostics\", 100);","title":"Code use"},{"location":"uuv-assistants/","text":"","title":"Overview"},{"location":"uuv-descriptions/","text":"nav: - Overview: \"README.md\"","title":"Overview"},{"location":"uuv-gazebo-plugins/","text":"","title":"Overview"},{"location":"uuv-gazebo-ros-plugins/","text":"","title":"Overview"},{"location":"uuv-gazebo-ros-plugins-msgs/","text":"","title":"Overview"},{"location":"uuv-sensor-ros-plugins/","text":"","title":"Overview"},{"location":"uuv-sensor-ros-plugins-messages/","text":"","title":"Overview"},{"location":"uuv-world-plugins/","text":"","title":"Overview"},{"location":"uuv-world-ros-plugins/","text":"","title":"Overview"},{"location":"uuv-world-ros-plugins-messages/","text":"","title":"Overview"},{"location":"vehicle-stabilizer/","text":"","title":"Reference"}]}