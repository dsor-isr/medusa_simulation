{"config":{"indexing":"full","lang":["en","pt"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;"},"docs":[{"location":"","text":"Medusa Simulation This repository holds the Medusa Simulation code stack for underwater marine vehicles of DSOR-ISR (Dynamical Systems for Ocean Robotics - Institute for System Robotics). It contains the necessary components to simulate and control the MEDUSA class of marine vehicles. It provides 2 types of simulation. A matlab like simulation written in C++ and another using gazebo simulator. Requirements This code stack was developed with ROS1 in mind. In order to use, you are required to have: - Ubuntu 20.04LTS (64-bit) - ROS1 Noetic - Python 3","title":"Introduction"},{"location":"#medusa-simulation","text":"This repository holds the Medusa Simulation code stack for underwater marine vehicles of DSOR-ISR (Dynamical Systems for Ocean Robotics - Institute for System Robotics). It contains the necessary components to simulate and control the MEDUSA class of marine vehicles. It provides 2 types of simulation. A matlab like simulation written in C++ and another using gazebo simulator.","title":"Medusa Simulation"},{"location":"#requirements","text":"This code stack was developed with ROS1 in mind. In order to use, you are required to have: - Ubuntu 20.04LTS (64-bit) - ROS1 Noetic - Python 3","title":"Requirements"},{"location":"Waypoint/","text":"","title":"Reference"},{"location":"acoustic-vehicle-state-broadcaster/","text":"acoustic_converters documentation","title":"Reference"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/","text":"Classes class CircularDelay A class that functions as a sample buffer. class const_iterator class const_reverse_iterator class iterator class reverse_iterator namespace DSOR struct VehicleState State class - used to save the state of a vehicle (using SNAME convention) class Differentiator Class for the differentiator. class DigitalFilter Abstract base class for digital moving filters. class HighPassFilter Class for high pass filter using bilinear transform. class HighPassFilter3 Class for third order high pass filter. This is designed using the bilinear transform. class LowPassFilter Class for a low pass filter. class LowPassFilter2 Class for a 2nd order low pass filter. class LowPassFilter3 Class for third order high pass filter. This is designed using the bilinear transform. class LowPassFilter3DiffApprox Class for third order high pass filter. This is designed using the approximated differtial approuch where s=(Z-1)/(Z*T). class LowPassFilter3MatchedZ Class for third order low pass filter. This is designed using the matched Z transform. class MovingAvarageFilter namespace tps Updated on 2022-05-30 at 14:56:42 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/#classes","text":"class CircularDelay A class that functions as a sample buffer. class const_iterator class const_reverse_iterator class iterator class reverse_iterator namespace DSOR struct VehicleState State class - used to save the state of a vehicle (using SNAME convention) class Differentiator Class for the differentiator. class DigitalFilter Abstract base class for digital moving filters. class HighPassFilter Class for high pass filter using bilinear transform. class HighPassFilter3 Class for third order high pass filter. This is designed using the bilinear transform. class LowPassFilter Class for a low pass filter. class LowPassFilter2 Class for a 2nd order low pass filter. class LowPassFilter3 Class for third order high pass filter. This is designed using the bilinear transform. class LowPassFilter3DiffApprox Class for third order high pass filter. This is designed using the approximated differtial approuch where s=(Z-1)/(Z*T). class LowPassFilter3MatchedZ Class for third order low pass filter. This is designed using the matched Z transform. class MovingAvarageFilter namespace tps Updated on 2022-05-30 at 14:56:42 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay/","text":"CircularDelay A class that functions as a sample buffer. More... #include <circular_buffer.hpp> Public Classes Name class const_iterator class const_reverse_iterator class iterator class reverse_iterator Public Functions Name CircularDelay () Constructor that initializes that buffer and its set index. type push (type input) With this function you can insert a new sample into the buffer. type get (size_t delay) With this function you can retrieve a sample from the past. iterator end () iterator begin () reverse_iterator rend () reverse_iterator rbegin () Detailed Description template <typename type , size_t size> class CircularDelay; A class that functions as a sample buffer. Template Parameters : type Type of sample that needs to be stored. size Size of how big the history buffer is. Copyright : GPL V3 Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/CircularDelay/tree/master Brief: Circular delay software library. Here data can be stored and retrieved is a LiFo manner. License: GNU Copyright (C) 2018 Jimmy van den Berg This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see http://www.gnu.org/licenses/ . You can use this to insert samples and use the get function to get a sample from the past. Public Functions Documentation function CircularDelay CircularDelay() Constructor that initializes that buffer and its set index. Template Parameters : type Type of sample that needs to be stored. size Size of how big the history buffer is. function push type push( type input ) With this function you can insert a new sample into the buffer. Parameters : input Sample to push into. Template Parameters : type Type of sample that needs to be stored. size Size of how big the history buffer is. Return : Value that has been pushed. function get type get( size_t delay ) With this function you can retrieve a sample from the past. Parameters : delay How many samples you ago you want to get. Template Parameters : type Type of sample that needs to be stored. size Size of how big the history buffer is. Return : The sample of delay ago. Maximum delay is the size of the CircularDelay - 1. function end inline iterator end() function begin inline iterator begin() function rend inline reverse_iterator rend() function rbegin inline reverse_iterator rbegin() Updated on 2022-05-30 at 14:56:42 +0000","title":"CircularDelay"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay/#circulardelay","text":"A class that functions as a sample buffer. More... #include <circular_buffer.hpp>","title":"CircularDelay"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay/#public-classes","text":"Name class const_iterator class const_reverse_iterator class iterator class reverse_iterator","title":"Public Classes"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay/#public-functions","text":"Name CircularDelay () Constructor that initializes that buffer and its set index. type push (type input) With this function you can insert a new sample into the buffer. type get (size_t delay) With this function you can retrieve a sample from the past. iterator end () iterator begin () reverse_iterator rend () reverse_iterator rbegin ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay/#detailed-description","text":"template <typename type , size_t size> class CircularDelay; A class that functions as a sample buffer. Template Parameters : type Type of sample that needs to be stored. size Size of how big the history buffer is. Copyright : GPL V3 Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/CircularDelay/tree/master Brief: Circular delay software library. Here data can be stored and retrieved is a LiFo manner. License: GNU Copyright (C) 2018 Jimmy van den Berg This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see http://www.gnu.org/licenses/ . You can use this to insert samples and use the get function to get a sample from the past.","title":"Detailed Description"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay/#function-circulardelay","text":"CircularDelay() Constructor that initializes that buffer and its set index. Template Parameters : type Type of sample that needs to be stored. size Size of how big the history buffer is.","title":"function CircularDelay"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay/#function-push","text":"type push( type input ) With this function you can insert a new sample into the buffer. Parameters : input Sample to push into. Template Parameters : type Type of sample that needs to be stored. size Size of how big the history buffer is. Return : Value that has been pushed.","title":"function push"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay/#function-get","text":"type get( size_t delay ) With this function you can retrieve a sample from the past. Parameters : delay How many samples you ago you want to get. Template Parameters : type Type of sample that needs to be stored. size Size of how big the history buffer is. Return : The sample of delay ago. Maximum delay is the size of the CircularDelay - 1.","title":"function get"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay/#function-end","text":"inline iterator end()","title":"function end"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay/#function-begin","text":"inline iterator begin()","title":"function begin"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay/#function-rend","text":"inline reverse_iterator rend()","title":"function rend"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay/#function-rbegin","text":"inline reverse_iterator rbegin() Updated on 2022-05-30 at 14:56:42 +0000","title":"function rbegin"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/","text":"CircularDelay::const_iterator Public Types Name typedef const_iterator self_type typedef std::bidirectional_iterator_tag iterator_category typedef int difference_type Public Functions Name const_iterator (const CircularDelay < type, size >:: const_iterator & it) self_type operator++ () self_type operator++ (int ) self_type operator-- () self_type operator-- (int ) const type & operator* () const type * operator-> () const type & operator[] (unsigned int index) bool operator== (const self_type & rhs) bool operator!= (const self_type & rhs) Friends Name class CircularDelay Public Types Documentation typedef self_type typedef const_iterator CircularDelay< type, size >::const_iterator::self_type; typedef iterator_category typedef std::bidirectional_iterator_tag CircularDelay< type, size >::const_iterator::iterator_category; typedef difference_type typedef int CircularDelay< type, size >::const_iterator::difference_type; Public Functions Documentation function const_iterator inline const_iterator( const CircularDelay< type, size >::const_iterator & it ) function operator++ inline self_type operator++() function operator++ inline self_type operator++( int ) function operator-- inline self_type operator--() function operator-- inline self_type operator--( int ) function operator* inline const type & operator*() function operator-> inline const type * operator->() function operator[] inline const type & operator[]( unsigned int index ) function operator== inline bool operator==( const self_type & rhs ) function operator!= inline bool operator!=( const self_type & rhs ) Friends friend CircularDelay friend class CircularDelay; Updated on 2022-05-30 at 14:56:42 +0000","title":"CircularDelay::const_iterator"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#circulardelayconst_iterator","text":"","title":"CircularDelay::const_iterator"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#public-types","text":"Name typedef const_iterator self_type typedef std::bidirectional_iterator_tag iterator_category typedef int difference_type","title":"Public Types"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#public-functions","text":"Name const_iterator (const CircularDelay < type, size >:: const_iterator & it) self_type operator++ () self_type operator++ (int ) self_type operator-- () self_type operator-- (int ) const type & operator* () const type * operator-> () const type & operator[] (unsigned int index) bool operator== (const self_type & rhs) bool operator!= (const self_type & rhs)","title":"Public Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#friends","text":"Name class CircularDelay","title":"Friends"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#typedef-self_type","text":"typedef const_iterator CircularDelay< type, size >::const_iterator::self_type;","title":"typedef self_type"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#typedef-iterator_category","text":"typedef std::bidirectional_iterator_tag CircularDelay< type, size >::const_iterator::iterator_category;","title":"typedef iterator_category"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#typedef-difference_type","text":"typedef int CircularDelay< type, size >::const_iterator::difference_type;","title":"typedef difference_type"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#function-const_iterator","text":"inline const_iterator( const CircularDelay< type, size >::const_iterator & it )","title":"function const_iterator"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#function-operator","text":"inline self_type operator++()","title":"function operator++"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#function-operator_1","text":"inline self_type operator++( int )","title":"function operator++"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#function-operator-","text":"inline self_type operator--()","title":"function operator--"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#function-operator-_1","text":"inline self_type operator--( int )","title":"function operator--"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#function-operator_2","text":"inline const type & operator*()","title":"function operator*"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#function-operator-_2","text":"inline const type * operator->()","title":"function operator-&gt;"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#function-operator_3","text":"inline const type & operator[]( unsigned int index )","title":"function operator[]"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#function-operator_4","text":"inline bool operator==( const self_type & rhs )","title":"function operator=="},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#function-operator_5","text":"inline bool operator!=( const self_type & rhs )","title":"function operator!="},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#friends_1","text":"","title":"Friends"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#friend-circulardelay","text":"friend class CircularDelay; Updated on 2022-05-30 at 14:56:42 +0000","title":"friend CircularDelay"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/","text":"CircularDelay::const_reverse_iterator Public Types Name typedef const_reverse_iterator self_type typedef std::bidirectional_iterator_tag iterator_category typedef int difference_type Public Functions Name const_reverse_iterator (const CircularDelay < type, size >:: const_reverse_iterator & it) self_type operator++ () self_type operator++ (int ) self_type operator-- () self_type operator-- (int ) const type & operator* () const type * operator-> () const type & operator[] (int index) bool operator== (const self_type & rhs) bool operator!= (const self_type & rhs) Friends Name class CircularDelay Public Types Documentation typedef self_type typedef const_reverse_iterator CircularDelay< type, size >::const_reverse_iterator::self_type; typedef iterator_category typedef std::bidirectional_iterator_tag CircularDelay< type, size >::const_reverse_iterator::iterator_category; typedef difference_type typedef int CircularDelay< type, size >::const_reverse_iterator::difference_type; Public Functions Documentation function const_reverse_iterator inline const_reverse_iterator( const CircularDelay< type, size >::const_reverse_iterator & it ) function operator++ inline self_type operator++() function operator++ inline self_type operator++( int ) function operator-- inline self_type operator--() function operator-- inline self_type operator--( int ) function operator* inline const type & operator*() function operator-> inline const type * operator->() function operator[] inline const type & operator[]( int index ) function operator== inline bool operator==( const self_type & rhs ) function operator!= inline bool operator!=( const self_type & rhs ) Friends friend CircularDelay friend class CircularDelay; Updated on 2022-05-30 at 14:56:42 +0000","title":"CircularDelay::const_reverse_iterator"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#circulardelayconst_reverse_iterator","text":"","title":"CircularDelay::const_reverse_iterator"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#public-types","text":"Name typedef const_reverse_iterator self_type typedef std::bidirectional_iterator_tag iterator_category typedef int difference_type","title":"Public Types"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#public-functions","text":"Name const_reverse_iterator (const CircularDelay < type, size >:: const_reverse_iterator & it) self_type operator++ () self_type operator++ (int ) self_type operator-- () self_type operator-- (int ) const type & operator* () const type * operator-> () const type & operator[] (int index) bool operator== (const self_type & rhs) bool operator!= (const self_type & rhs)","title":"Public Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#friends","text":"Name class CircularDelay","title":"Friends"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#typedef-self_type","text":"typedef const_reverse_iterator CircularDelay< type, size >::const_reverse_iterator::self_type;","title":"typedef self_type"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#typedef-iterator_category","text":"typedef std::bidirectional_iterator_tag CircularDelay< type, size >::const_reverse_iterator::iterator_category;","title":"typedef iterator_category"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#typedef-difference_type","text":"typedef int CircularDelay< type, size >::const_reverse_iterator::difference_type;","title":"typedef difference_type"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#function-const_reverse_iterator","text":"inline const_reverse_iterator( const CircularDelay< type, size >::const_reverse_iterator & it )","title":"function const_reverse_iterator"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#function-operator","text":"inline self_type operator++()","title":"function operator++"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#function-operator_1","text":"inline self_type operator++( int )","title":"function operator++"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#function-operator-","text":"inline self_type operator--()","title":"function operator--"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#function-operator-_1","text":"inline self_type operator--( int )","title":"function operator--"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#function-operator_2","text":"inline const type & operator*()","title":"function operator*"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#function-operator-_2","text":"inline const type * operator->()","title":"function operator-&gt;"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#function-operator_3","text":"inline const type & operator[]( int index )","title":"function operator[]"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#function-operator_4","text":"inline bool operator==( const self_type & rhs )","title":"function operator=="},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#function-operator_5","text":"inline bool operator!=( const self_type & rhs )","title":"function operator!="},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#friends_1","text":"","title":"Friends"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#friend-circulardelay","text":"friend class CircularDelay; Updated on 2022-05-30 at 14:56:42 +0000","title":"friend CircularDelay"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/","text":"CircularDelay::iterator Public Types Name typedef iterator self_type typedef std::bidirectional_iterator_tag iterator_category typedef int difference_type Public Functions Name iterator (const CircularDelay < type, size >:: iterator & it) self_type operator++ () self_type operator++ (int ) self_type operator-- () self_type operator-- (int ) type & operator* () type * operator-> () type & operator[] (unsigned int index) bool operator== (const self_type & rhs) bool operator!= (const self_type & rhs) Friends Name class CircularDelay Public Types Documentation typedef self_type typedef iterator CircularDelay< type, size >::iterator::self_type; typedef iterator_category typedef std::bidirectional_iterator_tag CircularDelay< type, size >::iterator::iterator_category; typedef difference_type typedef int CircularDelay< type, size >::iterator::difference_type; Public Functions Documentation function iterator inline iterator( const CircularDelay< type, size >::iterator & it ) function operator++ inline self_type operator++() function operator++ inline self_type operator++( int ) function operator-- inline self_type operator--() function operator-- inline self_type operator--( int ) function operator* inline type & operator*() function operator-> inline type * operator->() function operator[] inline type & operator[]( unsigned int index ) function operator== inline bool operator==( const self_type & rhs ) function operator!= inline bool operator!=( const self_type & rhs ) Friends friend CircularDelay friend class CircularDelay; Updated on 2022-05-30 at 14:56:42 +0000","title":"CircularDelay::iterator"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#circulardelayiterator","text":"","title":"CircularDelay::iterator"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#public-types","text":"Name typedef iterator self_type typedef std::bidirectional_iterator_tag iterator_category typedef int difference_type","title":"Public Types"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#public-functions","text":"Name iterator (const CircularDelay < type, size >:: iterator & it) self_type operator++ () self_type operator++ (int ) self_type operator-- () self_type operator-- (int ) type & operator* () type * operator-> () type & operator[] (unsigned int index) bool operator== (const self_type & rhs) bool operator!= (const self_type & rhs)","title":"Public Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#friends","text":"Name class CircularDelay","title":"Friends"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#typedef-self_type","text":"typedef iterator CircularDelay< type, size >::iterator::self_type;","title":"typedef self_type"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#typedef-iterator_category","text":"typedef std::bidirectional_iterator_tag CircularDelay< type, size >::iterator::iterator_category;","title":"typedef iterator_category"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#typedef-difference_type","text":"typedef int CircularDelay< type, size >::iterator::difference_type;","title":"typedef difference_type"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#function-iterator","text":"inline iterator( const CircularDelay< type, size >::iterator & it )","title":"function iterator"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#function-operator","text":"inline self_type operator++()","title":"function operator++"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#function-operator_1","text":"inline self_type operator++( int )","title":"function operator++"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#function-operator-","text":"inline self_type operator--()","title":"function operator--"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#function-operator-_1","text":"inline self_type operator--( int )","title":"function operator--"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#function-operator_2","text":"inline type & operator*()","title":"function operator*"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#function-operator-_2","text":"inline type * operator->()","title":"function operator-&gt;"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#function-operator_3","text":"inline type & operator[]( unsigned int index )","title":"function operator[]"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#function-operator_4","text":"inline bool operator==( const self_type & rhs )","title":"function operator=="},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#function-operator_5","text":"inline bool operator!=( const self_type & rhs )","title":"function operator!="},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#friends_1","text":"","title":"Friends"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1iterator/#friend-circulardelay","text":"friend class CircularDelay; Updated on 2022-05-30 at 14:56:42 +0000","title":"friend CircularDelay"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/","text":"CircularDelay::reverse_iterator Public Types Name typedef reverse_iterator self_type typedef std::bidirectional_iterator_tag iterator_category typedef int difference_type Public Functions Name reverse_iterator (const CircularDelay < type, size >:: reverse_iterator & it) self_type operator++ () self_type operator++ (int ) self_type operator-- () self_type operator-- (int ) type & operator* () type * operator-> () type & operator[] (int index) bool operator== (const self_type & rhs) bool operator!= (const self_type & rhs) Friends Name class CircularDelay Public Types Documentation typedef self_type typedef reverse_iterator CircularDelay< type, size >::reverse_iterator::self_type; typedef iterator_category typedef std::bidirectional_iterator_tag CircularDelay< type, size >::reverse_iterator::iterator_category; typedef difference_type typedef int CircularDelay< type, size >::reverse_iterator::difference_type; Public Functions Documentation function reverse_iterator inline reverse_iterator( const CircularDelay< type, size >::reverse_iterator & it ) function operator++ inline self_type operator++() function operator++ inline self_type operator++( int ) function operator-- inline self_type operator--() function operator-- inline self_type operator--( int ) function operator* inline type & operator*() function operator-> inline type * operator->() function operator[] inline type & operator[]( int index ) function operator== inline bool operator==( const self_type & rhs ) function operator!= inline bool operator!=( const self_type & rhs ) Friends friend CircularDelay friend class CircularDelay; Updated on 2022-05-30 at 14:56:42 +0000","title":"CircularDelay::reverse_iterator"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#circulardelayreverse_iterator","text":"","title":"CircularDelay::reverse_iterator"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#public-types","text":"Name typedef reverse_iterator self_type typedef std::bidirectional_iterator_tag iterator_category typedef int difference_type","title":"Public Types"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#public-functions","text":"Name reverse_iterator (const CircularDelay < type, size >:: reverse_iterator & it) self_type operator++ () self_type operator++ (int ) self_type operator-- () self_type operator-- (int ) type & operator* () type * operator-> () type & operator[] (int index) bool operator== (const self_type & rhs) bool operator!= (const self_type & rhs)","title":"Public Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#friends","text":"Name class CircularDelay","title":"Friends"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#typedef-self_type","text":"typedef reverse_iterator CircularDelay< type, size >::reverse_iterator::self_type;","title":"typedef self_type"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#typedef-iterator_category","text":"typedef std::bidirectional_iterator_tag CircularDelay< type, size >::reverse_iterator::iterator_category;","title":"typedef iterator_category"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#typedef-difference_type","text":"typedef int CircularDelay< type, size >::reverse_iterator::difference_type;","title":"typedef difference_type"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#function-reverse_iterator","text":"inline reverse_iterator( const CircularDelay< type, size >::reverse_iterator & it )","title":"function reverse_iterator"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#function-operator","text":"inline self_type operator++()","title":"function operator++"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#function-operator_1","text":"inline self_type operator++( int )","title":"function operator++"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#function-operator-","text":"inline self_type operator--()","title":"function operator--"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#function-operator-_1","text":"inline self_type operator--( int )","title":"function operator--"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#function-operator_2","text":"inline type & operator*()","title":"function operator*"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#function-operator-_2","text":"inline type * operator->()","title":"function operator-&gt;"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#function-operator_3","text":"inline type & operator[]( int index )","title":"function operator[]"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#function-operator_4","text":"inline bool operator==( const self_type & rhs )","title":"function operator=="},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#function-operator_5","text":"inline bool operator!=( const self_type & rhs )","title":"function operator!="},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#friends_1","text":"","title":"Friends"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#friend-circulardelay","text":"friend class CircularDelay; Updated on 2022-05-30 at 14:56:42 +0000","title":"friend CircularDelay"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classDifferentiator/","text":"Differentiator Class for the differentiator. More... #include <differentiator.hpp> Inherits from DigitalFilter< T > Public Functions Name Differentiator (T sampleTime) Constructor to set sample time and the tau constant. virtual T update (T input) Update function to push new value into the differentiator. virtual T getOutput () Gets the output. Detailed Description template <typename T > class Differentiator; Class for the differentiator. Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/DigitalFilters License: GNU Brief: Class for a differentiator, inherited from the DigitalFilter class of moving filters. A differentiator is a filter that is designed such that the output is approximately directly proportionalto the rate of change (the time derivative) of the input. Public Functions Documentation function Differentiator inline Differentiator( T sampleTime ) Constructor to set sample time and the tau constant. Parameters : sampleTime Sample time for the low pass filter function update inline virtual T update( T input ) Update function to push new value into the differentiator. Parameters : input The new value after dt time Return : The new output value Reimplements : DigitalFilter::update function getOutput inline virtual T getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput Updated on 2022-05-30 at 14:56:42 +0000","title":"Differentiator"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classDifferentiator/#differentiator","text":"Class for the differentiator. More... #include <differentiator.hpp> Inherits from DigitalFilter< T >","title":"Differentiator"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classDifferentiator/#public-functions","text":"Name Differentiator (T sampleTime) Constructor to set sample time and the tau constant. virtual T update (T input) Update function to push new value into the differentiator. virtual T getOutput () Gets the output.","title":"Public Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classDifferentiator/#detailed-description","text":"template <typename T > class Differentiator; Class for the differentiator. Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/DigitalFilters License: GNU Brief: Class for a differentiator, inherited from the DigitalFilter class of moving filters. A differentiator is a filter that is designed such that the output is approximately directly proportionalto the rate of change (the time derivative) of the input.","title":"Detailed Description"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classDifferentiator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classDifferentiator/#function-differentiator","text":"inline Differentiator( T sampleTime ) Constructor to set sample time and the tau constant. Parameters : sampleTime Sample time for the low pass filter","title":"function Differentiator"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classDifferentiator/#function-update","text":"inline virtual T update( T input ) Update function to push new value into the differentiator. Parameters : input The new value after dt time Return : The new output value Reimplements : DigitalFilter::update","title":"function update"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classDifferentiator/#function-getoutput","text":"inline virtual T getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput Updated on 2022-05-30 at 14:56:42 +0000","title":"function getOutput"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classDigitalFilter/","text":"DigitalFilter Abstract base class for digital moving filters. More... #include <digital_filter.hpp> Public Functions Name virtual Type update (Type newValue) =0 virtual Type getOutput () =0 Detailed Description template <typename Type > class DigitalFilter; Abstract base class for digital moving filters. Template Parameters : Type Floating point type used. Public Functions Documentation function update virtual Type update( Type newValue ) =0 Reimplemented by : HighPassFilter::update , LowPassFilter::update , LowPassFilter2::update , HighPassFilter3::update , LowPassFilter3::update , LowPassFilter3MatchedZ::update , LowPassFilter3DiffApprox::update , Differentiator::update function getOutput virtual Type getOutput() =0 Reimplemented by : Differentiator::getOutput , LowPassFilter::getOutput , HighPassFilter::getOutput , LowPassFilter2::getOutput , HighPassFilter3::getOutput , LowPassFilter3::getOutput , LowPassFilter3MatchedZ::getOutput , LowPassFilter3DiffApprox::getOutput Updated on 2022-05-30 at 14:56:42 +0000","title":"DigitalFilter"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classDigitalFilter/#digitalfilter","text":"Abstract base class for digital moving filters. More... #include <digital_filter.hpp>","title":"DigitalFilter"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classDigitalFilter/#public-functions","text":"Name virtual Type update (Type newValue) =0 virtual Type getOutput () =0","title":"Public Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classDigitalFilter/#detailed-description","text":"template <typename Type > class DigitalFilter; Abstract base class for digital moving filters. Template Parameters : Type Floating point type used.","title":"Detailed Description"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classDigitalFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classDigitalFilter/#function-update","text":"virtual Type update( Type newValue ) =0 Reimplemented by : HighPassFilter::update , LowPassFilter::update , LowPassFilter2::update , HighPassFilter3::update , LowPassFilter3::update , LowPassFilter3MatchedZ::update , LowPassFilter3DiffApprox::update , Differentiator::update","title":"function update"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classDigitalFilter/#function-getoutput","text":"virtual Type getOutput() =0 Reimplemented by : Differentiator::getOutput , LowPassFilter::getOutput , HighPassFilter::getOutput , LowPassFilter2::getOutput , HighPassFilter3::getOutput , LowPassFilter3::getOutput , LowPassFilter3MatchedZ::getOutput , LowPassFilter3DiffApprox::getOutput Updated on 2022-05-30 at 14:56:42 +0000","title":"function getOutput"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter/","text":"HighPassFilter Class for high pass filter using bilinear transform. More... #include <highpass_filter.hpp> Inherits from DigitalFilter< float > Public Functions Name HighPassFilter (float idt, float omega_c) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the low pass filter. virtual float getOutput () Gets the output. void configOutput (float newOutput) Force the output to a desired value. const float * outputPointer () Detailed Description class HighPassFilter; Class for high pass filter using bilinear transform. Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/DigitalFilters License: GNU Brief: Multiple classes for low pass filters of different orders, inherited from the DigitalFilter class of moving filters. A low-pass filter is a filter that passes signals with a frequency lower than a selected cutoff frequency and attenuates signals with frequencies higher than the cutoff frequency. Public Functions Documentation function HighPassFilter inline HighPassFilter( float idt, float omega_c ) Constructor to set sample time and the tau constant. Parameters : idt Sample time for the low pass filter omega_c Cutoff angular frequency ( \\omega_c = 2 pi f_c) where ( f_c ) is the cutoff frequency function update inline virtual float update( float newValue ) Update function to push new value into the low pass filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update function getOutput inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput function configOutput inline void configOutput( float newOutput ) Force the output to a desired value. Parameters : newOutput The new output This can be useful when the output needs to be forced in case of extreme inputs or such function outputPointer inline const float * outputPointer() Updated on 2022-05-30 at 14:56:42 +0000","title":"HighPassFilter"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter/#highpassfilter","text":"Class for high pass filter using bilinear transform. More... #include <highpass_filter.hpp> Inherits from DigitalFilter< float >","title":"HighPassFilter"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter/#public-functions","text":"Name HighPassFilter (float idt, float omega_c) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the low pass filter. virtual float getOutput () Gets the output. void configOutput (float newOutput) Force the output to a desired value. const float * outputPointer ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter/#detailed-description","text":"class HighPassFilter; Class for high pass filter using bilinear transform. Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/DigitalFilters License: GNU Brief: Multiple classes for low pass filters of different orders, inherited from the DigitalFilter class of moving filters. A low-pass filter is a filter that passes signals with a frequency lower than a selected cutoff frequency and attenuates signals with frequencies higher than the cutoff frequency.","title":"Detailed Description"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter/#function-highpassfilter","text":"inline HighPassFilter( float idt, float omega_c ) Constructor to set sample time and the tau constant. Parameters : idt Sample time for the low pass filter omega_c Cutoff angular frequency ( \\omega_c = 2 pi f_c) where ( f_c ) is the cutoff frequency","title":"function HighPassFilter"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter/#function-update","text":"inline virtual float update( float newValue ) Update function to push new value into the low pass filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update","title":"function update"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter/#function-getoutput","text":"inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput","title":"function getOutput"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter/#function-configoutput","text":"inline void configOutput( float newOutput ) Force the output to a desired value. Parameters : newOutput The new output This can be useful when the output needs to be forced in case of extreme inputs or such","title":"function configOutput"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter/#function-outputpointer","text":"inline const float * outputPointer() Updated on 2022-05-30 at 14:56:42 +0000","title":"function outputPointer"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter3/","text":"HighPassFilter3 Class for third order high pass filter. This is designed using the bilinear transform. #include <highpass_filter.hpp> Inherits from DigitalFilter< float > Public Functions Name HighPassFilter3 (float sampleTime, float omega_c, float ioutput =0) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the low pass filter. virtual float getOutput () Gets the output. Public Functions Documentation function HighPassFilter3 inline HighPassFilter3( float sampleTime, float omega_c, float ioutput =0 ) Constructor to set sample time and the tau constant. Parameters : idt Sample time for the low pass filter omega_c Cutoff angular frequency ( \\omega_c = 2 pi f_c) where ( f_c ) is the cutoff frequency function update inline virtual float update( float newValue ) Update function to push new value into the low pass filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update function getOutput inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput Updated on 2022-05-30 at 14:56:42 +0000","title":"HighPassFilter3"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter3/#highpassfilter3","text":"Class for third order high pass filter. This is designed using the bilinear transform. #include <highpass_filter.hpp> Inherits from DigitalFilter< float >","title":"HighPassFilter3"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter3/#public-functions","text":"Name HighPassFilter3 (float sampleTime, float omega_c, float ioutput =0) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the low pass filter. virtual float getOutput () Gets the output.","title":"Public Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter3/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter3/#function-highpassfilter3","text":"inline HighPassFilter3( float sampleTime, float omega_c, float ioutput =0 ) Constructor to set sample time and the tau constant. Parameters : idt Sample time for the low pass filter omega_c Cutoff angular frequency ( \\omega_c = 2 pi f_c) where ( f_c ) is the cutoff frequency","title":"function HighPassFilter3"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter3/#function-update","text":"inline virtual float update( float newValue ) Update function to push new value into the low pass filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update","title":"function update"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classHighPassFilter3/#function-getoutput","text":"inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput Updated on 2022-05-30 at 14:56:42 +0000","title":"function getOutput"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter/","text":"LowPassFilter Class for a low pass filter. More... #include <lowpass_filter.hpp> Inherits from DigitalFilter< float > Public Functions Name LowPassFilter (float idt, float omega_c, float ioutput =0) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the low pass filter. virtual float getOutput () Gets the output. void configOutput (float newOutput) Force the output to a desired value. const float * outputPointer () Detailed Description class LowPassFilter; Class for a low pass filter. Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/DigitalFilters License: GNU Brief: Multiple classes for low pass filters of different orders, inherited from the DigitalFilter class of moving filters. A low-pass filter is a filter that passes signals with a frequency lower than a selected cutoff frequency and attenuates signals with frequencies higher than the cutoff frequency. Design to be a first order Butterworth low pass filter. Transformation done using the matched-Z-transform method Public Functions Documentation function LowPassFilter inline LowPassFilter( float idt, float omega_c, float ioutput =0 ) Constructor to set sample time and the tau constant. Parameters : idt Sample time for the low pass filter omega_c Cutoff angular frequency ( \\omega_c = 2 pi f_c) where ( f_c ) is the cutoff frequency function update inline virtual float update( float newValue ) Update function to push new value into the low pass filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update function getOutput inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput function configOutput inline void configOutput( float newOutput ) Force the output to a desired value. Parameters : newOutput The new output This can be useful when the output needs to be forced in case of extreme inputs or such function outputPointer inline const float * outputPointer() Updated on 2022-05-30 at 14:56:42 +0000","title":"LowPassFilter"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter/#lowpassfilter","text":"Class for a low pass filter. More... #include <lowpass_filter.hpp> Inherits from DigitalFilter< float >","title":"LowPassFilter"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter/#public-functions","text":"Name LowPassFilter (float idt, float omega_c, float ioutput =0) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the low pass filter. virtual float getOutput () Gets the output. void configOutput (float newOutput) Force the output to a desired value. const float * outputPointer ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter/#detailed-description","text":"class LowPassFilter; Class for a low pass filter. Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/DigitalFilters License: GNU Brief: Multiple classes for low pass filters of different orders, inherited from the DigitalFilter class of moving filters. A low-pass filter is a filter that passes signals with a frequency lower than a selected cutoff frequency and attenuates signals with frequencies higher than the cutoff frequency. Design to be a first order Butterworth low pass filter. Transformation done using the matched-Z-transform method","title":"Detailed Description"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter/#function-lowpassfilter","text":"inline LowPassFilter( float idt, float omega_c, float ioutput =0 ) Constructor to set sample time and the tau constant. Parameters : idt Sample time for the low pass filter omega_c Cutoff angular frequency ( \\omega_c = 2 pi f_c) where ( f_c ) is the cutoff frequency","title":"function LowPassFilter"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter/#function-update","text":"inline virtual float update( float newValue ) Update function to push new value into the low pass filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update","title":"function update"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter/#function-getoutput","text":"inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput","title":"function getOutput"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter/#function-configoutput","text":"inline void configOutput( float newOutput ) Force the output to a desired value. Parameters : newOutput The new output This can be useful when the output needs to be forced in case of extreme inputs or such","title":"function configOutput"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter/#function-outputpointer","text":"inline const float * outputPointer() Updated on 2022-05-30 at 14:56:42 +0000","title":"function outputPointer"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter2/","text":"LowPassFilter2 Class for a 2nd order low pass filter. More... #include <lowpass_filter.hpp> Inherits from DigitalFilter< float > Public Functions Name LowPassFilter2 (float dt, float tau_c, float ioutput =0) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the filter. virtual float getOutput () Gets the output. void configOutput (float newOutput) Force the output to a desired value. Detailed Description class LowPassFilter2; Class for a 2nd order low pass filter. Design to be a 2nd order Butterworth low pass filter. Transformation done using the bilinear transform method Public Functions Documentation function LowPassFilter2 inline LowPassFilter2( float dt, float tau_c, float ioutput =0 ) Constructor to set sample time and the tau constant. Parameters : dt Sample time for the low pass filter tau_c The time constant for the filter ( \\tau_c = \\frac{1}{2 pi f_c}), where ( f_c ) is the cutoff frequency function update inline virtual float update( float newValue ) Update function to push new value into the filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update function getOutput inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput function configOutput inline void configOutput( float newOutput ) Force the output to a desired value. Parameters : newOutput The new output This can be useful when the output needs to be forced in case of extreme inputs or such Updated on 2022-05-30 at 14:56:42 +0000","title":"LowPassFilter2"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter2/#lowpassfilter2","text":"Class for a 2nd order low pass filter. More... #include <lowpass_filter.hpp> Inherits from DigitalFilter< float >","title":"LowPassFilter2"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter2/#public-functions","text":"Name LowPassFilter2 (float dt, float tau_c, float ioutput =0) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the filter. virtual float getOutput () Gets the output. void configOutput (float newOutput) Force the output to a desired value.","title":"Public Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter2/#detailed-description","text":"class LowPassFilter2; Class for a 2nd order low pass filter. Design to be a 2nd order Butterworth low pass filter. Transformation done using the bilinear transform method","title":"Detailed Description"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter2/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter2/#function-lowpassfilter2","text":"inline LowPassFilter2( float dt, float tau_c, float ioutput =0 ) Constructor to set sample time and the tau constant. Parameters : dt Sample time for the low pass filter tau_c The time constant for the filter ( \\tau_c = \\frac{1}{2 pi f_c}), where ( f_c ) is the cutoff frequency","title":"function LowPassFilter2"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter2/#function-update","text":"inline virtual float update( float newValue ) Update function to push new value into the filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update","title":"function update"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter2/#function-getoutput","text":"inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput","title":"function getOutput"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter2/#function-configoutput","text":"inline void configOutput( float newOutput ) Force the output to a desired value. Parameters : newOutput The new output This can be useful when the output needs to be forced in case of extreme inputs or such Updated on 2022-05-30 at 14:56:42 +0000","title":"function configOutput"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3/","text":"LowPassFilter3 Class for third order high pass filter. This is designed using the bilinear transform. #include <lowpass_filter.hpp> Inherits from DigitalFilter< float > Public Functions Name LowPassFilter3 (float sampleTime, float omega_c, float ioutput =0) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the filter. virtual float getOutput () Gets the output. Public Functions Documentation function LowPassFilter3 inline LowPassFilter3( float sampleTime, float omega_c, float ioutput =0 ) Constructor to set sample time and the tau constant. Parameters : sampleTime Sample time for the low pass filter omega_c Cutoff angular frequency ( \\omega_c = 2 pi f_c) where ( f_c ) is the cutoff frequency function update inline virtual float update( float newValue ) Update function to push new value into the filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update function getOutput inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput Updated on 2022-05-30 at 14:56:42 +0000","title":"LowPassFilter3"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3/#lowpassfilter3","text":"Class for third order high pass filter. This is designed using the bilinear transform. #include <lowpass_filter.hpp> Inherits from DigitalFilter< float >","title":"LowPassFilter3"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3/#public-functions","text":"Name LowPassFilter3 (float sampleTime, float omega_c, float ioutput =0) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the filter. virtual float getOutput () Gets the output.","title":"Public Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3/#function-lowpassfilter3","text":"inline LowPassFilter3( float sampleTime, float omega_c, float ioutput =0 ) Constructor to set sample time and the tau constant. Parameters : sampleTime Sample time for the low pass filter omega_c Cutoff angular frequency ( \\omega_c = 2 pi f_c) where ( f_c ) is the cutoff frequency","title":"function LowPassFilter3"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3/#function-update","text":"inline virtual float update( float newValue ) Update function to push new value into the filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update","title":"function update"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3/#function-getoutput","text":"inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput Updated on 2022-05-30 at 14:56:42 +0000","title":"function getOutput"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3DiffApprox/","text":"LowPassFilter3DiffApprox Class for third order high pass filter. This is designed using the approximated differtial approuch where s=(Z-1)/(Z*T). #include <lowpass_filter.hpp> Inherits from DigitalFilter< float > Public Functions Name LowPassFilter3DiffApprox (float sampleTime, float omega_c, float ioutput =0) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the filter. virtual float getOutput () Gets the output. Public Functions Documentation function LowPassFilter3DiffApprox inline LowPassFilter3DiffApprox( float sampleTime, float omega_c, float ioutput =0 ) Constructor to set sample time and the tau constant. Parameters : sampleTime Sample time for the low pass filter omega_c Cutoff angular frequency ( \\omega_c = 2 pi f_c) where ( f_c ) is the cutoff frequency function update inline virtual float update( float newValue ) Update function to push new value into the filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update function getOutput inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput Updated on 2022-05-30 at 14:56:42 +0000","title":"LowPassFilter3DiffApprox"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3DiffApprox/#lowpassfilter3diffapprox","text":"Class for third order high pass filter. This is designed using the approximated differtial approuch where s=(Z-1)/(Z*T). #include <lowpass_filter.hpp> Inherits from DigitalFilter< float >","title":"LowPassFilter3DiffApprox"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3DiffApprox/#public-functions","text":"Name LowPassFilter3DiffApprox (float sampleTime, float omega_c, float ioutput =0) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the filter. virtual float getOutput () Gets the output.","title":"Public Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3DiffApprox/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3DiffApprox/#function-lowpassfilter3diffapprox","text":"inline LowPassFilter3DiffApprox( float sampleTime, float omega_c, float ioutput =0 ) Constructor to set sample time and the tau constant. Parameters : sampleTime Sample time for the low pass filter omega_c Cutoff angular frequency ( \\omega_c = 2 pi f_c) where ( f_c ) is the cutoff frequency","title":"function LowPassFilter3DiffApprox"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3DiffApprox/#function-update","text":"inline virtual float update( float newValue ) Update function to push new value into the filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update","title":"function update"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3DiffApprox/#function-getoutput","text":"inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput Updated on 2022-05-30 at 14:56:42 +0000","title":"function getOutput"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3MatchedZ/","text":"LowPassFilter3MatchedZ Class for third order low pass filter. This is designed using the matched Z transform. #include <lowpass_filter.hpp> Inherits from DigitalFilter< float > Public Functions Name LowPassFilter3MatchedZ (float sampleTime, float omega_c) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the filter. virtual float getOutput () Gets the output. Public Functions Documentation function LowPassFilter3MatchedZ inline LowPassFilter3MatchedZ( float sampleTime, float omega_c ) Constructor to set sample time and the tau constant. Parameters : sampleTime Sample time for the low pass filter omega_c Cutoff angular frequency ( \\omega_c = 2 pi f_c) where ( f_c ) is the cutoff frequency function update inline virtual float update( float newValue ) Update function to push new value into the filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update function getOutput inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput Updated on 2022-05-30 at 14:56:42 +0000","title":"LowPassFilter3MatchedZ"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3MatchedZ/#lowpassfilter3matchedz","text":"Class for third order low pass filter. This is designed using the matched Z transform. #include <lowpass_filter.hpp> Inherits from DigitalFilter< float >","title":"LowPassFilter3MatchedZ"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3MatchedZ/#public-functions","text":"Name LowPassFilter3MatchedZ (float sampleTime, float omega_c) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the filter. virtual float getOutput () Gets the output.","title":"Public Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3MatchedZ/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3MatchedZ/#function-lowpassfilter3matchedz","text":"inline LowPassFilter3MatchedZ( float sampleTime, float omega_c ) Constructor to set sample time and the tau constant. Parameters : sampleTime Sample time for the low pass filter omega_c Cutoff angular frequency ( \\omega_c = 2 pi f_c) where ( f_c ) is the cutoff frequency","title":"function LowPassFilter3MatchedZ"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3MatchedZ/#function-update","text":"inline virtual float update( float newValue ) Update function to push new value into the filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update","title":"function update"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classLowPassFilter3MatchedZ/#function-getoutput","text":"inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput Updated on 2022-05-30 at 14:56:42 +0000","title":"function getOutput"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classMovingAvarageFilter/","text":"MovingAvarageFilter More... #include <moving_average_filter.hpp> Public Functions Name double update (double input) Update function to push new value into the moving average filter. Detailed Description template <size_t size> class MovingAvarageFilter; Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/DigitalFilters License: GNU Brief: Class for a moving average filter, inherited from the DigitalFilter class of moving filters. A moving average filter is operates by averaging a number of points from the input signal to produce each point in the output signal. Public Functions Documentation function update inline double update( double input ) Update function to push new value into the moving average filter. Parameters : input The new value after dt time Return : The new output value Updated on 2022-05-30 at 14:56:42 +0000","title":"MovingAvarageFilter"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classMovingAvarageFilter/#movingavaragefilter","text":"More... #include <moving_average_filter.hpp>","title":"MovingAvarageFilter"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classMovingAvarageFilter/#public-functions","text":"Name double update (double input) Update function to push new value into the moving average filter.","title":"Public Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classMovingAvarageFilter/#detailed-description","text":"template <size_t size> class MovingAvarageFilter; Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/DigitalFilters License: GNU Brief: Class for a moving average filter, inherited from the DigitalFilter class of moving filters. A moving average filter is operates by averaging a number of points from the input signal to produce each point in the output signal.","title":"Detailed Description"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classMovingAvarageFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/classMovingAvarageFilter/#function-update","text":"inline double update( double input ) Update function to push new value into the moving average filter. Parameters : input The new value after dt time Return : The new output value Updated on 2022-05-30 at 14:56:42 +0000","title":"function update"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/structDSOR_1_1VehicleState/","text":"DSOR::VehicleState State class - used to save the state of a vehicle (using SNAME convention) More... #include <vehicle_state.hpp> Public Attributes Name Eigen::Vector3d eta1 Eigen::Vector3d eta2 Eigen::Vector3d v1 Eigen::Vector3d v2 Detailed Description struct DSOR::VehicleState; State class - used to save the state of a vehicle (using SNAME convention) Author : Eduardo Cunha Andre Potes Marcelo Jacinto Version : 1.0.0 Date : 2022/05/26 Copyright : MIT Public Attributes Documentation variable eta1 Eigen::Vector3d eta1 {0.0, 0.0, 0.0}; The position of the vehicle expressed in the inertial frame eta1=[x,y,z]^T variable eta2 Eigen::Vector3d eta2 {0.0, 0.0, 0.0}; The orientation of the vehicle expressed in the inertial frame, using euler angles eta2=[roll, pitch, yaw]^T variable v1 Eigen::Vector3d v1 {0.0, 0.0, 0.0}; The body velocity of the vehicle v1=[u,v,w]^T variable v2 Eigen::Vector3d v2 {0.0, 0.0, 0.0}; The body angular velocity of the vehicle v2=[p,q,r]^T Updated on 2022-05-30 at 14:56:42 +0000","title":"DSOR::VehicleState"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/structDSOR_1_1VehicleState/#dsorvehiclestate","text":"State class - used to save the state of a vehicle (using SNAME convention) More... #include <vehicle_state.hpp>","title":"DSOR::VehicleState"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/structDSOR_1_1VehicleState/#public-attributes","text":"Name Eigen::Vector3d eta1 Eigen::Vector3d eta2 Eigen::Vector3d v1 Eigen::Vector3d v2","title":"Public Attributes"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/structDSOR_1_1VehicleState/#detailed-description","text":"struct DSOR::VehicleState; State class - used to save the state of a vehicle (using SNAME convention) Author : Eduardo Cunha Andre Potes Marcelo Jacinto Version : 1.0.0 Date : 2022/05/26 Copyright : MIT","title":"Detailed Description"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/structDSOR_1_1VehicleState/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/structDSOR_1_1VehicleState/#variable-eta1","text":"Eigen::Vector3d eta1 {0.0, 0.0, 0.0}; The position of the vehicle expressed in the inertial frame eta1=[x,y,z]^T","title":"variable eta1"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/structDSOR_1_1VehicleState/#variable-eta2","text":"Eigen::Vector3d eta2 {0.0, 0.0, 0.0}; The orientation of the vehicle expressed in the inertial frame, using euler angles eta2=[roll, pitch, yaw]^T","title":"variable eta2"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/structDSOR_1_1VehicleState/#variable-v1","text":"Eigen::Vector3d v1 {0.0, 0.0, 0.0}; The body velocity of the vehicle v1=[u,v,w]^T","title":"variable v1"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Classes/structDSOR_1_1VehicleState/#variable-v2","text":"Eigen::Vector3d v2 {0.0, 0.0, 0.0}; The body angular velocity of the vehicle v2=[p,q,r]^T Updated on 2022-05-30 at 14:56:42 +0000","title":"variable v2"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Examples/","text":"Examples Updated on 2022-05-30 at 14:56:42 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Examples/#examples","text":"Updated on 2022-05-30 at 14:56:42 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Modules/","text":"Modules Updated on 2022-05-30 at 14:56:42 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Modules/#modules","text":"Updated on 2022-05-30 at 14:56:42 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/","text":"Namespaces namespace DSOR namespace tps Updated on 2022-05-30 at 14:56:42 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/#namespaces","text":"namespace DSOR namespace tps Updated on 2022-05-30 at 14:56:42 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/","text":"DSOR More... Classes Name struct DSOR::VehicleState State class - used to save the state of a vehicle (using SNAME convention) Functions Name template <typename T > T saturateControlDepthUsingMinAltitude (T depth_command, T altitude_min, T measured_depth, T measured_altitude) Method to saturate the control in depth. template <typename T > T saturateControlAltitudeUsingMinAltitude (T altitude_command, T altitude_min) Method to saturate the control in altitude. template <typename T > T saturateControlDepthUsingMaxDepth (T depth_command, T max_depth) Method to saturate the control in depth. template <typename T > T saturateControlAltitudeUsingMaxDepth (T altitude_command, T measured_depth, T measured_altitude, T max_depth) Method to saturate the control in altitude. const Eigen::PermutationMatrix< 3 > NED_ENU_REFLECTION_XY (Eigen::Vector3i(1, 0, 2) ) Use reflections instead of rotations for NED <-> ENU transformation to avoid NaN/Inf floating point pollution across different axes since in NED <-> ENU the axes are perfectly aligned. template <typename T > const Eigen::DiagonalMatrix< T, 3 > NED_ENU_REFLECTION_Z (1 , 1 , - 1) template <typename T > Eigen::Quaternion< T > rot_body_rotation (const Eigen::Quaternion< T > & q) Transform a rotation (as a quaternion) from body expressed in ENU (or NED) to inertial frame to a similar rotation (as quaternion) from body expressed in NED (or ENU) to inertial frame. template <typename T > Eigen::Quaternion< T > rot_inertial_rotation (const Eigen::Quaternion< T > & q) Transform a rotation (as a quaternion) from body to inertial frame expressed in ENU (or NED) to a similar rotation (as quaternion) from body to inertial frame expressed in NED (or ENU) template <typename T > Eigen::Quaternion< T > rot_body_to_inertial (const Eigen::Quaternion< T > & q) Transform a rotation of a rigid body (as a quaternion) from body (ENU or NED) to inertial frame (ENU or NED) to a similar rotation (as quaternion) from body (NED or ENU) to inertial frame (NED or ENU) template <typename T > Eigen::Matrix< T, 3, 1 > transform_vect_body_enu_ned (const Eigen::Matrix< T, 3, 1 > & vec) Transform vector in ENU (or NED) to NED (or ENU), expressed in body-frame. +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU). template <typename T > Eigen::Matrix< T, 3, 1 > transform_vect_between_arbitrary_ref (const Eigen::Matrix< T, 3, 1 > & vec, const Eigen::Quaternion< T > & q) Transform a vector in a given frame of reference to another frame of reference. template <typename T > Eigen::Matrix< T, 3, 1 > transform_vect_inertial_enu_ned (const Eigen::Matrix< T, 3, 1 > & vec) Transform vector in ENU (or NED) to NED (or ENU), expressed in inertial-frame. ENU <\u2014> NED - Invert the Z axis and switch the XY axis. template <typename T > Eigen::Matrix< T, 3, 3 > transform_cov3_body_enu_ned (const Eigen::Matrix< T, 3, 3 > & cov_in) Transform 3x3 covariance matrix in ENU (or NED) to NED (or ENU), expressed in body-frame. template <typename T > Eigen::Matrix< T, 3, 3 > transform_cov3_inertial_enu_ned (const Eigen::Matrix< T, 3, 3 > & cov_in) Transform 3x3 covariance matrix in ENU (or NED) to NED (or ENU), expressed in inertial-frame. template <typename T > int sign (T v) Returns the sign of the number. template <typename T > T saturation (T value, T min, T max) A function that saturates 2 values linearly. template <typename T > bool approximatelyEquals (T a, T b, T tolerance =1e-6) A function to check if two numbers are equal (int, float, double, etc) template <typename T > Eigen::Matrix< T, 3, 1 > quaternion_to_euler (const Eigen::Quaternion< T > & q) Function to convert from quaternion to (roll, pitch and yaw), according to Z-Y-X convention This function is from: https://github.com/mavlink/mavros/issues/444 and the logic is also available at: https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles . template <typename T > Eigen::Quaternion< T > euler_to_quaternion (const Eigen::Matrix< T, 3, 1 > & v) Converts a vector of euler angles according to Z-Y-X convention into a quaternion. template <typename T > T yaw_from_quaternion (const Eigen::Quaternion< T > & q) Gets the yaw angle from a quaternion (assumed a Z-Y-X rotation) NOTE: this function is based on: https://github.com/mavlink/mavros/blob/ros2/mavros/src/lib/ftf_quaternion_utils.cpp which in turn has the theory explained in: https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles . template <typename T > T wrapTo2pi (T angle) Wrap angle between [0, 2PI]. template <typename T > T wrapTopi (T angle) Wrap angle between [-PI, PI]. template <typename T > T radToDeg (T angle) Convert an angle in radian to degrees. template <typename T > T degToRad (T angle) Convert an angle in degrees to radians. template <typename T > T angleDiff (T a, T b) Method to calculate the diference between angles correctly even if they wrap between -pi and pi. template <typename T > Eigen::Matrix< T, 3, 3 > computeSkewSymmetric3 (const Eigen::Matrix< T, 3, 1 > & v) Compute the 3x3 skew-symmetric matrix from a vector 3x1. template <typename T > Eigen::Matrix< T, 2, 2 > computeSkewSymmetric2 (T c) Compute the 2x2 skew-symmetric matrix from a constant (int, float or double) template <typename T > Eigen::Matrix< T, 3, 3 > rotationAngularBodyToInertial (const Eigen::Matrix< T, 3, 1 > & v) Compute the rotation matrix that converts angular velocities expressed in the body frame to angular velocities expressed in the inertial frame (according to Z-Y-X convention) - makes use of small angle approximation. template <typename T > Eigen::Matrix< T, 3, 3 > rotationBodyToInertial (const Eigen::Matrix< T, 3, 1 > & v) Method that returns a rotation matrix from body frame to inertial frame, assuming a Z-Y-X convention. template <typename T > Eigen::Matrix< T, 3, 1 > spherical_to_cartesian (T bearing, T elevation, T range) Convert from spherical to cartesian coordinates. Used mainly with usbl fixes. Attributes Name const Eigen::Quaternion< T > ENU_NED_INERTIAL_Q Static quaternion to convert a rotation expressed in ENU to a rotation expressed in NED (Z->Y->X convention) on the inertial frame Rotate PI/2 about Z-axis -> Rotate 0 about Y-axis -> Rotate PI about X-axis. const Eigen::Quaternion< T > ENU_NED_BODY_Q Static quaternion to convert a rotation expressed in ENU body frame (ROS base_link) to a rotation expressed in NED body frame (Z->Y->X convention) Rotate 0 about Z-axis -> Rotate 0 about Y-axis -> Rotate PI about X-axis. const Eigen::Quaternion< T > BODY_ENU_NED_Q Static quaternion needed for rotating vectors in body frames between ENU and NED +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU). const Eigen::Transform< T, 3, Eigen::Affine > BODY_ENU_NED_TF Static affine matrix to roate vectors ENU (or NED) -> NED (or ENU) expressed in body frame +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU). Detailed Description Authors: Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 10/02/2022 License: MIT File: [vehicle_saturations.hpp] Brief: Defines functions used for saturating the vehicle inputs to the system Authors: Andr\u00e9 Potes ( andre.potes@gmail.com ) Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 14/12/2021 License: MIT File: [frames.hpp] Brief: Defines all functions related to conversions between ENU do NED frames and vice-versa NOTE: Most of this code is adapted from mavros https://github.com/mavlink/mavros/blob/master/mavros/src/lib/ftf_frame_conversions.cpp which had as authors Nuno Marques ( n.marques21@hotmail.com ) and Eddy Scott ( scott.edward@aurora.aero ) Authors: Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Joao Quintas ( jquintas@gmail.com ) Joao Cruz ( joao.pedro.cruz@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 14/12/2021 License: MIT File: [math.hpp] Brief: Defines all functions related to general math functions that can be used anywhere Authors: Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Andre Potes ( andre.potes@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 14/12/2021 License: MIT File: [rotations.hpp] Brief: Defines all functions related to angle wrapping, rotation matrices, euler angles, convertion to quaternions, etc. Authors: Joao Quintas ( jquintas@gmail.com ) Joao Cruz ( joao.pedro.cruz@tecnico.ulisboa.pt ) Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 14/12/2021 License: MIT File: [spherical_coordinates.hpp] Brief: Defines all functions related to spherical coordinates conversions Functions Documentation function saturateControlDepthUsingMinAltitude template <typename T > inline T saturateControlDepthUsingMinAltitude( T depth_command, T altitude_min, T measured_depth, T measured_altitude ) Method to saturate the control in depth. Parameters : depth_command The input command in depth altitude_min The minimum altitude (positive distance from the vehicle to the bottom in m) measured_depth The measured depth of the vehicle measured_altitude The measured altitude of the vehicle Return : The saturated control of depth such that the vehicle does not surpass the minimum altitude function saturateControlAltitudeUsingMinAltitude template <typename T > inline T saturateControlAltitudeUsingMinAltitude( T altitude_command, T altitude_min ) Method to saturate the control in altitude. Parameters : altitude_command The input command in altitude altitude_min The minimum altitude to keep from the ground Return : The output command of the altitude saturated such that the vehicle does not surpass the minimum altitude function saturateControlDepthUsingMaxDepth template <typename T > inline T saturateControlDepthUsingMaxDepth( T depth_command, T max_depth ) Method to saturate the control in depth. Parameters : depth_command The input command in depth max_depth The max depth Return : The output command of the depth saturated such that the vehicle does not surpass the maximum depth function saturateControlAltitudeUsingMaxDepth template <typename T > inline T saturateControlAltitudeUsingMaxDepth( T altitude_command, T measured_depth, T measured_altitude, T max_depth ) Method to saturate the control in altitude. Parameters : altitude_command The input command in altitude measured_depth The measured depth of the vehicle measured_altitude The measured altitude of the vehicle max_depth The maximum depth allowed Return : The output command of the altitude saturated such that the vehicle does not surpass the maximum depth function NED_ENU_REFLECTION_XY static const Eigen::PermutationMatrix< 3 > NED_ENU_REFLECTION_XY( Eigen::Vector3i(1, 0, 2) ) Use reflections instead of rotations for NED <-> ENU transformation to avoid NaN/Inf floating point pollution across different axes since in NED <-> ENU the axes are perfectly aligned. function NED_ENU_REFLECTION_Z template <typename T > static const Eigen::DiagonalMatrix< T, 3 > NED_ENU_REFLECTION_Z( 1 , 1 , - 1 ) function rot_body_rotation template <typename T > inline Eigen::Quaternion< T > rot_body_rotation( const Eigen::Quaternion< T > & q ) Transform a rotation (as a quaternion) from body expressed in ENU (or NED) to inertial frame to a similar rotation (as quaternion) from body expressed in NED (or ENU) to inertial frame. Parameters : q quaternion representing a rotation: body frame ENU (or NED) -> inertial frame (in arbitrary convention) Return : quaternion represeting a rotation: body frame NED (or ENU) -> inertial frame (in arbitrary convention) NOTE: Check http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/transforms/ for more details behind these type of transformations towards obtaining rotations in different frames of reference. function rot_inertial_rotation template <typename T > inline Eigen::Quaternion< T > rot_inertial_rotation( const Eigen::Quaternion< T > & q ) Transform a rotation (as a quaternion) from body to inertial frame expressed in ENU (or NED) to a similar rotation (as quaternion) from body to inertial frame expressed in NED (or ENU) Parameters : q quaternion representing a rotation: body frame (in arbitrary convention) -> inertial frame ENU (or NED) Return : quaternion represeting a rotation: body frame (in arbitrary convention) -> inertial frame NED (or ENU) NOTE: Check http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/transforms/ for more details behind these type of transformations towards obtaining rotations in different frames of reference. function rot_body_to_inertial template <typename T > inline Eigen::Quaternion< T > rot_body_to_inertial( const Eigen::Quaternion< T > & q ) Transform a rotation of a rigid body (as a quaternion) from body (ENU or NED) to inertial frame (ENU or NED) to a similar rotation (as quaternion) from body (NED or ENU) to inertial frame (NED or ENU) Parameters : q quaternion representing a rotation: body frame (ENU or NED) -> inertial frame (ENU or NED) Return : quaternion representing a rotation: body frame (NED or ENU) -> inertial frame (NED or ENU) NOTE: This function is usefull to convert the attitude of a vehicle from \"ROS\" quaternion to a typicall literature quaternion (where both the body frame and inertial frames are in ENU). If you are converting a quaternion that expresses the orientation of a sensor with respect to a rigid body's body frame (and not the inertial frame), then you DO NOT WANT TO USE THIS FUNCTION. Body-FRAME NED is not the same as INERTIAL-FRAME NED (this comes once again from the fact that in ned body the x-y axis don't switch like in inertial frame) as explained in the documentation. Essencial only use this if you are representing a body in inertial frame! NOTE: Check http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/transforms/ for more details behind these type of transformations towards obtaining rotations in different frames of reference. function transform_vect_body_enu_ned template <typename T > inline Eigen::Matrix< T, 3, 1 > transform_vect_body_enu_ned( const Eigen::Matrix< T, 3, 1 > & vec ) Transform vector in ENU (or NED) to NED (or ENU), expressed in body-frame. +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU). Parameters : vec Vector expressed in body-frame (ENU or NED) Return : Vector expressed in body-frame (NED or ENU) function transform_vect_between_arbitrary_ref template <typename T > inline Eigen::Matrix< T, 3, 1 > transform_vect_between_arbitrary_ref( const Eigen::Matrix< T, 3, 1 > & vec, const Eigen::Quaternion< T > & q ) Transform a vector in a given frame of reference to another frame of reference. Parameters : vec Vector expressed in the original frame of reference q Quaternion that expresses the orientation of the original frame of reference with respect to the final frame of reference Return : Vector expressed in the new frame of reference function transform_vect_inertial_enu_ned template <typename T > inline Eigen::Matrix< T, 3, 1 > transform_vect_inertial_enu_ned( const Eigen::Matrix< T, 3, 1 > & vec ) Transform vector in ENU (or NED) to NED (or ENU), expressed in inertial-frame. ENU <\u2014> NED - Invert the Z axis and switch the XY axis. Parameters : vec Vector expressed in inertial-frame (ENU or NED) Return : Vector expressed in inertial-frame (NED or ENU) function transform_cov3_body_enu_ned template <typename T > inline Eigen::Matrix< T, 3, 3 > transform_cov3_body_enu_ned( const Eigen::Matrix< T, 3, 3 > & cov_in ) Transform 3x3 covariance matrix in ENU (or NED) to NED (or ENU), expressed in body-frame. Parameters : cov_in Covariance matrix expressed in body-frame (ENU or NED) Return : Covariance matrix expressed in body-frame (NED or ENU) NOTE: Check https://robotics.stackexchange.com/questions/2556/how-to-rotate-covariance for a detailed explanation of the actual conversion proof for covariance matrices function transform_cov3_inertial_enu_ned template <typename T > inline Eigen::Matrix< T, 3, 3 > transform_cov3_inertial_enu_ned( const Eigen::Matrix< T, 3, 3 > & cov_in ) Transform 3x3 covariance matrix in ENU (or NED) to NED (or ENU), expressed in inertial-frame. Parameters : cov_in Covariance matrix expressed in inertial-frame (ENU or NED) Return : Covariance matrix expressed in inertial-frame (NED or ENU) NOTE: Check https://robotics.stackexchange.com/questions/2556/how-to-rotate-covariance for a detailed explanation of the actual conversion proof for covariance matrices function sign template <typename T > inline int sign( T v ) Returns the sign of the number. Parameters : v A number Return : 1 if value is positive 0 if value is 0 -1 if value is negative function saturation template <typename T > inline T saturation( T value, T min, T max ) A function that saturates 2 values linearly. Parameters : value A number to saturate min The minimum value max The maximum value Return : A value such that value in [min, max] function approximatelyEquals template <typename T > inline bool approximatelyEquals( T a, T b, T tolerance =1e-6 ) A function to check if two numbers are equal (int, float, double, etc) Parameters : a a number to compare b another number to compare tolerance tolerance of comparison Return : A boolean for true if equal within tolerance, or otherwise function quaternion_to_euler template <typename T > inline Eigen::Matrix< T, 3, 1 > quaternion_to_euler( const Eigen::Quaternion< T > & q ) Function to convert from quaternion to (roll, pitch and yaw), according to Z-Y-X convention This function is from: https://github.com/mavlink/mavros/issues/444 and the logic is also available at: https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles . Parameters : q An eigen quaternion Return : A Vector with the [roll, pitch, yaw] obtained according to Z-Y-X convention function euler_to_quaternion template <typename T > inline Eigen::Quaternion< T > euler_to_quaternion( const Eigen::Matrix< T, 3, 1 > & v ) Converts a vector of euler angles according to Z-Y-X convention into a quaternion. Parameters : v An eigen vector of either floats or doubles [roll, pitch, yaw] Return : An Eigen Quaternion function yaw_from_quaternion template <typename T > inline T yaw_from_quaternion( const Eigen::Quaternion< T > & q ) Gets the yaw angle from a quaternion (assumed a Z-Y-X rotation) NOTE: this function is based on: https://github.com/mavlink/mavros/blob/ros2/mavros/src/lib/ftf_quaternion_utils.cpp which in turn has the theory explained in: https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles . Parameters : q A eigen quaternion Return : The yaw angle in radians (assumed a Z-Y-X rotation) function wrapTo2pi template <typename T > inline T wrapTo2pi( T angle ) Wrap angle between [0, 2PI]. Parameters : angle angle in radians Return : The wraped angle function wrapTopi template <typename T > inline T wrapTopi( T angle ) Wrap angle between [-PI, PI]. Parameters : angle angle in radians Return : The wraped angle function radToDeg template <typename T > inline T radToDeg( T angle ) Convert an angle in radian to degrees. Parameters : angle in radians Return : angle in degrees function degToRad template <typename T > inline T degToRad( T angle ) Convert an angle in degrees to radians. Parameters : angle in degrees Return : angle in radians function angleDiff template <typename T > inline T angleDiff( T a, T b ) Method to calculate the diference between angles correctly even if they wrap between -pi and pi. Parameters : a angle 1 in radians b angle 2 in radians Return : The minimum difference between the two angles function computeSkewSymmetric3 template <typename T > inline Eigen::Matrix< T, 3, 3 > computeSkewSymmetric3( const Eigen::Matrix< T, 3, 1 > & v ) Compute the 3x3 skew-symmetric matrix from a vector 3x1. Parameters : v A vector with 3 elements Return : A 3x3 skew-symmetric matrix function computeSkewSymmetric2 template <typename T > inline Eigen::Matrix< T, 2, 2 > computeSkewSymmetric2( T c ) Compute the 2x2 skew-symmetric matrix from a constant (int, float or double) Parameters : v A constant Return : A 2x2 skew-symmetric matrix function rotationAngularBodyToInertial template <typename T > inline Eigen::Matrix< T, 3, 3 > rotationAngularBodyToInertial( const Eigen::Matrix< T, 3, 1 > & v ) Compute the rotation matrix that converts angular velocities expressed in the body frame to angular velocities expressed in the inertial frame (according to Z-Y-X convention) - makes use of small angle approximation. Parameters : v A vector with 3 elements (roll, pitch, yaw) Return : A 3x3 rotation matrix function rotationBodyToInertial template <typename T > inline Eigen::Matrix< T, 3, 3 > rotationBodyToInertial( const Eigen::Matrix< T, 3, 1 > & v ) Method that returns a rotation matrix from body frame to inertial frame, assuming a Z-Y-X convention. Parameters : v A vector with euler angles (roll, pith, yaw) according to Z-Y-X convention Return : A 3x3 rotation matrix function spherical_to_cartesian template <typename T > Eigen::Matrix< T, 3, 1 > spherical_to_cartesian( T bearing, T elevation, T range ) Convert from spherical to cartesian coordinates. Used mainly with usbl fixes. Parameters : bearing Horizontal angle between the direction of an object and another object or between it and the true north direction in degrees. elevation Angle measured between the horizontal and the vehicle line of sight to the object range Distance to the object bearing Horizontal angle between the direction of an object and another object or between it and the true north direction in degrees. elevation Angle measured between the horizontal and the vehicle line of sight to the object range Distance to the object Return : Eigen Vector with cartesian coordinates Eigen Vector with cartesian coordinates Authors: Joao Quintas ( jquintas@gmail.com ) Joao Cruz ( joao.pedro.cruz@tecnico.ulisboa.pt ) Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 14/12/2021 License: MIT File: spherical_coordinates.cpp Brief: Defines all functions related to spherical coordinates conversions Attributes Documentation variable ENU_NED_INERTIAL_Q static const Eigen::Quaternion< T > ENU_NED_INERTIAL_Q = euler_to_quaternion(Eigen::Matrix<T, 3, 1>(M_PI, 0.0, M_PI_2)); Static quaternion to convert a rotation expressed in ENU to a rotation expressed in NED (Z->Y->X convention) on the inertial frame Rotate PI/2 about Z-axis -> Rotate 0 about Y-axis -> Rotate PI about X-axis. NOTE: this quaternion is as valid as the quaternion representing the rotation from NED to ENU (quaternion ambiguity) on the inertial frame variable ENU_NED_BODY_Q static const Eigen::Quaternion< T > ENU_NED_BODY_Q = euler_to_quaternion(Eigen::Matrix<T, 3, 1>(M_PI, 0.0, 0.0)); Static quaternion to convert a rotation expressed in ENU body frame (ROS base_link) to a rotation expressed in NED body frame (Z->Y->X convention) Rotate 0 about Z-axis -> Rotate 0 about Y-axis -> Rotate PI about X-axis. NOTE: this quaternion is as valid as the quaternion representing the rotation from NED to ENU (quaternion ambiguity) on the body frame variable BODY_ENU_NED_Q static const Eigen::Quaternion< T > BODY_ENU_NED_Q = euler_to_quaternion(Eigen::Matrix<T, 3, 1>(M_PI, 0.0, 0.0)); Static quaternion needed for rotating vectors in body frames between ENU and NED +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU). variable BODY_ENU_NED_TF static const Eigen::Transform< T, 3, Eigen::Affine > BODY_ENU_NED_TF = Eigen::Transform<T, 3, Eigen::Affine>(BODY_ENU_NED_Q<T>); Static affine matrix to roate vectors ENU (or NED) -> NED (or ENU) expressed in body frame +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU). Updated on 2022-05-30 at 14:56:42 +0000","title":"DSOR"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#dsor","text":"More...","title":"DSOR"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#classes","text":"Name struct DSOR::VehicleState State class - used to save the state of a vehicle (using SNAME convention)","title":"Classes"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#functions","text":"Name template <typename T > T saturateControlDepthUsingMinAltitude (T depth_command, T altitude_min, T measured_depth, T measured_altitude) Method to saturate the control in depth. template <typename T > T saturateControlAltitudeUsingMinAltitude (T altitude_command, T altitude_min) Method to saturate the control in altitude. template <typename T > T saturateControlDepthUsingMaxDepth (T depth_command, T max_depth) Method to saturate the control in depth. template <typename T > T saturateControlAltitudeUsingMaxDepth (T altitude_command, T measured_depth, T measured_altitude, T max_depth) Method to saturate the control in altitude. const Eigen::PermutationMatrix< 3 > NED_ENU_REFLECTION_XY (Eigen::Vector3i(1, 0, 2) ) Use reflections instead of rotations for NED <-> ENU transformation to avoid NaN/Inf floating point pollution across different axes since in NED <-> ENU the axes are perfectly aligned. template <typename T > const Eigen::DiagonalMatrix< T, 3 > NED_ENU_REFLECTION_Z (1 , 1 , - 1) template <typename T > Eigen::Quaternion< T > rot_body_rotation (const Eigen::Quaternion< T > & q) Transform a rotation (as a quaternion) from body expressed in ENU (or NED) to inertial frame to a similar rotation (as quaternion) from body expressed in NED (or ENU) to inertial frame. template <typename T > Eigen::Quaternion< T > rot_inertial_rotation (const Eigen::Quaternion< T > & q) Transform a rotation (as a quaternion) from body to inertial frame expressed in ENU (or NED) to a similar rotation (as quaternion) from body to inertial frame expressed in NED (or ENU) template <typename T > Eigen::Quaternion< T > rot_body_to_inertial (const Eigen::Quaternion< T > & q) Transform a rotation of a rigid body (as a quaternion) from body (ENU or NED) to inertial frame (ENU or NED) to a similar rotation (as quaternion) from body (NED or ENU) to inertial frame (NED or ENU) template <typename T > Eigen::Matrix< T, 3, 1 > transform_vect_body_enu_ned (const Eigen::Matrix< T, 3, 1 > & vec) Transform vector in ENU (or NED) to NED (or ENU), expressed in body-frame. +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU). template <typename T > Eigen::Matrix< T, 3, 1 > transform_vect_between_arbitrary_ref (const Eigen::Matrix< T, 3, 1 > & vec, const Eigen::Quaternion< T > & q) Transform a vector in a given frame of reference to another frame of reference. template <typename T > Eigen::Matrix< T, 3, 1 > transform_vect_inertial_enu_ned (const Eigen::Matrix< T, 3, 1 > & vec) Transform vector in ENU (or NED) to NED (or ENU), expressed in inertial-frame. ENU <\u2014> NED - Invert the Z axis and switch the XY axis. template <typename T > Eigen::Matrix< T, 3, 3 > transform_cov3_body_enu_ned (const Eigen::Matrix< T, 3, 3 > & cov_in) Transform 3x3 covariance matrix in ENU (or NED) to NED (or ENU), expressed in body-frame. template <typename T > Eigen::Matrix< T, 3, 3 > transform_cov3_inertial_enu_ned (const Eigen::Matrix< T, 3, 3 > & cov_in) Transform 3x3 covariance matrix in ENU (or NED) to NED (or ENU), expressed in inertial-frame. template <typename T > int sign (T v) Returns the sign of the number. template <typename T > T saturation (T value, T min, T max) A function that saturates 2 values linearly. template <typename T > bool approximatelyEquals (T a, T b, T tolerance =1e-6) A function to check if two numbers are equal (int, float, double, etc) template <typename T > Eigen::Matrix< T, 3, 1 > quaternion_to_euler (const Eigen::Quaternion< T > & q) Function to convert from quaternion to (roll, pitch and yaw), according to Z-Y-X convention This function is from: https://github.com/mavlink/mavros/issues/444 and the logic is also available at: https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles . template <typename T > Eigen::Quaternion< T > euler_to_quaternion (const Eigen::Matrix< T, 3, 1 > & v) Converts a vector of euler angles according to Z-Y-X convention into a quaternion. template <typename T > T yaw_from_quaternion (const Eigen::Quaternion< T > & q) Gets the yaw angle from a quaternion (assumed a Z-Y-X rotation) NOTE: this function is based on: https://github.com/mavlink/mavros/blob/ros2/mavros/src/lib/ftf_quaternion_utils.cpp which in turn has the theory explained in: https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles . template <typename T > T wrapTo2pi (T angle) Wrap angle between [0, 2PI]. template <typename T > T wrapTopi (T angle) Wrap angle between [-PI, PI]. template <typename T > T radToDeg (T angle) Convert an angle in radian to degrees. template <typename T > T degToRad (T angle) Convert an angle in degrees to radians. template <typename T > T angleDiff (T a, T b) Method to calculate the diference between angles correctly even if they wrap between -pi and pi. template <typename T > Eigen::Matrix< T, 3, 3 > computeSkewSymmetric3 (const Eigen::Matrix< T, 3, 1 > & v) Compute the 3x3 skew-symmetric matrix from a vector 3x1. template <typename T > Eigen::Matrix< T, 2, 2 > computeSkewSymmetric2 (T c) Compute the 2x2 skew-symmetric matrix from a constant (int, float or double) template <typename T > Eigen::Matrix< T, 3, 3 > rotationAngularBodyToInertial (const Eigen::Matrix< T, 3, 1 > & v) Compute the rotation matrix that converts angular velocities expressed in the body frame to angular velocities expressed in the inertial frame (according to Z-Y-X convention) - makes use of small angle approximation. template <typename T > Eigen::Matrix< T, 3, 3 > rotationBodyToInertial (const Eigen::Matrix< T, 3, 1 > & v) Method that returns a rotation matrix from body frame to inertial frame, assuming a Z-Y-X convention. template <typename T > Eigen::Matrix< T, 3, 1 > spherical_to_cartesian (T bearing, T elevation, T range) Convert from spherical to cartesian coordinates. Used mainly with usbl fixes.","title":"Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#attributes","text":"Name const Eigen::Quaternion< T > ENU_NED_INERTIAL_Q Static quaternion to convert a rotation expressed in ENU to a rotation expressed in NED (Z->Y->X convention) on the inertial frame Rotate PI/2 about Z-axis -> Rotate 0 about Y-axis -> Rotate PI about X-axis. const Eigen::Quaternion< T > ENU_NED_BODY_Q Static quaternion to convert a rotation expressed in ENU body frame (ROS base_link) to a rotation expressed in NED body frame (Z->Y->X convention) Rotate 0 about Z-axis -> Rotate 0 about Y-axis -> Rotate PI about X-axis. const Eigen::Quaternion< T > BODY_ENU_NED_Q Static quaternion needed for rotating vectors in body frames between ENU and NED +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU). const Eigen::Transform< T, 3, Eigen::Affine > BODY_ENU_NED_TF Static affine matrix to roate vectors ENU (or NED) -> NED (or ENU) expressed in body frame +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU).","title":"Attributes"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#detailed-description","text":"Authors: Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 10/02/2022 License: MIT File: [vehicle_saturations.hpp] Brief: Defines functions used for saturating the vehicle inputs to the system Authors: Andr\u00e9 Potes ( andre.potes@gmail.com ) Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 14/12/2021 License: MIT File: [frames.hpp] Brief: Defines all functions related to conversions between ENU do NED frames and vice-versa NOTE: Most of this code is adapted from mavros https://github.com/mavlink/mavros/blob/master/mavros/src/lib/ftf_frame_conversions.cpp which had as authors Nuno Marques ( n.marques21@hotmail.com ) and Eddy Scott ( scott.edward@aurora.aero ) Authors: Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Joao Quintas ( jquintas@gmail.com ) Joao Cruz ( joao.pedro.cruz@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 14/12/2021 License: MIT File: [math.hpp] Brief: Defines all functions related to general math functions that can be used anywhere Authors: Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Andre Potes ( andre.potes@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 14/12/2021 License: MIT File: [rotations.hpp] Brief: Defines all functions related to angle wrapping, rotation matrices, euler angles, convertion to quaternions, etc. Authors: Joao Quintas ( jquintas@gmail.com ) Joao Cruz ( joao.pedro.cruz@tecnico.ulisboa.pt ) Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 14/12/2021 License: MIT File: [spherical_coordinates.hpp] Brief: Defines all functions related to spherical coordinates conversions","title":"Detailed Description"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-saturatecontroldepthusingminaltitude","text":"template <typename T > inline T saturateControlDepthUsingMinAltitude( T depth_command, T altitude_min, T measured_depth, T measured_altitude ) Method to saturate the control in depth. Parameters : depth_command The input command in depth altitude_min The minimum altitude (positive distance from the vehicle to the bottom in m) measured_depth The measured depth of the vehicle measured_altitude The measured altitude of the vehicle Return : The saturated control of depth such that the vehicle does not surpass the minimum altitude","title":"function saturateControlDepthUsingMinAltitude"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-saturatecontrolaltitudeusingminaltitude","text":"template <typename T > inline T saturateControlAltitudeUsingMinAltitude( T altitude_command, T altitude_min ) Method to saturate the control in altitude. Parameters : altitude_command The input command in altitude altitude_min The minimum altitude to keep from the ground Return : The output command of the altitude saturated such that the vehicle does not surpass the minimum altitude","title":"function saturateControlAltitudeUsingMinAltitude"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-saturatecontroldepthusingmaxdepth","text":"template <typename T > inline T saturateControlDepthUsingMaxDepth( T depth_command, T max_depth ) Method to saturate the control in depth. Parameters : depth_command The input command in depth max_depth The max depth Return : The output command of the depth saturated such that the vehicle does not surpass the maximum depth","title":"function saturateControlDepthUsingMaxDepth"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-saturatecontrolaltitudeusingmaxdepth","text":"template <typename T > inline T saturateControlAltitudeUsingMaxDepth( T altitude_command, T measured_depth, T measured_altitude, T max_depth ) Method to saturate the control in altitude. Parameters : altitude_command The input command in altitude measured_depth The measured depth of the vehicle measured_altitude The measured altitude of the vehicle max_depth The maximum depth allowed Return : The output command of the altitude saturated such that the vehicle does not surpass the maximum depth","title":"function saturateControlAltitudeUsingMaxDepth"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-ned_enu_reflection_xy","text":"static const Eigen::PermutationMatrix< 3 > NED_ENU_REFLECTION_XY( Eigen::Vector3i(1, 0, 2) ) Use reflections instead of rotations for NED <-> ENU transformation to avoid NaN/Inf floating point pollution across different axes since in NED <-> ENU the axes are perfectly aligned.","title":"function NED_ENU_REFLECTION_XY"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-ned_enu_reflection_z","text":"template <typename T > static const Eigen::DiagonalMatrix< T, 3 > NED_ENU_REFLECTION_Z( 1 , 1 , - 1 )","title":"function NED_ENU_REFLECTION_Z"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-rot_body_rotation","text":"template <typename T > inline Eigen::Quaternion< T > rot_body_rotation( const Eigen::Quaternion< T > & q ) Transform a rotation (as a quaternion) from body expressed in ENU (or NED) to inertial frame to a similar rotation (as quaternion) from body expressed in NED (or ENU) to inertial frame. Parameters : q quaternion representing a rotation: body frame ENU (or NED) -> inertial frame (in arbitrary convention) Return : quaternion represeting a rotation: body frame NED (or ENU) -> inertial frame (in arbitrary convention) NOTE: Check http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/transforms/ for more details behind these type of transformations towards obtaining rotations in different frames of reference.","title":"function rot_body_rotation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-rot_inertial_rotation","text":"template <typename T > inline Eigen::Quaternion< T > rot_inertial_rotation( const Eigen::Quaternion< T > & q ) Transform a rotation (as a quaternion) from body to inertial frame expressed in ENU (or NED) to a similar rotation (as quaternion) from body to inertial frame expressed in NED (or ENU) Parameters : q quaternion representing a rotation: body frame (in arbitrary convention) -> inertial frame ENU (or NED) Return : quaternion represeting a rotation: body frame (in arbitrary convention) -> inertial frame NED (or ENU) NOTE: Check http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/transforms/ for more details behind these type of transformations towards obtaining rotations in different frames of reference.","title":"function rot_inertial_rotation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-rot_body_to_inertial","text":"template <typename T > inline Eigen::Quaternion< T > rot_body_to_inertial( const Eigen::Quaternion< T > & q ) Transform a rotation of a rigid body (as a quaternion) from body (ENU or NED) to inertial frame (ENU or NED) to a similar rotation (as quaternion) from body (NED or ENU) to inertial frame (NED or ENU) Parameters : q quaternion representing a rotation: body frame (ENU or NED) -> inertial frame (ENU or NED) Return : quaternion representing a rotation: body frame (NED or ENU) -> inertial frame (NED or ENU) NOTE: This function is usefull to convert the attitude of a vehicle from \"ROS\" quaternion to a typicall literature quaternion (where both the body frame and inertial frames are in ENU). If you are converting a quaternion that expresses the orientation of a sensor with respect to a rigid body's body frame (and not the inertial frame), then you DO NOT WANT TO USE THIS FUNCTION. Body-FRAME NED is not the same as INERTIAL-FRAME NED (this comes once again from the fact that in ned body the x-y axis don't switch like in inertial frame) as explained in the documentation. Essencial only use this if you are representing a body in inertial frame! NOTE: Check http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/transforms/ for more details behind these type of transformations towards obtaining rotations in different frames of reference.","title":"function rot_body_to_inertial"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-transform_vect_body_enu_ned","text":"template <typename T > inline Eigen::Matrix< T, 3, 1 > transform_vect_body_enu_ned( const Eigen::Matrix< T, 3, 1 > & vec ) Transform vector in ENU (or NED) to NED (or ENU), expressed in body-frame. +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU). Parameters : vec Vector expressed in body-frame (ENU or NED) Return : Vector expressed in body-frame (NED or ENU)","title":"function transform_vect_body_enu_ned"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-transform_vect_between_arbitrary_ref","text":"template <typename T > inline Eigen::Matrix< T, 3, 1 > transform_vect_between_arbitrary_ref( const Eigen::Matrix< T, 3, 1 > & vec, const Eigen::Quaternion< T > & q ) Transform a vector in a given frame of reference to another frame of reference. Parameters : vec Vector expressed in the original frame of reference q Quaternion that expresses the orientation of the original frame of reference with respect to the final frame of reference Return : Vector expressed in the new frame of reference","title":"function transform_vect_between_arbitrary_ref"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-transform_vect_inertial_enu_ned","text":"template <typename T > inline Eigen::Matrix< T, 3, 1 > transform_vect_inertial_enu_ned( const Eigen::Matrix< T, 3, 1 > & vec ) Transform vector in ENU (or NED) to NED (or ENU), expressed in inertial-frame. ENU <\u2014> NED - Invert the Z axis and switch the XY axis. Parameters : vec Vector expressed in inertial-frame (ENU or NED) Return : Vector expressed in inertial-frame (NED or ENU)","title":"function transform_vect_inertial_enu_ned"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-transform_cov3_body_enu_ned","text":"template <typename T > inline Eigen::Matrix< T, 3, 3 > transform_cov3_body_enu_ned( const Eigen::Matrix< T, 3, 3 > & cov_in ) Transform 3x3 covariance matrix in ENU (or NED) to NED (or ENU), expressed in body-frame. Parameters : cov_in Covariance matrix expressed in body-frame (ENU or NED) Return : Covariance matrix expressed in body-frame (NED or ENU) NOTE: Check https://robotics.stackexchange.com/questions/2556/how-to-rotate-covariance for a detailed explanation of the actual conversion proof for covariance matrices","title":"function transform_cov3_body_enu_ned"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-transform_cov3_inertial_enu_ned","text":"template <typename T > inline Eigen::Matrix< T, 3, 3 > transform_cov3_inertial_enu_ned( const Eigen::Matrix< T, 3, 3 > & cov_in ) Transform 3x3 covariance matrix in ENU (or NED) to NED (or ENU), expressed in inertial-frame. Parameters : cov_in Covariance matrix expressed in inertial-frame (ENU or NED) Return : Covariance matrix expressed in inertial-frame (NED or ENU) NOTE: Check https://robotics.stackexchange.com/questions/2556/how-to-rotate-covariance for a detailed explanation of the actual conversion proof for covariance matrices","title":"function transform_cov3_inertial_enu_ned"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-sign","text":"template <typename T > inline int sign( T v ) Returns the sign of the number. Parameters : v A number Return : 1 if value is positive 0 if value is 0 -1 if value is negative","title":"function sign"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-saturation","text":"template <typename T > inline T saturation( T value, T min, T max ) A function that saturates 2 values linearly. Parameters : value A number to saturate min The minimum value max The maximum value Return : A value such that value in [min, max]","title":"function saturation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-approximatelyequals","text":"template <typename T > inline bool approximatelyEquals( T a, T b, T tolerance =1e-6 ) A function to check if two numbers are equal (int, float, double, etc) Parameters : a a number to compare b another number to compare tolerance tolerance of comparison Return : A boolean for true if equal within tolerance, or otherwise","title":"function approximatelyEquals"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-quaternion_to_euler","text":"template <typename T > inline Eigen::Matrix< T, 3, 1 > quaternion_to_euler( const Eigen::Quaternion< T > & q ) Function to convert from quaternion to (roll, pitch and yaw), according to Z-Y-X convention This function is from: https://github.com/mavlink/mavros/issues/444 and the logic is also available at: https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles . Parameters : q An eigen quaternion Return : A Vector with the [roll, pitch, yaw] obtained according to Z-Y-X convention","title":"function quaternion_to_euler"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-euler_to_quaternion","text":"template <typename T > inline Eigen::Quaternion< T > euler_to_quaternion( const Eigen::Matrix< T, 3, 1 > & v ) Converts a vector of euler angles according to Z-Y-X convention into a quaternion. Parameters : v An eigen vector of either floats or doubles [roll, pitch, yaw] Return : An Eigen Quaternion","title":"function euler_to_quaternion"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-yaw_from_quaternion","text":"template <typename T > inline T yaw_from_quaternion( const Eigen::Quaternion< T > & q ) Gets the yaw angle from a quaternion (assumed a Z-Y-X rotation) NOTE: this function is based on: https://github.com/mavlink/mavros/blob/ros2/mavros/src/lib/ftf_quaternion_utils.cpp which in turn has the theory explained in: https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles . Parameters : q A eigen quaternion Return : The yaw angle in radians (assumed a Z-Y-X rotation)","title":"function yaw_from_quaternion"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-wrapto2pi","text":"template <typename T > inline T wrapTo2pi( T angle ) Wrap angle between [0, 2PI]. Parameters : angle angle in radians Return : The wraped angle","title":"function wrapTo2pi"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-wraptopi","text":"template <typename T > inline T wrapTopi( T angle ) Wrap angle between [-PI, PI]. Parameters : angle angle in radians Return : The wraped angle","title":"function wrapTopi"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-radtodeg","text":"template <typename T > inline T radToDeg( T angle ) Convert an angle in radian to degrees. Parameters : angle in radians Return : angle in degrees","title":"function radToDeg"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-degtorad","text":"template <typename T > inline T degToRad( T angle ) Convert an angle in degrees to radians. Parameters : angle in degrees Return : angle in radians","title":"function degToRad"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-anglediff","text":"template <typename T > inline T angleDiff( T a, T b ) Method to calculate the diference between angles correctly even if they wrap between -pi and pi. Parameters : a angle 1 in radians b angle 2 in radians Return : The minimum difference between the two angles","title":"function angleDiff"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-computeskewsymmetric3","text":"template <typename T > inline Eigen::Matrix< T, 3, 3 > computeSkewSymmetric3( const Eigen::Matrix< T, 3, 1 > & v ) Compute the 3x3 skew-symmetric matrix from a vector 3x1. Parameters : v A vector with 3 elements Return : A 3x3 skew-symmetric matrix","title":"function computeSkewSymmetric3"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-computeskewsymmetric2","text":"template <typename T > inline Eigen::Matrix< T, 2, 2 > computeSkewSymmetric2( T c ) Compute the 2x2 skew-symmetric matrix from a constant (int, float or double) Parameters : v A constant Return : A 2x2 skew-symmetric matrix","title":"function computeSkewSymmetric2"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-rotationangularbodytoinertial","text":"template <typename T > inline Eigen::Matrix< T, 3, 3 > rotationAngularBodyToInertial( const Eigen::Matrix< T, 3, 1 > & v ) Compute the rotation matrix that converts angular velocities expressed in the body frame to angular velocities expressed in the inertial frame (according to Z-Y-X convention) - makes use of small angle approximation. Parameters : v A vector with 3 elements (roll, pitch, yaw) Return : A 3x3 rotation matrix","title":"function rotationAngularBodyToInertial"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-rotationbodytoinertial","text":"template <typename T > inline Eigen::Matrix< T, 3, 3 > rotationBodyToInertial( const Eigen::Matrix< T, 3, 1 > & v ) Method that returns a rotation matrix from body frame to inertial frame, assuming a Z-Y-X convention. Parameters : v A vector with euler angles (roll, pith, yaw) according to Z-Y-X convention Return : A 3x3 rotation matrix","title":"function rotationBodyToInertial"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#function-spherical_to_cartesian","text":"template <typename T > Eigen::Matrix< T, 3, 1 > spherical_to_cartesian( T bearing, T elevation, T range ) Convert from spherical to cartesian coordinates. Used mainly with usbl fixes. Parameters : bearing Horizontal angle between the direction of an object and another object or between it and the true north direction in degrees. elevation Angle measured between the horizontal and the vehicle line of sight to the object range Distance to the object bearing Horizontal angle between the direction of an object and another object or between it and the true north direction in degrees. elevation Angle measured between the horizontal and the vehicle line of sight to the object range Distance to the object Return : Eigen Vector with cartesian coordinates Eigen Vector with cartesian coordinates Authors: Joao Quintas ( jquintas@gmail.com ) Joao Cruz ( joao.pedro.cruz@tecnico.ulisboa.pt ) Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 14/12/2021 License: MIT File: spherical_coordinates.cpp Brief: Defines all functions related to spherical coordinates conversions","title":"function spherical_to_cartesian"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#variable-enu_ned_inertial_q","text":"static const Eigen::Quaternion< T > ENU_NED_INERTIAL_Q = euler_to_quaternion(Eigen::Matrix<T, 3, 1>(M_PI, 0.0, M_PI_2)); Static quaternion to convert a rotation expressed in ENU to a rotation expressed in NED (Z->Y->X convention) on the inertial frame Rotate PI/2 about Z-axis -> Rotate 0 about Y-axis -> Rotate PI about X-axis. NOTE: this quaternion is as valid as the quaternion representing the rotation from NED to ENU (quaternion ambiguity) on the inertial frame","title":"variable ENU_NED_INERTIAL_Q"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#variable-enu_ned_body_q","text":"static const Eigen::Quaternion< T > ENU_NED_BODY_Q = euler_to_quaternion(Eigen::Matrix<T, 3, 1>(M_PI, 0.0, 0.0)); Static quaternion to convert a rotation expressed in ENU body frame (ROS base_link) to a rotation expressed in NED body frame (Z->Y->X convention) Rotate 0 about Z-axis -> Rotate 0 about Y-axis -> Rotate PI about X-axis. NOTE: this quaternion is as valid as the quaternion representing the rotation from NED to ENU (quaternion ambiguity) on the body frame","title":"variable ENU_NED_BODY_Q"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#variable-body_enu_ned_q","text":"static const Eigen::Quaternion< T > BODY_ENU_NED_Q = euler_to_quaternion(Eigen::Matrix<T, 3, 1>(M_PI, 0.0, 0.0)); Static quaternion needed for rotating vectors in body frames between ENU and NED +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU).","title":"variable BODY_ENU_NED_Q"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespaceDSOR/#variable-body_enu_ned_tf","text":"static const Eigen::Transform< T, 3, Eigen::Affine > BODY_ENU_NED_TF = Eigen::Transform<T, 3, Eigen::Affine>(BODY_ENU_NED_Q<T>); Static affine matrix to roate vectors ENU (or NED) -> NED (or ENU) expressed in body frame +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU). Updated on 2022-05-30 at 14:56:42 +0000","title":"variable BODY_ENU_NED_TF"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespacetps/","text":"tps More... Functions Name template <typename T > constexpr T pow (T input, unsigned int power) Detailed Description Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/DigitalFilters License: GNU Brief: Abstract class for moving filters. Moving filter are real time filter used for applications where continuous filtering is necessary as it can be part of an control system. Functions Documentation function pow template <typename T > constexpr T pow( T input, unsigned int power ) Updated on 2022-05-30 at 14:56:42 +0000","title":"tps"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespacetps/#tps","text":"More...","title":"tps"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespacetps/#functions","text":"Name template <typename T > constexpr T pow (T input, unsigned int power)","title":"Functions"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespacetps/#detailed-description","text":"Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/DigitalFilters License: GNU Brief: Abstract class for moving filters. Moving filter are real time filter used for applications where continuous filtering is necessary as it can be part of an control system.","title":"Detailed Description"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespacetps/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_base/dsor_utils/dsor_utils/Namespaces/namespacetps/#function-pow","text":"template <typename T > constexpr T pow( T input, unsigned int power ) Updated on 2022-05-30 at 14:56:42 +0000","title":"function pow"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/","text":"Classes class ConsolePathParserNode Class Responsible for parsing a mission from the console Yebisu to medusa_vx stack format. class Formation Contains Formation variables for cooperative path following. class Section Contains Section variables for path followin algorithms. Updated on 2022-05-30 at 14:56:47 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/#classes","text":"class ConsolePathParserNode Class Responsible for parsing a mission from the console Yebisu to medusa_vx stack format. class Formation Contains Formation variables for cooperative path following. class Section Contains Section variables for path followin algorithms. Updated on 2022-05-30 at 14:56:47 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/","text":"ConsolePathParserNode Class Responsible for parsing a mission from the console Yebisu to medusa_vx stack format. #include <ConsolePathParserNode.h> Public Functions Name ConsolePathParserNode (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) Construct a new Console Path Parser Node object. ~ConsolePathParserNode () Destroy the Console Path Parser Node object. double nodeFrequency () Method to setup the frequency of the node. Public Attributes Name std::list< Section > mission std::list< Formation > formation std::list< Section >::iterator act_section medusa_msgs::Section section_copy ros::Time depth_end int own_id double xrefpoint double yrefpoint double gamma_s double gamma_e double x_act double y_act double gamma double gamma_old double u_est double x_forma double y_forma float DesiredDepth bool wpOrient bool ENABLE bool formation_mode bool biased_formation_mode float node_frequency std::string path_folder Public Functions Documentation function ConsolePathParserNode ConsolePathParserNode( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private ) Construct a new Console Path Parser Node object. Parameters : nodehandle nodehandle_private nodehandle the public ros nodehandle nodehandle_private the private ros nodehandle Console Path Parser node constructor. function ~ConsolePathParserNode ~ConsolePathParserNode() Destroy the Console Path Parser Node object. Console Path Parser node destructor. function nodeFrequency double nodeFrequency() Method to setup the frequency of the node. Return : double Public Attributes Documentation variable mission std::list< Section > mission; variable formation std::list< Formation > formation; variable act_section std::list< Section >::iterator act_section; variable section_copy medusa_msgs::Section section_copy; variable depth_end ros::Time depth_end; variable own_id int own_id {0}; variable xrefpoint double xrefpoint = 0; variable yrefpoint double yrefpoint = 0; variable gamma_s double gamma_s = 0; variable gamma_e double gamma_e = 0; variable x_act double x_act = 0; variable y_act double y_act = 0; variable gamma double gamma = 0; variable gamma_old double gamma_old = 0; variable u_est double u_est = 0; variable x_forma double x_forma = 0; variable y_forma double y_forma = 0; variable DesiredDepth float DesiredDepth = 0.0; variable wpOrient bool wpOrient; variable ENABLE bool ENABLE = false; variable formation_mode bool formation_mode = false; variable biased_formation_mode bool biased_formation_mode = false; variable node_frequency float node_frequency; variable path_folder std::string path_folder; Updated on 2022-05-30 at 14:56:47 +0000","title":"ConsolePathParserNode"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#consolepathparsernode","text":"Class Responsible for parsing a mission from the console Yebisu to medusa_vx stack format. #include <ConsolePathParserNode.h>","title":"ConsolePathParserNode"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#public-functions","text":"Name ConsolePathParserNode (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) Construct a new Console Path Parser Node object. ~ConsolePathParserNode () Destroy the Console Path Parser Node object. double nodeFrequency () Method to setup the frequency of the node.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#public-attributes","text":"Name std::list< Section > mission std::list< Formation > formation std::list< Section >::iterator act_section medusa_msgs::Section section_copy ros::Time depth_end int own_id double xrefpoint double yrefpoint double gamma_s double gamma_e double x_act double y_act double gamma double gamma_old double u_est double x_forma double y_forma float DesiredDepth bool wpOrient bool ENABLE bool formation_mode bool biased_formation_mode float node_frequency std::string path_folder","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#function-consolepathparsernode","text":"ConsolePathParserNode( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private ) Construct a new Console Path Parser Node object. Parameters : nodehandle nodehandle_private nodehandle the public ros nodehandle nodehandle_private the private ros nodehandle Console Path Parser node constructor.","title":"function ConsolePathParserNode"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#function-consolepathparsernode_1","text":"~ConsolePathParserNode() Destroy the Console Path Parser Node object. Console Path Parser node destructor.","title":"function ~ConsolePathParserNode"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#function-nodefrequency","text":"double nodeFrequency() Method to setup the frequency of the node. Return : double","title":"function nodeFrequency"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-mission","text":"std::list< Section > mission;","title":"variable mission"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-formation","text":"std::list< Formation > formation;","title":"variable formation"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-act_section","text":"std::list< Section >::iterator act_section;","title":"variable act_section"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-section_copy","text":"medusa_msgs::Section section_copy;","title":"variable section_copy"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-depth_end","text":"ros::Time depth_end;","title":"variable depth_end"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-own_id","text":"int own_id {0};","title":"variable own_id"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-xrefpoint","text":"double xrefpoint = 0;","title":"variable xrefpoint"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-yrefpoint","text":"double yrefpoint = 0;","title":"variable yrefpoint"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-gamma_s","text":"double gamma_s = 0;","title":"variable gamma_s"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-gamma_e","text":"double gamma_e = 0;","title":"variable gamma_e"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-x_act","text":"double x_act = 0;","title":"variable x_act"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-y_act","text":"double y_act = 0;","title":"variable y_act"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-gamma","text":"double gamma = 0;","title":"variable gamma"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-gamma_old","text":"double gamma_old = 0;","title":"variable gamma_old"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-u_est","text":"double u_est = 0;","title":"variable u_est"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-x_forma","text":"double x_forma = 0;","title":"variable x_forma"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-y_forma","text":"double y_forma = 0;","title":"variable y_forma"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-desireddepth","text":"float DesiredDepth = 0.0;","title":"variable DesiredDepth"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-wporient","text":"bool wpOrient;","title":"variable wpOrient"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-enable","text":"bool ENABLE = false;","title":"variable ENABLE"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-formation_mode","text":"bool formation_mode = false;","title":"variable formation_mode"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-biased_formation_mode","text":"bool biased_formation_mode = false;","title":"variable biased_formation_mode"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-node_frequency","text":"float node_frequency;","title":"variable node_frequency"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classConsolePathParserNode/#variable-path_folder","text":"std::string path_folder; Updated on 2022-05-30 at 14:56:47 +0000","title":"variable path_folder"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classFormation/","text":"Formation Contains Formation variables for cooperative path following. #include <Formation.h> Public Functions Name Formation () Public Attributes Name int id vehicle id double x x value to change xi and xe in section double y y value to change yi and ye in section Public Functions Documentation function Formation inline Formation() Public Attributes Documentation variable id int id; vehicle id variable x double x; x value to change xi and xe in section variable y double y; y value to change yi and ye in section Updated on 2022-05-30 at 14:56:47 +0000","title":"Formation"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classFormation/#formation","text":"Contains Formation variables for cooperative path following. #include <Formation.h>","title":"Formation"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classFormation/#public-functions","text":"Name Formation ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classFormation/#public-attributes","text":"Name int id vehicle id double x x value to change xi and xe in section double y y value to change yi and ye in section","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classFormation/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classFormation/#function-formation","text":"inline Formation()","title":"function Formation"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classFormation/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classFormation/#variable-id","text":"int id; vehicle id","title":"variable id"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classFormation/#variable-x","text":"double x; x value to change xi and xe in section","title":"variable x"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classFormation/#variable-y","text":"double y; y value to change yi and ye in section Updated on 2022-05-30 at 14:56:47 +0000","title":"variable y"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/","text":"Section Contains Section variables for path followin algorithms. More... #include <Section.h> Public Functions Name Section () Public Attributes Name int type 1= WP; 2=Line; 3=Arc; 4=Depth double xi initial x of section double yi initial y of section double xc x of center of arc (-1 if line or point) double yc y of center of arc (-1 if line or point) double xe ending x of section double ye ending y of section float velocity velocity desired of the vehicle int adirection -1 if vehicle is turning clockwise, -1 otherwise (only applied to arcs) float radius adius of the arc float heading yaw of the vehicle float time only used for point, depth and alt, time to use the reference int nVehicle number of the vehicle (possible id) double gamma_s Starting gamma (not normalized) double gamma_e Ending gamma (not normalized) float depth Depth of the section. Detailed Description class Section; Contains Section variables for path followin algorithms. Note : nVehicle is always -1, probably not being used Public Functions Documentation function Section inline Section() Public Attributes Documentation variable type int type; 1= WP; 2=Line; 3=Arc; 4=Depth variable xi double xi; initial x of section variable yi double yi; initial y of section variable xc double xc; x of center of arc (-1 if line or point) variable yc double yc; y of center of arc (-1 if line or point) variable xe double xe; ending x of section variable ye double ye; ending y of section variable velocity float velocity; velocity desired of the vehicle variable adirection int adirection; -1 if vehicle is turning clockwise, -1 otherwise (only applied to arcs) variable radius float radius; adius of the arc variable heading float heading; yaw of the vehicle variable time float time; only used for point, depth and alt, time to use the reference variable nVehicle int nVehicle; number of the vehicle (possible id) variable gamma_s double gamma_s; Starting gamma (not normalized) variable gamma_e double gamma_e; Ending gamma (not normalized) variable depth float depth; Depth of the section. Updated on 2022-05-30 at 14:56:47 +0000","title":"Section"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#section","text":"Contains Section variables for path followin algorithms. More... #include <Section.h>","title":"Section"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#public-functions","text":"Name Section ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#public-attributes","text":"Name int type 1= WP; 2=Line; 3=Arc; 4=Depth double xi initial x of section double yi initial y of section double xc x of center of arc (-1 if line or point) double yc y of center of arc (-1 if line or point) double xe ending x of section double ye ending y of section float velocity velocity desired of the vehicle int adirection -1 if vehicle is turning clockwise, -1 otherwise (only applied to arcs) float radius adius of the arc float heading yaw of the vehicle float time only used for point, depth and alt, time to use the reference int nVehicle number of the vehicle (possible id) double gamma_s Starting gamma (not normalized) double gamma_e Ending gamma (not normalized) float depth Depth of the section.","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#detailed-description","text":"class Section; Contains Section variables for path followin algorithms. Note : nVehicle is always -1, probably not being used","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#function-section","text":"inline Section()","title":"function Section"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#variable-type","text":"int type; 1= WP; 2=Line; 3=Arc; 4=Depth","title":"variable type"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#variable-xi","text":"double xi; initial x of section","title":"variable xi"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#variable-yi","text":"double yi; initial y of section","title":"variable yi"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#variable-xc","text":"double xc; x of center of arc (-1 if line or point)","title":"variable xc"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#variable-yc","text":"double yc; y of center of arc (-1 if line or point)","title":"variable yc"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#variable-xe","text":"double xe; ending x of section","title":"variable xe"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#variable-ye","text":"double ye; ending y of section","title":"variable ye"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#variable-velocity","text":"float velocity; velocity desired of the vehicle","title":"variable velocity"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#variable-adirection","text":"int adirection; -1 if vehicle is turning clockwise, -1 otherwise (only applied to arcs)","title":"variable adirection"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#variable-radius","text":"float radius; adius of the arc","title":"variable radius"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#variable-heading","text":"float heading; yaw of the vehicle","title":"variable heading"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#variable-time","text":"float time; only used for point, depth and alt, time to use the reference","title":"variable time"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#variable-nvehicle","text":"int nVehicle; number of the vehicle (possible id)","title":"variable nVehicle"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#variable-gamma_s","text":"double gamma_s; Starting gamma (not normalized)","title":"variable gamma_s"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#variable-gamma_e","text":"double gamma_e; Ending gamma (not normalized)","title":"variable gamma_e"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Classes/classSection/#variable-depth","text":"float depth; Depth of the section. Updated on 2022-05-30 at 14:56:47 +0000","title":"variable depth"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Examples/","text":"Examples Updated on 2022-05-30 at 14:56:47 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Examples/#examples","text":"Updated on 2022-05-30 at 14:56:47 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Modules/","text":"Modules Updated on 2022-05-30 at 14:56:47 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Modules/#modules","text":"Updated on 2022-05-30 at 14:56:47 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Namespaces/","text":"Namespaces Updated on 2022-05-30 at 14:56:47 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_addons/console_path_parser/Namespaces/#namespaces","text":"Updated on 2022-05-30 at 14:56:47 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/","text":"Classes namespace console class CallbackEcho class ERROR_Struct class HTTP_Handler class ROSTopicException class ROSTopicIOException class ThreadedHTTPServer class Topic_Struct class subscriber_Thread namespace setup namespace waypoint::srv Updated on 2022-05-30 at 14:56:42 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/#classes","text":"namespace console class CallbackEcho class ERROR_Struct class HTTP_Handler class ROSTopicException class ROSTopicIOException class ThreadedHTTPServer class Topic_Struct class subscriber_Thread namespace setup namespace waypoint::srv Updated on 2022-05-30 at 14:56:42 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/","text":"console::CallbackEcho More... Inherits from object Public Functions Name def init (self self, topic topic) def callback (self self, data data, topic topic, current_time current_time =None) Public Attributes Name topic count prefix suffix done str_fn first last_msg_eval last_topic Detailed Description class console::CallbackEcho; Callback instance that can print callback data in a variety of formats. Used for all variants of rostopic echo Public Functions Documentation function init def __init__( self self, topic topic ) :param plot: if ``True``, echo in plotting-friendly format, ``bool`` :param filter_fn: function that evaluates to ``True`` if message is to be echo'd, ``fn(topic, msg)`` :param echo_all_topics: (optional) if ``True``, echo all messages in bag, ``bool`` :param offset_time: (optional) if ``True``, display time as offset from current time, ``bool`` :param count: number of messages to echo, ``None`` for infinite, ``int`` :param field_filter_fn: filter the fields that are strified for Messages, ``fn(Message)->iter(str)`` function callback def callback( self self, data data, topic topic, current_time current_time =None ) Callback to pass to rospy.Subscriber or to call manually. rospy.Subscriber constructor must also pass in the topic name as an additional arg :param data: Message :param topic: topic name, ``str`` :param current_time: override calculation of current time, :class:`genpy.Time` Public Attributes Documentation variable topic topic; variable count count; variable prefix prefix; variable suffix suffix; variable done done; variable str_fn str_fn; variable first first; variable last_msg_eval last_msg_eval; variable last_topic last_topic; Updated on 2022-05-30 at 14:56:42 +0000","title":"console::CallbackEcho"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#consolecallbackecho","text":"More... Inherits from object","title":"console::CallbackEcho"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#public-functions","text":"Name def init (self self, topic topic) def callback (self self, data data, topic topic, current_time current_time =None)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#public-attributes","text":"Name topic count prefix suffix done str_fn first last_msg_eval last_topic","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#detailed-description","text":"class console::CallbackEcho; Callback instance that can print callback data in a variety of formats. Used for all variants of rostopic echo","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#function-init","text":"def __init__( self self, topic topic ) :param plot: if ``True``, echo in plotting-friendly format, ``bool`` :param filter_fn: function that evaluates to ``True`` if message is to be echo'd, ``fn(topic, msg)`` :param echo_all_topics: (optional) if ``True``, echo all messages in bag, ``bool`` :param offset_time: (optional) if ``True``, display time as offset from current time, ``bool`` :param count: number of messages to echo, ``None`` for infinite, ``int`` :param field_filter_fn: filter the fields that are strified for Messages, ``fn(Message)->iter(str)``","title":"function init"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#function-callback","text":"def callback( self self, data data, topic topic, current_time current_time =None ) Callback to pass to rospy.Subscriber or to call manually. rospy.Subscriber constructor must also pass in the topic name as an additional arg :param data: Message :param topic: topic name, ``str`` :param current_time: override calculation of current time, :class:`genpy.Time`","title":"function callback"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#variable-topic","text":"topic;","title":"variable topic"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#variable-count","text":"count;","title":"variable count"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#variable-prefix","text":"prefix;","title":"variable prefix"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#variable-suffix","text":"suffix;","title":"variable suffix"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#variable-done","text":"done;","title":"variable done"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#variable-str_fn","text":"str_fn;","title":"variable str_fn"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#variable-first","text":"first;","title":"variable first"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#variable-last_msg_eval","text":"last_msg_eval;","title":"variable last_msg_eval"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1CallbackEcho/#variable-last_topic","text":"last_topic; Updated on 2022-05-30 at 14:56:42 +0000","title":"variable last_topic"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ERROR__Struct/","text":"console::ERROR_Struct Inherits from object Public Functions Name def init (self self) def clear (self self) def clearitem (self self, i i) def str (self self) def add_error (self self, topic_name topic_name, data data) Public Attributes Name node_name line msg time time_rcv Public Functions Documentation function init def __init__( self self ) function clear def __clear__( self self ) function clearitem def __clearitem__( self self, i i ) function str def __str__( self self ) function add_error def add_error( self self, topic_name topic_name, data data ) Public Attributes Documentation variable node_name node_name; variable line line; variable msg msg; variable time time; variable time_rcv time_rcv; Updated on 2022-05-30 at 14:56:42 +0000","title":"console::ERROR_Struct"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ERROR__Struct/#consoleerror_struct","text":"Inherits from object","title":"console::ERROR_Struct"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ERROR__Struct/#public-functions","text":"Name def init (self self) def clear (self self) def clearitem (self self, i i) def str (self self) def add_error (self self, topic_name topic_name, data data)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ERROR__Struct/#public-attributes","text":"Name node_name line msg time time_rcv","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ERROR__Struct/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ERROR__Struct/#function-init","text":"def __init__( self self )","title":"function init"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ERROR__Struct/#function-clear","text":"def __clear__( self self )","title":"function clear"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ERROR__Struct/#function-clearitem","text":"def __clearitem__( self self, i i )","title":"function clearitem"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ERROR__Struct/#function-str","text":"def __str__( self self )","title":"function str"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ERROR__Struct/#function-add_error","text":"def add_error( self self, topic_name topic_name, data data )","title":"function add_error"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ERROR__Struct/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ERROR__Struct/#variable-node_name","text":"node_name;","title":"variable node_name"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ERROR__Struct/#variable-line","text":"line;","title":"variable line"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ERROR__Struct/#variable-msg","text":"msg;","title":"variable msg"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ERROR__Struct/#variable-time","text":"time;","title":"variable time"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ERROR__Struct/#variable-time_rcv","text":"time_rcv; Updated on 2022-05-30 at 14:56:42 +0000","title":"variable time_rcv"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1HTTP__Handler/","text":"console::HTTP_Handler Inherits from BaseHTTPRequestHandler Public Functions Name def do_GET (self self) def do_POST (self self) def do_HEAD (self self) def address_string (self self) def log_request (self self, inputs inputs) Public Functions Documentation function do_GET def do_GET( self self ) function do_POST def do_POST( self self ) function do_HEAD def do_HEAD( self self ) function address_string def address_string( self self ) function log_request def log_request( self self, inputs inputs ) Updated on 2022-05-30 at 14:56:42 +0000","title":"console::HTTP_Handler"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1HTTP__Handler/#consolehttp_handler","text":"Inherits from BaseHTTPRequestHandler","title":"console::HTTP_Handler"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1HTTP__Handler/#public-functions","text":"Name def do_GET (self self) def do_POST (self self) def do_HEAD (self self) def address_string (self self) def log_request (self self, inputs inputs)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1HTTP__Handler/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1HTTP__Handler/#function-do_get","text":"def do_GET( self self )","title":"function do_GET"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1HTTP__Handler/#function-do_post","text":"def do_POST( self self )","title":"function do_POST"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1HTTP__Handler/#function-do_head","text":"def do_HEAD( self self )","title":"function do_HEAD"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1HTTP__Handler/#function-address_string","text":"def address_string( self self )","title":"function address_string"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1HTTP__Handler/#function-log_request","text":"def log_request( self self, inputs inputs ) Updated on 2022-05-30 at 14:56:42 +0000","title":"function log_request"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ROSTopicException/","text":"console::ROSTopicException More... Inherits from Exception Inherited by console.ROSTopicIOException Detailed Description class console::ROSTopicException; Base exception class of rostopic-related errors Updated on 2022-05-30 at 14:56:42 +0000","title":"console::ROSTopicException"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ROSTopicException/#consolerostopicexception","text":"More... Inherits from Exception Inherited by console.ROSTopicIOException","title":"console::ROSTopicException"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ROSTopicException/#detailed-description","text":"class console::ROSTopicException; Base exception class of rostopic-related errors Updated on 2022-05-30 at 14:56:42 +0000","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ROSTopicIOException/","text":"console::ROSTopicIOException More... Inherits from console.ROSTopicException , Exception Detailed Description class console::ROSTopicIOException; rostopic errors related to network I/O failures Updated on 2022-05-30 at 14:56:42 +0000","title":"console::ROSTopicIOException"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ROSTopicIOException/#consolerostopicioexception","text":"More... Inherits from console.ROSTopicException , Exception","title":"console::ROSTopicIOException"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ROSTopicIOException/#detailed-description","text":"class console::ROSTopicIOException; rostopic errors related to network I/O failures Updated on 2022-05-30 at 14:56:42 +0000","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ThreadedHTTPServer/","text":"console::ThreadedHTTPServer More... Inherits from ThreadingMixIn, HTTPServer Detailed Description class console::ThreadedHTTPServer; Handle requests in a separate thread. Updated on 2022-05-30 at 14:56:42 +0000","title":"console::ThreadedHTTPServer"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ThreadedHTTPServer/#consolethreadedhttpserver","text":"More... Inherits from ThreadingMixIn, HTTPServer","title":"console::ThreadedHTTPServer"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1ThreadedHTTPServer/#detailed-description","text":"class console::ThreadedHTTPServer; Handle requests in a separate thread. Updated on 2022-05-30 at 14:56:42 +0000","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1Topic__Struct/","text":"console::Topic_Struct Inherits from object Public Functions Name def init (self self) def str (self self) def add_value (self self, topic_name topic_name, data data) def del_value (self self, topic_name topic_name) def data_topic (self self, topic_name topic_name) def count (self self, topic_name topic_name) def str_list (self self) Public Attributes Name time_rcv topics topics_data Public Functions Documentation function init def __init__( self self ) function str def __str__( self self ) function add_value def add_value( self self, topic_name topic_name, data data ) function del_value def del_value( self self, topic_name topic_name ) function data_topic def data_topic( self self, topic_name topic_name ) function count def count( self self, topic_name topic_name ) function str_list def str_list( self self ) Public Attributes Documentation variable time_rcv time_rcv; variable topics topics; variable topics_data topics_data; Updated on 2022-05-30 at 14:56:42 +0000","title":"console::Topic_Struct"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1Topic__Struct/#consoletopic_struct","text":"Inherits from object","title":"console::Topic_Struct"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1Topic__Struct/#public-functions","text":"Name def init (self self) def str (self self) def add_value (self self, topic_name topic_name, data data) def del_value (self self, topic_name topic_name) def data_topic (self self, topic_name topic_name) def count (self self, topic_name topic_name) def str_list (self self)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1Topic__Struct/#public-attributes","text":"Name time_rcv topics topics_data","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1Topic__Struct/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1Topic__Struct/#function-init","text":"def __init__( self self )","title":"function init"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1Topic__Struct/#function-str","text":"def __str__( self self )","title":"function str"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1Topic__Struct/#function-add_value","text":"def add_value( self self, topic_name topic_name, data data )","title":"function add_value"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1Topic__Struct/#function-del_value","text":"def del_value( self self, topic_name topic_name )","title":"function del_value"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1Topic__Struct/#function-data_topic","text":"def data_topic( self self, topic_name topic_name )","title":"function data_topic"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1Topic__Struct/#function-count","text":"def count( self self, topic_name topic_name )","title":"function count"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1Topic__Struct/#function-str_list","text":"def str_list( self self )","title":"function str_list"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1Topic__Struct/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1Topic__Struct/#variable-time_rcv","text":"time_rcv;","title":"variable time_rcv"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1Topic__Struct/#variable-topics","text":"topics;","title":"variable topics"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1Topic__Struct/#variable-topics_data","text":"topics_data; Updated on 2022-05-30 at 14:56:42 +0000","title":"variable topics_data"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1subscriber__Thread/","text":"console::subscriber_Thread Inherits from Thread Public Functions Name def init (self self, topic topic) def run (self self) Public Attributes Name topic callback_echo msg_eval Public Functions Documentation function init def __init__( self self, topic topic ) function run def run( self self ) Public Attributes Documentation variable topic topic; variable callback_echo callback_echo; variable msg_eval msg_eval; Updated on 2022-05-30 at 14:56:42 +0000","title":"console::subscriber_Thread"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1subscriber__Thread/#consolesubscriber_thread","text":"Inherits from Thread","title":"console::subscriber_Thread"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1subscriber__Thread/#public-functions","text":"Name def init (self self, topic topic) def run (self self)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1subscriber__Thread/#public-attributes","text":"Name topic callback_echo msg_eval","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1subscriber__Thread/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1subscriber__Thread/#function-init","text":"def __init__( self self, topic topic )","title":"function init"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1subscriber__Thread/#function-run","text":"def run( self self )","title":"function run"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1subscriber__Thread/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1subscriber__Thread/#variable-topic","text":"topic;","title":"variable topic"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1subscriber__Thread/#variable-callback_echo","text":"callback_echo;","title":"variable callback_echo"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Classes/classconsole_1_1subscriber__Thread/#variable-msg_eval","text":"msg_eval; Updated on 2022-05-30 at 14:56:42 +0000","title":"variable msg_eval"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Examples/","text":"Examples Updated on 2022-05-30 at 14:56:42 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Examples/#examples","text":"Updated on 2022-05-30 at 14:56:42 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Modules/","text":"Modules Updated on 2022-05-30 at 14:56:42 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Modules/#modules","text":"Updated on 2022-05-30 at 14:56:42 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/","text":"Namespaces namespace console namespace setup namespace waypoint::srv Updated on 2022-05-30 at 14:56:42 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/#namespaces","text":"namespace console namespace setup namespace waypoint::srv Updated on 2022-05-30 at 14:56:42 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/","text":"console Classes Name class console::CallbackEcho class console::ERROR_Struct class console::HTTP_Handler class console::ROSTopicException class console::ROSTopicIOException class console::subscriber_Thread class console::ThreadedHTTPServer class console::Topic_Struct Functions Name def get_topic_class (topic topic, blocking blocking =False) def get_topic_type (topic topic, blocking blocking =False) def msgevalgen (pattern pattern) def ros2xml (msg msg, name name, depth depth =0) def moos2xml (msg msg, name name, time time, depth depth =0) def create_publisher (topic_name topic_name, topic_type topic_type) def publish_message (pub pub, msg_class msg_class, pub_args pub_args) def cmd_set_topic (args args) def getfiles (dirpath dirpath) def populenv (self self) def signal_handler (signal signal, frame frame) Attributes Name string NAME string MISSION_PATH string pages_folder int NFILE ALL_TOPICS SUBSCRIBED_TOPICS UNKNOWN_TOPICS ALL_ERRORs int g_list_topic_thrsh int g_list_topic_stamp SIGNALS_TO_NAMES_DICT argv anonymous True disable_rosout disable_rostime server_port ROOT_NAMESPACE command server Functions Documentation function get_topic_class def get_topic_class( topic topic, blocking blocking =False ) Get the topic message class :returns: message class for topic, real topic name, and function for evaluating message objects into the subtopic (or ``None``). ``(Message, str, str)`` :raises: :exc:`ROSTopicException` If topic type cannot be determined or loaded function get_topic_type def get_topic_type( topic topic, blocking blocking =False ) Get the topic type. :param topic: topic name, ``str`` :param blocking: (default False) block until topic becomes available, ``bool`` :returns: topic type, real topic name and fn to evaluate the message instance if the topic points to a field within a topic, e.g. /rosout/msg. fn is None otherwise. ``(str, str, fn)`` :raises: :exc:`ROSTopicException` If master cannot be contacted function msgevalgen def msgevalgen( pattern pattern ) Generates a function that returns the relevant field (aka 'subtopic') of a Message object :param pattern: subtopic, e.g. /x. Must have a leading '/' if specified, ``str`` :returns: function that converts a message into the desired value, ``fn(Message) -> value`` function ros2xml def ros2xml( msg msg, name name, depth depth =0 ) function moos2xml def moos2xml( msg msg, name name, time time, depth depth =0 ) function create_publisher def create_publisher( topic_name topic_name, topic_type topic_type ) Create rospy.Publisher instance from the string topic name and type. This is a powerful method as it allows creation of rospy.Publisher and Message instances using the topic and type names. This enables more dynamic publishing from Python programs. :param topic_name: name of topic, ``str`` :param topic_type: name of topic type, ``str`` :param latch: latching topic, ``bool`` :returns: topic :class:`rospy.Publisher`, :class:`Message` class function publish_message def publish_message( pub pub, msg_class msg_class, pub_args pub_args ) Create new instance of msg_class, populate with pub_args, and publish. This may print output to screen. :param pub: :class:`rospy.Publisher` instance for topic :param msg_class: Message type, ``Class`` :param pub_args: Arguments to initialize message that is published, ``[val]`` function cmd_set_topic def cmd_set_topic( args args ) function getfiles def getfiles( dirpath dirpath ) function populenv def populenv( self self ) function signal_handler def signal_handler( signal signal, frame frame ) Attributes Documentation variable NAME string NAME = 'Console'; variable MISSION_PATH string MISSION_PATH = \"/home/cog/cog-sw/Missions_FOLDER\"; variable pages_folder string pages_folder = \"\"; variable NFILE int NFILE = 0; variable ALL_TOPICS ALL_TOPICS = Topic_Struct(); variable SUBSCRIBED_TOPICS SUBSCRIBED_TOPICS = Topic_Struct(); variable UNKNOWN_TOPICS UNKNOWN_TOPICS = Topic_Struct(); variable ALL_ERRORs ALL_ERRORs = ERROR_Struct(); variable g_list_topic_thrsh int g_list_topic_thrsh = 30; variable g_list_topic_stamp int g_list_topic_stamp = 0; variable SIGNALS_TO_NAMES_DICT SIGNALS_TO_NAMES_DICT = dict((getattr(signal, n), n) \\ for n in dir(signal) if n.startswith('SIG') and '_' not in n ); variable argv argv = sys.argv; variable anonymous anonymous; variable True True; variable disable_rosout disable_rosout; variable disable_rostime disable_rostime; variable server_port server_port = rospy.get_param('~PORT',7080); variable ROOT_NAMESPACE ROOT_NAMESPACE = rospy.get_param('~ROOT_NAMESPACE',True); variable command command = argv[1]; variable server server = ThreadedHTTPServer(('', server_port), HTTP_Handler); Updated on 2022-05-30 at 14:56:42 +0000","title":"console"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#console","text":"","title":"console"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#classes","text":"Name class console::CallbackEcho class console::ERROR_Struct class console::HTTP_Handler class console::ROSTopicException class console::ROSTopicIOException class console::subscriber_Thread class console::ThreadedHTTPServer class console::Topic_Struct","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#functions","text":"Name def get_topic_class (topic topic, blocking blocking =False) def get_topic_type (topic topic, blocking blocking =False) def msgevalgen (pattern pattern) def ros2xml (msg msg, name name, depth depth =0) def moos2xml (msg msg, name name, time time, depth depth =0) def create_publisher (topic_name topic_name, topic_type topic_type) def publish_message (pub pub, msg_class msg_class, pub_args pub_args) def cmd_set_topic (args args) def getfiles (dirpath dirpath) def populenv (self self) def signal_handler (signal signal, frame frame)","title":"Functions"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#attributes","text":"Name string NAME string MISSION_PATH string pages_folder int NFILE ALL_TOPICS SUBSCRIBED_TOPICS UNKNOWN_TOPICS ALL_ERRORs int g_list_topic_thrsh int g_list_topic_stamp SIGNALS_TO_NAMES_DICT argv anonymous True disable_rosout disable_rostime server_port ROOT_NAMESPACE command server","title":"Attributes"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#function-get_topic_class","text":"def get_topic_class( topic topic, blocking blocking =False ) Get the topic message class :returns: message class for topic, real topic name, and function for evaluating message objects into the subtopic (or ``None``). ``(Message, str, str)`` :raises: :exc:`ROSTopicException` If topic type cannot be determined or loaded","title":"function get_topic_class"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#function-get_topic_type","text":"def get_topic_type( topic topic, blocking blocking =False ) Get the topic type. :param topic: topic name, ``str`` :param blocking: (default False) block until topic becomes available, ``bool`` :returns: topic type, real topic name and fn to evaluate the message instance if the topic points to a field within a topic, e.g. /rosout/msg. fn is None otherwise. ``(str, str, fn)`` :raises: :exc:`ROSTopicException` If master cannot be contacted","title":"function get_topic_type"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#function-msgevalgen","text":"def msgevalgen( pattern pattern ) Generates a function that returns the relevant field (aka 'subtopic') of a Message object :param pattern: subtopic, e.g. /x. Must have a leading '/' if specified, ``str`` :returns: function that converts a message into the desired value, ``fn(Message) -> value``","title":"function msgevalgen"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#function-ros2xml","text":"def ros2xml( msg msg, name name, depth depth =0 )","title":"function ros2xml"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#function-moos2xml","text":"def moos2xml( msg msg, name name, time time, depth depth =0 )","title":"function moos2xml"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#function-create_publisher","text":"def create_publisher( topic_name topic_name, topic_type topic_type ) Create rospy.Publisher instance from the string topic name and type. This is a powerful method as it allows creation of rospy.Publisher and Message instances using the topic and type names. This enables more dynamic publishing from Python programs. :param topic_name: name of topic, ``str`` :param topic_type: name of topic type, ``str`` :param latch: latching topic, ``bool`` :returns: topic :class:`rospy.Publisher`, :class:`Message` class","title":"function create_publisher"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#function-publish_message","text":"def publish_message( pub pub, msg_class msg_class, pub_args pub_args ) Create new instance of msg_class, populate with pub_args, and publish. This may print output to screen. :param pub: :class:`rospy.Publisher` instance for topic :param msg_class: Message type, ``Class`` :param pub_args: Arguments to initialize message that is published, ``[val]``","title":"function publish_message"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#function-cmd_set_topic","text":"def cmd_set_topic( args args )","title":"function cmd_set_topic"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#function-getfiles","text":"def getfiles( dirpath dirpath )","title":"function getfiles"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#function-populenv","text":"def populenv( self self )","title":"function populenv"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#function-signal_handler","text":"def signal_handler( signal signal, frame frame )","title":"function signal_handler"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-name","text":"string NAME = 'Console';","title":"variable NAME"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-mission_path","text":"string MISSION_PATH = \"/home/cog/cog-sw/Missions_FOLDER\";","title":"variable MISSION_PATH"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-pages_folder","text":"string pages_folder = \"\";","title":"variable pages_folder"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-nfile","text":"int NFILE = 0;","title":"variable NFILE"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-all_topics","text":"ALL_TOPICS = Topic_Struct();","title":"variable ALL_TOPICS"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-subscribed_topics","text":"SUBSCRIBED_TOPICS = Topic_Struct();","title":"variable SUBSCRIBED_TOPICS"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-unknown_topics","text":"UNKNOWN_TOPICS = Topic_Struct();","title":"variable UNKNOWN_TOPICS"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-all_errors","text":"ALL_ERRORs = ERROR_Struct();","title":"variable ALL_ERRORs"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-g_list_topic_thrsh","text":"int g_list_topic_thrsh = 30;","title":"variable g_list_topic_thrsh"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-g_list_topic_stamp","text":"int g_list_topic_stamp = 0;","title":"variable g_list_topic_stamp"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-signals_to_names_dict","text":"SIGNALS_TO_NAMES_DICT = dict((getattr(signal, n), n) \\ for n in dir(signal) if n.startswith('SIG') and '_' not in n );","title":"variable SIGNALS_TO_NAMES_DICT"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-argv","text":"argv = sys.argv;","title":"variable argv"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-anonymous","text":"anonymous;","title":"variable anonymous"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-true","text":"True;","title":"variable True"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-disable_rosout","text":"disable_rosout;","title":"variable disable_rosout"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-disable_rostime","text":"disable_rostime;","title":"variable disable_rostime"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-server_port","text":"server_port = rospy.get_param('~PORT',7080);","title":"variable server_port"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-root_namespace","text":"ROOT_NAMESPACE = rospy.get_param('~ROOT_NAMESPACE',True);","title":"variable ROOT_NAMESPACE"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-command","text":"command = argv[1];","title":"variable command"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespaceconsole/#variable-server","text":"server = ThreadedHTTPServer(('', server_port), HTTP_Handler); Updated on 2022-05-30 at 14:56:42 +0000","title":"variable server"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespacesetup/","text":"setup Updated on 2022-05-30 at 14:56:42 +0000","title":"setup"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespacesetup/#setup","text":"Updated on 2022-05-30 at 14:56:42 +0000","title":"setup"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespacewaypoint_1_1srv/","text":"waypoint::srv Updated on 2022-05-30 at 14:56:42 +0000","title":"waypoint::srv"},{"location":"api/markdown/medusa_base/medusa_addons/http_server/Namespaces/namespacewaypoint_1_1srv/#waypointsrv","text":"Updated on 2022-05-30 at 14:56:42 +0000","title":"waypoint::srv"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Classes/","text":"Classes namespace MedusaDiagnostics MedusaDiagnostics namespace. Updated on 2022-05-30 at 14:56:42 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Classes/#classes","text":"namespace MedusaDiagnostics MedusaDiagnostics namespace. Updated on 2022-05-30 at 14:56:42 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Examples/","text":"Examples Updated on 2022-05-30 at 14:56:42 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Examples/#examples","text":"Updated on 2022-05-30 at 14:56:42 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Modules/","text":"Modules Updated on 2022-05-30 at 14:56:42 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Modules/#modules","text":"Updated on 2022-05-30 at 14:56:42 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Namespaces/","text":"Namespaces namespace MedusaDiagnostics MedusaDiagnostics namespace. Updated on 2022-05-30 at 14:56:42 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Namespaces/#namespaces","text":"namespace MedusaDiagnostics MedusaDiagnostics namespace. Updated on 2022-05-30 at 14:56:42 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Namespaces/namespaceMedusaDiagnostics/","text":"MedusaDiagnostics MedusaDiagnostics namespace. Functions Name diagnostic_msgs::DiagnosticStatus setDiagnosisMsg (const uint8_t & level, const std::string & name, const std::string & message, const std::string & hardware_id) Set the Diagnosis Msg object (DiagnosticStatus) void addKeyValue (diagnostic_msgs::DiagnosticArray * diagnostic_msg, const std::string & key_name, const std::string & value, const unsigned int & index) add key values to diagnostic message template <typename T > bool checkLowerBound (const T & value, const T & lower_bound) Check lower bound value. template <typename T > bool checkUpperBound (const T & value, const T & upper_bound) void warnLevel (diagnostic_msgs::DiagnosticArray * diagnostic_msg, const std::string & message, const unsigned int & index) Define the level as WARN and change the message in diagnostics. void errorLevel (diagnostic_msgs::DiagnosticArray * diagnostic_msg, const std::string & message, const unsigned int & index) Define the level as Error and change the message in diagnostics. Functions Documentation function setDiagnosisMsg diagnostic_msgs::DiagnosticStatus setDiagnosisMsg( const uint8_t & level, const std::string & name, const std::string & message, const std::string & hardware_id ) Set the Diagnosis Msg object (DiagnosticStatus) Parameters : level 0->OK, 1-> WARN, 2-> ERROR, 3->STALE name name of what sensor/node is being diagnosed, ex: /sensors/ + node_name message Say if it is ok or not hardware_id name of the sensor Return : diagnostic_msgs::DiagnosticStatus function addKeyValue void addKeyValue( diagnostic_msgs::DiagnosticArray * diagnostic_msg, const std::string & key_name, const std::string & value, const unsigned int & index ) add key values to diagnostic message Parameters : diagnostic_msg array(DiagnosticArray) of diagnostic_msgs key_name name of what we are diagnosing ex: Temperature, Current, Yaw value value being diagnosed, ex: from sensor index of the diagnostic_msg array function checkLowerBound template <typename T > bool checkLowerBound( const T & value, const T & lower_bound ) Check lower bound value. Parameters : value value being diagnosed, ex: received by the sensor lower_bound value of lower bound defined by the user Template Parameters : T type of the values to be compared (int, double, float) Return : true if the sensor value is lower than the lower bound false if the sensor value is bigger than the lower bound function checkUpperBound template <typename T > bool checkUpperBound( const T & value, const T & upper_bound ) Parameters : value received by the sensor upper_bound value of the upper bound defined by the user Template Parameters : T type of the values to be compared (int, double, float) Return : true if the sensor value is bigger than the upper bound false if the sensor value is lower thant the upper bound function warnLevel void warnLevel( diagnostic_msgs::DiagnosticArray * diagnostic_msg, const std::string & message, const unsigned int & index ) Define the level as WARN and change the message in diagnostics. Parameters : diagnostic_msg array(DiagnosticArray) of diagnostic_msgs message to clarify warning index of the diagnostic_msg array function errorLevel void errorLevel( diagnostic_msgs::DiagnosticArray * diagnostic_msg, const std::string & message, const unsigned int & index ) Define the level as Error and change the message in diagnostics. Parameters : diagnostic_msg array(DiagnosticArray) of diagnostic_msgs message to clarify error index of the diagnostic_msg array Updated on 2022-05-30 at 14:56:42 +0000","title":"MedusaDiagnostics"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Namespaces/namespaceMedusaDiagnostics/#medusadiagnostics","text":"MedusaDiagnostics namespace.","title":"MedusaDiagnostics"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Namespaces/namespaceMedusaDiagnostics/#functions","text":"Name diagnostic_msgs::DiagnosticStatus setDiagnosisMsg (const uint8_t & level, const std::string & name, const std::string & message, const std::string & hardware_id) Set the Diagnosis Msg object (DiagnosticStatus) void addKeyValue (diagnostic_msgs::DiagnosticArray * diagnostic_msg, const std::string & key_name, const std::string & value, const unsigned int & index) add key values to diagnostic message template <typename T > bool checkLowerBound (const T & value, const T & lower_bound) Check lower bound value. template <typename T > bool checkUpperBound (const T & value, const T & upper_bound) void warnLevel (diagnostic_msgs::DiagnosticArray * diagnostic_msg, const std::string & message, const unsigned int & index) Define the level as WARN and change the message in diagnostics. void errorLevel (diagnostic_msgs::DiagnosticArray * diagnostic_msg, const std::string & message, const unsigned int & index) Define the level as Error and change the message in diagnostics.","title":"Functions"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Namespaces/namespaceMedusaDiagnostics/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Namespaces/namespaceMedusaDiagnostics/#function-setdiagnosismsg","text":"diagnostic_msgs::DiagnosticStatus setDiagnosisMsg( const uint8_t & level, const std::string & name, const std::string & message, const std::string & hardware_id ) Set the Diagnosis Msg object (DiagnosticStatus) Parameters : level 0->OK, 1-> WARN, 2-> ERROR, 3->STALE name name of what sensor/node is being diagnosed, ex: /sensors/ + node_name message Say if it is ok or not hardware_id name of the sensor Return : diagnostic_msgs::DiagnosticStatus","title":"function setDiagnosisMsg"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Namespaces/namespaceMedusaDiagnostics/#function-addkeyvalue","text":"void addKeyValue( diagnostic_msgs::DiagnosticArray * diagnostic_msg, const std::string & key_name, const std::string & value, const unsigned int & index ) add key values to diagnostic message Parameters : diagnostic_msg array(DiagnosticArray) of diagnostic_msgs key_name name of what we are diagnosing ex: Temperature, Current, Yaw value value being diagnosed, ex: from sensor index of the diagnostic_msg array","title":"function addKeyValue"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Namespaces/namespaceMedusaDiagnostics/#function-checklowerbound","text":"template <typename T > bool checkLowerBound( const T & value, const T & lower_bound ) Check lower bound value. Parameters : value value being diagnosed, ex: received by the sensor lower_bound value of lower bound defined by the user Template Parameters : T type of the values to be compared (int, double, float) Return : true if the sensor value is lower than the lower bound false if the sensor value is bigger than the lower bound","title":"function checkLowerBound"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Namespaces/namespaceMedusaDiagnostics/#function-checkupperbound","text":"template <typename T > bool checkUpperBound( const T & value, const T & upper_bound ) Parameters : value received by the sensor upper_bound value of the upper bound defined by the user Template Parameters : T type of the values to be compared (int, double, float) Return : true if the sensor value is bigger than the upper bound false if the sensor value is lower thant the upper bound","title":"function checkUpperBound"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Namespaces/namespaceMedusaDiagnostics/#function-warnlevel","text":"void warnLevel( diagnostic_msgs::DiagnosticArray * diagnostic_msg, const std::string & message, const unsigned int & index ) Define the level as WARN and change the message in diagnostics. Parameters : diagnostic_msg array(DiagnosticArray) of diagnostic_msgs message to clarify warning index of the diagnostic_msg array","title":"function warnLevel"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_diagnostics_library/Namespaces/namespaceMedusaDiagnostics/#function-errorlevel","text":"void errorLevel( diagnostic_msgs::DiagnosticArray * diagnostic_msg, const std::string & message, const unsigned int & index ) Define the level as Error and change the message in diagnostics. Parameters : diagnostic_msg array(DiagnosticArray) of diagnostic_msgs message to clarify error index of the diagnostic_msg array Updated on 2022-05-30 at 14:56:42 +0000","title":"function errorLevel"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Classes/","text":"Classes namespace MedusaGimmicks MedusaGimmicks namespace. Updated on 2022-05-30 at 14:56:43 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Classes/#classes","text":"namespace MedusaGimmicks MedusaGimmicks namespace. Updated on 2022-05-30 at 14:56:43 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Examples/","text":"Examples Updated on 2022-05-30 at 14:56:43 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Examples/#examples","text":"Updated on 2022-05-30 at 14:56:43 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Modules/","text":"Modules Updated on 2022-05-30 at 14:56:43 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Modules/#modules","text":"Updated on 2022-05-30 at 14:56:43 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/","text":"Namespaces namespace MedusaGimmicks MedusaGimmicks namespace. Updated on 2022-05-30 at 14:56:43 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/#namespaces","text":"namespace MedusaGimmicks MedusaGimmicks namespace. Updated on 2022-05-30 at 14:56:43 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/","text":"MedusaGimmicks MedusaGimmicks namespace. More... Functions Name template <typename T > T getParameters (ros::NodeHandle & _nh, std::string const & parameter_name) Get the Parameters object. template <typename T > T getParameters (ros::NodeHandle & _nh, std::string const & parameter_name, T default_value) Get the Parameters object. template <typename T > T getParameters (ros::NodeHandle & _nh, std::string const & parameter_name, T default_value, bool delete_param) Get the Parameters object. void spherical_to_cartesian (double bearing, double elevation, double range, double * out_pos_cart) Convert from spherical to cartesian coordinates. Used mainly with usbl fixes. int signVal (double v) Returns the sign of a double. double wrap2pi (double theta, const int mode) Wraps angle between [0, 2PI] or [-PI, PI]. double wrapTo2pi (double in) Wrap angle between [0, 2PI]. double angleDiff (double a, double b) Method to calculate the diference between angles correctly even if they wrap between -pi and pi. template <typename A ,typename B > void publishValue (ros::Publisher & pub, B & value) Attributes Name const double PI PI value. Detailed Description MedusaGimmicks namespace. Note : why the code of templates is here -> because linkage problems see https://stackoverflow.com/a/1353981 Functions Documentation function getParameters template <typename T > T getParameters( ros::NodeHandle & _nh, std::string const & parameter_name ) Get the Parameters object. Parameters : _nh ros nodehandle parameter_name string with paramenter name Template Parameters : T the type of data of a desired parameter Return : T parameter value Note : Option not considering default value, so the config file must have the parameter; function getParameters template <typename T > T getParameters( ros::NodeHandle & _nh, std::string const & parameter_name, T default_value ) Get the Parameters object. Parameters : _nh ros nodehandle parameter_name string with parameter name default_value default value of the parameter Template Parameters : T the type of data of a desired parameter Return : T parameter value Note : Option considering default value. Even if the parameter doesn't exist in config file it is possible to use a default value. function getParameters template <typename T > T getParameters( ros::NodeHandle & _nh, std::string const & parameter_name, T default_value, bool delete_param ) Get the Parameters object. Parameters : _nh ros nodehandle parameter_name string with parameter name default_value default value of the parameter delete_param boolean to delete or not the parameter from parameter server Template Parameters : T the type of data of a desired parameter Return : T parameter value Note : Option considering default value. Even if the parameter doesn't exist in config file it is possible to use a default value. Removes parameter from parameter server function spherical_to_cartesian void spherical_to_cartesian( double bearing, double elevation, double range, double * out_pos_cart ) Convert from spherical to cartesian coordinates. Used mainly with usbl fixes. Parameters : bearing horizontal angle between the direction of an object and another object or between it and the true north direction in degrees. elevation angle measured between the horizontal and the vehicle line of sight to the object range distance to the object out_pos_cart cartesian coordinates pointer function signVal int signVal( double v ) Returns the sign of a double. Parameters : v double value Return : int 1 if value is positive int 0 if value is 0 int -1 if value is negative function wrap2pi double wrap2pi( double theta, const int mode ) Wraps angle between [0, 2PI] or [-PI, PI]. Parameters : theta angle in radians mode 0 = Wrap from [0, 2*pi]; 1 = Wrap from [-pi, pi] Return : double wraped angle function wrapTo2pi double wrapTo2pi( double in ) Wrap angle between [0, 2PI]. Parameters : in angle in radians Return : double wraped angle function angleDiff double angleDiff( double a, double b ) Method to calculate the diference between angles correctly even if they wrap between -pi and pi. Parameters : a angle 1 in radians b angle 2 in radians Return : double function publishValue template <typename A , typename B > void publishValue( ros::Publisher & pub, B & value ) Parameters : pub publisher value value Template Parameters : A value type B publisher type Attributes Documentation variable PI const double PI = 3.14159265; PI value. Updated on 2022-05-30 at 14:56:43 +0000","title":"MedusaGimmicks"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/#medusagimmicks","text":"MedusaGimmicks namespace. More...","title":"MedusaGimmicks"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/#functions","text":"Name template <typename T > T getParameters (ros::NodeHandle & _nh, std::string const & parameter_name) Get the Parameters object. template <typename T > T getParameters (ros::NodeHandle & _nh, std::string const & parameter_name, T default_value) Get the Parameters object. template <typename T > T getParameters (ros::NodeHandle & _nh, std::string const & parameter_name, T default_value, bool delete_param) Get the Parameters object. void spherical_to_cartesian (double bearing, double elevation, double range, double * out_pos_cart) Convert from spherical to cartesian coordinates. Used mainly with usbl fixes. int signVal (double v) Returns the sign of a double. double wrap2pi (double theta, const int mode) Wraps angle between [0, 2PI] or [-PI, PI]. double wrapTo2pi (double in) Wrap angle between [0, 2PI]. double angleDiff (double a, double b) Method to calculate the diference between angles correctly even if they wrap between -pi and pi. template <typename A ,typename B > void publishValue (ros::Publisher & pub, B & value)","title":"Functions"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/#attributes","text":"Name const double PI PI value.","title":"Attributes"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/#detailed-description","text":"MedusaGimmicks namespace. Note : why the code of templates is here -> because linkage problems see https://stackoverflow.com/a/1353981","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/#function-getparameters","text":"template <typename T > T getParameters( ros::NodeHandle & _nh, std::string const & parameter_name ) Get the Parameters object. Parameters : _nh ros nodehandle parameter_name string with paramenter name Template Parameters : T the type of data of a desired parameter Return : T parameter value Note : Option not considering default value, so the config file must have the parameter;","title":"function getParameters"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/#function-getparameters_1","text":"template <typename T > T getParameters( ros::NodeHandle & _nh, std::string const & parameter_name, T default_value ) Get the Parameters object. Parameters : _nh ros nodehandle parameter_name string with parameter name default_value default value of the parameter Template Parameters : T the type of data of a desired parameter Return : T parameter value Note : Option considering default value. Even if the parameter doesn't exist in config file it is possible to use a default value.","title":"function getParameters"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/#function-getparameters_2","text":"template <typename T > T getParameters( ros::NodeHandle & _nh, std::string const & parameter_name, T default_value, bool delete_param ) Get the Parameters object. Parameters : _nh ros nodehandle parameter_name string with parameter name default_value default value of the parameter delete_param boolean to delete or not the parameter from parameter server Template Parameters : T the type of data of a desired parameter Return : T parameter value Note : Option considering default value. Even if the parameter doesn't exist in config file it is possible to use a default value. Removes parameter from parameter server","title":"function getParameters"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/#function-spherical_to_cartesian","text":"void spherical_to_cartesian( double bearing, double elevation, double range, double * out_pos_cart ) Convert from spherical to cartesian coordinates. Used mainly with usbl fixes. Parameters : bearing horizontal angle between the direction of an object and another object or between it and the true north direction in degrees. elevation angle measured between the horizontal and the vehicle line of sight to the object range distance to the object out_pos_cart cartesian coordinates pointer","title":"function spherical_to_cartesian"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/#function-signval","text":"int signVal( double v ) Returns the sign of a double. Parameters : v double value Return : int 1 if value is positive int 0 if value is 0 int -1 if value is negative","title":"function signVal"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/#function-wrap2pi","text":"double wrap2pi( double theta, const int mode ) Wraps angle between [0, 2PI] or [-PI, PI]. Parameters : theta angle in radians mode 0 = Wrap from [0, 2*pi]; 1 = Wrap from [-pi, pi] Return : double wraped angle","title":"function wrap2pi"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/#function-wrapto2pi","text":"double wrapTo2pi( double in ) Wrap angle between [0, 2PI]. Parameters : in angle in radians Return : double wraped angle","title":"function wrapTo2pi"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/#function-anglediff","text":"double angleDiff( double a, double b ) Method to calculate the diference between angles correctly even if they wrap between -pi and pi. Parameters : a angle 1 in radians b angle 2 in radians Return : double","title":"function angleDiff"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/#function-publishvalue","text":"template <typename A , typename B > void publishValue( ros::Publisher & pub, B & value ) Parameters : pub publisher value value Template Parameters : A value type B publisher type","title":"function publishValue"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/libraries/medusa_gimmicks_library/Namespaces/namespaceMedusaGimmicks/#variable-pi","text":"const double PI = 3.14159265; PI value. Updated on 2022-05-30 at 14:56:43 +0000","title":"variable PI"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/","text":"Classes namespace RemoteControllerNode class RemoteControllerNode Updated on 2022-05-30 at 14:56:45 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/#classes","text":"namespace RemoteControllerNode class RemoteControllerNode Updated on 2022-05-30 at 14:56:45 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/","text":"RemoteControllerNode::RemoteControllerNode More... Public Functions Name def init (self self) def timerCallback (self self, event event) def initializeTimer (self self) def initializeSubscribers (self self) def initializePublishers (self self) def initializeJoystick (self self) def state_callback (self self, msg msg) Public Attributes Name node_frequency h_timerActivate yaw_state_ timer state_sub surge_pub sway_pub heave_pub yaw_rate_pub yaw_pub depth_pub control_assignment Detailed Description class RemoteControllerNode::RemoteControllerNode; Remote controller ROS node class. Receives from a joystick (using pygame) the desired controls for the inner-loops and publishes these periodically (at a pre-defined frequency) to the inner-loops of the vehicle Public Functions Documentation function init def __init__( self self ) Class constructor. Initializes the ros node, loads the parameters from the ros parameter server, creates the inner-loops publishers and initializes the timer that publishes the desired inputs to the inner-loops function timerCallback def timerCallback( self self, event event ) Callback used to publish to the inner-loops the desired control inputs :param event: A timer event - unused but required by the ROS API function initializeTimer def initializeTimer( self self ) Method that starts the system timer that periodically calls a callback function initializeSubscribers def initializeSubscribers( self self ) Method that initializes the ROS subscribers (to receive the current state of the AUV) function initializePublishers def initializePublishers( self self ) Method that initializes the ROS publishers (to publish the references for the inner-loops) function initializeJoystick def initializeJoystick( self self ) Method that initializes the joystick driver (using pygame) function state_callback def state_callback( self self, msg msg ) Callback that is called when a message with the current state of the AUV is received. Currently only the yaw orientation is saved (used to switch between yaw and yaw-rate controllers) :param msg: NavigationStatus message Public Attributes Documentation variable node_frequency node_frequency; variable h_timerActivate h_timerActivate; variable yaw_state_ yaw_state_; variable timer timer; variable state_sub state_sub; variable surge_pub surge_pub; variable sway_pub sway_pub; variable heave_pub heave_pub; variable yaw_rate_pub yaw_rate_pub; variable yaw_pub yaw_pub; variable depth_pub depth_pub; variable control_assignment control_assignment; Updated on 2022-05-30 at 14:56:45 +0000","title":"RemoteControllerNode::RemoteControllerNode"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#remotecontrollernoderemotecontrollernode","text":"More...","title":"RemoteControllerNode::RemoteControllerNode"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#public-functions","text":"Name def init (self self) def timerCallback (self self, event event) def initializeTimer (self self) def initializeSubscribers (self self) def initializePublishers (self self) def initializeJoystick (self self) def state_callback (self self, msg msg)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#public-attributes","text":"Name node_frequency h_timerActivate yaw_state_ timer state_sub surge_pub sway_pub heave_pub yaw_rate_pub yaw_pub depth_pub control_assignment","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#detailed-description","text":"class RemoteControllerNode::RemoteControllerNode; Remote controller ROS node class. Receives from a joystick (using pygame) the desired controls for the inner-loops and publishes these periodically (at a pre-defined frequency) to the inner-loops of the vehicle","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#function-init","text":"def __init__( self self ) Class constructor. Initializes the ros node, loads the parameters from the ros parameter server, creates the inner-loops publishers and initializes the timer that publishes the desired inputs to the inner-loops","title":"function init"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#function-timercallback","text":"def timerCallback( self self, event event ) Callback used to publish to the inner-loops the desired control inputs :param event: A timer event - unused but required by the ROS API","title":"function timerCallback"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#function-initializetimer","text":"def initializeTimer( self self ) Method that starts the system timer that periodically calls a callback","title":"function initializeTimer"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#function-initializesubscribers","text":"def initializeSubscribers( self self ) Method that initializes the ROS subscribers (to receive the current state of the AUV)","title":"function initializeSubscribers"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#function-initializepublishers","text":"def initializePublishers( self self ) Method that initializes the ROS publishers (to publish the references for the inner-loops)","title":"function initializePublishers"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#function-initializejoystick","text":"def initializeJoystick( self self ) Method that initializes the joystick driver (using pygame)","title":"function initializeJoystick"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#function-state_callback","text":"def state_callback( self self, msg msg ) Callback that is called when a message with the current state of the AUV is received. Currently only the yaw orientation is saved (used to switch between yaw and yaw-rate controllers) :param msg: NavigationStatus message","title":"function state_callback"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#variable-node_frequency","text":"node_frequency;","title":"variable node_frequency"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#variable-h_timeractivate","text":"h_timerActivate;","title":"variable h_timerActivate"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#variable-yaw_state_","text":"yaw_state_;","title":"variable yaw_state_"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#variable-timer","text":"timer;","title":"variable timer"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#variable-state_sub","text":"state_sub;","title":"variable state_sub"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#variable-surge_pub","text":"surge_pub;","title":"variable surge_pub"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#variable-sway_pub","text":"sway_pub;","title":"variable sway_pub"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#variable-heave_pub","text":"heave_pub;","title":"variable heave_pub"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#variable-yaw_rate_pub","text":"yaw_rate_pub;","title":"variable yaw_rate_pub"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#variable-yaw_pub","text":"yaw_pub;","title":"variable yaw_pub"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#variable-depth_pub","text":"depth_pub;","title":"variable depth_pub"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Classes/classRemoteControllerNode_1_1RemoteControllerNode/#variable-control_assignment","text":"control_assignment; Updated on 2022-05-30 at 14:56:45 +0000","title":"variable control_assignment"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Examples/","text":"Examples Updated on 2022-05-30 at 14:56:45 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Examples/#examples","text":"Updated on 2022-05-30 at 14:56:45 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Modules/","text":"Modules Updated on 2022-05-30 at 14:56:45 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Modules/#modules","text":"Updated on 2022-05-30 at 14:56:45 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Namespaces/","text":"Namespaces namespace RemoteControllerNode Updated on 2022-05-30 at 14:56:45 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Namespaces/#namespaces","text":"namespace RemoteControllerNode Updated on 2022-05-30 at 14:56:45 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Namespaces/namespaceRemoteControllerNode/","text":"RemoteControllerNode More... Classes Name class RemoteControllerNode::RemoteControllerNode Functions Name def main () Detailed Description @author: Marcelo Fialho Jacinto @email: marcelo.jacinto@tecnico.ulisboa.pt @date: 25/11/2021 @licence: MIT Functions Documentation function main def main() Initialize the RemoteControllerNode and let the timer callback do all the work Updated on 2022-05-30 at 14:56:45 +0000","title":"RemoteControllerNode"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Namespaces/namespaceRemoteControllerNode/#remotecontrollernode","text":"More...","title":"RemoteControllerNode"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Namespaces/namespaceRemoteControllerNode/#classes","text":"Name class RemoteControllerNode::RemoteControllerNode","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Namespaces/namespaceRemoteControllerNode/#functions","text":"Name def main ()","title":"Functions"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Namespaces/namespaceRemoteControllerNode/#detailed-description","text":"@author: Marcelo Fialho Jacinto @email: marcelo.jacinto@tecnico.ulisboa.pt @date: 25/11/2021 @licence: MIT","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Namespaces/namespaceRemoteControllerNode/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/remote_controller/Namespaces/namespaceRemoteControllerNode/#function-main","text":"def main() Initialize the RemoteControllerNode and let the timer callback do all the work Updated on 2022-05-30 at 14:56:45 +0000","title":"function main"},{"location":"api/markdown/medusa_base/medusa_addons/safety_feature/Classes/","text":"Classes Updated on 2022-05-30 at 14:56:45 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_addons/safety_feature/Classes/#classes","text":"Updated on 2022-05-30 at 14:56:45 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_addons/safety_feature/Examples/","text":"Examples Updated on 2022-05-30 at 14:56:45 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_addons/safety_feature/Examples/#examples","text":"Updated on 2022-05-30 at 14:56:45 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_addons/safety_feature/Modules/","text":"Modules Updated on 2022-05-30 at 14:56:45 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_addons/safety_feature/Modules/#modules","text":"Updated on 2022-05-30 at 14:56:45 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_addons/safety_feature/Namespaces/","text":"Namespaces Updated on 2022-05-30 at 14:56:45 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_addons/safety_feature/Namespaces/#namespaces","text":"Updated on 2022-05-30 at 14:56:45 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Classes/","text":"Classes namespace diagnostic_aggregator Construct a new pluginlib export class object. class StatusAnalyzer Class StatusAnalyzer derived from AnalyzerGroup. Updated on 2022-05-30 at 14:56:46 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Classes/#classes","text":"namespace diagnostic_aggregator Construct a new pluginlib export class object. class StatusAnalyzer Class StatusAnalyzer derived from AnalyzerGroup. Updated on 2022-05-30 at 14:56:46 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Classes/classdiagnostic__aggregator_1_1StatusAnalyzer/","text":"diagnostic_aggregator::StatusAnalyzer Class StatusAnalyzer derived from AnalyzerGroup. #include <StatusAnalyzer.h> Inherits from AnalyzerGroup Public Functions Name StatusAnalyzer () Construct a new Status Analyzer object. bool init (const std::string base_path, const ros::NodeHandle & n) override Initializes StatusAnalyzer from namespace. std::vector< diagnostic_msgs::DiagnosticStatusPtr > report () override Reports current state, returns vector of formatted status messages. Public Functions Documentation function StatusAnalyzer StatusAnalyzer() Construct a new Status Analyzer object. function init bool init( const std::string base_path, const ros::NodeHandle & n ) override Initializes StatusAnalyzer from namespace. Parameters : base_path : Prefix for all analyzers (ex: 'Sensors') n : NodeHandle in full namespace Return : True if initialization succeed, false if no errors function report std::vector< diagnostic_msgs::DiagnosticStatusPtr > report() override Reports current state, returns vector of formatted status messages. Return : std::vector Updated on 2022-05-30 at 14:56:46 +0000","title":"diagnostic_aggregator::StatusAnalyzer"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Classes/classdiagnostic__aggregator_1_1StatusAnalyzer/#diagnostic_aggregatorstatusanalyzer","text":"Class StatusAnalyzer derived from AnalyzerGroup. #include <StatusAnalyzer.h> Inherits from AnalyzerGroup","title":"diagnostic_aggregator::StatusAnalyzer"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Classes/classdiagnostic__aggregator_1_1StatusAnalyzer/#public-functions","text":"Name StatusAnalyzer () Construct a new Status Analyzer object. bool init (const std::string base_path, const ros::NodeHandle & n) override Initializes StatusAnalyzer from namespace. std::vector< diagnostic_msgs::DiagnosticStatusPtr > report () override Reports current state, returns vector of formatted status messages.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Classes/classdiagnostic__aggregator_1_1StatusAnalyzer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Classes/classdiagnostic__aggregator_1_1StatusAnalyzer/#function-statusanalyzer","text":"StatusAnalyzer() Construct a new Status Analyzer object.","title":"function StatusAnalyzer"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Classes/classdiagnostic__aggregator_1_1StatusAnalyzer/#function-init","text":"bool init( const std::string base_path, const ros::NodeHandle & n ) override Initializes StatusAnalyzer from namespace. Parameters : base_path : Prefix for all analyzers (ex: 'Sensors') n : NodeHandle in full namespace Return : True if initialization succeed, false if no errors","title":"function init"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Classes/classdiagnostic__aggregator_1_1StatusAnalyzer/#function-report","text":"std::vector< diagnostic_msgs::DiagnosticStatusPtr > report() override Reports current state, returns vector of formatted status messages. Return : std::vector Updated on 2022-05-30 at 14:56:46 +0000","title":"function report"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Examples/","text":"Examples Updated on 2022-05-30 at 14:56:46 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Examples/#examples","text":"Updated on 2022-05-30 at 14:56:46 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Modules/","text":"Modules Updated on 2022-05-30 at 14:56:46 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Modules/#modules","text":"Updated on 2022-05-30 at 14:56:46 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Namespaces/","text":"Namespaces namespace diagnostic_aggregator Construct a new pluginlib export class object. Updated on 2022-05-30 at 14:56:46 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Namespaces/#namespaces","text":"namespace diagnostic_aggregator Construct a new pluginlib export class object. Updated on 2022-05-30 at 14:56:46 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Namespaces/namespacediagnostic__aggregator/","text":"diagnostic_aggregator Construct a new pluginlib export class object. Classes Name class diagnostic_aggregator::StatusAnalyzer Class StatusAnalyzer derived from AnalyzerGroup. Updated on 2022-05-30 at 14:56:46 +0000","title":"diagnostic_aggregator"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Namespaces/namespacediagnostic__aggregator/#diagnostic_aggregator","text":"Construct a new pluginlib export class object.","title":"diagnostic_aggregator"},{"location":"api/markdown/medusa_base/medusa_addons/status_aggregator/Namespaces/namespacediagnostic__aggregator/#classes","text":"Name class diagnostic_aggregator::StatusAnalyzer Class StatusAnalyzer derived from AnalyzerGroup. Updated on 2022-05-30 at 14:56:46 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/","text":"Classes namespace medusa_bringup_algorithms namespace MedusaSetup class MedusaSetup class Process class ProcessActionType class ProcessNotFound namespace medusa_bringup_ros namespace MedusaBringupVxNode class MedusaBringupVxNode namespace setup Updated on 2022-05-30 at 14:56:43 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/#classes","text":"namespace medusa_bringup_algorithms namespace MedusaSetup class MedusaSetup class Process class ProcessActionType class ProcessNotFound namespace medusa_bringup_ros namespace MedusaBringupVxNode class MedusaBringupVxNode namespace setup Updated on 2022-05-30 at 14:56:43 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/","text":"medusa_bringup_algorithms::MedusaSetup::MedusaSetup Public Functions Name def init (self self, vehicle_name vehicle_name, config_package_path config_package_path, folder folder, namespace namespace, vehicle_configuration vehicle_configuration =None) def publish_process_state (self self, event event) def callback_manage_process (self self, req req) def clean_ros_processes (self self) def create_processes (self self) def start_init_processes (self self) def start_all_processes (self self) def stop_all_processes (self self) def get_process_from_name (self self, name name) def get_dependency_process_list (self self, process process) def are_dependencies_met (self self, process process) def check_and_start_dependencies (self self, process process) def start_process (self self, p p, start_dependencies start_dependencies =False) def start_process_from_name (self self, name name, start_dependencies start_dependencies =False) def stop_process_from_name (self self, name name) def restart_process_from_name (self self, name name) def kill_process_from_name (self self, name name) def create_response (status status, message message) def stop_process (p p) def restart_process (p p) def kill_process (p p) Public Attributes Name vehicle_name config_package_path folder namespace vehicle_configuration process_list process_config process_state_publish_rate process_state_publisher manage_process_server Public Functions Documentation function init def __init__( self self, vehicle_name vehicle_name, config_package_path config_package_path, folder folder, namespace namespace, vehicle_configuration vehicle_configuration =None ) function publish_process_state def publish_process_state( self self, event event ) function callback_manage_process def callback_manage_process( self self, req req ) function clean_ros_processes def clean_ros_processes( self self ) function create_processes def create_processes( self self ) function start_init_processes def start_init_processes( self self ) function start_all_processes def start_all_processes( self self ) function stop_all_processes def stop_all_processes( self self ) function get_process_from_name def get_process_from_name( self self, name name ) function get_dependency_process_list def get_dependency_process_list( self self, process process ) function are_dependencies_met def are_dependencies_met( self self, process process ) function check_and_start_dependencies def check_and_start_dependencies( self self, process process ) function start_process def start_process( self self, p p, start_dependencies start_dependencies =False ) function start_process_from_name def start_process_from_name( self self, name name, start_dependencies start_dependencies =False ) function stop_process_from_name def stop_process_from_name( self self, name name ) function restart_process_from_name def restart_process_from_name( self self, name name ) function kill_process_from_name def kill_process_from_name( self self, name name ) function create_response static def create_response( status status, message message ) function stop_process static def stop_process( p p ) function restart_process static def restart_process( p p ) function kill_process static def kill_process( p p ) Public Attributes Documentation variable vehicle_name vehicle_name; variable config_package_path config_package_path; variable folder folder; variable namespace namespace; variable vehicle_configuration vehicle_configuration; variable process_list process_list; variable process_config process_config; variable process_state_publish_rate process_state_publish_rate; variable process_state_publisher process_state_publisher; variable manage_process_server manage_process_server; Updated on 2022-05-30 at 14:56:43 +0000","title":"medusa_bringup_algorithms::MedusaSetup::MedusaSetup"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#medusa_bringup_algorithmsmedusasetupmedusasetup","text":"","title":"medusa_bringup_algorithms::MedusaSetup::MedusaSetup"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#public-functions","text":"Name def init (self self, vehicle_name vehicle_name, config_package_path config_package_path, folder folder, namespace namespace, vehicle_configuration vehicle_configuration =None) def publish_process_state (self self, event event) def callback_manage_process (self self, req req) def clean_ros_processes (self self) def create_processes (self self) def start_init_processes (self self) def start_all_processes (self self) def stop_all_processes (self self) def get_process_from_name (self self, name name) def get_dependency_process_list (self self, process process) def are_dependencies_met (self self, process process) def check_and_start_dependencies (self self, process process) def start_process (self self, p p, start_dependencies start_dependencies =False) def start_process_from_name (self self, name name, start_dependencies start_dependencies =False) def stop_process_from_name (self self, name name) def restart_process_from_name (self self, name name) def kill_process_from_name (self self, name name) def create_response (status status, message message) def stop_process (p p) def restart_process (p p) def kill_process (p p)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#public-attributes","text":"Name vehicle_name config_package_path folder namespace vehicle_configuration process_list process_config process_state_publish_rate process_state_publisher manage_process_server","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-init","text":"def __init__( self self, vehicle_name vehicle_name, config_package_path config_package_path, folder folder, namespace namespace, vehicle_configuration vehicle_configuration =None )","title":"function init"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-publish_process_state","text":"def publish_process_state( self self, event event )","title":"function publish_process_state"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-callback_manage_process","text":"def callback_manage_process( self self, req req )","title":"function callback_manage_process"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-clean_ros_processes","text":"def clean_ros_processes( self self )","title":"function clean_ros_processes"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-create_processes","text":"def create_processes( self self )","title":"function create_processes"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-start_init_processes","text":"def start_init_processes( self self )","title":"function start_init_processes"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-start_all_processes","text":"def start_all_processes( self self )","title":"function start_all_processes"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-stop_all_processes","text":"def stop_all_processes( self self )","title":"function stop_all_processes"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-get_process_from_name","text":"def get_process_from_name( self self, name name )","title":"function get_process_from_name"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-get_dependency_process_list","text":"def get_dependency_process_list( self self, process process )","title":"function get_dependency_process_list"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-are_dependencies_met","text":"def are_dependencies_met( self self, process process )","title":"function are_dependencies_met"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-check_and_start_dependencies","text":"def check_and_start_dependencies( self self, process process )","title":"function check_and_start_dependencies"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-start_process","text":"def start_process( self self, p p, start_dependencies start_dependencies =False )","title":"function start_process"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-start_process_from_name","text":"def start_process_from_name( self self, name name, start_dependencies start_dependencies =False )","title":"function start_process_from_name"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-stop_process_from_name","text":"def stop_process_from_name( self self, name name )","title":"function stop_process_from_name"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-restart_process_from_name","text":"def restart_process_from_name( self self, name name )","title":"function restart_process_from_name"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-kill_process_from_name","text":"def kill_process_from_name( self self, name name )","title":"function kill_process_from_name"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-create_response","text":"static def create_response( status status, message message )","title":"function create_response"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-stop_process","text":"static def stop_process( p p )","title":"function stop_process"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-restart_process","text":"static def restart_process( p p )","title":"function restart_process"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#function-kill_process","text":"static def kill_process( p p )","title":"function kill_process"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#variable-vehicle_name","text":"vehicle_name;","title":"variable vehicle_name"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#variable-config_package_path","text":"config_package_path;","title":"variable config_package_path"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#variable-folder","text":"folder;","title":"variable folder"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#variable-namespace","text":"namespace;","title":"variable namespace"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#variable-vehicle_configuration","text":"vehicle_configuration;","title":"variable vehicle_configuration"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#variable-process_list","text":"process_list;","title":"variable process_list"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#variable-process_config","text":"process_config;","title":"variable process_config"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#variable-process_state_publish_rate","text":"process_state_publish_rate;","title":"variable process_state_publish_rate"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#variable-process_state_publisher","text":"process_state_publisher;","title":"variable process_state_publisher"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1MedusaSetup/#variable-manage_process_server","text":"manage_process_server; Updated on 2022-05-30 at 14:56:43 +0000","title":"variable manage_process_server"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/","text":"medusa_bringup_algorithms::MedusaSetup::Process Public Functions Name def init (self self, name name, cmd cmd, vehicle_name vehicle_name, config_package_path config_package_path, folder folder, namespace namespace, vehicle_configuration vehicle_configuration =None, args args =None, launch_on_startup launch_on_startup =False, delay_before_start delay_before_start =0.0, dependencies dependencies =None) def start (self self) def restart (self self) def stop (self self) def kill (self self) def is_active (self self) Public Attributes Name name config_package_path cmd folder namespace vehicle_configuration args dependencies launch_on_startup delay_before_start process vehicle_name Public Functions Documentation function init def __init__( self self, name name, cmd cmd, vehicle_name vehicle_name, config_package_path config_package_path, folder folder, namespace namespace, vehicle_configuration vehicle_configuration =None, args args =None, launch_on_startup launch_on_startup =False, delay_before_start delay_before_start =0.0, dependencies dependencies =None ) function start def start( self self ) function restart def restart( self self ) function stop def stop( self self ) function kill def kill( self self ) function is_active def is_active( self self ) Public Attributes Documentation variable name name; variable config_package_path config_package_path; variable cmd cmd; variable folder folder; variable namespace namespace; variable vehicle_configuration vehicle_configuration; variable args args; variable dependencies dependencies; variable launch_on_startup launch_on_startup; variable delay_before_start delay_before_start; variable process process; variable vehicle_name vehicle_name; Updated on 2022-05-30 at 14:56:43 +0000","title":"medusa_bringup_algorithms::MedusaSetup::Process"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#medusa_bringup_algorithmsmedusasetupprocess","text":"","title":"medusa_bringup_algorithms::MedusaSetup::Process"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#public-functions","text":"Name def init (self self, name name, cmd cmd, vehicle_name vehicle_name, config_package_path config_package_path, folder folder, namespace namespace, vehicle_configuration vehicle_configuration =None, args args =None, launch_on_startup launch_on_startup =False, delay_before_start delay_before_start =0.0, dependencies dependencies =None) def start (self self) def restart (self self) def stop (self self) def kill (self self) def is_active (self self)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#public-attributes","text":"Name name config_package_path cmd folder namespace vehicle_configuration args dependencies launch_on_startup delay_before_start process vehicle_name","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#function-init","text":"def __init__( self self, name name, cmd cmd, vehicle_name vehicle_name, config_package_path config_package_path, folder folder, namespace namespace, vehicle_configuration vehicle_configuration =None, args args =None, launch_on_startup launch_on_startup =False, delay_before_start delay_before_start =0.0, dependencies dependencies =None )","title":"function init"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#function-start","text":"def start( self self )","title":"function start"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#function-restart","text":"def restart( self self )","title":"function restart"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#function-stop","text":"def stop( self self )","title":"function stop"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#function-kill","text":"def kill( self self )","title":"function kill"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#function-is_active","text":"def is_active( self self )","title":"function is_active"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#variable-name","text":"name;","title":"variable name"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#variable-config_package_path","text":"config_package_path;","title":"variable config_package_path"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#variable-cmd","text":"cmd;","title":"variable cmd"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#variable-folder","text":"folder;","title":"variable folder"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#variable-namespace","text":"namespace;","title":"variable namespace"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#variable-vehicle_configuration","text":"vehicle_configuration;","title":"variable vehicle_configuration"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#variable-args","text":"args;","title":"variable args"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#variable-dependencies","text":"dependencies;","title":"variable dependencies"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#variable-launch_on_startup","text":"launch_on_startup;","title":"variable launch_on_startup"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#variable-delay_before_start","text":"delay_before_start;","title":"variable delay_before_start"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#variable-process","text":"process;","title":"variable process"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1Process/#variable-vehicle_name","text":"vehicle_name; Updated on 2022-05-30 at 14:56:43 +0000","title":"variable vehicle_name"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1ProcessActionType/","text":"medusa_bringup_algorithms::MedusaSetup::ProcessActionType Inherits from object Public Attributes Name int START int STOP int RESTART int KILL int START_ALL int STOP_ALL Public Attributes Documentation variable START static int START = 1; variable STOP static int STOP = 2; variable RESTART static int RESTART = 3; variable KILL static int KILL = 4; variable START_ALL static int START_ALL = 5; variable STOP_ALL static int STOP_ALL = 6; Updated on 2022-05-30 at 14:56:43 +0000","title":"medusa_bringup_algorithms::MedusaSetup::ProcessActionType"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1ProcessActionType/#medusa_bringup_algorithmsmedusasetupprocessactiontype","text":"Inherits from object","title":"medusa_bringup_algorithms::MedusaSetup::ProcessActionType"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1ProcessActionType/#public-attributes","text":"Name int START int STOP int RESTART int KILL int START_ALL int STOP_ALL","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1ProcessActionType/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1ProcessActionType/#variable-start","text":"static int START = 1;","title":"variable START"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1ProcessActionType/#variable-stop","text":"static int STOP = 2;","title":"variable STOP"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1ProcessActionType/#variable-restart","text":"static int RESTART = 3;","title":"variable RESTART"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1ProcessActionType/#variable-kill","text":"static int KILL = 4;","title":"variable KILL"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1ProcessActionType/#variable-start_all","text":"static int START_ALL = 5;","title":"variable START_ALL"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1ProcessActionType/#variable-stop_all","text":"static int STOP_ALL = 6; Updated on 2022-05-30 at 14:56:43 +0000","title":"variable STOP_ALL"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1ProcessNotFound/","text":"medusa_bringup_algorithms::MedusaSetup::ProcessNotFound Inherits from Exception Updated on 2022-05-30 at 14:56:43 +0000","title":"medusa_bringup_algorithms::MedusaSetup::ProcessNotFound"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__algorithms_1_1MedusaSetup_1_1ProcessNotFound/#medusa_bringup_algorithmsmedusasetupprocessnotfound","text":"Inherits from Exception Updated on 2022-05-30 at 14:56:43 +0000","title":"medusa_bringup_algorithms::MedusaSetup::ProcessNotFound"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__ros_1_1MedusaBringupVxNode_1_1MedusaBringupVxNode/","text":"medusa_bringup_ros::MedusaBringupVxNode::MedusaBringupVxNode Public Functions Name def init (self self) def loadParams (self self) Public Attributes Name name config_package_path folder namespace vehicle_configuration Public Functions Documentation function init def __init__( self self ) Constructor for ros node ########################################################################################### @.@ Init node ########################################################################################### function loadParams def loadParams( self self ) Public Attributes Documentation variable name name; variable config_package_path config_package_path; variable folder folder; variable namespace namespace; variable vehicle_configuration vehicle_configuration; Updated on 2022-05-30 at 14:56:43 +0000","title":"medusa_bringup_ros::MedusaBringupVxNode::MedusaBringupVxNode"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__ros_1_1MedusaBringupVxNode_1_1MedusaBringupVxNode/#medusa_bringup_rosmedusabringupvxnodemedusabringupvxnode","text":"","title":"medusa_bringup_ros::MedusaBringupVxNode::MedusaBringupVxNode"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__ros_1_1MedusaBringupVxNode_1_1MedusaBringupVxNode/#public-functions","text":"Name def init (self self) def loadParams (self self)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__ros_1_1MedusaBringupVxNode_1_1MedusaBringupVxNode/#public-attributes","text":"Name name config_package_path folder namespace vehicle_configuration","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__ros_1_1MedusaBringupVxNode_1_1MedusaBringupVxNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__ros_1_1MedusaBringupVxNode_1_1MedusaBringupVxNode/#function-init","text":"def __init__( self self ) Constructor for ros node ########################################################################################### @.@ Init node ###########################################################################################","title":"function init"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__ros_1_1MedusaBringupVxNode_1_1MedusaBringupVxNode/#function-loadparams","text":"def loadParams( self self )","title":"function loadParams"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__ros_1_1MedusaBringupVxNode_1_1MedusaBringupVxNode/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__ros_1_1MedusaBringupVxNode_1_1MedusaBringupVxNode/#variable-name","text":"name;","title":"variable name"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__ros_1_1MedusaBringupVxNode_1_1MedusaBringupVxNode/#variable-config_package_path","text":"config_package_path;","title":"variable config_package_path"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__ros_1_1MedusaBringupVxNode_1_1MedusaBringupVxNode/#variable-folder","text":"folder;","title":"variable folder"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__ros_1_1MedusaBringupVxNode_1_1MedusaBringupVxNode/#variable-namespace","text":"namespace;","title":"variable namespace"},{"location":"api/markdown/medusa_base/medusa_bringup/Classes/classmedusa__bringup__ros_1_1MedusaBringupVxNode_1_1MedusaBringupVxNode/#variable-vehicle_configuration","text":"vehicle_configuration; Updated on 2022-05-30 at 14:56:43 +0000","title":"variable vehicle_configuration"},{"location":"api/markdown/medusa_base/medusa_bringup/Examples/","text":"Examples Updated on 2022-05-30 at 14:56:43 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_bringup/Examples/#examples","text":"Updated on 2022-05-30 at 14:56:43 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_bringup/Modules/","text":"Modules Updated on 2022-05-30 at 14:56:43 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_bringup/Modules/#modules","text":"Updated on 2022-05-30 at 14:56:43 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/","text":"Namespaces namespace medusa_bringup_algorithms namespace MedusaSetup namespace medusa_bringup_ros namespace MedusaBringupVxNode namespace setup Updated on 2022-05-30 at 14:56:43 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/#namespaces","text":"namespace medusa_bringup_algorithms namespace MedusaSetup namespace medusa_bringup_ros namespace MedusaBringupVxNode namespace setup Updated on 2022-05-30 at 14:56:43 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__algorithms/","text":"medusa_bringup_algorithms Namespaces Name medusa_bringup_algorithms::MedusaSetup Updated on 2022-05-30 at 14:56:43 +0000","title":"medusa_bringup_algorithms"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__algorithms/#medusa_bringup_algorithms","text":"","title":"medusa_bringup_algorithms"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__algorithms/#namespaces","text":"Name medusa_bringup_algorithms::MedusaSetup Updated on 2022-05-30 at 14:56:43 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__algorithms_1_1MedusaSetup/","text":"medusa_bringup_algorithms::MedusaSetup Classes Name class medusa_bringup_algorithms::MedusaSetup::MedusaSetup class medusa_bringup_algorithms::MedusaSetup::Process class medusa_bringup_algorithms::MedusaSetup::ProcessActionType class medusa_bringup_algorithms::MedusaSetup::ProcessNotFound Functions Name def kill_rosmaster () Attributes Name float PROCESS_TIMEOUT_RESTART Functions Documentation function kill_rosmaster def kill_rosmaster() Attributes Documentation variable PROCESS_TIMEOUT_RESTART float PROCESS_TIMEOUT_RESTART = 5.0; Updated on 2022-05-30 at 14:56:43 +0000","title":"medusa_bringup_algorithms::MedusaSetup"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__algorithms_1_1MedusaSetup/#medusa_bringup_algorithmsmedusasetup","text":"","title":"medusa_bringup_algorithms::MedusaSetup"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__algorithms_1_1MedusaSetup/#classes","text":"Name class medusa_bringup_algorithms::MedusaSetup::MedusaSetup class medusa_bringup_algorithms::MedusaSetup::Process class medusa_bringup_algorithms::MedusaSetup::ProcessActionType class medusa_bringup_algorithms::MedusaSetup::ProcessNotFound","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__algorithms_1_1MedusaSetup/#functions","text":"Name def kill_rosmaster ()","title":"Functions"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__algorithms_1_1MedusaSetup/#attributes","text":"Name float PROCESS_TIMEOUT_RESTART","title":"Attributes"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__algorithms_1_1MedusaSetup/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__algorithms_1_1MedusaSetup/#function-kill_rosmaster","text":"def kill_rosmaster()","title":"function kill_rosmaster"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__algorithms_1_1MedusaSetup/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__algorithms_1_1MedusaSetup/#variable-process_timeout_restart","text":"float PROCESS_TIMEOUT_RESTART = 5.0; Updated on 2022-05-30 at 14:56:43 +0000","title":"variable PROCESS_TIMEOUT_RESTART"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__ros/","text":"medusa_bringup_ros Namespaces Name medusa_bringup_ros::MedusaBringupVxNode Updated on 2022-05-30 at 14:56:43 +0000","title":"medusa_bringup_ros"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__ros/#medusa_bringup_ros","text":"","title":"medusa_bringup_ros"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__ros/#namespaces","text":"Name medusa_bringup_ros::MedusaBringupVxNode Updated on 2022-05-30 at 14:56:43 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__ros_1_1MedusaBringupVxNode/","text":"medusa_bringup_ros::MedusaBringupVxNode More... Classes Name class medusa_bringup_ros::MedusaBringupVxNode::MedusaBringupVxNode Functions Name def main () Detailed Description Developers: DSOR Team -> @isr.ist.pt Instituto Superior Tecnico Description: Please check the documentation of this package for more info. Functions Documentation function main def main() Updated on 2022-05-30 at 14:56:43 +0000","title":"medusa_bringup_ros::MedusaBringupVxNode"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__ros_1_1MedusaBringupVxNode/#medusa_bringup_rosmedusabringupvxnode","text":"More...","title":"medusa_bringup_ros::MedusaBringupVxNode"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__ros_1_1MedusaBringupVxNode/#classes","text":"Name class medusa_bringup_ros::MedusaBringupVxNode::MedusaBringupVxNode","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__ros_1_1MedusaBringupVxNode/#functions","text":"Name def main ()","title":"Functions"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__ros_1_1MedusaBringupVxNode/#detailed-description","text":"Developers: DSOR Team -> @isr.ist.pt Instituto Superior Tecnico Description: Please check the documentation of this package for more info.","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__ros_1_1MedusaBringupVxNode/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacemedusa__bringup__ros_1_1MedusaBringupVxNode/#function-main","text":"def main() Updated on 2022-05-30 at 14:56:43 +0000","title":"function main"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacesetup/","text":"setup Attributes Name d Attributes Documentation variable d d = generate_distutils_setup( packages=['medusa_bringup_algorithms', 'medusa_bringup_ros'], package_dir={'medusa_bringup_algorithms': 'src/medusa_bringup_algorithms', 'medusa_bringup_ros': 'src/medusa_bringup_ros'} ); Updated on 2022-05-30 at 14:56:43 +0000","title":"setup"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacesetup/#setup","text":"","title":"setup"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacesetup/#attributes","text":"Name d","title":"Attributes"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacesetup/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_bringup/Namespaces/namespacesetup/#variable-d","text":"d = generate_distutils_setup( packages=['medusa_bringup_algorithms', 'medusa_bringup_ros'], package_dir={'medusa_bringup_algorithms': 'src/medusa_bringup_algorithms', 'medusa_bringup_ros': 'src/medusa_bringup_ros'} ); Updated on 2022-05-30 at 14:56:43 +0000","title":"variable d"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/","text":"Classes class Gnss2State class State2Gnss class UsblFix2State Updated on 2022-05-30 at 14:56:43 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/#classes","text":"class Gnss2State class State2Gnss class UsblFix2State Updated on 2022-05-30 at 14:56:43 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classGnss2State/","text":"Gnss2State Public Functions Name Gnss2State (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~Gnss2State () Public Functions Documentation function Gnss2State Gnss2State( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private ) function ~Gnss2State ~Gnss2State() Updated on 2022-05-30 at 14:56:43 +0000","title":"Gnss2State"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classGnss2State/#gnss2state","text":"","title":"Gnss2State"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classGnss2State/#public-functions","text":"Name Gnss2State (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~Gnss2State ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classGnss2State/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classGnss2State/#function-gnss2state","text":"Gnss2State( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private )","title":"function Gnss2State"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classGnss2State/#function-gnss2state_1","text":"~Gnss2State() Updated on 2022-05-30 at 14:56:43 +0000","title":"function ~Gnss2State"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classState2Gnss/","text":"State2Gnss Public Functions Name State2Gnss (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~State2Gnss () Public Functions Documentation function State2Gnss State2Gnss( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private ) function ~State2Gnss ~State2Gnss() Updated on 2022-05-30 at 14:56:43 +0000","title":"State2Gnss"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classState2Gnss/#state2gnss","text":"","title":"State2Gnss"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classState2Gnss/#public-functions","text":"Name State2Gnss (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~State2Gnss ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classState2Gnss/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classState2Gnss/#function-state2gnss","text":"State2Gnss( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private )","title":"function State2Gnss"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classState2Gnss/#function-state2gnss_1","text":"~State2Gnss() Updated on 2022-05-30 at 14:56:43 +0000","title":"function ~State2Gnss"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classUsblFix2State/","text":"UsblFix2State Public Functions Name UsblFix2State (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~UsblFix2State () Public Functions Documentation function UsblFix2State UsblFix2State( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private ) function ~UsblFix2State ~UsblFix2State() Updated on 2022-05-30 at 14:56:43 +0000","title":"UsblFix2State"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classUsblFix2State/#usblfix2state","text":"","title":"UsblFix2State"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classUsblFix2State/#public-functions","text":"Name UsblFix2State (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~UsblFix2State ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classUsblFix2State/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classUsblFix2State/#function-usblfix2state","text":"UsblFix2State( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private )","title":"function UsblFix2State"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Classes/classUsblFix2State/#function-usblfix2state_1","text":"~UsblFix2State() Updated on 2022-05-30 at 14:56:43 +0000","title":"function ~UsblFix2State"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Examples/","text":"Examples Updated on 2022-05-30 at 14:56:43 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Examples/#examples","text":"Updated on 2022-05-30 at 14:56:43 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Modules/","text":"Modules Updated on 2022-05-30 at 14:56:43 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Modules/#modules","text":"Updated on 2022-05-30 at 14:56:43 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Namespaces/","text":"Namespaces Updated on 2022-05-30 at 14:56:43 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/comms_state_broadcaster/Namespaces/#namespaces","text":"Updated on 2022-05-30 at 14:56:43 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Classes/","text":"Classes namespace data_serializer_algorithms namespace DataSerializerAlgorithm namespace data_serializer_ros namespace DataSerializerNode class DataSerializerNode namespace setup Updated on 2022-05-30 at 14:56:42 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Classes/#classes","text":"namespace data_serializer_algorithms namespace DataSerializerAlgorithm namespace data_serializer_ros namespace DataSerializerNode class DataSerializerNode namespace setup Updated on 2022-05-30 at 14:56:42 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Classes/classdata__serializer__ros_1_1DataSerializerNode_1_1DataSerializerNode/","text":"data_serializer_ros::DataSerializerNode::DataSerializerNode Public Functions Name def init (self self) def initializeSubscribers (self self) def initializePublishers (self self) def loadParams (self self) def generic_callback (self self, msg_data msg_data, channel_info channel_info) def from_modem_callback (self self, msg_data msg_data) def trigger_serialization_callback (self self, msg_data msg_data) Public Functions Documentation function init def __init__( self self ) Constructor for ros node ########################################################################################### @.@ Init node ########################################################################################### function initializeSubscribers def initializeSubscribers( self self ) function initializePublishers def initializePublishers( self self ) function loadParams def loadParams( self self ) function generic_callback def generic_callback( self self, msg_data msg_data, channel_info channel_info ) function from_modem_callback def from_modem_callback( self self, msg_data msg_data ) function trigger_serialization_callback def trigger_serialization_callback( self self, msg_data msg_data ) Updated on 2022-05-30 at 14:56:42 +0000","title":"data_serializer_ros::DataSerializerNode::DataSerializerNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Classes/classdata__serializer__ros_1_1DataSerializerNode_1_1DataSerializerNode/#data_serializer_rosdataserializernodedataserializernode","text":"","title":"data_serializer_ros::DataSerializerNode::DataSerializerNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Classes/classdata__serializer__ros_1_1DataSerializerNode_1_1DataSerializerNode/#public-functions","text":"Name def init (self self) def initializeSubscribers (self self) def initializePublishers (self self) def loadParams (self self) def generic_callback (self self, msg_data msg_data, channel_info channel_info) def from_modem_callback (self self, msg_data msg_data) def trigger_serialization_callback (self self, msg_data msg_data)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Classes/classdata__serializer__ros_1_1DataSerializerNode_1_1DataSerializerNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Classes/classdata__serializer__ros_1_1DataSerializerNode_1_1DataSerializerNode/#function-init","text":"def __init__( self self ) Constructor for ros node ########################################################################################### @.@ Init node ###########################################################################################","title":"function init"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Classes/classdata__serializer__ros_1_1DataSerializerNode_1_1DataSerializerNode/#function-initializesubscribers","text":"def initializeSubscribers( self self )","title":"function initializeSubscribers"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Classes/classdata__serializer__ros_1_1DataSerializerNode_1_1DataSerializerNode/#function-initializepublishers","text":"def initializePublishers( self self )","title":"function initializePublishers"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Classes/classdata__serializer__ros_1_1DataSerializerNode_1_1DataSerializerNode/#function-loadparams","text":"def loadParams( self self )","title":"function loadParams"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Classes/classdata__serializer__ros_1_1DataSerializerNode_1_1DataSerializerNode/#function-generic_callback","text":"def generic_callback( self self, msg_data msg_data, channel_info channel_info )","title":"function generic_callback"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Classes/classdata__serializer__ros_1_1DataSerializerNode_1_1DataSerializerNode/#function-from_modem_callback","text":"def from_modem_callback( self self, msg_data msg_data )","title":"function from_modem_callback"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Classes/classdata__serializer__ros_1_1DataSerializerNode_1_1DataSerializerNode/#function-trigger_serialization_callback","text":"def trigger_serialization_callback( self self, msg_data msg_data ) Updated on 2022-05-30 at 14:56:42 +0000","title":"function trigger_serialization_callback"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Examples/","text":"Examples Updated on 2022-05-30 at 14:56:42 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Examples/#examples","text":"Updated on 2022-05-30 at 14:56:42 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Modules/","text":"Modules Updated on 2022-05-30 at 14:56:42 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Modules/#modules","text":"Updated on 2022-05-30 at 14:56:42 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/","text":"Namespaces namespace data_serializer_algorithms namespace DataSerializerAlgorithm namespace data_serializer_ros namespace DataSerializerNode namespace setup Updated on 2022-05-30 at 14:56:42 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/#namespaces","text":"namespace data_serializer_algorithms namespace DataSerializerAlgorithm namespace data_serializer_ros namespace DataSerializerNode namespace setup Updated on 2022-05-30 at 14:56:42 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__algorithms/","text":"data_serializer_algorithms Namespaces Name data_serializer_algorithms::DataSerializerAlgorithm Updated on 2022-05-30 at 14:56:42 +0000","title":"data_serializer_algorithms"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__algorithms/#data_serializer_algorithms","text":"","title":"data_serializer_algorithms"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__algorithms/#namespaces","text":"Name data_serializer_algorithms::DataSerializerAlgorithm Updated on 2022-05-30 at 14:56:42 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__algorithms_1_1DataSerializerAlgorithm/","text":"data_serializer_algorithms::DataSerializerAlgorithm Functions Name def payload_to_bytes (bits_string bits_string) def payload_to_bits (bytes_string bytes_string) def dec_to_bin (dec_value dec_value, low low, high high, bits bits, is_int is_int =False) def bin_to_dec (bin_value bin_value, low low, high high, bits bits, is_int is_int =False) def extract_field (msg_data msg_data, field_address field_address) def add_field_to_dict (final_dict final_dict, field_address field_address, field_value field_value) Functions Documentation function payload_to_bytes def payload_to_bytes( bits_string bits_string ) function payload_to_bits def payload_to_bits( bytes_string bytes_string ) function dec_to_bin def dec_to_bin( dec_value dec_value, low low, high high, bits bits, is_int is_int =False ) function bin_to_dec def bin_to_dec( bin_value bin_value, low low, high high, bits bits, is_int is_int =False ) function extract_field def extract_field( msg_data msg_data, field_address field_address ) function add_field_to_dict def add_field_to_dict( final_dict final_dict, field_address field_address, field_value field_value ) Updated on 2022-05-30 at 14:56:42 +0000","title":"data_serializer_algorithms::DataSerializerAlgorithm"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__algorithms_1_1DataSerializerAlgorithm/#data_serializer_algorithmsdataserializeralgorithm","text":"","title":"data_serializer_algorithms::DataSerializerAlgorithm"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__algorithms_1_1DataSerializerAlgorithm/#functions","text":"Name def payload_to_bytes (bits_string bits_string) def payload_to_bits (bytes_string bytes_string) def dec_to_bin (dec_value dec_value, low low, high high, bits bits, is_int is_int =False) def bin_to_dec (bin_value bin_value, low low, high high, bits bits, is_int is_int =False) def extract_field (msg_data msg_data, field_address field_address) def add_field_to_dict (final_dict final_dict, field_address field_address, field_value field_value)","title":"Functions"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__algorithms_1_1DataSerializerAlgorithm/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__algorithms_1_1DataSerializerAlgorithm/#function-payload_to_bytes","text":"def payload_to_bytes( bits_string bits_string )","title":"function payload_to_bytes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__algorithms_1_1DataSerializerAlgorithm/#function-payload_to_bits","text":"def payload_to_bits( bytes_string bytes_string )","title":"function payload_to_bits"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__algorithms_1_1DataSerializerAlgorithm/#function-dec_to_bin","text":"def dec_to_bin( dec_value dec_value, low low, high high, bits bits, is_int is_int =False )","title":"function dec_to_bin"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__algorithms_1_1DataSerializerAlgorithm/#function-bin_to_dec","text":"def bin_to_dec( bin_value bin_value, low low, high high, bits bits, is_int is_int =False )","title":"function bin_to_dec"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__algorithms_1_1DataSerializerAlgorithm/#function-extract_field","text":"def extract_field( msg_data msg_data, field_address field_address )","title":"function extract_field"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__algorithms_1_1DataSerializerAlgorithm/#function-add_field_to_dict","text":"def add_field_to_dict( final_dict final_dict, field_address field_address, field_value field_value ) Updated on 2022-05-30 at 14:56:42 +0000","title":"function add_field_to_dict"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__ros/","text":"data_serializer_ros Namespaces Name data_serializer_ros::DataSerializerNode Updated on 2022-05-30 at 14:56:42 +0000","title":"data_serializer_ros"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__ros/#data_serializer_ros","text":"","title":"data_serializer_ros"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__ros/#namespaces","text":"Name data_serializer_ros::DataSerializerNode Updated on 2022-05-30 at 14:56:42 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__ros_1_1DataSerializerNode/","text":"data_serializer_ros::DataSerializerNode More... Classes Name class data_serializer_ros::DataSerializerNode::DataSerializerNode Functions Name def main () Detailed Description Developers: DSOR Team -> @irt.ist.pt Instituto Superior Tecnico Description: Please check the documentation of this package for more info. Functions Documentation function main def main() Updated on 2022-05-30 at 14:56:42 +0000","title":"data_serializer_ros::DataSerializerNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__ros_1_1DataSerializerNode/#data_serializer_rosdataserializernode","text":"More...","title":"data_serializer_ros::DataSerializerNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__ros_1_1DataSerializerNode/#classes","text":"Name class data_serializer_ros::DataSerializerNode::DataSerializerNode","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__ros_1_1DataSerializerNode/#functions","text":"Name def main ()","title":"Functions"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__ros_1_1DataSerializerNode/#detailed-description","text":"Developers: DSOR Team -> @irt.ist.pt Instituto Superior Tecnico Description: Please check the documentation of this package for more info.","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__ros_1_1DataSerializerNode/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacedata__serializer__ros_1_1DataSerializerNode/#function-main","text":"def main() Updated on 2022-05-30 at 14:56:42 +0000","title":"function main"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacesetup/","text":"setup Attributes Name d Attributes Documentation variable d d = generate_distutils_setup( packages=['data_serializer_algorithms', 'data_serializer_ros'], package_dir={'data_serializer_algorithms': 'src/data_serializer_algorithms', 'data_serializer_ros': 'src/data_serializer_ros'} ); Updated on 2022-05-30 at 14:56:42 +0000","title":"setup"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacesetup/#setup","text":"","title":"setup"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacesetup/#attributes","text":"Name d","title":"Attributes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacesetup/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/data_serializer/Namespaces/namespacesetup/#variable-d","text":"d = generate_distutils_setup( packages=['data_serializer_algorithms', 'data_serializer_ros'], package_dir={'data_serializer_algorithms': 'src/data_serializer_algorithms', 'data_serializer_ros': 'src/data_serializer_ros'} ); Updated on 2022-05-30 at 14:56:42 +0000","title":"variable d"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/","text":"Classes class DmacToMedusaNode namespace pos2simmodem class Pos2SimModem Updated on 2022-05-30 at 14:56:44 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/#classes","text":"class DmacToMedusaNode namespace pos2simmodem class Pos2SimModem Updated on 2022-05-30 at 14:56:44 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classDmacToMedusaNode/","text":"DmacToMedusaNode Public Functions Name DmacToMedusaNode (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~DmacToMedusaNode () Public Functions Documentation function DmacToMedusaNode DmacToMedusaNode( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private ) function ~DmacToMedusaNode ~DmacToMedusaNode() Updated on 2022-05-30 at 14:56:44 +0000","title":"DmacToMedusaNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classDmacToMedusaNode/#dmactomedusanode","text":"","title":"DmacToMedusaNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classDmacToMedusaNode/#public-functions","text":"Name DmacToMedusaNode (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~DmacToMedusaNode ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classDmacToMedusaNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classDmacToMedusaNode/#function-dmactomedusanode","text":"DmacToMedusaNode( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private )","title":"function DmacToMedusaNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classDmacToMedusaNode/#function-dmactomedusanode_1","text":"~DmacToMedusaNode() Updated on 2022-05-30 at 14:56:44 +0000","title":"function ~DmacToMedusaNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classpos2simmodem_1_1Pos2SimModem/","text":"pos2simmodem::Pos2SimModem More... Inherits from object Public Functions Name def init (self self) def position_callback (self self, msg msg) Public Attributes Name address sock time sub_odom Detailed Description class pos2simmodem::Pos2SimModem; Class to hold the read of Odometry messages and send position to the simulated modem. Public Functions Documentation function init def __init__( self self ) Initializing the necessary variables. function position_callback def position_callback( self self, msg msg ) Reads Odometry and sends position. Public Attributes Documentation variable address address; variable sock sock; variable time time; variable sub_odom sub_odom; Updated on 2022-05-30 at 14:56:44 +0000","title":"pos2simmodem::Pos2SimModem"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classpos2simmodem_1_1Pos2SimModem/#pos2simmodempos2simmodem","text":"More... Inherits from object","title":"pos2simmodem::Pos2SimModem"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classpos2simmodem_1_1Pos2SimModem/#public-functions","text":"Name def init (self self) def position_callback (self self, msg msg)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classpos2simmodem_1_1Pos2SimModem/#public-attributes","text":"Name address sock time sub_odom","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classpos2simmodem_1_1Pos2SimModem/#detailed-description","text":"class pos2simmodem::Pos2SimModem; Class to hold the read of Odometry messages and send position to the simulated modem.","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classpos2simmodem_1_1Pos2SimModem/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classpos2simmodem_1_1Pos2SimModem/#function-init","text":"def __init__( self self ) Initializing the necessary variables.","title":"function init"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classpos2simmodem_1_1Pos2SimModem/#function-position_callback","text":"def position_callback( self self, msg msg ) Reads Odometry and sends position.","title":"function position_callback"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classpos2simmodem_1_1Pos2SimModem/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classpos2simmodem_1_1Pos2SimModem/#variable-address","text":"address;","title":"variable address"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classpos2simmodem_1_1Pos2SimModem/#variable-sock","text":"sock;","title":"variable sock"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classpos2simmodem_1_1Pos2SimModem/#variable-time","text":"time;","title":"variable time"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Classes/classpos2simmodem_1_1Pos2SimModem/#variable-sub_odom","text":"sub_odom; Updated on 2022-05-30 at 14:56:44 +0000","title":"variable sub_odom"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Examples/","text":"Examples Updated on 2022-05-30 at 14:56:44 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Examples/#examples","text":"Updated on 2022-05-30 at 14:56:44 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Modules/","text":"Modules Updated on 2022-05-30 at 14:56:44 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Modules/#modules","text":"Updated on 2022-05-30 at 14:56:44 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Namespaces/","text":"Namespaces namespace pos2simmodem Updated on 2022-05-30 at 14:56:44 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Namespaces/#namespaces","text":"namespace pos2simmodem Updated on 2022-05-30 at 14:56:44 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Namespaces/namespacepos2simmodem/","text":"pos2simmodem Classes Name class pos2simmodem::Pos2SimModem Attributes Name node Attributes Documentation variable node node = Pos2SimModem(); Updated on 2022-05-30 at 14:56:44 +0000","title":"pos2simmodem"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Namespaces/namespacepos2simmodem/#pos2simmodem","text":"","title":"pos2simmodem"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Namespaces/namespacepos2simmodem/#classes","text":"Name class pos2simmodem::Pos2SimModem","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Namespaces/namespacepos2simmodem/#attributes","text":"Name node","title":"Attributes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Namespaces/namespacepos2simmodem/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/evo_tools/Namespaces/namespacepos2simmodem/#variable-node","text":"node = Pos2SimModem(); Updated on 2022-05-30 at 14:56:44 +0000","title":"variable node"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/","text":"Classes class AcousticPinger class ReplierNode Updated on 2022-05-30 at 14:56:44 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/#classes","text":"class AcousticPinger class ReplierNode Updated on 2022-05-30 at 14:56:44 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/","text":"AcousticPinger Public Functions Name AcousticPinger (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~AcousticPinger () void updateClock (unsigned long int tmodem, ros::Time tros) unsigned long int getModemClockNow () void triggerSerialization () void pingNextNode () void serializerCallback (const std_msgs::String & msg) void EnableCallback (const std_msgs::Bool & msg) void RECVIMSCallback (const dmac::DMACPayload & msg) void Timer (const ros::TimerEvent & e) Public Attributes Name ros::NodeHandle nh Public Functions Documentation function AcousticPinger AcousticPinger( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private ) function ~AcousticPinger ~AcousticPinger() function updateClock void updateClock( unsigned long int tmodem, ros::Time tros ) function getModemClockNow unsigned long int getModemClockNow() function triggerSerialization void triggerSerialization() function pingNextNode void pingNextNode() function serializerCallback void serializerCallback( const std_msgs::String & msg ) function EnableCallback void EnableCallback( const std_msgs::Bool & msg ) function RECVIMSCallback void RECVIMSCallback( const dmac::DMACPayload & msg ) function Timer void Timer( const ros::TimerEvent & e ) Public Attributes Documentation variable nh ros::NodeHandle nh; Updated on 2022-05-30 at 14:56:44 +0000","title":"AcousticPinger"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/#acousticpinger","text":"","title":"AcousticPinger"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/#public-functions","text":"Name AcousticPinger (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~AcousticPinger () void updateClock (unsigned long int tmodem, ros::Time tros) unsigned long int getModemClockNow () void triggerSerialization () void pingNextNode () void serializerCallback (const std_msgs::String & msg) void EnableCallback (const std_msgs::Bool & msg) void RECVIMSCallback (const dmac::DMACPayload & msg) void Timer (const ros::TimerEvent & e)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/#public-attributes","text":"Name ros::NodeHandle nh","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/#function-acousticpinger","text":"AcousticPinger( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private )","title":"function AcousticPinger"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/#function-acousticpinger_1","text":"~AcousticPinger()","title":"function ~AcousticPinger"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/#function-updateclock","text":"void updateClock( unsigned long int tmodem, ros::Time tros )","title":"function updateClock"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/#function-getmodemclocknow","text":"unsigned long int getModemClockNow()","title":"function getModemClockNow"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/#function-triggerserialization","text":"void triggerSerialization()","title":"function triggerSerialization"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/#function-pingnextnode","text":"void pingNextNode()","title":"function pingNextNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/#function-serializercallback","text":"void serializerCallback( const std_msgs::String & msg )","title":"function serializerCallback"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/#function-enablecallback","text":"void EnableCallback( const std_msgs::Bool & msg )","title":"function EnableCallback"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/#function-recvimscallback","text":"void RECVIMSCallback( const dmac::DMACPayload & msg )","title":"function RECVIMSCallback"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/#function-timer","text":"void Timer( const ros::TimerEvent & e )","title":"function Timer"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classAcousticPinger/#variable-nh","text":"ros::NodeHandle nh; Updated on 2022-05-30 at 14:56:44 +0000","title":"variable nh"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classReplierNode/","text":"ReplierNode Public Functions Name ReplierNode (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~ReplierNode () Public Functions Documentation function ReplierNode ReplierNode( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private ) function ~ReplierNode ~ReplierNode() Updated on 2022-05-30 at 14:56:44 +0000","title":"ReplierNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classReplierNode/#repliernode","text":"","title":"ReplierNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classReplierNode/#public-functions","text":"Name ReplierNode (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~ReplierNode ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classReplierNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classReplierNode/#function-repliernode","text":"ReplierNode( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private )","title":"function ReplierNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Classes/classReplierNode/#function-repliernode_1","text":"~ReplierNode() Updated on 2022-05-30 at 14:56:44 +0000","title":"function ~ReplierNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Examples/","text":"Examples Updated on 2022-05-30 at 14:56:44 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Examples/#examples","text":"Updated on 2022-05-30 at 14:56:44 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Modules/","text":"Modules Updated on 2022-05-30 at 14:56:44 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Modules/#modules","text":"Updated on 2022-05-30 at 14:56:44 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Namespaces/","text":"Namespaces Updated on 2022-05-30 at 14:56:44 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_comms/comms_acoustic/interrogation_scheme/Namespaces/#namespaces","text":"Updated on 2022-05-30 at 14:56:44 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/","text":"Classes namespace cpf_gamma_ros namespace CpfGammaClientNode class CpfGammaClientNode namespace CpfGammaServerNode class CpfGammaServerNode namespace setup Updated on 2022-05-30 at 14:56:42 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/#classes","text":"namespace cpf_gamma_ros namespace CpfGammaClientNode class CpfGammaClientNode namespace CpfGammaServerNode class CpfGammaServerNode namespace setup Updated on 2022-05-30 at 14:56:42 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaClientNode_1_1CpfGammaClientNode/","text":"cpf_gamma_ros::CpfGammaClientNode::CpfGammaClientNode Public Functions Name def init (self self) def initializeSubscribers (self self) def loadParams (self self) def broadcastGammaCallback (self self, msg msg) Public Attributes Name address sock node_frequency port addr Public Functions Documentation function init def __init__( self self ) Constructor for ros node ########################################################################################### @.@ Init node ########################################################################################### function initializeSubscribers def initializeSubscribers( self self ) function loadParams def loadParams( self self ) function broadcastGammaCallback def broadcastGammaCallback( self self, msg msg ) Public Attributes Documentation variable address address; variable sock sock; variable node_frequency node_frequency; variable port port; variable addr addr; Updated on 2022-05-30 at 14:56:42 +0000","title":"cpf_gamma_ros::CpfGammaClientNode::CpfGammaClientNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaClientNode_1_1CpfGammaClientNode/#cpf_gamma_roscpfgammaclientnodecpfgammaclientnode","text":"","title":"cpf_gamma_ros::CpfGammaClientNode::CpfGammaClientNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaClientNode_1_1CpfGammaClientNode/#public-functions","text":"Name def init (self self) def initializeSubscribers (self self) def loadParams (self self) def broadcastGammaCallback (self self, msg msg)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaClientNode_1_1CpfGammaClientNode/#public-attributes","text":"Name address sock node_frequency port addr","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaClientNode_1_1CpfGammaClientNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaClientNode_1_1CpfGammaClientNode/#function-init","text":"def __init__( self self ) Constructor for ros node ########################################################################################### @.@ Init node ###########################################################################################","title":"function init"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaClientNode_1_1CpfGammaClientNode/#function-initializesubscribers","text":"def initializeSubscribers( self self )","title":"function initializeSubscribers"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaClientNode_1_1CpfGammaClientNode/#function-loadparams","text":"def loadParams( self self )","title":"function loadParams"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaClientNode_1_1CpfGammaClientNode/#function-broadcastgammacallback","text":"def broadcastGammaCallback( self self, msg msg )","title":"function broadcastGammaCallback"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaClientNode_1_1CpfGammaClientNode/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaClientNode_1_1CpfGammaClientNode/#variable-address","text":"address;","title":"variable address"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaClientNode_1_1CpfGammaClientNode/#variable-sock","text":"sock;","title":"variable sock"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaClientNode_1_1CpfGammaClientNode/#variable-node_frequency","text":"node_frequency;","title":"variable node_frequency"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaClientNode_1_1CpfGammaClientNode/#variable-port","text":"port;","title":"variable port"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaClientNode_1_1CpfGammaClientNode/#variable-addr","text":"addr; Updated on 2022-05-30 at 14:56:42 +0000","title":"variable addr"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/","text":"cpf_gamma_ros::CpfGammaServerNode::CpfGammaServerNode Public Functions Name def init (self self) def initializePublishers (self self) def loadParams (self self) def serverEnable (self self) def parseData (self self, data data) def cpfGammaMessage (self self, parsed_data parsed_data) def etcpfGammaMessage (parsed_data parsed_data) def etcpfAckMessage (parsed_data parsed_data) Public Attributes Name messages_type data_populate sock pubs node_frequency id port Public Functions Documentation function init def __init__( self self ) Constructor for ros node ########################################################################################### @.@ Init node ########################################################################################### function initializePublishers def initializePublishers( self self ) function loadParams def loadParams( self self ) function serverEnable def serverEnable( self self ) function parseData def parseData( self self, data data ) function cpfGammaMessage def cpfGammaMessage( self self, parsed_data parsed_data ) function etcpfGammaMessage static def etcpfGammaMessage( parsed_data parsed_data ) function etcpfAckMessage static def etcpfAckMessage( parsed_data parsed_data ) Public Attributes Documentation variable messages_type messages_type; variable data_populate data_populate; variable sock sock; variable pubs pubs; variable node_frequency node_frequency; variable id id; variable port port; Updated on 2022-05-30 at 14:56:42 +0000","title":"cpf_gamma_ros::CpfGammaServerNode::CpfGammaServerNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#cpf_gamma_roscpfgammaservernodecpfgammaservernode","text":"","title":"cpf_gamma_ros::CpfGammaServerNode::CpfGammaServerNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#public-functions","text":"Name def init (self self) def initializePublishers (self self) def loadParams (self self) def serverEnable (self self) def parseData (self self, data data) def cpfGammaMessage (self self, parsed_data parsed_data) def etcpfGammaMessage (parsed_data parsed_data) def etcpfAckMessage (parsed_data parsed_data)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#public-attributes","text":"Name messages_type data_populate sock pubs node_frequency id port","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#function-init","text":"def __init__( self self ) Constructor for ros node ########################################################################################### @.@ Init node ###########################################################################################","title":"function init"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#function-initializepublishers","text":"def initializePublishers( self self )","title":"function initializePublishers"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#function-loadparams","text":"def loadParams( self self )","title":"function loadParams"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#function-serverenable","text":"def serverEnable( self self )","title":"function serverEnable"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#function-parsedata","text":"def parseData( self self, data data )","title":"function parseData"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#function-cpfgammamessage","text":"def cpfGammaMessage( self self, parsed_data parsed_data )","title":"function cpfGammaMessage"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#function-etcpfgammamessage","text":"static def etcpfGammaMessage( parsed_data parsed_data )","title":"function etcpfGammaMessage"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#function-etcpfackmessage","text":"static def etcpfAckMessage( parsed_data parsed_data )","title":"function etcpfAckMessage"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#variable-messages_type","text":"messages_type;","title":"variable messages_type"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#variable-data_populate","text":"data_populate;","title":"variable data_populate"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#variable-sock","text":"sock;","title":"variable sock"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#variable-pubs","text":"pubs;","title":"variable pubs"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#variable-node_frequency","text":"node_frequency;","title":"variable node_frequency"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#variable-id","text":"id;","title":"variable id"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Classes/classcpf__gamma__ros_1_1CpfGammaServerNode_1_1CpfGammaServerNode/#variable-port","text":"port; Updated on 2022-05-30 at 14:56:42 +0000","title":"variable port"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Examples/","text":"Examples Updated on 2022-05-30 at 14:56:42 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Examples/#examples","text":"Updated on 2022-05-30 at 14:56:42 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Modules/","text":"Modules Updated on 2022-05-30 at 14:56:42 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Modules/#modules","text":"Updated on 2022-05-30 at 14:56:42 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/","text":"Namespaces namespace cpf_gamma_ros namespace CpfGammaClientNode namespace CpfGammaServerNode namespace setup Updated on 2022-05-30 at 14:56:42 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/#namespaces","text":"namespace cpf_gamma_ros namespace CpfGammaClientNode namespace CpfGammaServerNode namespace setup Updated on 2022-05-30 at 14:56:42 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros/","text":"cpf_gamma_ros Namespaces Name cpf_gamma_ros::CpfGammaClientNode cpf_gamma_ros::CpfGammaServerNode Updated on 2022-05-30 at 14:56:42 +0000","title":"cpf_gamma_ros"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros/#cpf_gamma_ros","text":"","title":"cpf_gamma_ros"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros/#namespaces","text":"Name cpf_gamma_ros::CpfGammaClientNode cpf_gamma_ros::CpfGammaServerNode Updated on 2022-05-30 at 14:56:42 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros_1_1CpfGammaClientNode/","text":"cpf_gamma_ros::CpfGammaClientNode More... Classes Name class cpf_gamma_ros::CpfGammaClientNode::CpfGammaClientNode Functions Name def main () Detailed Description Developers: DSOR Team -> @isr.ist.pt Instituto Superior Tecnico Description: Please check the documentation of this package for more info. Functions Documentation function main def main() Updated on 2022-05-30 at 14:56:42 +0000","title":"cpf_gamma_ros::CpfGammaClientNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros_1_1CpfGammaClientNode/#cpf_gamma_roscpfgammaclientnode","text":"More...","title":"cpf_gamma_ros::CpfGammaClientNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros_1_1CpfGammaClientNode/#classes","text":"Name class cpf_gamma_ros::CpfGammaClientNode::CpfGammaClientNode","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros_1_1CpfGammaClientNode/#functions","text":"Name def main ()","title":"Functions"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros_1_1CpfGammaClientNode/#detailed-description","text":"Developers: DSOR Team -> @isr.ist.pt Instituto Superior Tecnico Description: Please check the documentation of this package for more info.","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros_1_1CpfGammaClientNode/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros_1_1CpfGammaClientNode/#function-main","text":"def main() Updated on 2022-05-30 at 14:56:42 +0000","title":"function main"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros_1_1CpfGammaServerNode/","text":"cpf_gamma_ros::CpfGammaServerNode More... Classes Name class cpf_gamma_ros::CpfGammaServerNode::CpfGammaServerNode Functions Name def main () Detailed Description Developers: DSOR Team -> @isr.ist.pt Instituto Superior Tecnico Description: Please check the documentation of this package for more info. Functions Documentation function main def main() Updated on 2022-05-30 at 14:56:42 +0000","title":"cpf_gamma_ros::CpfGammaServerNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros_1_1CpfGammaServerNode/#cpf_gamma_roscpfgammaservernode","text":"More...","title":"cpf_gamma_ros::CpfGammaServerNode"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros_1_1CpfGammaServerNode/#classes","text":"Name class cpf_gamma_ros::CpfGammaServerNode::CpfGammaServerNode","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros_1_1CpfGammaServerNode/#functions","text":"Name def main ()","title":"Functions"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros_1_1CpfGammaServerNode/#detailed-description","text":"Developers: DSOR Team -> @isr.ist.pt Instituto Superior Tecnico Description: Please check the documentation of this package for more info.","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros_1_1CpfGammaServerNode/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacecpf__gamma__ros_1_1CpfGammaServerNode/#function-main","text":"def main() Updated on 2022-05-30 at 14:56:42 +0000","title":"function main"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacesetup/","text":"setup Attributes Name d Attributes Documentation variable d d = generate_distutils_setup( packages=['cpf_gamma_algorithms', 'cpf_gamma_ros'], package_dir={'cpf_gamma_algorithms': 'src/cpf_gamma_algorithms', 'cpf_gamma_ros': 'src/cpf_gamma_ros'} ); Updated on 2022-05-30 at 14:56:42 +0000","title":"setup"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacesetup/#setup","text":"","title":"setup"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacesetup/#attributes","text":"Name d","title":"Attributes"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacesetup/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_comms/comms_radio/cpf_gamma/Namespaces/namespacesetup/#variable-d","text":"d = generate_distutils_setup( packages=['cpf_gamma_algorithms', 'cpf_gamma_ros'], package_dir={'cpf_gamma_algorithms': 'src/cpf_gamma_algorithms', 'cpf_gamma_ros': 'src/cpf_gamma_ros'} ); Updated on 2022-05-30 at 14:56:42 +0000","title":"variable d"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/","text":"Classes class Innerloops Implementation of the inner loops. Computes the forces and torques (tau) to be applied on the vehicle based on desired reference values. class PID_Controller Implementation of a PID with anti windup. class RosController ROS implementation of the innerloops controllers. Based on a desired reference computes the force or torque to be applied. class Safeties Updated on 2022-05-30 at 14:56:44 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/#classes","text":"class Innerloops Implementation of the inner loops. Computes the forces and torques (tau) to be applied on the vehicle based on desired reference values. class PID_Controller Implementation of a PID with anti windup. class RosController ROS implementation of the innerloops controllers. Based on a desired reference computes the force or torque to be applied. class Safeties Updated on 2022-05-30 at 14:56:44 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classInnerloops/","text":"Innerloops Implementation of the inner loops. Computes the forces and torques (tau) to be applied on the vehicle based on desired reference values. #include <innerloops.h> Public Functions Name Innerloops (ros::NodeHandle & nh) Contructor of the innerloops class. ~Innerloops () Destructor of the innerloops class. Public Functions Documentation function Innerloops Innerloops( ros::NodeHandle & nh ) Contructor of the innerloops class. Parameters : nh ROS nodehandle to subscribe, publish and read parameters. function ~Innerloops ~Innerloops() Destructor of the innerloops class. Updated on 2022-05-30 at 14:56:44 +0000","title":"Innerloops"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classInnerloops/#innerloops","text":"Implementation of the inner loops. Computes the forces and torques (tau) to be applied on the vehicle based on desired reference values. #include <innerloops.h>","title":"Innerloops"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classInnerloops/#public-functions","text":"Name Innerloops (ros::NodeHandle & nh) Contructor of the innerloops class. ~Innerloops () Destructor of the innerloops class.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classInnerloops/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classInnerloops/#function-innerloops","text":"Innerloops( ros::NodeHandle & nh ) Contructor of the innerloops class. Parameters : nh ROS nodehandle to subscribe, publish and read parameters.","title":"function Innerloops"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classInnerloops/#function-innerloops_1","text":"~Innerloops() Destructor of the innerloops class. Updated on 2022-05-30 at 14:56:44 +0000","title":"function ~Innerloops"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/","text":"PID_Controller Implementation of a PID with anti windup. #include <pid_controller.h> Public Functions Name PID_Controller () Constructor of a pid controller with kp, ki and kd equal to 0. PID_Controller (float Kp, float Ki, float Kd, float max_error, float max_out) Constructor of a PID controller. Initially enabled. PID_Controller (float Kp, float Ki, float Kd, float max_error, float max_out, float min_error, float min_out) Constructor of a PID controller. Initially enabled. PID_Controller (float Kp, float Ki, float Kd, float Kff, float Kff_d, float Kff_lin_drag, float Kff_quad_drag, float max_error, float max_out, float min_error, float min_out) Constructor of a PID controller (without low pass filter). Initially enabled. PID_Controller (float Kp, float Ki, float Kd, float Kff, float Kff_d, float Kff_lin_drag, float Kff_quad_drag, float max_error, float max_out, float min_error, float min_out, double lpf_dt, double lpf_fc) Constructor of a PID controller (with low pass filter). Initially enabled. float computeCommand (float error_p, float ref_value, float duration, bool debug) Core function. Computes the output of the PID. void reset () Reset function. Sets the integral error term to 0. void setFFGains (const float & ff_gain, const float & ff_d_gain, const float & ff_lin_drag_gain, const float & ff_quad_drag_gain) Set the feedfoward Gains object. void setGains (const float & kp, const float & ki, const float & kd) Set the Gains object. void setLimitBounds (const float & max_out, const float & min_out) Set the Limit Bounds object. std::vector< double > getGains () const Get the Gains object. std::vector< double > getLimitBounds () const Get the Limit Bounds object. medusa_msgs::mPidDebug getDebugInfo () const Get debug info from the PID controller internal variables. Public Attributes Name bool disable Protected Attributes Name float p_gain_ float i_gain_ float d_gain_ float ff_gain_ float ff_d_gain_ float ff_lin_drag_gain_ float ff_quad_drag_gain_ float max_error_ float max_out_ float min_error_ float min_out_ float integral_ float pre_error_ float prev_ref_value_ bool has_lpf_ std::unique_ptr< LowPassFilter > lpf_ medusa_msgs::mPidDebug msg_debug_ Public Functions Documentation function PID_Controller PID_Controller() Constructor of a pid controller with kp, ki and kd equal to 0. function PID_Controller PID_Controller( float Kp, float Ki, float Kd, float max_error, float max_out ) Constructor of a PID controller. Initially enabled. Parameters : Kp Proporcional gain Ki Integral gain Kd Derivative gain max_error maximum reference error allowed max_out minimum reference error allowed function PID_Controller PID_Controller( float Kp, float Ki, float Kd, float max_error, float max_out, float min_error, float min_out ) Constructor of a PID controller. Initially enabled. Parameters : Kp Proporcional gain Ki Integral gain Kd Derivative gain max_error maximum reference error allowed max_out maximum output allowed min_error minimum refrence error allowed min_out minimum output allowed function PID_Controller PID_Controller( float Kp, float Ki, float Kd, float Kff, float Kff_d, float Kff_lin_drag, float Kff_quad_drag, float max_error, float max_out, float min_error, float min_out ) Constructor of a PID controller (without low pass filter). Initially enabled. Parameters : Kp Proporcional gain Ki Integral gain Kd Derivative gain Kff Feedforward gain Kff_d Feedforward gain (linear drag) [] Kff_dd Feedforward gain (quadratic drag) max_error maximum reference error allowed max_out maximum output allowed min_error minimum refrence error allowed min_out minimum output allowed function PID_Controller PID_Controller( float Kp, float Ki, float Kd, float Kff, float Kff_d, float Kff_lin_drag, float Kff_quad_drag, float max_error, float max_out, float min_error, float min_out, double lpf_dt, double lpf_fc ) Constructor of a PID controller (with low pass filter). Initially enabled. Parameters : Kp Proporcional gain Ki Integral gain Kd Derivative gain Kff Feedforward gain Kff_d Feedforward gain (linear drag) [] Kff_dd Feedforward gain (quadratic drag) max_error maximum reference error allowed max_out maximum output allowed min_error minimum refrence error allowed min_out minimum output allowed lpf_dt Low pass filter sampling time lpf_fc Low pass filter cutoff param function computeCommand float computeCommand( float error_p, float ref_value, float duration, bool debug ) Core function. Computes the output of the PID. Parameters : error_p Error between the reference and the estimated variable ref_value Reference value to compute the feedforward term duration Sample time debug Check if we want to generate a debugging message to later publish Return : function reset void reset() Reset function. Sets the integral error term to 0. function setFFGains void setFFGains( const float & ff_gain, const float & ff_d_gain, const float & ff_lin_drag_gain, const float & ff_quad_drag_gain ) Set the feedfoward Gains object. Parameters : ff_gain Feefoward gain of reference ff_d_gain Feedoforward gain of reference derivative ff_lin_drag_gain Feefoward gain (for linear drag) ff_quad_drag_gain Feefoward gain (for quadratic drag) function setGains void setGains( const float & kp, const float & ki, const float & kd ) Set the Gains object. Parameters : kp Proportional gain ki Integral gain kd Derivative gain function setLimitBounds void setLimitBounds( const float & max_out, const float & min_out ) Set the Limit Bounds object. Parameters : max_out maximum output allowed min_out minimum output allowed function getGains std::vector< double > getGains() const Get the Gains object. Return : std::vector const function getLimitBounds std::vector< double > getLimitBounds() const Get the Limit Bounds object. Return : std::vector const function getDebugInfo medusa_msgs::mPidDebug getDebugInfo() const Get debug info from the PID controller internal variables. Return : std::vector const Public Attributes Documentation variable disable bool disable; Protected Attributes Documentation variable p_gain_ float p_gain_; variable i_gain_ float i_gain_; variable d_gain_ float d_gain_; variable ff_gain_ float ff_gain_; variable ff_d_gain_ float ff_d_gain_; variable ff_lin_drag_gain_ float ff_lin_drag_gain_; variable ff_quad_drag_gain_ float ff_quad_drag_gain_; variable max_error_ float max_error_; variable max_out_ float max_out_; variable min_error_ float min_error_; variable min_out_ float min_out_; variable integral_ float integral_; variable pre_error_ float pre_error_; variable prev_ref_value_ float prev_ref_value_; variable has_lpf_ bool has_lpf_ {false}; variable lpf_ std::unique_ptr< LowPassFilter > lpf_; variable msg_debug_ medusa_msgs::mPidDebug msg_debug_; Updated on 2022-05-30 at 14:56:44 +0000","title":"PID_Controller"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#pid_controller","text":"Implementation of a PID with anti windup. #include <pid_controller.h>","title":"PID_Controller"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#public-functions","text":"Name PID_Controller () Constructor of a pid controller with kp, ki and kd equal to 0. PID_Controller (float Kp, float Ki, float Kd, float max_error, float max_out) Constructor of a PID controller. Initially enabled. PID_Controller (float Kp, float Ki, float Kd, float max_error, float max_out, float min_error, float min_out) Constructor of a PID controller. Initially enabled. PID_Controller (float Kp, float Ki, float Kd, float Kff, float Kff_d, float Kff_lin_drag, float Kff_quad_drag, float max_error, float max_out, float min_error, float min_out) Constructor of a PID controller (without low pass filter). Initially enabled. PID_Controller (float Kp, float Ki, float Kd, float Kff, float Kff_d, float Kff_lin_drag, float Kff_quad_drag, float max_error, float max_out, float min_error, float min_out, double lpf_dt, double lpf_fc) Constructor of a PID controller (with low pass filter). Initially enabled. float computeCommand (float error_p, float ref_value, float duration, bool debug) Core function. Computes the output of the PID. void reset () Reset function. Sets the integral error term to 0. void setFFGains (const float & ff_gain, const float & ff_d_gain, const float & ff_lin_drag_gain, const float & ff_quad_drag_gain) Set the feedfoward Gains object. void setGains (const float & kp, const float & ki, const float & kd) Set the Gains object. void setLimitBounds (const float & max_out, const float & min_out) Set the Limit Bounds object. std::vector< double > getGains () const Get the Gains object. std::vector< double > getLimitBounds () const Get the Limit Bounds object. medusa_msgs::mPidDebug getDebugInfo () const Get debug info from the PID controller internal variables.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#public-attributes","text":"Name bool disable","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#protected-attributes","text":"Name float p_gain_ float i_gain_ float d_gain_ float ff_gain_ float ff_d_gain_ float ff_lin_drag_gain_ float ff_quad_drag_gain_ float max_error_ float max_out_ float min_error_ float min_out_ float integral_ float pre_error_ float prev_ref_value_ bool has_lpf_ std::unique_ptr< LowPassFilter > lpf_ medusa_msgs::mPidDebug msg_debug_","title":"Protected Attributes"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#function-pid_controller","text":"PID_Controller() Constructor of a pid controller with kp, ki and kd equal to 0.","title":"function PID_Controller"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#function-pid_controller_1","text":"PID_Controller( float Kp, float Ki, float Kd, float max_error, float max_out ) Constructor of a PID controller. Initially enabled. Parameters : Kp Proporcional gain Ki Integral gain Kd Derivative gain max_error maximum reference error allowed max_out minimum reference error allowed","title":"function PID_Controller"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#function-pid_controller_2","text":"PID_Controller( float Kp, float Ki, float Kd, float max_error, float max_out, float min_error, float min_out ) Constructor of a PID controller. Initially enabled. Parameters : Kp Proporcional gain Ki Integral gain Kd Derivative gain max_error maximum reference error allowed max_out maximum output allowed min_error minimum refrence error allowed min_out minimum output allowed","title":"function PID_Controller"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#function-pid_controller_3","text":"PID_Controller( float Kp, float Ki, float Kd, float Kff, float Kff_d, float Kff_lin_drag, float Kff_quad_drag, float max_error, float max_out, float min_error, float min_out ) Constructor of a PID controller (without low pass filter). Initially enabled. Parameters : Kp Proporcional gain Ki Integral gain Kd Derivative gain Kff Feedforward gain Kff_d Feedforward gain (linear drag) [] Kff_dd Feedforward gain (quadratic drag) max_error maximum reference error allowed max_out maximum output allowed min_error minimum refrence error allowed min_out minimum output allowed","title":"function PID_Controller"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#function-pid_controller_4","text":"PID_Controller( float Kp, float Ki, float Kd, float Kff, float Kff_d, float Kff_lin_drag, float Kff_quad_drag, float max_error, float max_out, float min_error, float min_out, double lpf_dt, double lpf_fc ) Constructor of a PID controller (with low pass filter). Initially enabled. Parameters : Kp Proporcional gain Ki Integral gain Kd Derivative gain Kff Feedforward gain Kff_d Feedforward gain (linear drag) [] Kff_dd Feedforward gain (quadratic drag) max_error maximum reference error allowed max_out maximum output allowed min_error minimum refrence error allowed min_out minimum output allowed lpf_dt Low pass filter sampling time lpf_fc Low pass filter cutoff param","title":"function PID_Controller"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#function-computecommand","text":"float computeCommand( float error_p, float ref_value, float duration, bool debug ) Core function. Computes the output of the PID. Parameters : error_p Error between the reference and the estimated variable ref_value Reference value to compute the feedforward term duration Sample time debug Check if we want to generate a debugging message to later publish Return :","title":"function computeCommand"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#function-reset","text":"void reset() Reset function. Sets the integral error term to 0.","title":"function reset"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#function-setffgains","text":"void setFFGains( const float & ff_gain, const float & ff_d_gain, const float & ff_lin_drag_gain, const float & ff_quad_drag_gain ) Set the feedfoward Gains object. Parameters : ff_gain Feefoward gain of reference ff_d_gain Feedoforward gain of reference derivative ff_lin_drag_gain Feefoward gain (for linear drag) ff_quad_drag_gain Feefoward gain (for quadratic drag)","title":"function setFFGains"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#function-setgains","text":"void setGains( const float & kp, const float & ki, const float & kd ) Set the Gains object. Parameters : kp Proportional gain ki Integral gain kd Derivative gain","title":"function setGains"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#function-setlimitbounds","text":"void setLimitBounds( const float & max_out, const float & min_out ) Set the Limit Bounds object. Parameters : max_out maximum output allowed min_out minimum output allowed","title":"function setLimitBounds"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#function-getgains","text":"std::vector< double > getGains() const Get the Gains object. Return : std::vector const","title":"function getGains"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#function-getlimitbounds","text":"std::vector< double > getLimitBounds() const Get the Limit Bounds object. Return : std::vector const","title":"function getLimitBounds"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#function-getdebuginfo","text":"medusa_msgs::mPidDebug getDebugInfo() const Get debug info from the PID controller internal variables. Return : std::vector const","title":"function getDebugInfo"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-disable","text":"bool disable;","title":"variable disable"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-p_gain_","text":"float p_gain_;","title":"variable p_gain_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-i_gain_","text":"float i_gain_;","title":"variable i_gain_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-d_gain_","text":"float d_gain_;","title":"variable d_gain_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-ff_gain_","text":"float ff_gain_;","title":"variable ff_gain_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-ff_d_gain_","text":"float ff_d_gain_;","title":"variable ff_d_gain_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-ff_lin_drag_gain_","text":"float ff_lin_drag_gain_;","title":"variable ff_lin_drag_gain_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-ff_quad_drag_gain_","text":"float ff_quad_drag_gain_;","title":"variable ff_quad_drag_gain_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-max_error_","text":"float max_error_;","title":"variable max_error_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-max_out_","text":"float max_out_;","title":"variable max_out_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-min_error_","text":"float min_error_;","title":"variable min_error_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-min_out_","text":"float min_out_;","title":"variable min_out_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-integral_","text":"float integral_;","title":"variable integral_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-pre_error_","text":"float pre_error_;","title":"variable pre_error_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-prev_ref_value_","text":"float prev_ref_value_;","title":"variable prev_ref_value_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-has_lpf_","text":"bool has_lpf_ {false};","title":"variable has_lpf_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-lpf_","text":"std::unique_ptr< LowPassFilter > lpf_;","title":"variable lpf_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classPID__Controller/#variable-msg_debug_","text":"medusa_msgs::mPidDebug msg_debug_; Updated on 2022-05-30 at 14:56:44 +0000","title":"variable msg_debug_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/","text":"RosController ROS implementation of the innerloops controllers. Based on a desired reference computes the force or torque to be applied. #include <ros_controller.h> Public Functions Name RosController (ros::NodeHandle & nh, std::string controller_name, std::string refCallback_topic, double * state, double * force_or_torque, double frequency) Constructor of a innerloop controller. RosController (ros::NodeHandle & nh, std::string controller_name, std::string refCallback_topic, double * state, double * state_dot, double * force_or_torque, double frequency) Constructor of a innerloop controller. virtual double computeCommand () Core function. Computes the PID output. void setCircularUnits (const bool & flag) Setter function for the circular units flag. void setPositiveOutput (const bool & flag) Set the Positive Output object. std::string getControllerName () const Get the Controller Name object. void setFFGainsPID (const float & kff, const float & kff_d, const float & kff_lin_drag, const float kff_quad_drag) Set the Feedforwar gains P I D object. void setGainsPID (const float & kp, const float & ki, const float & kd) Set the Gains P I D object. void setLimitBoundsPID (const float & max_out, const float & min_out) Protected Functions Name void refCallback (const std_msgs::Float64 & ptr) Callback function. Saturates the value if boundaries exist. void init (ros::NodeHandle & nh, std::string controller_name, std::string refCallback_topic) Initialize function. Reads the parameters, creates a pid controller if any gain is different from zero and subscribes to the relevant topic. virtual bool validRef () Check if the reference is new. Protected Attributes Name ros::Duration timeout_ref_ std::string controller_name_ double ref_value_ double max_ref_value_ double min_ref_value_ ros::Time ref_time_ ros::Time last_cmd_ bool debug_ medusa_msgs::mPidDebug debug_msg_ double * state_ptr_ double * force_or_torque_ptr_ double frequency_ bool circular_units_ bool positive_output_ PID_Controller * pid_c_ ros::Subscriber ros_sub_ ros::Publisher debug_pub_ Public Functions Documentation function RosController RosController( ros::NodeHandle & nh, std::string controller_name, std::string refCallback_topic, double * state, double * force_or_torque, double frequency ) Constructor of a innerloop controller. Parameters : nh ROS nodehandle to read parameters and subscribe to relevant topics controller_name Controller name (variable being controlled) refCallback_topic Topic name state Pointer to state variable being controlled force_or_torque Pointer to force or torque output frequency Frequency of controller sampling rate function RosController RosController( ros::NodeHandle & nh, std::string controller_name, std::string refCallback_topic, double * state, double * state_dot, double * force_or_torque, double frequency ) Constructor of a innerloop controller. Parameters : nh ROS nodehandle to read parameters and subscribe to relevant topics controller_name Controller name (variable being controlled) refCallback_topic Topic name state Pointer to state variable being controlled state_dot Pointer to the derivative of the state variable being controlled force_or_torque Pointer to force or torque output frequency Frequency of controller sampling rate function computeCommand virtual double computeCommand() Core function. Computes the PID output. Return : The force or torque that result from the PID computation function setCircularUnits inline void setCircularUnits( const bool & flag ) Setter function for the circular units flag. Parameters : flag true for controllers using angles, false otherwise function setPositiveOutput inline void setPositiveOutput( const bool & flag ) Set the Positive Output object. Parameters : flag function getControllerName inline std::string getControllerName() const Get the Controller Name object. function setFFGainsPID inline void setFFGainsPID( const float & kff, const float & kff_d, const float & kff_lin_drag, const float kff_quad_drag ) Set the Feedforwar gains P I D object. Parameters : kff Feedforward gain (quadratic) kff_d Feedforwad derivative gain kff_lin_drag Feedforward linear drag gain kff_quad_drag Feedforwad quadratic drag gain function setGainsPID inline void setGainsPID( const float & kp, const float & ki, const float & kd ) Set the Gains P I D object. Parameters : kp Proportional gain ki Integral gain kd Derivative gain function setLimitBoundsPID inline void setLimitBoundsPID( const float & max_out, const float & min_out ) Protected Functions Documentation function refCallback void refCallback( const std_msgs::Float64 & ptr ) Callback function. Saturates the value if boundaries exist. Parameters : msg Float64 value of the variable being controlled function init void init( ros::NodeHandle & nh, std::string controller_name, std::string refCallback_topic ) Initialize function. Reads the parameters, creates a pid controller if any gain is different from zero and subscribes to the relevant topic. Parameters : nh Nodehandle to read parameters and subscribe to relevant topics controller_name Controller name (variable being controlled) refCallback_topic Topic name function validRef virtual bool validRef() Check if the reference is new. Return : True if valid, false otherwise Protected Attributes Documentation variable timeout_ref_ ros::Duration timeout_ref_; variable controller_name_ std::string controller_name_; variable ref_value_ double ref_value_; variable max_ref_value_ double max_ref_value_; variable min_ref_value_ double min_ref_value_; variable ref_time_ ros::Time ref_time_; variable last_cmd_ ros::Time last_cmd_; variable debug_ bool debug_; variable debug_msg_ medusa_msgs::mPidDebug debug_msg_; variable state_ptr_ double * state_ptr_; variable force_or_torque_ptr_ double * force_or_torque_ptr_; variable frequency_ double frequency_; variable circular_units_ bool circular_units_; variable positive_output_ bool positive_output_; variable pid_c_ PID_Controller * pid_c_; variable ros_sub_ ros::Subscriber ros_sub_; variable debug_pub_ ros::Publisher debug_pub_; Updated on 2022-05-30 at 14:56:44 +0000","title":"RosController"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#roscontroller","text":"ROS implementation of the innerloops controllers. Based on a desired reference computes the force or torque to be applied. #include <ros_controller.h>","title":"RosController"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#public-functions","text":"Name RosController (ros::NodeHandle & nh, std::string controller_name, std::string refCallback_topic, double * state, double * force_or_torque, double frequency) Constructor of a innerloop controller. RosController (ros::NodeHandle & nh, std::string controller_name, std::string refCallback_topic, double * state, double * state_dot, double * force_or_torque, double frequency) Constructor of a innerloop controller. virtual double computeCommand () Core function. Computes the PID output. void setCircularUnits (const bool & flag) Setter function for the circular units flag. void setPositiveOutput (const bool & flag) Set the Positive Output object. std::string getControllerName () const Get the Controller Name object. void setFFGainsPID (const float & kff, const float & kff_d, const float & kff_lin_drag, const float kff_quad_drag) Set the Feedforwar gains P I D object. void setGainsPID (const float & kp, const float & ki, const float & kd) Set the Gains P I D object. void setLimitBoundsPID (const float & max_out, const float & min_out)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#protected-functions","text":"Name void refCallback (const std_msgs::Float64 & ptr) Callback function. Saturates the value if boundaries exist. void init (ros::NodeHandle & nh, std::string controller_name, std::string refCallback_topic) Initialize function. Reads the parameters, creates a pid controller if any gain is different from zero and subscribes to the relevant topic. virtual bool validRef () Check if the reference is new.","title":"Protected Functions"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#protected-attributes","text":"Name ros::Duration timeout_ref_ std::string controller_name_ double ref_value_ double max_ref_value_ double min_ref_value_ ros::Time ref_time_ ros::Time last_cmd_ bool debug_ medusa_msgs::mPidDebug debug_msg_ double * state_ptr_ double * force_or_torque_ptr_ double frequency_ bool circular_units_ bool positive_output_ PID_Controller * pid_c_ ros::Subscriber ros_sub_ ros::Publisher debug_pub_","title":"Protected Attributes"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#function-roscontroller","text":"RosController( ros::NodeHandle & nh, std::string controller_name, std::string refCallback_topic, double * state, double * force_or_torque, double frequency ) Constructor of a innerloop controller. Parameters : nh ROS nodehandle to read parameters and subscribe to relevant topics controller_name Controller name (variable being controlled) refCallback_topic Topic name state Pointer to state variable being controlled force_or_torque Pointer to force or torque output frequency Frequency of controller sampling rate","title":"function RosController"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#function-roscontroller_1","text":"RosController( ros::NodeHandle & nh, std::string controller_name, std::string refCallback_topic, double * state, double * state_dot, double * force_or_torque, double frequency ) Constructor of a innerloop controller. Parameters : nh ROS nodehandle to read parameters and subscribe to relevant topics controller_name Controller name (variable being controlled) refCallback_topic Topic name state Pointer to state variable being controlled state_dot Pointer to the derivative of the state variable being controlled force_or_torque Pointer to force or torque output frequency Frequency of controller sampling rate","title":"function RosController"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#function-computecommand","text":"virtual double computeCommand() Core function. Computes the PID output. Return : The force or torque that result from the PID computation","title":"function computeCommand"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#function-setcircularunits","text":"inline void setCircularUnits( const bool & flag ) Setter function for the circular units flag. Parameters : flag true for controllers using angles, false otherwise","title":"function setCircularUnits"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#function-setpositiveoutput","text":"inline void setPositiveOutput( const bool & flag ) Set the Positive Output object. Parameters : flag","title":"function setPositiveOutput"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#function-getcontrollername","text":"inline std::string getControllerName() const Get the Controller Name object.","title":"function getControllerName"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#function-setffgainspid","text":"inline void setFFGainsPID( const float & kff, const float & kff_d, const float & kff_lin_drag, const float kff_quad_drag ) Set the Feedforwar gains P I D object. Parameters : kff Feedforward gain (quadratic) kff_d Feedforwad derivative gain kff_lin_drag Feedforward linear drag gain kff_quad_drag Feedforwad quadratic drag gain","title":"function setFFGainsPID"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#function-setgainspid","text":"inline void setGainsPID( const float & kp, const float & ki, const float & kd ) Set the Gains P I D object. Parameters : kp Proportional gain ki Integral gain kd Derivative gain","title":"function setGainsPID"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#function-setlimitboundspid","text":"inline void setLimitBoundsPID( const float & max_out, const float & min_out )","title":"function setLimitBoundsPID"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#function-refcallback","text":"void refCallback( const std_msgs::Float64 & ptr ) Callback function. Saturates the value if boundaries exist. Parameters : msg Float64 value of the variable being controlled","title":"function refCallback"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#function-init","text":"void init( ros::NodeHandle & nh, std::string controller_name, std::string refCallback_topic ) Initialize function. Reads the parameters, creates a pid controller if any gain is different from zero and subscribes to the relevant topic. Parameters : nh Nodehandle to read parameters and subscribe to relevant topics controller_name Controller name (variable being controlled) refCallback_topic Topic name","title":"function init"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#function-validref","text":"virtual bool validRef() Check if the reference is new. Return : True if valid, false otherwise","title":"function validRef"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-timeout_ref_","text":"ros::Duration timeout_ref_;","title":"variable timeout_ref_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-controller_name_","text":"std::string controller_name_;","title":"variable controller_name_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-ref_value_","text":"double ref_value_;","title":"variable ref_value_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-max_ref_value_","text":"double max_ref_value_;","title":"variable max_ref_value_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-min_ref_value_","text":"double min_ref_value_;","title":"variable min_ref_value_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-ref_time_","text":"ros::Time ref_time_;","title":"variable ref_time_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-last_cmd_","text":"ros::Time last_cmd_;","title":"variable last_cmd_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-debug_","text":"bool debug_;","title":"variable debug_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-debug_msg_","text":"medusa_msgs::mPidDebug debug_msg_;","title":"variable debug_msg_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-state_ptr_","text":"double * state_ptr_;","title":"variable state_ptr_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-force_or_torque_ptr_","text":"double * force_or_torque_ptr_;","title":"variable force_or_torque_ptr_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-frequency_","text":"double frequency_;","title":"variable frequency_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-circular_units_","text":"bool circular_units_;","title":"variable circular_units_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-positive_output_","text":"bool positive_output_;","title":"variable positive_output_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-pid_c_","text":"PID_Controller * pid_c_;","title":"variable pid_c_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-ros_sub_","text":"ros::Subscriber ros_sub_;","title":"variable ros_sub_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classRosController/#variable-debug_pub_","text":"ros::Publisher debug_pub_; Updated on 2022-05-30 at 14:56:44 +0000","title":"variable debug_pub_"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classSafeties/","text":"Safeties Public Functions Name Safeties (ros::NodeHandle & nh) Innerloops safeties constructor. virtual ~Safeties () Innerloops safeties Destructor. void loadParams (ros::NodeHandle & nh) Method to read parameters from yaml files. void initializeSubscribers (ros::NodeHandle & nh) Method to initialize subscribers. void initializePublishers (ros::NodeHandle & nh) Method to initialize publishers. void depthSafetyCallback (const std_msgs::Float64 & msg) Method called when a depth reference is received. Will check safeties regarding altitude: if valid will publish in the depth controller topic the desired reference, otherwise will publish the minimum altitude in the altitude controller. void altitudeSafetyCallback (const std_msgs::Float64 & msg) Method called when a altitude reference is received. Will check safeties regarding altitude: if above the minimum altitude will publish the desired reference, otherwise will publish the minimum altitude. void stateCallback (const auv_msgs::NavigationStatus & msg) Method called when a state msg is received. Updates depth and altitude values to calculate the water collumn needed for depth safeties. Public Functions Documentation function Safeties Safeties( ros::NodeHandle & nh ) Innerloops safeties constructor. Parameters : nh ros nodehandle to subscribe and publish topics function ~Safeties virtual ~Safeties() Innerloops safeties Destructor. function loadParams void loadParams( ros::NodeHandle & nh ) Method to read parameters from yaml files. Parameters : nh ros nodehandle to subscribe and publish topics function initializeSubscribers void initializeSubscribers( ros::NodeHandle & nh ) Method to initialize subscribers. Parameters : nh ros nodehandle to subscribe and publish topics function initializePublishers void initializePublishers( ros::NodeHandle & nh ) Method to initialize publishers. Parameters : nh ros nodehandle to subscribe and publish topics function depthSafetyCallback void depthSafetyCallback( const std_msgs::Float64 & msg ) Method called when a depth reference is received. Will check safeties regarding altitude: if valid will publish in the depth controller topic the desired reference, otherwise will publish the minimum altitude in the altitude controller. Parameters : msg Desired depth function altitudeSafetyCallback void altitudeSafetyCallback( const std_msgs::Float64 & msg ) Method called when a altitude reference is received. Will check safeties regarding altitude: if above the minimum altitude will publish the desired reference, otherwise will publish the minimum altitude. Parameters : msg Desired altitude function stateCallback void stateCallback( const auv_msgs::NavigationStatus & msg ) Method called when a state msg is received. Updates depth and altitude values to calculate the water collumn needed for depth safeties. Parameters : msg Vehicles state Updated on 2022-05-30 at 14:56:44 +0000","title":"Safeties"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classSafeties/#safeties","text":"","title":"Safeties"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classSafeties/#public-functions","text":"Name Safeties (ros::NodeHandle & nh) Innerloops safeties constructor. virtual ~Safeties () Innerloops safeties Destructor. void loadParams (ros::NodeHandle & nh) Method to read parameters from yaml files. void initializeSubscribers (ros::NodeHandle & nh) Method to initialize subscribers. void initializePublishers (ros::NodeHandle & nh) Method to initialize publishers. void depthSafetyCallback (const std_msgs::Float64 & msg) Method called when a depth reference is received. Will check safeties regarding altitude: if valid will publish in the depth controller topic the desired reference, otherwise will publish the minimum altitude in the altitude controller. void altitudeSafetyCallback (const std_msgs::Float64 & msg) Method called when a altitude reference is received. Will check safeties regarding altitude: if above the minimum altitude will publish the desired reference, otherwise will publish the minimum altitude. void stateCallback (const auv_msgs::NavigationStatus & msg) Method called when a state msg is received. Updates depth and altitude values to calculate the water collumn needed for depth safeties.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classSafeties/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classSafeties/#function-safeties","text":"Safeties( ros::NodeHandle & nh ) Innerloops safeties constructor. Parameters : nh ros nodehandle to subscribe and publish topics","title":"function Safeties"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classSafeties/#function-safeties_1","text":"virtual ~Safeties() Innerloops safeties Destructor.","title":"function ~Safeties"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classSafeties/#function-loadparams","text":"void loadParams( ros::NodeHandle & nh ) Method to read parameters from yaml files. Parameters : nh ros nodehandle to subscribe and publish topics","title":"function loadParams"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classSafeties/#function-initializesubscribers","text":"void initializeSubscribers( ros::NodeHandle & nh ) Method to initialize subscribers. Parameters : nh ros nodehandle to subscribe and publish topics","title":"function initializeSubscribers"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classSafeties/#function-initializepublishers","text":"void initializePublishers( ros::NodeHandle & nh ) Method to initialize publishers. Parameters : nh ros nodehandle to subscribe and publish topics","title":"function initializePublishers"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classSafeties/#function-depthsafetycallback","text":"void depthSafetyCallback( const std_msgs::Float64 & msg ) Method called when a depth reference is received. Will check safeties regarding altitude: if valid will publish in the depth controller topic the desired reference, otherwise will publish the minimum altitude in the altitude controller. Parameters : msg Desired depth","title":"function depthSafetyCallback"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classSafeties/#function-altitudesafetycallback","text":"void altitudeSafetyCallback( const std_msgs::Float64 & msg ) Method called when a altitude reference is received. Will check safeties regarding altitude: if above the minimum altitude will publish the desired reference, otherwise will publish the minimum altitude. Parameters : msg Desired altitude","title":"function altitudeSafetyCallback"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Classes/classSafeties/#function-statecallback","text":"void stateCallback( const auv_msgs::NavigationStatus & msg ) Method called when a state msg is received. Updates depth and altitude values to calculate the water collumn needed for depth safeties. Parameters : msg Vehicles state Updated on 2022-05-30 at 14:56:44 +0000","title":"function stateCallback"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Examples/","text":"Examples Updated on 2022-05-30 at 14:56:44 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Examples/#examples","text":"Updated on 2022-05-30 at 14:56:44 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Modules/","text":"Modules Updated on 2022-05-30 at 14:56:44 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Modules/#modules","text":"Updated on 2022-05-30 at 14:56:44 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Namespaces/","text":"Namespaces Updated on 2022-05-30 at 14:56:44 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/inner_loops_pid/Namespaces/#namespaces","text":"Updated on 2022-05-30 at 14:56:44 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/","text":"Classes namespace setup namespace src namespace open_loop_controller namespace OpenLoopNode class OpenLoopNode Updated on 2022-05-30 at 14:56:45 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/#classes","text":"namespace setup namespace src namespace open_loop_controller namespace OpenLoopNode class OpenLoopNode Updated on 2022-05-30 at 14:56:45 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/","text":"src::open_loop_controller::OpenLoopNode::OpenLoopNode More... Public Functions Name def init (self self) def load_params (self self) def initializeSubscribers (self self) def initializePublishers (self self) def timerCallback (self self, event event) def surgeCallback (self self, Float64 msg) def swayCallback (self self, Float64 msg) def heaveCallback (self self, Float64 msg) def yawRateCallback (self self, Float64 msg) def initializeTimer (self self) Public Attributes Name h_timerActivate surge_desired sway_desired heave_desired yaw_rate_desired last_update node_frequency gain_Fx gain_Fy gain_Fz gain_Tz surge_sub sway_sub heave_sub yaw_rate_sub force_pub timer Detailed Description class src::open_loop_controller::OpenLoopNode::OpenLoopNode; Remote controller ROS node class. Receives from a joystick (using pygame) the desired controls for the inner-loops and publishes these periodically (at a pre-defined frequency) to the inner-loops of the vehicle Public Functions Documentation function init def __init__( self self ) Class constructor. Initializes the ros node, loads the parameters from the ros parameter server, creates the inner-loops publishers and initializes the timer that publishes the desired inputs to the inner-loops function load_params def load_params( self self ) function initializeSubscribers def initializeSubscribers( self self ) function initializePublishers def initializePublishers( self self ) function timerCallback def timerCallback( self self, event event ) Callback used to publish to the inner-loops the desired control inputs :param event: A timer event - unused but required by the ROS API function surgeCallback def surgeCallback( self self, Float64 msg ) function swayCallback def swayCallback( self self, Float64 msg ) function heaveCallback def heaveCallback( self self, Float64 msg ) function yawRateCallback def yawRateCallback( self self, Float64 msg ) function initializeTimer def initializeTimer( self self ) Method that starts the system timer that periodically calls a callback Public Attributes Documentation variable h_timerActivate h_timerActivate; variable surge_desired surge_desired; variable sway_desired sway_desired; variable heave_desired heave_desired; variable yaw_rate_desired yaw_rate_desired; variable last_update last_update; variable node_frequency node_frequency; variable gain_Fx gain_Fx; variable gain_Fy gain_Fy; variable gain_Fz gain_Fz; variable gain_Tz gain_Tz; variable surge_sub surge_sub; variable sway_sub sway_sub; variable heave_sub heave_sub; variable yaw_rate_sub yaw_rate_sub; variable force_pub force_pub; variable timer timer; Updated on 2022-05-30 at 14:56:45 +0000","title":"src::open_loop_controller::OpenLoopNode::OpenLoopNode"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#srcopen_loop_controlleropenloopnodeopenloopnode","text":"More...","title":"src::open_loop_controller::OpenLoopNode::OpenLoopNode"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#public-functions","text":"Name def init (self self) def load_params (self self) def initializeSubscribers (self self) def initializePublishers (self self) def timerCallback (self self, event event) def surgeCallback (self self, Float64 msg) def swayCallback (self self, Float64 msg) def heaveCallback (self self, Float64 msg) def yawRateCallback (self self, Float64 msg) def initializeTimer (self self)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#public-attributes","text":"Name h_timerActivate surge_desired sway_desired heave_desired yaw_rate_desired last_update node_frequency gain_Fx gain_Fy gain_Fz gain_Tz surge_sub sway_sub heave_sub yaw_rate_sub force_pub timer","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#detailed-description","text":"class src::open_loop_controller::OpenLoopNode::OpenLoopNode; Remote controller ROS node class. Receives from a joystick (using pygame) the desired controls for the inner-loops and publishes these periodically (at a pre-defined frequency) to the inner-loops of the vehicle","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#function-init","text":"def __init__( self self ) Class constructor. Initializes the ros node, loads the parameters from the ros parameter server, creates the inner-loops publishers and initializes the timer that publishes the desired inputs to the inner-loops","title":"function init"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#function-load_params","text":"def load_params( self self )","title":"function load_params"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#function-initializesubscribers","text":"def initializeSubscribers( self self )","title":"function initializeSubscribers"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#function-initializepublishers","text":"def initializePublishers( self self )","title":"function initializePublishers"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#function-timercallback","text":"def timerCallback( self self, event event ) Callback used to publish to the inner-loops the desired control inputs :param event: A timer event - unused but required by the ROS API","title":"function timerCallback"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#function-surgecallback","text":"def surgeCallback( self self, Float64 msg )","title":"function surgeCallback"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#function-swaycallback","text":"def swayCallback( self self, Float64 msg )","title":"function swayCallback"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#function-heavecallback","text":"def heaveCallback( self self, Float64 msg )","title":"function heaveCallback"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#function-yawratecallback","text":"def yawRateCallback( self self, Float64 msg )","title":"function yawRateCallback"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#function-initializetimer","text":"def initializeTimer( self self ) Method that starts the system timer that periodically calls a callback","title":"function initializeTimer"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-h_timeractivate","text":"h_timerActivate;","title":"variable h_timerActivate"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-surge_desired","text":"surge_desired;","title":"variable surge_desired"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-sway_desired","text":"sway_desired;","title":"variable sway_desired"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-heave_desired","text":"heave_desired;","title":"variable heave_desired"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-yaw_rate_desired","text":"yaw_rate_desired;","title":"variable yaw_rate_desired"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-last_update","text":"last_update;","title":"variable last_update"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-node_frequency","text":"node_frequency;","title":"variable node_frequency"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-gain_fx","text":"gain_Fx;","title":"variable gain_Fx"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-gain_fy","text":"gain_Fy;","title":"variable gain_Fy"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-gain_fz","text":"gain_Fz;","title":"variable gain_Fz"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-gain_tz","text":"gain_Tz;","title":"variable gain_Tz"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-surge_sub","text":"surge_sub;","title":"variable surge_sub"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-sway_sub","text":"sway_sub;","title":"variable sway_sub"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-heave_sub","text":"heave_sub;","title":"variable heave_sub"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-yaw_rate_sub","text":"yaw_rate_sub;","title":"variable yaw_rate_sub"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-force_pub","text":"force_pub;","title":"variable force_pub"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Classes/classsrc_1_1open__loop__controller_1_1OpenLoopNode_1_1OpenLoopNode/#variable-timer","text":"timer; Updated on 2022-05-30 at 14:56:45 +0000","title":"variable timer"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Examples/","text":"Examples Updated on 2022-05-30 at 14:56:45 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Examples/#examples","text":"Updated on 2022-05-30 at 14:56:45 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Modules/","text":"Modules Updated on 2022-05-30 at 14:56:45 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Modules/#modules","text":"Updated on 2022-05-30 at 14:56:45 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/","text":"Namespaces namespace setup namespace src namespace open_loop_controller namespace OpenLoopNode Updated on 2022-05-30 at 14:56:45 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/#namespaces","text":"namespace setup namespace src namespace open_loop_controller namespace OpenLoopNode Updated on 2022-05-30 at 14:56:45 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesetup/","text":"setup Attributes Name d Attributes Documentation variable d d = generate_distutils_setup( packages=['open_loop_controller'], package_dir={'open_loop_controller': 'src/open_loop_controller'} ); Updated on 2022-05-30 at 14:56:45 +0000","title":"setup"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesetup/#setup","text":"","title":"setup"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesetup/#attributes","text":"Name d","title":"Attributes"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesetup/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesetup/#variable-d","text":"d = generate_distutils_setup( packages=['open_loop_controller'], package_dir={'open_loop_controller': 'src/open_loop_controller'} ); Updated on 2022-05-30 at 14:56:45 +0000","title":"variable d"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesrc/","text":"src Namespaces Name src::open_loop_controller Updated on 2022-05-30 at 14:56:45 +0000","title":"src"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesrc/#src","text":"","title":"src"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesrc/#namespaces","text":"Name src::open_loop_controller Updated on 2022-05-30 at 14:56:45 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesrc_1_1open__loop__controller/","text":"src::open_loop_controller Namespaces Name src::open_loop_controller::OpenLoopNode Updated on 2022-05-30 at 14:56:45 +0000","title":"src::open_loop_controller"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesrc_1_1open__loop__controller/#srcopen_loop_controller","text":"","title":"src::open_loop_controller"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesrc_1_1open__loop__controller/#namespaces","text":"Name src::open_loop_controller::OpenLoopNode Updated on 2022-05-30 at 14:56:45 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesrc_1_1open__loop__controller_1_1OpenLoopNode/","text":"src::open_loop_controller::OpenLoopNode More... Classes Name class src::open_loop_controller::OpenLoopNode::OpenLoopNode Functions Name def main () Detailed Description @author: Marcelo Fialho Jacinto @email: marcelo.jacinto@tecnico.ulisboa.pt @date: 30/03/2022 @licence: MIT Functions Documentation function main def main() Initialize the RemoteControllerNode and let the timer callback do all the work Updated on 2022-05-30 at 14:56:45 +0000","title":"src::open_loop_controller::OpenLoopNode"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesrc_1_1open__loop__controller_1_1OpenLoopNode/#srcopen_loop_controlleropenloopnode","text":"More...","title":"src::open_loop_controller::OpenLoopNode"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesrc_1_1open__loop__controller_1_1OpenLoopNode/#classes","text":"Name class src::open_loop_controller::OpenLoopNode::OpenLoopNode","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesrc_1_1open__loop__controller_1_1OpenLoopNode/#functions","text":"Name def main ()","title":"Functions"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesrc_1_1open__loop__controller_1_1OpenLoopNode/#detailed-description","text":"@author: Marcelo Fialho Jacinto @email: marcelo.jacinto@tecnico.ulisboa.pt @date: 30/03/2022 @licence: MIT","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesrc_1_1open__loop__controller_1_1OpenLoopNode/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/inner_loops_controllers/open_loop_controller/Namespaces/namespacesrc_1_1open__loop__controller_1_1OpenLoopNode/#function-main","text":"def main() Initialize the RemoteControllerNode and let the timer callback do all the work Updated on 2022-05-30 at 14:56:45 +0000","title":"function main"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/","text":"Classes class CPFControl Abstract class to implement the cooperative path following synchronization controller. class CpfNode ROS node to actually do the Cooperative Control. class EventTriggered Implements a CPF controller using Event triggered communications. struct VehicleInfo Auxiliar structure to hold information regarding one vehicle. Updated on 2022-05-30 at 14:56:44 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/#classes","text":"class CPFControl Abstract class to implement the cooperative path following synchronization controller. class CpfNode ROS node to actually do the Cooperative Control. class EventTriggered Implements a CPF controller using Event triggered communications. struct VehicleInfo Auxiliar structure to hold information regarding one vehicle. Updated on 2022-05-30 at 14:56:44 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/","text":"CPFControl Abstract class to implement the cooperative path following synchronization controller. More... #include <CPFControl.h> Inherited by EventTriggered Public Functions Name virtual double coordinationController (double time) =0 Method to that updated the coordination control law and returns the correction speed vc to be used by the virtual target. virtual bool updateVehiclesInformation (double time, unsigned int ID, double gamma, double vd) =0 Method to update each individual vehicle information given an int with the ID of the vehicle and the new virtual target value. virtual bool publishCurrentGamma (double time) =0 Method to inform the user if the current gamma should be published or not. virtual bool reset () =0 Method to reset the current CPF controller. Eigen::MatrixXi getAdjencyMatrix () Method to get the Adjency Matrix that represents the network topology. Eigen::VectorXi getNeighbors () Method to get a vector with the neighbors of the current vehicle. bool updateAdjencyMatrix (Eigen::Matrix< int, Eigen::Dynamic, Eigen::Dynamic > & adjency_matrix) Method to update the Adjency Matrix that represents the network topology. unsigned int getNetworkSize () Method to get the number of vehicles used in the network. unsigned int getCurrentVehicleID () Method to get the current vehicle ID in the network. virtual ~CPFControl () Virtual destructor for the abstract class. Protected Functions Name CPFControl (Eigen::Matrix< int, Eigen::Dynamic, Eigen::Dynamic > & adjency_matrix, unsigned int vehicle_ID) Constructor for the abstract class. Receive the adjency matrix as a parameter. Detailed Description class CPFControl; Abstract class to implement the cooperative path following synchronization controller. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT In this class it is assumed that each vehicle has an ID which corresponds to each position in the adjency matrix that describes the topology of the network. The first ID is assumed to be 0. Public Functions Documentation function coordinationController virtual double coordinationController( double time ) =0 Method to that updated the coordination control law and returns the correction speed vc to be used by the virtual target. Parameters : time An int with the current time expressed in seconds Return : A double with the speed correction term vc Reimplemented by : EventTriggered::coordinationController function updateVehiclesInformation virtual bool updateVehiclesInformation( double time, unsigned int ID, double gamma, double vd ) =0 Method to update each individual vehicle information given an int with the ID of the vehicle and the new virtual target value. Parameters : time An int with the current time expressed in seconds ID An int with the ID of the vehicle which to update information gamma A double with the new information of the virtual target position vd A double with the desired velocity of the virtual target of that particular vehicle Return : A boolean with the information whether the information was used with success or not Reimplemented by : EventTriggered::updateVehiclesInformation function publishCurrentGamma virtual bool publishCurrentGamma( double time ) =0 Method to inform the user if the current gamma should be published or not. Parameters : time The current time expressed in seconds Return : A boolean that is true if the current gamma should be published Reimplemented by : EventTriggered::publishCurrentGamma function reset virtual bool reset() =0 Method to reset the current CPF controller. Return : A boolean whether it was reset correctly or not Reimplemented by : EventTriggered::reset function getAdjencyMatrix Eigen::MatrixXi getAdjencyMatrix() Method to get the Adjency Matrix that represents the network topology. Return : An eigen adjecy matrix of ints An eigen adjecy matrix of doubles function getNeighbors Eigen::VectorXi getNeighbors() Method to get a vector with the neighbors of the current vehicle. Return : An eigen vector with ints function updateAdjencyMatrix bool updateAdjencyMatrix( Eigen::Matrix< int, Eigen::Dynamic, Eigen::Dynamic > & adjency_matrix ) Method to update the Adjency Matrix that represents the network topology. Return : A boolean informing if update was done successfully or not function getNetworkSize unsigned int getNetworkSize() Method to get the number of vehicles used in the network. Return : An int with the number of vehicles in the network function getCurrentVehicleID unsigned int getCurrentVehicleID() Method to get the current vehicle ID in the network. Return : An int with the current vehicle ID function ~CPFControl virtual ~CPFControl() Virtual destructor for the abstract class. Protected Functions Documentation function CPFControl CPFControl( Eigen::Matrix< int, Eigen::Dynamic, Eigen::Dynamic > & adjency_matrix, unsigned int vehicle_ID ) Constructor for the abstract class. Receive the adjency matrix as a parameter. Parameters : adjency_matrix An Eigen adjency matrix vehicle_ID The current vehicle ID Updated on 2022-05-30 at 14:56:44 +0000","title":"CPFControl"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#cpfcontrol","text":"Abstract class to implement the cooperative path following synchronization controller. More... #include <CPFControl.h> Inherited by EventTriggered","title":"CPFControl"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#public-functions","text":"Name virtual double coordinationController (double time) =0 Method to that updated the coordination control law and returns the correction speed vc to be used by the virtual target. virtual bool updateVehiclesInformation (double time, unsigned int ID, double gamma, double vd) =0 Method to update each individual vehicle information given an int with the ID of the vehicle and the new virtual target value. virtual bool publishCurrentGamma (double time) =0 Method to inform the user if the current gamma should be published or not. virtual bool reset () =0 Method to reset the current CPF controller. Eigen::MatrixXi getAdjencyMatrix () Method to get the Adjency Matrix that represents the network topology. Eigen::VectorXi getNeighbors () Method to get a vector with the neighbors of the current vehicle. bool updateAdjencyMatrix (Eigen::Matrix< int, Eigen::Dynamic, Eigen::Dynamic > & adjency_matrix) Method to update the Adjency Matrix that represents the network topology. unsigned int getNetworkSize () Method to get the number of vehicles used in the network. unsigned int getCurrentVehicleID () Method to get the current vehicle ID in the network. virtual ~CPFControl () Virtual destructor for the abstract class.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#protected-functions","text":"Name CPFControl (Eigen::Matrix< int, Eigen::Dynamic, Eigen::Dynamic > & adjency_matrix, unsigned int vehicle_ID) Constructor for the abstract class. Receive the adjency matrix as a parameter.","title":"Protected Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#detailed-description","text":"class CPFControl; Abstract class to implement the cooperative path following synchronization controller. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT In this class it is assumed that each vehicle has an ID which corresponds to each position in the adjency matrix that describes the topology of the network. The first ID is assumed to be 0.","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#function-coordinationcontroller","text":"virtual double coordinationController( double time ) =0 Method to that updated the coordination control law and returns the correction speed vc to be used by the virtual target. Parameters : time An int with the current time expressed in seconds Return : A double with the speed correction term vc Reimplemented by : EventTriggered::coordinationController","title":"function coordinationController"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#function-updatevehiclesinformation","text":"virtual bool updateVehiclesInformation( double time, unsigned int ID, double gamma, double vd ) =0 Method to update each individual vehicle information given an int with the ID of the vehicle and the new virtual target value. Parameters : time An int with the current time expressed in seconds ID An int with the ID of the vehicle which to update information gamma A double with the new information of the virtual target position vd A double with the desired velocity of the virtual target of that particular vehicle Return : A boolean with the information whether the information was used with success or not Reimplemented by : EventTriggered::updateVehiclesInformation","title":"function updateVehiclesInformation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#function-publishcurrentgamma","text":"virtual bool publishCurrentGamma( double time ) =0 Method to inform the user if the current gamma should be published or not. Parameters : time The current time expressed in seconds Return : A boolean that is true if the current gamma should be published Reimplemented by : EventTriggered::publishCurrentGamma","title":"function publishCurrentGamma"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#function-reset","text":"virtual bool reset() =0 Method to reset the current CPF controller. Return : A boolean whether it was reset correctly or not Reimplemented by : EventTriggered::reset","title":"function reset"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#function-getadjencymatrix","text":"Eigen::MatrixXi getAdjencyMatrix() Method to get the Adjency Matrix that represents the network topology. Return : An eigen adjecy matrix of ints An eigen adjecy matrix of doubles","title":"function getAdjencyMatrix"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#function-getneighbors","text":"Eigen::VectorXi getNeighbors() Method to get a vector with the neighbors of the current vehicle. Return : An eigen vector with ints","title":"function getNeighbors"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#function-updateadjencymatrix","text":"bool updateAdjencyMatrix( Eigen::Matrix< int, Eigen::Dynamic, Eigen::Dynamic > & adjency_matrix ) Method to update the Adjency Matrix that represents the network topology. Return : A boolean informing if update was done successfully or not","title":"function updateAdjencyMatrix"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#function-getnetworksize","text":"unsigned int getNetworkSize() Method to get the number of vehicles used in the network. Return : An int with the number of vehicles in the network","title":"function getNetworkSize"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#function-getcurrentvehicleid","text":"unsigned int getCurrentVehicleID() Method to get the current vehicle ID in the network. Return : An int with the current vehicle ID","title":"function getCurrentVehicleID"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#function-cpfcontrol","text":"virtual ~CPFControl() Virtual destructor for the abstract class.","title":"function ~CPFControl"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCPFControl/#function-cpfcontrol_1","text":"CPFControl( Eigen::Matrix< int, Eigen::Dynamic, Eigen::Dynamic > & adjency_matrix, unsigned int vehicle_ID ) Constructor for the abstract class. Receive the adjency matrix as a parameter. Parameters : adjency_matrix An Eigen adjency matrix vehicle_ID The current vehicle ID Updated on 2022-05-30 at 14:56:44 +0000","title":"function CPFControl"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCpfNode/","text":"CpfNode ROS node to actually do the Cooperative Control. More... #include <CpfNode.h> Public Functions Name CpfNode (ros::NodeHandle * nh, ros::NodeHandle * nh_p) The constructor for the Cooperative control law. ~CpfNode () Destructor for the CPF Node. Here all the subscribers, publishers and timers are shutdown. Detailed Description class CpfNode; ROS node to actually do the Cooperative Control. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT Public Functions Documentation function CpfNode CpfNode( ros::NodeHandle * nh, ros::NodeHandle * nh_p ) The constructor for the Cooperative control law. Parameters : nh The public nodehandle nh_p The private nodehandle nh Pointer to the public nodehandle nh Pointer to the private nodehandle Constructor for the CpfNode . function ~CpfNode ~CpfNode() Destructor for the CPF Node. Here all the subscribers, publishers and timers are shutdown. Destructor for the CpfNode . Updated on 2022-05-30 at 14:56:44 +0000","title":"CpfNode"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCpfNode/#cpfnode","text":"ROS node to actually do the Cooperative Control. More... #include <CpfNode.h>","title":"CpfNode"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCpfNode/#public-functions","text":"Name CpfNode (ros::NodeHandle * nh, ros::NodeHandle * nh_p) The constructor for the Cooperative control law. ~CpfNode () Destructor for the CPF Node. Here all the subscribers, publishers and timers are shutdown.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCpfNode/#detailed-description","text":"class CpfNode; ROS node to actually do the Cooperative Control. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCpfNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCpfNode/#function-cpfnode","text":"CpfNode( ros::NodeHandle * nh, ros::NodeHandle * nh_p ) The constructor for the Cooperative control law. Parameters : nh The public nodehandle nh_p The private nodehandle nh Pointer to the public nodehandle nh Pointer to the private nodehandle Constructor for the CpfNode .","title":"function CpfNode"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classCpfNode/#function-cpfnode_1","text":"~CpfNode() Destructor for the CPF Node. Here all the subscribers, publishers and timers are shutdown. Destructor for the CpfNode . Updated on 2022-05-30 at 14:56:44 +0000","title":"function ~CpfNode"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classEventTriggered/","text":"EventTriggered Implements a CPF controller using Event triggered communications. More... #include <EventTriggered.h> Inherits from CPFControl Public Functions Name EventTriggered (Eigen::Matrix< int, Eigen::Dynamic, Eigen::Dynamic > & adjency_matrix, unsigned int vehicle_ID, double k_epsilon, double c0, double c1, double alpha) Constructor for the EventTriggered CPF class. Receive the adjency matrix as a parameter. ~EventTriggered () The destructor for the EventTriggered class. virtual double coordinationController (double time) override Method to that updated the coordination control law and returns the correction speed vc to be used by the virtual target. virtual bool updateVehiclesInformation (double time, unsigned int ID, double gamma, double vd) override Method to update each individual vehicle information given an int with the ID of the vehicle and the new virtual target value. virtual bool publishCurrentGamma (double time) override Method to inform the user if the current gamma should be published or not This method will update the value of gamma last sent to the network when this method returns true. virtual bool reset () override Method to reset the current CPF controller. Protected Functions Name void predictVehicleEstimator (unsigned int ID, double time) Method to estimate the current gamma of a vehicle represented by ID. Additional inherited members Public Functions inherited from CPFControl Name Eigen::MatrixXi getAdjencyMatrix () Method to get the Adjency Matrix that represents the network topology. Eigen::VectorXi getNeighbors () Method to get a vector with the neighbors of the current vehicle. bool updateAdjencyMatrix (Eigen::Matrix< int, Eigen::Dynamic, Eigen::Dynamic > & adjency_matrix) Method to update the Adjency Matrix that represents the network topology. unsigned int getNetworkSize () Method to get the number of vehicles used in the network. unsigned int getCurrentVehicleID () Method to get the current vehicle ID in the network. virtual ~CPFControl () Virtual destructor for the abstract class. Protected Functions inherited from CPFControl Name CPFControl (Eigen::Matrix< int, Eigen::Dynamic, Eigen::Dynamic > & adjency_matrix, unsigned int vehicle_ID) Constructor for the abstract class. Receive the adjency matrix as a parameter. Detailed Description class EventTriggered; Implements a CPF controller using Event triggered communications. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : GPLv3 Public Functions Documentation function EventTriggered EventTriggered( Eigen::Matrix< int, Eigen::Dynamic, Eigen::Dynamic > & adjency_matrix, unsigned int vehicle_ID, double k_epsilon, double c0, double c1, double alpha ) Constructor for the EventTriggered CPF class. Receive the adjency matrix as a parameter. Parameters : adjency_matrix An Eigen adjency matrix vehicle_ID An unsigned int with the ID of this particular vehicle k_epsilon The gain for the correction control law c0 The gain for the event trigger threshold c1 The gain for the event trigger threshold alpha The gian for the event trigger threshold function ~EventTriggered ~EventTriggered() The destructor for the EventTriggered class. Destructor for the EventTriggered class. function coordinationController virtual double coordinationController( double time ) override Method to that updated the coordination control law and returns the correction speed vc to be used by the virtual target. Parameters : time An int with the current time expressed in seconds Return : A double with the speed correction term vc Reimplements : CPFControl::coordinationController function updateVehiclesInformation virtual bool updateVehiclesInformation( double time, unsigned int ID, double gamma, double vd ) override Method to update each individual vehicle information given an int with the ID of the vehicle and the new virtual target value. Parameters : time An int with the current time expressed in seconds ID An int with the ID of the vehicle which to update information gamma A double with the new information of the virtual target position vd A double with the desired velocity of the virtual target of that particular vehicle Return : A boolean with the information whether the information was used with success or not Reimplements : CPFControl::updateVehiclesInformation function publishCurrentGamma virtual bool publishCurrentGamma( double time ) override Method to inform the user if the current gamma should be published or not This method will update the value of gamma last sent to the network when this method returns true. Parameters : time The current time expressed in seconds Return : A boolean that is true if the current gamma should be published Reimplements : CPFControl::publishCurrentGamma Method to inform the user if the current gamma should be published or not. function reset virtual bool reset() override Method to reset the current CPF controller. Return : A boolean whether it was reset correctly or not Reimplements : CPFControl::reset Protected Functions Documentation function predictVehicleEstimator void predictVehicleEstimator( unsigned int ID, double time ) Method to estimate the current gamma of a vehicle represented by ID. Parameters : ID The ID of the vehicle to update the prediction time The current time expressed in seconds Updated on 2022-05-30 at 14:56:44 +0000","title":"EventTriggered"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classEventTriggered/#eventtriggered","text":"Implements a CPF controller using Event triggered communications. More... #include <EventTriggered.h> Inherits from CPFControl","title":"EventTriggered"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classEventTriggered/#public-functions","text":"Name EventTriggered (Eigen::Matrix< int, Eigen::Dynamic, Eigen::Dynamic > & adjency_matrix, unsigned int vehicle_ID, double k_epsilon, double c0, double c1, double alpha) Constructor for the EventTriggered CPF class. Receive the adjency matrix as a parameter. ~EventTriggered () The destructor for the EventTriggered class. virtual double coordinationController (double time) override Method to that updated the coordination control law and returns the correction speed vc to be used by the virtual target. virtual bool updateVehiclesInformation (double time, unsigned int ID, double gamma, double vd) override Method to update each individual vehicle information given an int with the ID of the vehicle and the new virtual target value. virtual bool publishCurrentGamma (double time) override Method to inform the user if the current gamma should be published or not This method will update the value of gamma last sent to the network when this method returns true. virtual bool reset () override Method to reset the current CPF controller.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classEventTriggered/#protected-functions","text":"Name void predictVehicleEstimator (unsigned int ID, double time) Method to estimate the current gamma of a vehicle represented by ID.","title":"Protected Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classEventTriggered/#additional-inherited-members","text":"Public Functions inherited from CPFControl Name Eigen::MatrixXi getAdjencyMatrix () Method to get the Adjency Matrix that represents the network topology. Eigen::VectorXi getNeighbors () Method to get a vector with the neighbors of the current vehicle. bool updateAdjencyMatrix (Eigen::Matrix< int, Eigen::Dynamic, Eigen::Dynamic > & adjency_matrix) Method to update the Adjency Matrix that represents the network topology. unsigned int getNetworkSize () Method to get the number of vehicles used in the network. unsigned int getCurrentVehicleID () Method to get the current vehicle ID in the network. virtual ~CPFControl () Virtual destructor for the abstract class. Protected Functions inherited from CPFControl Name CPFControl (Eigen::Matrix< int, Eigen::Dynamic, Eigen::Dynamic > & adjency_matrix, unsigned int vehicle_ID) Constructor for the abstract class. Receive the adjency matrix as a parameter.","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classEventTriggered/#detailed-description","text":"class EventTriggered; Implements a CPF controller using Event triggered communications. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : GPLv3","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classEventTriggered/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classEventTriggered/#function-eventtriggered","text":"EventTriggered( Eigen::Matrix< int, Eigen::Dynamic, Eigen::Dynamic > & adjency_matrix, unsigned int vehicle_ID, double k_epsilon, double c0, double c1, double alpha ) Constructor for the EventTriggered CPF class. Receive the adjency matrix as a parameter. Parameters : adjency_matrix An Eigen adjency matrix vehicle_ID An unsigned int with the ID of this particular vehicle k_epsilon The gain for the correction control law c0 The gain for the event trigger threshold c1 The gain for the event trigger threshold alpha The gian for the event trigger threshold","title":"function EventTriggered"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classEventTriggered/#function-eventtriggered_1","text":"~EventTriggered() The destructor for the EventTriggered class. Destructor for the EventTriggered class.","title":"function ~EventTriggered"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classEventTriggered/#function-coordinationcontroller","text":"virtual double coordinationController( double time ) override Method to that updated the coordination control law and returns the correction speed vc to be used by the virtual target. Parameters : time An int with the current time expressed in seconds Return : A double with the speed correction term vc Reimplements : CPFControl::coordinationController","title":"function coordinationController"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classEventTriggered/#function-updatevehiclesinformation","text":"virtual bool updateVehiclesInformation( double time, unsigned int ID, double gamma, double vd ) override Method to update each individual vehicle information given an int with the ID of the vehicle and the new virtual target value. Parameters : time An int with the current time expressed in seconds ID An int with the ID of the vehicle which to update information gamma A double with the new information of the virtual target position vd A double with the desired velocity of the virtual target of that particular vehicle Return : A boolean with the information whether the information was used with success or not Reimplements : CPFControl::updateVehiclesInformation","title":"function updateVehiclesInformation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classEventTriggered/#function-publishcurrentgamma","text":"virtual bool publishCurrentGamma( double time ) override Method to inform the user if the current gamma should be published or not This method will update the value of gamma last sent to the network when this method returns true. Parameters : time The current time expressed in seconds Return : A boolean that is true if the current gamma should be published Reimplements : CPFControl::publishCurrentGamma Method to inform the user if the current gamma should be published or not.","title":"function publishCurrentGamma"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classEventTriggered/#function-reset","text":"virtual bool reset() override Method to reset the current CPF controller. Return : A boolean whether it was reset correctly or not Reimplements : CPFControl::reset","title":"function reset"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classEventTriggered/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/classEventTriggered/#function-predictvehicleestimator","text":"void predictVehicleEstimator( unsigned int ID, double time ) Method to estimate the current gamma of a vehicle represented by ID. Parameters : ID The ID of the vehicle to update the prediction time The current time expressed in seconds Updated on 2022-05-30 at 14:56:44 +0000","title":"function predictVehicleEstimator"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/structVehicleInfo/","text":"VehicleInfo Auxiliar structure to hold information regarding one vehicle. More... #include <EventTriggered.h> Public Attributes Name double gamma The real value of gamma received by the network and the corresponding time at which this value was received by the network. double time The time instant expressed in seconds corresponding to the instant when gamma was received. double gamma_hat The estimated value of gamma. double vd The desired speed for that gamma. bool is_active Flag that will become true when the first value is received from the network for this vehicle. Detailed Description struct VehicleInfo; Auxiliar structure to hold information regarding one vehicle. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT Public Attributes Documentation variable gamma double gamma {0.0}; The real value of gamma received by the network and the corresponding time at which this value was received by the network. variable time double time {0.0}; The time instant expressed in seconds corresponding to the instant when gamma was received. variable gamma_hat double gamma_hat {0.0}; The estimated value of gamma. variable vd double vd {0.0}; The desired speed for that gamma. variable is_active bool is_active {false}; Flag that will become true when the first value is received from the network for this vehicle. Updated on 2022-05-30 at 14:56:44 +0000","title":"VehicleInfo"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/structVehicleInfo/#vehicleinfo","text":"Auxiliar structure to hold information regarding one vehicle. More... #include <EventTriggered.h>","title":"VehicleInfo"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/structVehicleInfo/#public-attributes","text":"Name double gamma The real value of gamma received by the network and the corresponding time at which this value was received by the network. double time The time instant expressed in seconds corresponding to the instant when gamma was received. double gamma_hat The estimated value of gamma. double vd The desired speed for that gamma. bool is_active Flag that will become true when the first value is received from the network for this vehicle.","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/structVehicleInfo/#detailed-description","text":"struct VehicleInfo; Auxiliar structure to hold information regarding one vehicle. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/structVehicleInfo/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/structVehicleInfo/#variable-gamma","text":"double gamma {0.0}; The real value of gamma received by the network and the corresponding time at which this value was received by the network.","title":"variable gamma"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/structVehicleInfo/#variable-time","text":"double time {0.0}; The time instant expressed in seconds corresponding to the instant when gamma was received.","title":"variable time"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/structVehicleInfo/#variable-gamma_hat","text":"double gamma_hat {0.0}; The estimated value of gamma.","title":"variable gamma_hat"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/structVehicleInfo/#variable-vd","text":"double vd {0.0}; The desired speed for that gamma.","title":"variable vd"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Classes/structVehicleInfo/#variable-is_active","text":"bool is_active {false}; Flag that will become true when the first value is received from the network for this vehicle. Updated on 2022-05-30 at 14:56:44 +0000","title":"variable is_active"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Examples/","text":"Examples Updated on 2022-05-30 at 14:56:44 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Examples/#examples","text":"Updated on 2022-05-30 at 14:56:44 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Modules/","text":"Modules Updated on 2022-05-30 at 14:56:44 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Modules/#modules","text":"Updated on 2022-05-30 at 14:56:44 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Namespaces/","text":"Namespaces Updated on 2022-05-30 at 14:56:44 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/cpf_control/Namespaces/#namespaces","text":"Updated on 2022-05-30 at 14:56:44 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/","text":"Classes class Aguiar Path following using Aguiar 's algorithm for path following Method6: based on the work of Aguiar and Hespanha (2007) This algorithm support: Controls: class Brevik Path following using Brevik 's algorithm for path following Method4: based on the work of Brevik and Fossen (2005) This algorithm support: Controls: class Fossen Path following using Fossen 's algorithm for path following Method3: based on the work of Fossen(2015) class Lapierre Path following using Lapierre 's algorithm for path following Method2: developed from the work of Lionel Lapierre and Antonio(2003) class Marcelo Path following using Aguiar 's algorithm for path following Method6: based on the work of Aguiar and Hespanha (2007) This algorithm support: Controls: struct PFollowingDebug class PathFollowing A Base class to update the path following law. class PathFollowingNode Path Following Node, where the magic happens. struct PathState A structure to hold the data of the path. class Pramod Path following using Pramod 's algorithm for path following*. class RelativeHeading Path following using RelativeHeading 's algorithm for path following*. class Romulo Path following using Aguiar 's algorithm modified to also control sway instead of yaw_rate (by Romulo ) class Samson Path following using Lapierre 's algorithm for path following Method1: based on the work of Samson (1993) struct VehicleState A structure to hold the state of the vehicle. Updated on 2022-05-30 at 14:56:47 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/#classes","text":"class Aguiar Path following using Aguiar 's algorithm for path following Method6: based on the work of Aguiar and Hespanha (2007) This algorithm support: Controls: class Brevik Path following using Brevik 's algorithm for path following Method4: based on the work of Brevik and Fossen (2005) This algorithm support: Controls: class Fossen Path following using Fossen 's algorithm for path following Method3: based on the work of Fossen(2015) class Lapierre Path following using Lapierre 's algorithm for path following Method2: developed from the work of Lionel Lapierre and Antonio(2003) class Marcelo Path following using Aguiar 's algorithm for path following Method6: based on the work of Aguiar and Hespanha (2007) This algorithm support: Controls: struct PFollowingDebug class PathFollowing A Base class to update the path following law. class PathFollowingNode Path Following Node, where the magic happens. struct PathState A structure to hold the data of the path. class Pramod Path following using Pramod 's algorithm for path following*. class RelativeHeading Path following using RelativeHeading 's algorithm for path following*. class Romulo Path following using Aguiar 's algorithm modified to also control sway instead of yaw_rate (by Romulo ) class Samson Path following using Lapierre 's algorithm for path following Method1: based on the work of Samson (1993) struct VehicleState A structure to hold the state of the vehicle. Updated on 2022-05-30 at 14:56:47 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classAguiar/","text":"title: Aguiar summary: Path following using Aguiar's algorithm for path following Method6: based on the work of Aguiar and Hespanha (2007) This algorithm support: Controls: Aguiar Path following using Aguiar 's algorithm for path following Method6: based on the work of Aguiar and Hespanha (2007) This algorithm support: Controls: More... #include <Aguiar.h> Inherits from PathFollowing Public Functions Name Aguiar (double delta, double kk[2], double kz, double k_pos, double k_currents, ros::Publisher surge_pub, ros::Publisher yaw_rate_pub, ros::Publisher rabbit_pub) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method to update the gains, given a vector of doubles. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish_private the data from the path following. virtual void start () override Method used in the first run to do initial setup. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once. virtual bool resetVirtualTarget (float value) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Additional inherited members Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_ Detailed Description class Aguiar; Path following using Aguiar 's algorithm for path following Method6: based on the work of Aguiar and Hespanha (2007) This algorithm support: Controls: Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT yaw-rate surge virtual-target (gamma) Supports Cooperative Path Following - True Contains Currents Observers - True Public Functions Documentation function Aguiar Aguiar( double delta, double kk[2], double kz, double k_pos, double k_currents, ros::Publisher surge_pub, ros::Publisher yaw_rate_pub, ros::Publisher rabbit_pub ) Constructor method for the Path Following class. Parameters : delta Control gain kk Control gains kz Control gain k_pos Observer gain k_currents Observer gain surge_pub The ROS surge publisher yaw_rate_pub The ROS yaw rate publisher rabbit_pub The ROS rabbit publisher function setPFGains virtual bool setPFGains( std::vector< double > gains ) override Method to update the gains, given a vector of doubles. Parameters : gains A vector of gains to update in the controller The default order is: delta, kk[0], kk[1], kz, k_pos, k_currents Return : a boolean which represents the success of the operation Reimplements : PathFollowing::setPFGains function callPFController virtual void callPFController( double dt ) override Method that implements the path following control law. Parameters : dt The time step between last call and current call (in seconds) Reimplements : PathFollowing::callPFController function publish_private virtual void publish_private() override Method to publish_private the data from the path following. Reimplements : PathFollowing::publish_private function start virtual void start() override Method used in the first run to do initial setup. Reimplements : PathFollowing::start function stop virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : The success of the operation Reimplements : PathFollowing::stop Check if the gamma is greater then the gamma max of the path If so, we have reached the end function reset virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset function resetVirtualTarget virtual bool resetVirtualTarget( float value ) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Return : Whether the reset was made successfully or not Reimplements : PathFollowing::resetVirtualTarget Updated on 2022-05-30 at 14:56:47 +0000","title":"classAguiar"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classAguiar/#aguiar","text":"Path following using Aguiar 's algorithm for path following Method6: based on the work of Aguiar and Hespanha (2007) This algorithm support: Controls: More... #include <Aguiar.h> Inherits from PathFollowing","title":"Aguiar"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classAguiar/#public-functions","text":"Name Aguiar (double delta, double kk[2], double kz, double k_pos, double k_currents, ros::Publisher surge_pub, ros::Publisher yaw_rate_pub, ros::Publisher rabbit_pub) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method to update the gains, given a vector of doubles. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish_private the data from the path following. virtual void start () override Method used in the first run to do initial setup. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once. virtual bool resetVirtualTarget (float value) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classAguiar/#additional-inherited-members","text":"Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classAguiar/#detailed-description","text":"class Aguiar; Path following using Aguiar 's algorithm for path following Method6: based on the work of Aguiar and Hespanha (2007) This algorithm support: Controls: Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT yaw-rate surge virtual-target (gamma) Supports Cooperative Path Following - True Contains Currents Observers - True","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classAguiar/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classAguiar/#function-aguiar","text":"Aguiar( double delta, double kk[2], double kz, double k_pos, double k_currents, ros::Publisher surge_pub, ros::Publisher yaw_rate_pub, ros::Publisher rabbit_pub ) Constructor method for the Path Following class. Parameters : delta Control gain kk Control gains kz Control gain k_pos Observer gain k_currents Observer gain surge_pub The ROS surge publisher yaw_rate_pub The ROS yaw rate publisher rabbit_pub The ROS rabbit publisher","title":"function Aguiar"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classAguiar/#function-setpfgains","text":"virtual bool setPFGains( std::vector< double > gains ) override Method to update the gains, given a vector of doubles. Parameters : gains A vector of gains to update in the controller The default order is: delta, kk[0], kk[1], kz, k_pos, k_currents Return : a boolean which represents the success of the operation Reimplements : PathFollowing::setPFGains","title":"function setPFGains"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classAguiar/#function-callpfcontroller","text":"virtual void callPFController( double dt ) override Method that implements the path following control law. Parameters : dt The time step between last call and current call (in seconds) Reimplements : PathFollowing::callPFController","title":"function callPFController"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classAguiar/#function-publish_private","text":"virtual void publish_private() override Method to publish_private the data from the path following. Reimplements : PathFollowing::publish_private","title":"function publish_private"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classAguiar/#function-start","text":"virtual void start() override Method used in the first run to do initial setup. Reimplements : PathFollowing::start","title":"function start"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classAguiar/#function-stop","text":"virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : The success of the operation Reimplements : PathFollowing::stop Check if the gamma is greater then the gamma max of the path If so, we have reached the end","title":"function stop"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classAguiar/#function-reset","text":"virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset","title":"function reset"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classAguiar/#function-resetvirtualtarget","text":"virtual bool resetVirtualTarget( float value ) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Return : Whether the reset was made successfully or not Reimplements : PathFollowing::resetVirtualTarget Updated on 2022-05-30 at 14:56:47 +0000","title":"function resetVirtualTarget"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classBrevik/","text":"title: Brevik summary: Path following using Brevik's algorithm for path following Method4: based on the work of Brevik and Fossen (2005) This algorithm support: Controls: Brevik Path following using Brevik 's algorithm for path following Method4: based on the work of Brevik and Fossen (2005) This algorithm support: Controls: More... #include <Brevik.h> Inherits from PathFollowing Public Functions Name Brevik (ros::Publisher surge_pub, ros::Publisher yaw_pub, ros::Publisher rabbit_pub) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method to update the gains, given a vector of doubles. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish the data from the path following. virtual void start () override Method used in the first run to do initial setup. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once. virtual bool resetVirtualTarget (float value) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Additional inherited members Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_ Detailed Description class Brevik; Path following using Brevik 's algorithm for path following Method4: based on the work of Brevik and Fossen (2005) This algorithm support: Controls: Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT yaw surge virtual-target (gamma) Supports Cooperative Path Following - True Contains Currents Observers - False Public Functions Documentation function Brevik Brevik( ros::Publisher surge_pub, ros::Publisher yaw_pub, ros::Publisher rabbit_pub ) Constructor method for the Path Following class. Parameters : surge_pub The ROS surge publisher yaw_pub The ROS yaw publisher rabbit_pub The ROS rabbit publisher function setPFGains virtual bool setPFGains( std::vector< double > gains ) override Method to update the gains, given a vector of doubles. Parameters : gains The gains for the controller Return : By default just returns false for this algorithm Reimplements : PathFollowing::setPFGains NOTE: In this class the setPFGains method does nothing to the controller as all the gains are fixed function callPFController virtual void callPFController( double dt ) override Method that implements the path following control law. Parameters : dt The time difference between last call and current call (in seconds) Reimplements : PathFollowing::callPFController function publish_private virtual void publish_private() override Method to publish the data from the path following. Reimplements : PathFollowing::publish_private function start virtual void start() override Method used in the first run to do initial setup. Reimplements : PathFollowing::start function stop virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : The success of the operation Reimplements : PathFollowing::stop Check if the gamma is greater then the gamma max of the path If so, we have reached the end function reset virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset function resetVirtualTarget virtual bool resetVirtualTarget( float value ) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Return : Whether the reset was made successfully or not Reimplements : PathFollowing::resetVirtualTarget Updated on 2022-05-30 at 14:56:47 +0000","title":"classBrevik"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classBrevik/#brevik","text":"Path following using Brevik 's algorithm for path following Method4: based on the work of Brevik and Fossen (2005) This algorithm support: Controls: More... #include <Brevik.h> Inherits from PathFollowing","title":"Brevik"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classBrevik/#public-functions","text":"Name Brevik (ros::Publisher surge_pub, ros::Publisher yaw_pub, ros::Publisher rabbit_pub) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method to update the gains, given a vector of doubles. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish the data from the path following. virtual void start () override Method used in the first run to do initial setup. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once. virtual bool resetVirtualTarget (float value) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classBrevik/#additional-inherited-members","text":"Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classBrevik/#detailed-description","text":"class Brevik; Path following using Brevik 's algorithm for path following Method4: based on the work of Brevik and Fossen (2005) This algorithm support: Controls: Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT yaw surge virtual-target (gamma) Supports Cooperative Path Following - True Contains Currents Observers - False","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classBrevik/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classBrevik/#function-brevik","text":"Brevik( ros::Publisher surge_pub, ros::Publisher yaw_pub, ros::Publisher rabbit_pub ) Constructor method for the Path Following class. Parameters : surge_pub The ROS surge publisher yaw_pub The ROS yaw publisher rabbit_pub The ROS rabbit publisher","title":"function Brevik"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classBrevik/#function-setpfgains","text":"virtual bool setPFGains( std::vector< double > gains ) override Method to update the gains, given a vector of doubles. Parameters : gains The gains for the controller Return : By default just returns false for this algorithm Reimplements : PathFollowing::setPFGains NOTE: In this class the setPFGains method does nothing to the controller as all the gains are fixed","title":"function setPFGains"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classBrevik/#function-callpfcontroller","text":"virtual void callPFController( double dt ) override Method that implements the path following control law. Parameters : dt The time difference between last call and current call (in seconds) Reimplements : PathFollowing::callPFController","title":"function callPFController"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classBrevik/#function-publish_private","text":"virtual void publish_private() override Method to publish the data from the path following. Reimplements : PathFollowing::publish_private","title":"function publish_private"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classBrevik/#function-start","text":"virtual void start() override Method used in the first run to do initial setup. Reimplements : PathFollowing::start","title":"function start"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classBrevik/#function-stop","text":"virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : The success of the operation Reimplements : PathFollowing::stop Check if the gamma is greater then the gamma max of the path If so, we have reached the end","title":"function stop"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classBrevik/#function-reset","text":"virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset","title":"function reset"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classBrevik/#function-resetvirtualtarget","text":"virtual bool resetVirtualTarget( float value ) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Return : Whether the reset was made successfully or not Reimplements : PathFollowing::resetVirtualTarget Updated on 2022-05-30 at 14:56:47 +0000","title":"function resetVirtualTarget"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classFossen/","text":"title: Fossen summary: Path following using Fossen's algorithm for path following Method3: based on the work of Fossen(2015) Fossen Path following using Fossen 's algorithm for path following Method3: based on the work of Fossen(2015) More... #include <Fossen.h> Inherits from PathFollowing Public Functions Name Fossen (ros::Publisher surge_pub, ros::Publisher yaw_pub, ros::ServiceClient mode_client) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method that given an array of doubles, updates the gains of the controller. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish the data from the path following. virtual void start () override Method used to start the algorithm in the first run. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once. Additional inherited members Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. virtual bool resetVirtualTarget (float value) Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) bool resetVirtualTarget () Method to reset the virtual target of the vehicle (gamma) to zero. Not all controllers need this (example: Samson , Fossen which use the closest point) void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_ Detailed Description class Fossen; Path following using Fossen 's algorithm for path following Method3: based on the work of Fossen(2015) Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This algorithm support: Controls: yaw surge Supports Cooperative Path Following - True Contains Currents Observers - False Public Functions Documentation function Fossen Fossen( ros::Publisher surge_pub, ros::Publisher yaw_pub, ros::ServiceClient mode_client ) Constructor method for the Path Following class. Parameters : surge_pub The ROS surge publisher yaw_pub The ROS yaw publisher mode_client The ROS client for the path (to change the mode of operation to closest point) function setPFGains virtual bool setPFGains( std::vector< double > gains ) override Method that given an array of doubles, updates the gains of the controller. Parameters : gains The gains of the controller Return : By default just returns false for this algorithm Reimplements : PathFollowing::setPFGains NOTE: In this controller this method does nothing, as there are no gains to tweak. They are all fixed function callPFController virtual void callPFController( double dt ) override Method that implements the path following control law. Parameters : dt The time diference between last call and current call (in seconds) dt The time difference in seconds Reimplements : PathFollowing::callPFController Method that implements the path Following algorihtm. function publish_private virtual void publish_private() override Method to publish the data from the path following. Reimplements : PathFollowing::publish_private function start virtual void start() override Method used to start the algorithm in the first run. Return : the success of the operation Reimplements : PathFollowing::start function stop virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : the success of the operation Reimplements : PathFollowing::stop function reset virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset Updated on 2022-05-30 at 14:56:47 +0000","title":"classFossen"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classFossen/#fossen","text":"Path following using Fossen 's algorithm for path following Method3: based on the work of Fossen(2015) More... #include <Fossen.h> Inherits from PathFollowing","title":"Fossen"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classFossen/#public-functions","text":"Name Fossen (ros::Publisher surge_pub, ros::Publisher yaw_pub, ros::ServiceClient mode_client) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method that given an array of doubles, updates the gains of the controller. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish the data from the path following. virtual void start () override Method used to start the algorithm in the first run. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classFossen/#additional-inherited-members","text":"Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. virtual bool resetVirtualTarget (float value) Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) bool resetVirtualTarget () Method to reset the virtual target of the vehicle (gamma) to zero. Not all controllers need this (example: Samson , Fossen which use the closest point) void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classFossen/#detailed-description","text":"class Fossen; Path following using Fossen 's algorithm for path following Method3: based on the work of Fossen(2015) Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This algorithm support: Controls: yaw surge Supports Cooperative Path Following - True Contains Currents Observers - False","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classFossen/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classFossen/#function-fossen","text":"Fossen( ros::Publisher surge_pub, ros::Publisher yaw_pub, ros::ServiceClient mode_client ) Constructor method for the Path Following class. Parameters : surge_pub The ROS surge publisher yaw_pub The ROS yaw publisher mode_client The ROS client for the path (to change the mode of operation to closest point)","title":"function Fossen"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classFossen/#function-setpfgains","text":"virtual bool setPFGains( std::vector< double > gains ) override Method that given an array of doubles, updates the gains of the controller. Parameters : gains The gains of the controller Return : By default just returns false for this algorithm Reimplements : PathFollowing::setPFGains NOTE: In this controller this method does nothing, as there are no gains to tweak. They are all fixed","title":"function setPFGains"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classFossen/#function-callpfcontroller","text":"virtual void callPFController( double dt ) override Method that implements the path following control law. Parameters : dt The time diference between last call and current call (in seconds) dt The time difference in seconds Reimplements : PathFollowing::callPFController Method that implements the path Following algorihtm.","title":"function callPFController"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classFossen/#function-publish_private","text":"virtual void publish_private() override Method to publish the data from the path following. Reimplements : PathFollowing::publish_private","title":"function publish_private"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classFossen/#function-start","text":"virtual void start() override Method used to start the algorithm in the first run. Return : the success of the operation Reimplements : PathFollowing::start","title":"function start"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classFossen/#function-stop","text":"virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : the success of the operation Reimplements : PathFollowing::stop","title":"function stop"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classFossen/#function-reset","text":"virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset Updated on 2022-05-30 at 14:56:47 +0000","title":"function reset"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classLapierre/","text":"title: Lapierre summary: Path following using Lapierre's algorithm for path following Method2: developed from the work of Lionel Lapierre and Antonio(2003) Lapierre Path following using Lapierre 's algorithm for path following Method2: developed from the work of Lionel Lapierre and Antonio(2003) More... #include <Lapierre.h> Inherits from PathFollowing Public Functions Name Lapierre (double k1, double k2, double k3, double theta, double k_delta, ros::Publisher surge_pub, ros::Publisher yaw_rate_pub, ros::Publisher rabbit_pub) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method that given a vector of doubles, updates the gains of the controller. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish the data from the path following. virtual void start () override Method to run in the first iteration of the path following algorithm. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once. virtual bool resetVirtualTarget (float value) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Additional inherited members Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_ Detailed Description class Lapierre; Path following using Lapierre 's algorithm for path following Method2: developed from the work of Lionel Lapierre and Antonio(2003) Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This algorithm support: Controls: yaw-rate surge virtual-target (gamma) Supports Cooperative Path Following - True Contains Currents Observers - False Public Functions Documentation function Lapierre Lapierre( double k1, double k2, double k3, double theta, double k_delta, ros::Publisher surge_pub, ros::Publisher yaw_rate_pub, ros::Publisher rabbit_pub ) Constructor method for the Path Following class. Parameters : k1 Controller gain k2 Controller gain k3 Controller gain theta Controller gain k_delta Controller gain surge_pub The ROS surge publisher yaw_rate_pub The ROS yaw rate publisher rabbit_pub The ROS rabbit publisher function setPFGains virtual bool setPFGains( std::vector< double > gains ) override Method that given a vector of doubles, updates the gains of the controller. Parameters : gains A vector of gains Return : a boolean which represents the success of the operation Reimplements : PathFollowing::setPFGains NOTE: The default order of the gains is k1, k2, k3, theta, k_delta function callPFController virtual void callPFController( double dt ) override Method that implements the path following control law. Parameters : dt The time diference between the last and current call (in seconds) Reimplements : PathFollowing::callPFController function publish_private virtual void publish_private() override Method to publish the data from the path following. Reimplements : PathFollowing::publish_private function start virtual void start() override Method to run in the first iteration of the path following algorithm. Reimplements : PathFollowing::start function stop virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : the success of the operation Reimplements : PathFollowing::stop Check if the gamma is greater then the gamma max of the path If so, we have reached the end function reset virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset function resetVirtualTarget virtual bool resetVirtualTarget( float value ) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Return : Whether the reset was made successfully or not Reimplements : PathFollowing::resetVirtualTarget Updated on 2022-05-30 at 14:56:47 +0000","title":"classLapierre"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classLapierre/#lapierre","text":"Path following using Lapierre 's algorithm for path following Method2: developed from the work of Lionel Lapierre and Antonio(2003) More... #include <Lapierre.h> Inherits from PathFollowing","title":"Lapierre"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classLapierre/#public-functions","text":"Name Lapierre (double k1, double k2, double k3, double theta, double k_delta, ros::Publisher surge_pub, ros::Publisher yaw_rate_pub, ros::Publisher rabbit_pub) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method that given a vector of doubles, updates the gains of the controller. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish the data from the path following. virtual void start () override Method to run in the first iteration of the path following algorithm. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once. virtual bool resetVirtualTarget (float value) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classLapierre/#additional-inherited-members","text":"Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classLapierre/#detailed-description","text":"class Lapierre; Path following using Lapierre 's algorithm for path following Method2: developed from the work of Lionel Lapierre and Antonio(2003) Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This algorithm support: Controls: yaw-rate surge virtual-target (gamma) Supports Cooperative Path Following - True Contains Currents Observers - False","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classLapierre/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classLapierre/#function-lapierre","text":"Lapierre( double k1, double k2, double k3, double theta, double k_delta, ros::Publisher surge_pub, ros::Publisher yaw_rate_pub, ros::Publisher rabbit_pub ) Constructor method for the Path Following class. Parameters : k1 Controller gain k2 Controller gain k3 Controller gain theta Controller gain k_delta Controller gain surge_pub The ROS surge publisher yaw_rate_pub The ROS yaw rate publisher rabbit_pub The ROS rabbit publisher","title":"function Lapierre"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classLapierre/#function-setpfgains","text":"virtual bool setPFGains( std::vector< double > gains ) override Method that given a vector of doubles, updates the gains of the controller. Parameters : gains A vector of gains Return : a boolean which represents the success of the operation Reimplements : PathFollowing::setPFGains NOTE: The default order of the gains is k1, k2, k3, theta, k_delta","title":"function setPFGains"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classLapierre/#function-callpfcontroller","text":"virtual void callPFController( double dt ) override Method that implements the path following control law. Parameters : dt The time diference between the last and current call (in seconds) Reimplements : PathFollowing::callPFController","title":"function callPFController"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classLapierre/#function-publish_private","text":"virtual void publish_private() override Method to publish the data from the path following. Reimplements : PathFollowing::publish_private","title":"function publish_private"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classLapierre/#function-start","text":"virtual void start() override Method to run in the first iteration of the path following algorithm. Reimplements : PathFollowing::start","title":"function start"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classLapierre/#function-stop","text":"virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : the success of the operation Reimplements : PathFollowing::stop Check if the gamma is greater then the gamma max of the path If so, we have reached the end","title":"function stop"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classLapierre/#function-reset","text":"virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset","title":"function reset"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classLapierre/#function-resetvirtualtarget","text":"virtual bool resetVirtualTarget( float value ) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Return : Whether the reset was made successfully or not Reimplements : PathFollowing::resetVirtualTarget Updated on 2022-05-30 at 14:56:47 +0000","title":"function resetVirtualTarget"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classMarcelo/","text":"title: Marcelo summary: Path following using Aguiar's algorithm for path following Method6: based on the work of Aguiar and Hespanha (2007) This algorithm support: Controls: Marcelo Path following using Aguiar 's algorithm for path following Method6: based on the work of Aguiar and Hespanha (2007) This algorithm support: Controls: More... #include <Marcelo.h> Inherits from PathFollowing Public Functions Name Marcelo (double delta, double kk[2], double kz, double k_pos, double k_currents, double rd[3], double d[3], ros::Publisher surge_pub, ros::Publisher yaw_rate_pub, ros::Publisher rabbit_pub, ros::Publisher currents_estimation_x_pub, ros::Publisher currents_estimation_y_pub) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method to update the gains, given a vector of doubles. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish_private the data from the path following. virtual void start () override Method used in the first run to do initial setup. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once. virtual bool resetVirtualTarget (float value) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Additional inherited members Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_ Detailed Description class Marcelo; Path following using Aguiar 's algorithm for path following Method6: based on the work of Aguiar and Hespanha (2007) This algorithm support: Controls: Author : Marcelo Jacinto Version : 1.0a Date : 2021 Copyright : MIT yaw-rate surge virtual-target (gamma) Supports Cooperative Path Following - True Contains Currents Observers - True Public Functions Documentation function Marcelo Marcelo( double delta, double kk[2], double kz, double k_pos, double k_currents, double rd[3], double d[3], ros::Publisher surge_pub, ros::Publisher yaw_rate_pub, ros::Publisher rabbit_pub, ros::Publisher currents_estimation_x_pub, ros::Publisher currents_estimation_y_pub ) Constructor method for the Path Following class. Parameters : delta Control gain kk Control gains kz Control gain k_pos Observer gain k_currents Observer gain surge_pub The ROS surge publisher yaw_rate_pub The ROS yaw rate publisher rabbit_pub The ROS rabbit publisher function setPFGains virtual bool setPFGains( std::vector< double > gains ) override Method to update the gains, given a vector of doubles. Parameters : gains A vector of gains to update in the controller The default order is: delta, kk[0], kk[1], kz, k_pos, k_currents Return : a boolean which represents the success of the operation Reimplements : PathFollowing::setPFGains function callPFController virtual void callPFController( double dt ) override Method that implements the path following control law. Parameters : dt The time step between last call and current call (in seconds) Reimplements : PathFollowing::callPFController function publish_private virtual void publish_private() override Method to publish_private the data from the path following. Reimplements : PathFollowing::publish_private function start virtual void start() override Method used in the first run to do initial setup. Reimplements : PathFollowing::start function stop virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : The success of the operation Reimplements : PathFollowing::stop Check if the gamma is greater then the gamma max of the path If so, we have reached the end function reset virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset function resetVirtualTarget virtual bool resetVirtualTarget( float value ) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Return : Whether the reset was made successfully or not Reimplements : PathFollowing::resetVirtualTarget Updated on 2022-05-30 at 14:56:47 +0000","title":"classMarcelo"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classMarcelo/#marcelo","text":"Path following using Aguiar 's algorithm for path following Method6: based on the work of Aguiar and Hespanha (2007) This algorithm support: Controls: More... #include <Marcelo.h> Inherits from PathFollowing","title":"Marcelo"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classMarcelo/#public-functions","text":"Name Marcelo (double delta, double kk[2], double kz, double k_pos, double k_currents, double rd[3], double d[3], ros::Publisher surge_pub, ros::Publisher yaw_rate_pub, ros::Publisher rabbit_pub, ros::Publisher currents_estimation_x_pub, ros::Publisher currents_estimation_y_pub) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method to update the gains, given a vector of doubles. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish_private the data from the path following. virtual void start () override Method used in the first run to do initial setup. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once. virtual bool resetVirtualTarget (float value) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classMarcelo/#additional-inherited-members","text":"Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classMarcelo/#detailed-description","text":"class Marcelo; Path following using Aguiar 's algorithm for path following Method6: based on the work of Aguiar and Hespanha (2007) This algorithm support: Controls: Author : Marcelo Jacinto Version : 1.0a Date : 2021 Copyright : MIT yaw-rate surge virtual-target (gamma) Supports Cooperative Path Following - True Contains Currents Observers - True","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classMarcelo/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classMarcelo/#function-marcelo","text":"Marcelo( double delta, double kk[2], double kz, double k_pos, double k_currents, double rd[3], double d[3], ros::Publisher surge_pub, ros::Publisher yaw_rate_pub, ros::Publisher rabbit_pub, ros::Publisher currents_estimation_x_pub, ros::Publisher currents_estimation_y_pub ) Constructor method for the Path Following class. Parameters : delta Control gain kk Control gains kz Control gain k_pos Observer gain k_currents Observer gain surge_pub The ROS surge publisher yaw_rate_pub The ROS yaw rate publisher rabbit_pub The ROS rabbit publisher","title":"function Marcelo"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classMarcelo/#function-setpfgains","text":"virtual bool setPFGains( std::vector< double > gains ) override Method to update the gains, given a vector of doubles. Parameters : gains A vector of gains to update in the controller The default order is: delta, kk[0], kk[1], kz, k_pos, k_currents Return : a boolean which represents the success of the operation Reimplements : PathFollowing::setPFGains","title":"function setPFGains"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classMarcelo/#function-callpfcontroller","text":"virtual void callPFController( double dt ) override Method that implements the path following control law. Parameters : dt The time step between last call and current call (in seconds) Reimplements : PathFollowing::callPFController","title":"function callPFController"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classMarcelo/#function-publish_private","text":"virtual void publish_private() override Method to publish_private the data from the path following. Reimplements : PathFollowing::publish_private","title":"function publish_private"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classMarcelo/#function-start","text":"virtual void start() override Method used in the first run to do initial setup. Reimplements : PathFollowing::start","title":"function start"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classMarcelo/#function-stop","text":"virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : The success of the operation Reimplements : PathFollowing::stop Check if the gamma is greater then the gamma max of the path If so, we have reached the end","title":"function stop"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classMarcelo/#function-reset","text":"virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset","title":"function reset"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classMarcelo/#function-resetvirtualtarget","text":"virtual bool resetVirtualTarget( float value ) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Return : Whether the reset was made successfully or not Reimplements : PathFollowing::resetVirtualTarget Updated on 2022-05-30 at 14:56:47 +0000","title":"function resetVirtualTarget"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/","text":"PathFollowing A Base class to update the path following law. More... #include <PathFollowing.h> Inherited by Aguiar , Brevik , Fossen , Lapierre , Marcelo , Pramod , RelativeHeading , Romulo , Samson Public Functions Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. virtual void callPFController (double dt) =0 Method to update the path following control law. void publish () Method to publish the data given by the algorithm. virtual void publish_private () =0 virtual void start () =0 Method used to setup the algorithm in the first iteration. virtual bool stop () =0 Method used to check whether we have reached the end of the path following algorithm or not. This method will be called in every iteration of the algorithm, and when it return true, the algorithm will stop. virtual bool reset () =0 Method used to reset the algorithm control parameters when running the algorithm more than once. virtual bool resetVirtualTarget (float value) Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) bool resetVirtualTarget () Method to reset the virtual target of the vehicle (gamma) to zero. Not all controllers need this (example: Samson , Fossen which use the closest point) virtual bool setPFGains (std::vector< double > gains) =0 Receives a vector of gains that should be mapped to the specific controller gains. void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_ Detailed Description class PathFollowing; A Base class to update the path following law. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT Public Functions Documentation function ~PathFollowing virtual ~PathFollowing() Virtual destructor for the abstract pathfollowing class. function callPFController virtual void callPFController( double dt ) =0 Method to update the path following control law. Parameters : dt The time diference between the current and previous call (in seconds) Reimplemented by : Pramod::callPFController , RelativeHeading::callPFController , Romulo::callPFController , Fossen::callPFController , Brevik::callPFController , Marcelo::callPFController , Samson::callPFController , Lapierre::callPFController , Aguiar::callPFController function publish void publish() Method to publish the data given by the algorithm. function publish_private virtual void publish_private() =0 Reimplemented by : Pramod::publish_private , RelativeHeading::publish_private , Romulo::publish_private , Fossen::publish_private , Brevik::publish_private , Marcelo::publish_private , Samson::publish_private , Lapierre::publish_private , Aguiar::publish_private function start virtual void start() =0 Method used to setup the algorithm in the first iteration. Reimplemented by : Pramod::start , RelativeHeading::start , Romulo::start , Brevik::start , Marcelo::start , Samson::start , Fossen::start , Lapierre::start , Aguiar::start function stop virtual bool stop() =0 Method used to check whether we have reached the end of the path following algorithm or not. This method will be called in every iteration of the algorithm, and when it return true, the algorithm will stop. Return : A boolean that represents whether we have reached the end Reimplemented by : Pramod::stop , RelativeHeading::stop , Romulo::stop , Brevik::stop , Marcelo::stop , Samson::stop , Fossen::stop , Lapierre::stop , Aguiar::stop function reset virtual bool reset() =0 Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplemented by : Pramod::reset , RelativeHeading::reset , Romulo::reset , Brevik::reset , Marcelo::reset , Samson::reset , Fossen::reset , Lapierre::reset , Aguiar::reset function resetVirtualTarget virtual bool resetVirtualTarget( float value ) Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Return : Whether the reset was made successfully or not Reimplemented by : RelativeHeading::resetVirtualTarget , Romulo::resetVirtualTarget , Brevik::resetVirtualTarget , Marcelo::resetVirtualTarget , Lapierre::resetVirtualTarget , Aguiar::resetVirtualTarget function resetVirtualTarget bool resetVirtualTarget() Method to reset the virtual target of the vehicle (gamma) to zero. Not all controllers need this (example: Samson , Fossen which use the closest point) Return : Whether the reset was made successfully or not This method calls the resetVirtualTarget(float value) method which can be overriden by each pf controller function setPFGains virtual bool setPFGains( std::vector< double > gains ) =0 Receives a vector of gains that should be mapped to the specific controller gains. Parameters : gains A vector of gains for the controller Reimplemented by : Pramod::setPFGains , RelativeHeading::setPFGains , Romulo::setPFGains , Fossen::setPFGains , Brevik::setPFGains , Marcelo::setPFGains , Samson::setPFGains , Lapierre::setPFGains , Aguiar::setPFGains This method must be implemented by each Path Following class function UpdateVehicleState void UpdateVehicleState( const VehicleState & vehicle_state ) Method to update the vehicle state used by the controller. Parameters : vehicle_state A structure with the current state of the vehicle function UpdatePathState void UpdatePathState( const PathState & path_state ) Method to update the path state used by the controller. Parameters : path_state A structure with the current state of the path function setPFollowingDebugPublisher inline void setPFollowingDebugPublisher( const ros::Publisher & pfollowing_debug_pub ) Method to set common publishers. Protected Functions Documentation function algConvert double algConvert( double alg_new, double alg_old, double alg_out_old ) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes Documentation variable vehicle_state_ VehicleState vehicle_state_; Variable to store the state of the vehicle. variable path_state_ PathState path_state_; Variable to store the state of the path. variable pfollowing_debug_ PFollowingDebug pfollowing_debug_; Variable to store the state of the path. variable pfollowing_debug_pub_ ros::Publisher pfollowing_debug_pub_; Updated on 2022-05-30 at 14:56:47 +0000","title":"PathFollowing"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#pathfollowing","text":"A Base class to update the path following law. More... #include <PathFollowing.h> Inherited by Aguiar , Brevik , Fossen , Lapierre , Marcelo , Pramod , RelativeHeading , Romulo , Samson","title":"PathFollowing"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#public-functions","text":"Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. virtual void callPFController (double dt) =0 Method to update the path following control law. void publish () Method to publish the data given by the algorithm. virtual void publish_private () =0 virtual void start () =0 Method used to setup the algorithm in the first iteration. virtual bool stop () =0 Method used to check whether we have reached the end of the path following algorithm or not. This method will be called in every iteration of the algorithm, and when it return true, the algorithm will stop. virtual bool reset () =0 Method used to reset the algorithm control parameters when running the algorithm more than once. virtual bool resetVirtualTarget (float value) Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) bool resetVirtualTarget () Method to reset the virtual target of the vehicle (gamma) to zero. Not all controllers need this (example: Samson , Fossen which use the closest point) virtual bool setPFGains (std::vector< double > gains) =0 Receives a vector of gains that should be mapped to the specific controller gains. void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#protected-functions","text":"Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms.","title":"Protected Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#protected-attributes","text":"Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_","title":"Protected Attributes"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#detailed-description","text":"class PathFollowing; A Base class to update the path following law. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#function-pathfollowing","text":"virtual ~PathFollowing() Virtual destructor for the abstract pathfollowing class.","title":"function ~PathFollowing"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#function-callpfcontroller","text":"virtual void callPFController( double dt ) =0 Method to update the path following control law. Parameters : dt The time diference between the current and previous call (in seconds) Reimplemented by : Pramod::callPFController , RelativeHeading::callPFController , Romulo::callPFController , Fossen::callPFController , Brevik::callPFController , Marcelo::callPFController , Samson::callPFController , Lapierre::callPFController , Aguiar::callPFController","title":"function callPFController"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#function-publish","text":"void publish() Method to publish the data given by the algorithm.","title":"function publish"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#function-publish_private","text":"virtual void publish_private() =0 Reimplemented by : Pramod::publish_private , RelativeHeading::publish_private , Romulo::publish_private , Fossen::publish_private , Brevik::publish_private , Marcelo::publish_private , Samson::publish_private , Lapierre::publish_private , Aguiar::publish_private","title":"function publish_private"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#function-start","text":"virtual void start() =0 Method used to setup the algorithm in the first iteration. Reimplemented by : Pramod::start , RelativeHeading::start , Romulo::start , Brevik::start , Marcelo::start , Samson::start , Fossen::start , Lapierre::start , Aguiar::start","title":"function start"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#function-stop","text":"virtual bool stop() =0 Method used to check whether we have reached the end of the path following algorithm or not. This method will be called in every iteration of the algorithm, and when it return true, the algorithm will stop. Return : A boolean that represents whether we have reached the end Reimplemented by : Pramod::stop , RelativeHeading::stop , Romulo::stop , Brevik::stop , Marcelo::stop , Samson::stop , Fossen::stop , Lapierre::stop , Aguiar::stop","title":"function stop"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#function-reset","text":"virtual bool reset() =0 Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplemented by : Pramod::reset , RelativeHeading::reset , Romulo::reset , Brevik::reset , Marcelo::reset , Samson::reset , Fossen::reset , Lapierre::reset , Aguiar::reset","title":"function reset"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#function-resetvirtualtarget","text":"virtual bool resetVirtualTarget( float value ) Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Return : Whether the reset was made successfully or not Reimplemented by : RelativeHeading::resetVirtualTarget , Romulo::resetVirtualTarget , Brevik::resetVirtualTarget , Marcelo::resetVirtualTarget , Lapierre::resetVirtualTarget , Aguiar::resetVirtualTarget","title":"function resetVirtualTarget"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#function-resetvirtualtarget_1","text":"bool resetVirtualTarget() Method to reset the virtual target of the vehicle (gamma) to zero. Not all controllers need this (example: Samson , Fossen which use the closest point) Return : Whether the reset was made successfully or not This method calls the resetVirtualTarget(float value) method which can be overriden by each pf controller","title":"function resetVirtualTarget"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#function-setpfgains","text":"virtual bool setPFGains( std::vector< double > gains ) =0 Receives a vector of gains that should be mapped to the specific controller gains. Parameters : gains A vector of gains for the controller Reimplemented by : Pramod::setPFGains , RelativeHeading::setPFGains , Romulo::setPFGains , Fossen::setPFGains , Brevik::setPFGains , Marcelo::setPFGains , Samson::setPFGains , Lapierre::setPFGains , Aguiar::setPFGains This method must be implemented by each Path Following class","title":"function setPFGains"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#function-updatevehiclestate","text":"void UpdateVehicleState( const VehicleState & vehicle_state ) Method to update the vehicle state used by the controller. Parameters : vehicle_state A structure with the current state of the vehicle","title":"function UpdateVehicleState"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#function-updatepathstate","text":"void UpdatePathState( const PathState & path_state ) Method to update the path state used by the controller. Parameters : path_state A structure with the current state of the path","title":"function UpdatePathState"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#function-setpfollowingdebugpublisher","text":"inline void setPFollowingDebugPublisher( const ros::Publisher & pfollowing_debug_pub ) Method to set common publishers.","title":"function setPFollowingDebugPublisher"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#function-algconvert","text":"double algConvert( double alg_new, double alg_old, double alg_out_old ) Auxiliar method to smooth out the angle to be used by path following algorithms.","title":"function algConvert"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#variable-vehicle_state_","text":"VehicleState vehicle_state_; Variable to store the state of the vehicle.","title":"variable vehicle_state_"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#variable-path_state_","text":"PathState path_state_; Variable to store the state of the path.","title":"variable path_state_"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#variable-pfollowing_debug_","text":"PFollowingDebug pfollowing_debug_; Variable to store the state of the path.","title":"variable pfollowing_debug_"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowing/#variable-pfollowing_debug_pub_","text":"ros::Publisher pfollowing_debug_pub_; Updated on 2022-05-30 at 14:56:47 +0000","title":"variable pfollowing_debug_pub_"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowingNode/","text":"PathFollowingNode Path Following Node, where the magic happens. More... #include <PathFollowingNode.h> Public Functions Name PathFollowingNode (ros::NodeHandle * nh, ros::NodeHandle * nh_p) The constructor of the path following node. ~PathFollowingNode () The destructor of the path following node (where the subscribers, publishers and services are terminated) Detailed Description class PathFollowingNode; Path Following Node, where the magic happens. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT Public Functions Documentation function PathFollowingNode PathFollowingNode( ros::NodeHandle * nh, ros::NodeHandle * nh_p ) The constructor of the path following node. Parameters : nh The public ROS node handle nh_p The private ROS node handle nh Public ros node handle nh_p Private ros node handle The Path Following Node constructor. function ~PathFollowingNode ~PathFollowingNode() The destructor of the path following node (where the subscribers, publishers and services are terminated) Node class destructor. Updated on 2022-05-30 at 14:56:47 +0000","title":"PathFollowingNode"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowingNode/#pathfollowingnode","text":"Path Following Node, where the magic happens. More... #include <PathFollowingNode.h>","title":"PathFollowingNode"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowingNode/#public-functions","text":"Name PathFollowingNode (ros::NodeHandle * nh, ros::NodeHandle * nh_p) The constructor of the path following node. ~PathFollowingNode () The destructor of the path following node (where the subscribers, publishers and services are terminated)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowingNode/#detailed-description","text":"class PathFollowingNode; Path Following Node, where the magic happens. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowingNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowingNode/#function-pathfollowingnode","text":"PathFollowingNode( ros::NodeHandle * nh, ros::NodeHandle * nh_p ) The constructor of the path following node. Parameters : nh The public ROS node handle nh_p The private ROS node handle nh Public ros node handle nh_p Private ros node handle The Path Following Node constructor.","title":"function PathFollowingNode"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPathFollowingNode/#function-pathfollowingnode_1","text":"~PathFollowingNode() The destructor of the path following node (where the subscribers, publishers and services are terminated) Node class destructor. Updated on 2022-05-30 at 14:56:47 +0000","title":"function ~PathFollowingNode"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPramod/","text":"Pramod Path following using Pramod 's algorithm for path following*. More... #include <Pramod.h> Inherits from PathFollowing Public Functions Name Pramod (std::vector< double > gains, ros::Publisher surge_pub, ros::Publisher yaw_pub, ros::ServiceClient mode_client) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method that given an array of doubles, updates the gains of the controller. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish the data from the path following. virtual void start () override Method used to start the algorithm in the first run. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once. Additional inherited members Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. virtual bool resetVirtualTarget (float value) Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) bool resetVirtualTarget () Method to reset the virtual target of the vehicle (gamma) to zero. Not all controllers need this (example: Samson , Fossen which use the closest point) void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_ Detailed Description class Pramod; Path following using Pramod 's algorithm for path following*. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This algorithm support: Controls: yaw surge Supports Cooperative Path Following - True Contains Currents Observers - False Public Functions Documentation function Pramod Pramod( std::vector< double > gains, ros::Publisher surge_pub, ros::Publisher yaw_pub, ros::ServiceClient mode_client ) Constructor method for the Path Following class. Parameters : gains A vector with the gains of the controller (2 gains only - Kp and Kd) surge_pub The ROS surge publisher yaw_pub The ROS yaw publisher mode_client The ROS service client to change the mode of operation of the path (to the closest point) function setPFGains virtual bool setPFGains( std::vector< double > gains ) override Method that given an array of doubles, updates the gains of the controller. Parameters : gains A vector of gains of the controller (only 2 gains Kp and Kd) Return : a boolean which represents the success of the operation Reimplements : PathFollowing::setPFGains function callPFController virtual void callPFController( double dt ) override Method that implements the path following control law. Parameters : dt The time diference between the previous and current call (in seconds) Reimplements : PathFollowing::callPFController function publish_private virtual void publish_private() override Method to publish the data from the path following. Reimplements : PathFollowing::publish_private function start virtual void start() override Method used to start the algorithm in the first run. Reimplements : PathFollowing::start function stop virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : The success of the operation Reimplements : PathFollowing::stop function reset virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset Updated on 2022-05-30 at 14:56:47 +0000","title":"Pramod"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPramod/#pramod","text":"Path following using Pramod 's algorithm for path following*. More... #include <Pramod.h> Inherits from PathFollowing","title":"Pramod"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPramod/#public-functions","text":"Name Pramod (std::vector< double > gains, ros::Publisher surge_pub, ros::Publisher yaw_pub, ros::ServiceClient mode_client) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method that given an array of doubles, updates the gains of the controller. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish the data from the path following. virtual void start () override Method used to start the algorithm in the first run. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPramod/#additional-inherited-members","text":"Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. virtual bool resetVirtualTarget (float value) Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) bool resetVirtualTarget () Method to reset the virtual target of the vehicle (gamma) to zero. Not all controllers need this (example: Samson , Fossen which use the closest point) void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPramod/#detailed-description","text":"class Pramod; Path following using Pramod 's algorithm for path following*. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This algorithm support: Controls: yaw surge Supports Cooperative Path Following - True Contains Currents Observers - False","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPramod/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPramod/#function-pramod","text":"Pramod( std::vector< double > gains, ros::Publisher surge_pub, ros::Publisher yaw_pub, ros::ServiceClient mode_client ) Constructor method for the Path Following class. Parameters : gains A vector with the gains of the controller (2 gains only - Kp and Kd) surge_pub The ROS surge publisher yaw_pub The ROS yaw publisher mode_client The ROS service client to change the mode of operation of the path (to the closest point)","title":"function Pramod"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPramod/#function-setpfgains","text":"virtual bool setPFGains( std::vector< double > gains ) override Method that given an array of doubles, updates the gains of the controller. Parameters : gains A vector of gains of the controller (only 2 gains Kp and Kd) Return : a boolean which represents the success of the operation Reimplements : PathFollowing::setPFGains","title":"function setPFGains"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPramod/#function-callpfcontroller","text":"virtual void callPFController( double dt ) override Method that implements the path following control law. Parameters : dt The time diference between the previous and current call (in seconds) Reimplements : PathFollowing::callPFController","title":"function callPFController"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPramod/#function-publish_private","text":"virtual void publish_private() override Method to publish the data from the path following. Reimplements : PathFollowing::publish_private","title":"function publish_private"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPramod/#function-start","text":"virtual void start() override Method used to start the algorithm in the first run. Reimplements : PathFollowing::start","title":"function start"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPramod/#function-stop","text":"virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : The success of the operation Reimplements : PathFollowing::stop","title":"function stop"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classPramod/#function-reset","text":"virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset Updated on 2022-05-30 at 14:56:47 +0000","title":"function reset"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRelativeHeading/","text":"RelativeHeading Path following using RelativeHeading 's algorithm for path following*. More... #include <RelativeHeading.h> Inherits from PathFollowing Public Functions Name RelativeHeading (double kx, double ky, double kz, const Eigen::Vector2d & p_sat, double yaw_offset, ros::Publisher surge_pub, ros::Publisher sway_pub, ros::Publisher yaw_pub, ros::Publisher rabbit_pub) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method to update the gains, given a vector of doubles. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish_private the data from the path following. virtual void start () override Method used in the first run to do initial setup. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once. virtual bool resetVirtualTarget (float value) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Additional inherited members Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_ Detailed Description class RelativeHeading; Path following using RelativeHeading 's algorithm for path following*. Author : Francisco Rego Andre Potes Marcelo Jacinto Version : 1.0a Date : 2021 Copyright : MIT This algorithm support: Controls: yaw surge sway Supports Cooperative Path Following - True Contains Currents Observers - False Public Functions Documentation function RelativeHeading RelativeHeading( double kx, double ky, double kz, const Eigen::Vector2d & p_sat, double yaw_offset, ros::Publisher surge_pub, ros::Publisher sway_pub, ros::Publisher yaw_pub, ros::Publisher rabbit_pub ) Constructor method for the Path Following class. Parameters : surge_pub The ROS surge publisher sway_pub The ROS sway publisher yaw_pub The ROS yaw publisher rabbit_pub The ROS rabbit publisher function setPFGains virtual bool setPFGains( std::vector< double > gains ) override Method to update the gains, given a vector of doubles. Parameters : gains A vector of gains to update in the controller The default order is: TODO Return : a boolean which represents the success of the operation Reimplements : PathFollowing::setPFGains function callPFController virtual void callPFController( double dt ) override Method that implements the path following control law. Parameters : dt The time step between last call and current call (in seconds) Reimplements : PathFollowing::callPFController function publish_private virtual void publish_private() override Method to publish_private the data from the path following. Reimplements : PathFollowing::publish_private function start virtual void start() override Method used in the first run to do initial setup. Reimplements : PathFollowing::start function stop virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : The success of the operation Reimplements : PathFollowing::stop Check if the gamma is greater then the gamma max of the path If so, we have reached the end function reset virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset function resetVirtualTarget virtual bool resetVirtualTarget( float value ) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Return : Whether the reset was made successfully or not Reimplements : PathFollowing::resetVirtualTarget Updated on 2022-05-30 at 14:56:47 +0000","title":"RelativeHeading"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRelativeHeading/#relativeheading","text":"Path following using RelativeHeading 's algorithm for path following*. More... #include <RelativeHeading.h> Inherits from PathFollowing","title":"RelativeHeading"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRelativeHeading/#public-functions","text":"Name RelativeHeading (double kx, double ky, double kz, const Eigen::Vector2d & p_sat, double yaw_offset, ros::Publisher surge_pub, ros::Publisher sway_pub, ros::Publisher yaw_pub, ros::Publisher rabbit_pub) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method to update the gains, given a vector of doubles. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish_private the data from the path following. virtual void start () override Method used in the first run to do initial setup. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once. virtual bool resetVirtualTarget (float value) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRelativeHeading/#additional-inherited-members","text":"Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRelativeHeading/#detailed-description","text":"class RelativeHeading; Path following using RelativeHeading 's algorithm for path following*. Author : Francisco Rego Andre Potes Marcelo Jacinto Version : 1.0a Date : 2021 Copyright : MIT This algorithm support: Controls: yaw surge sway Supports Cooperative Path Following - True Contains Currents Observers - False","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRelativeHeading/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRelativeHeading/#function-relativeheading","text":"RelativeHeading( double kx, double ky, double kz, const Eigen::Vector2d & p_sat, double yaw_offset, ros::Publisher surge_pub, ros::Publisher sway_pub, ros::Publisher yaw_pub, ros::Publisher rabbit_pub ) Constructor method for the Path Following class. Parameters : surge_pub The ROS surge publisher sway_pub The ROS sway publisher yaw_pub The ROS yaw publisher rabbit_pub The ROS rabbit publisher","title":"function RelativeHeading"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRelativeHeading/#function-setpfgains","text":"virtual bool setPFGains( std::vector< double > gains ) override Method to update the gains, given a vector of doubles. Parameters : gains A vector of gains to update in the controller The default order is: TODO Return : a boolean which represents the success of the operation Reimplements : PathFollowing::setPFGains","title":"function setPFGains"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRelativeHeading/#function-callpfcontroller","text":"virtual void callPFController( double dt ) override Method that implements the path following control law. Parameters : dt The time step between last call and current call (in seconds) Reimplements : PathFollowing::callPFController","title":"function callPFController"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRelativeHeading/#function-publish_private","text":"virtual void publish_private() override Method to publish_private the data from the path following. Reimplements : PathFollowing::publish_private","title":"function publish_private"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRelativeHeading/#function-start","text":"virtual void start() override Method used in the first run to do initial setup. Reimplements : PathFollowing::start","title":"function start"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRelativeHeading/#function-stop","text":"virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : The success of the operation Reimplements : PathFollowing::stop Check if the gamma is greater then the gamma max of the path If so, we have reached the end","title":"function stop"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRelativeHeading/#function-reset","text":"virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset","title":"function reset"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRelativeHeading/#function-resetvirtualtarget","text":"virtual bool resetVirtualTarget( float value ) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Return : Whether the reset was made successfully or not Reimplements : PathFollowing::resetVirtualTarget Updated on 2022-05-30 at 14:56:47 +0000","title":"function resetVirtualTarget"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRomulo/","text":"Romulo Path following using Aguiar 's algorithm modified to also control sway instead of yaw_rate (by Romulo ) More... #include <Romulo.h> Inherits from PathFollowing Public Functions Name Romulo (std::vector< double > gains, ros::Publisher surge_pub, ros::Publisher sway_pub, ros::Publisher rabbit_pub) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method that given an array of doubles, updates the gains of the controller. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish the data from the path following. virtual void start () override Method to do initial setup for the first run. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once. virtual bool resetVirtualTarget (float value) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Additional inherited members Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_ Detailed Description class Romulo; Path following using Aguiar 's algorithm modified to also control sway instead of yaw_rate (by Romulo ) Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This algorithm support: Controls: surge sway virtual-target (gamma) Supports Cooperative Path Following - True Contains Currents Observers - False Public Functions Documentation function Romulo Romulo( std::vector< double > gains, ros::Publisher surge_pub, ros::Publisher sway_pub, ros::Publisher rabbit_pub ) Constructor method for the Path Following class. Parameters : gains The gains of the controller surge_pub The ROS publisher of surge sway_pub The ROS publisher of sway rabbit_pub The ROS publisher of the virtual rabbit function setPFGains virtual bool setPFGains( std::vector< double > gains ) override Method that given an array of doubles, updates the gains of the controller. Parameters : gains The gains of the controller Return : a boolean which represents the success of the operation Reimplements : PathFollowing::setPFGains function callPFController virtual void callPFController( double dt ) override Method that implements the path following control law. Parameters : dt The time difference between the current and previous call (in seconds) Reimplements : PathFollowing::callPFController function publish_private virtual void publish_private() override Method to publish the data from the path following. Reimplements : PathFollowing::publish_private function start virtual void start() override Method to do initial setup for the first run. Reimplements : PathFollowing::start function stop virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : The success of the operation Reimplements : PathFollowing::stop Check if the gamma is greater then the gamma max of the path If so, we have reached the end function reset virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset function resetVirtualTarget virtual bool resetVirtualTarget( float value ) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Return : Whether the reset was made successfully or not Reimplements : PathFollowing::resetVirtualTarget Updated on 2022-05-30 at 14:56:47 +0000","title":"Romulo"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRomulo/#romulo","text":"Path following using Aguiar 's algorithm modified to also control sway instead of yaw_rate (by Romulo ) More... #include <Romulo.h> Inherits from PathFollowing","title":"Romulo"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRomulo/#public-functions","text":"Name Romulo (std::vector< double > gains, ros::Publisher surge_pub, ros::Publisher sway_pub, ros::Publisher rabbit_pub) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method that given an array of doubles, updates the gains of the controller. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish the data from the path following. virtual void start () override Method to do initial setup for the first run. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once. virtual bool resetVirtualTarget (float value) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRomulo/#additional-inherited-members","text":"Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRomulo/#detailed-description","text":"class Romulo; Path following using Aguiar 's algorithm modified to also control sway instead of yaw_rate (by Romulo ) Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This algorithm support: Controls: surge sway virtual-target (gamma) Supports Cooperative Path Following - True Contains Currents Observers - False","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRomulo/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRomulo/#function-romulo","text":"Romulo( std::vector< double > gains, ros::Publisher surge_pub, ros::Publisher sway_pub, ros::Publisher rabbit_pub ) Constructor method for the Path Following class. Parameters : gains The gains of the controller surge_pub The ROS publisher of surge sway_pub The ROS publisher of sway rabbit_pub The ROS publisher of the virtual rabbit","title":"function Romulo"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRomulo/#function-setpfgains","text":"virtual bool setPFGains( std::vector< double > gains ) override Method that given an array of doubles, updates the gains of the controller. Parameters : gains The gains of the controller Return : a boolean which represents the success of the operation Reimplements : PathFollowing::setPFGains","title":"function setPFGains"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRomulo/#function-callpfcontroller","text":"virtual void callPFController( double dt ) override Method that implements the path following control law. Parameters : dt The time difference between the current and previous call (in seconds) Reimplements : PathFollowing::callPFController","title":"function callPFController"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRomulo/#function-publish_private","text":"virtual void publish_private() override Method to publish the data from the path following. Reimplements : PathFollowing::publish_private","title":"function publish_private"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRomulo/#function-start","text":"virtual void start() override Method to do initial setup for the first run. Reimplements : PathFollowing::start","title":"function start"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRomulo/#function-stop","text":"virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : The success of the operation Reimplements : PathFollowing::stop Check if the gamma is greater then the gamma max of the path If so, we have reached the end","title":"function stop"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRomulo/#function-reset","text":"virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset","title":"function reset"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classRomulo/#function-resetvirtualtarget","text":"virtual bool resetVirtualTarget( float value ) override Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) Return : Whether the reset was made successfully or not Reimplements : PathFollowing::resetVirtualTarget Updated on 2022-05-30 at 14:56:47 +0000","title":"function resetVirtualTarget"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classSamson/","text":"title: Samson summary: Path following using Lapierre's algorithm for path following Method1: based on the work of Samson (1993) Samson Path following using Lapierre 's algorithm for path following Method1: based on the work of Samson (1993) More... #include <Samson.h> Inherits from PathFollowing Public Functions Name Samson (double k1, double k2, double k3, double theta, double k_delta, ros::Publisher surge_pub, ros::Publisher yaw_rate_pub, ros::ServiceClient mode_client) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method that given a vector of doubles, updates the gains of the controller. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish the data from the path following. virtual void start () override Method to run in the first iteration of the path following algorithm. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once. Additional inherited members Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. virtual bool resetVirtualTarget (float value) Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) bool resetVirtualTarget () Method to reset the virtual target of the vehicle (gamma) to zero. Not all controllers need this (example: Samson , Fossen which use the closest point) void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_ Detailed Description class Samson; Path following using Lapierre 's algorithm for path following Method1: based on the work of Samson (1993) Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This algorithm support: Controls: yaw-rate surge Supports Cooperative Path Following - True Contains Currents Observers - False Public Functions Documentation function Samson Samson( double k1, double k2, double k3, double theta, double k_delta, ros::Publisher surge_pub, ros::Publisher yaw_rate_pub, ros::ServiceClient mode_client ) Constructor method for the Path Following class. Parameters : k1 The controller gain k2 The controller gain k3 The controller gain theta The controller gain k_delta The controller gain surge_pub The ROS surge publisher yaw_rate_pub The ROS yaw rate publisher mode_client The ROS service client to change the mode of operation of the path to be the closest point function setPFGains virtual bool setPFGains( std::vector< double > gains ) override Method that given a vector of doubles, updates the gains of the controller. Parameters : gains A vector of gains Return : a boolean which represents the success of the operation Reimplements : PathFollowing::setPFGains NOTE: The default order of the gains is k1, k2, k3, theta, k_delta function callPFController virtual void callPFController( double dt ) override Method that implements the path following control law. Reimplements : PathFollowing::callPFController function publish_private virtual void publish_private() override Method to publish the data from the path following. Reimplements : PathFollowing::publish_private function start virtual void start() override Method to run in the first iteration of the path following algorithm. Reimplements : PathFollowing::start function stop virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : The success of the operation Reimplements : PathFollowing::stop function reset virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset Updated on 2022-05-30 at 14:56:47 +0000","title":"classSamson"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classSamson/#samson","text":"Path following using Lapierre 's algorithm for path following Method1: based on the work of Samson (1993) More... #include <Samson.h> Inherits from PathFollowing","title":"Samson"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classSamson/#public-functions","text":"Name Samson (double k1, double k2, double k3, double theta, double k_delta, ros::Publisher surge_pub, ros::Publisher yaw_rate_pub, ros::ServiceClient mode_client) Constructor method for the Path Following class. virtual bool setPFGains (std::vector< double > gains) override Method that given a vector of doubles, updates the gains of the controller. virtual void callPFController (double dt) override Method that implements the path following control law. virtual void publish_private () override Method to publish the data from the path following. virtual void start () override Method to run in the first iteration of the path following algorithm. virtual bool stop () override Method used to check whether we reached the end of the algorithm or not. virtual bool reset () override Method used to reset the algorithm control parameters when running the algorithm more than once.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classSamson/#additional-inherited-members","text":"Public Functions inherited from PathFollowing Name virtual ~PathFollowing () Virtual destructor for the abstract pathfollowing class. void publish () Method to publish the data given by the algorithm. virtual bool resetVirtualTarget (float value) Method to reset the virtual target of the vehicle (gamma) to a pre-specified value. Not all controllers need this (example: Samson , Fossen which use the closest point) bool resetVirtualTarget () Method to reset the virtual target of the vehicle (gamma) to zero. Not all controllers need this (example: Samson , Fossen which use the closest point) void UpdateVehicleState (const VehicleState & vehicle_state) Method to update the vehicle state used by the controller. void UpdatePathState (const PathState & path_state) Method to update the path state used by the controller. void setPFollowingDebugPublisher (const ros::Publisher & pfollowing_debug_pub) Method to set common publishers. Protected Functions inherited from PathFollowing Name double algConvert (double alg_new, double alg_old, double alg_out_old) Auxiliar method to smooth out the angle to be used by path following algorithms. Protected Attributes inherited from PathFollowing Name VehicleState vehicle_state_ Variable to store the state of the vehicle. PathState path_state_ Variable to store the state of the path. PFollowingDebug pfollowing_debug_ Variable to store the state of the path. ros::Publisher pfollowing_debug_pub_","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classSamson/#detailed-description","text":"class Samson; Path following using Lapierre 's algorithm for path following Method1: based on the work of Samson (1993) Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This algorithm support: Controls: yaw-rate surge Supports Cooperative Path Following - True Contains Currents Observers - False","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classSamson/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classSamson/#function-samson","text":"Samson( double k1, double k2, double k3, double theta, double k_delta, ros::Publisher surge_pub, ros::Publisher yaw_rate_pub, ros::ServiceClient mode_client ) Constructor method for the Path Following class. Parameters : k1 The controller gain k2 The controller gain k3 The controller gain theta The controller gain k_delta The controller gain surge_pub The ROS surge publisher yaw_rate_pub The ROS yaw rate publisher mode_client The ROS service client to change the mode of operation of the path to be the closest point","title":"function Samson"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classSamson/#function-setpfgains","text":"virtual bool setPFGains( std::vector< double > gains ) override Method that given a vector of doubles, updates the gains of the controller. Parameters : gains A vector of gains Return : a boolean which represents the success of the operation Reimplements : PathFollowing::setPFGains NOTE: The default order of the gains is k1, k2, k3, theta, k_delta","title":"function setPFGains"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classSamson/#function-callpfcontroller","text":"virtual void callPFController( double dt ) override Method that implements the path following control law. Reimplements : PathFollowing::callPFController","title":"function callPFController"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classSamson/#function-publish_private","text":"virtual void publish_private() override Method to publish the data from the path following. Reimplements : PathFollowing::publish_private","title":"function publish_private"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classSamson/#function-start","text":"virtual void start() override Method to run in the first iteration of the path following algorithm. Reimplements : PathFollowing::start","title":"function start"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classSamson/#function-stop","text":"virtual bool stop() override Method used to check whether we reached the end of the algorithm or not. Return : The success of the operation Reimplements : PathFollowing::stop","title":"function stop"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/classSamson/#function-reset","text":"virtual bool reset() override Method used to reset the algorithm control parameters when running the algorithm more than once. Return : Whether the reset was made successfully or not Reimplements : PathFollowing::reset Updated on 2022-05-30 at 14:56:47 +0000","title":"function reset"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPFollowingDebug/","text":"PFollowingDebug Public Attributes Name std::string algorithm double cross_track_error double along_track_error double yaw double psi double gamma Public Attributes Documentation variable algorithm std::string algorithm; variable cross_track_error double cross_track_error {0.0}; variable along_track_error double along_track_error {0.0}; variable yaw double yaw {0.0}; variable psi double psi {0.0}; variable gamma double gamma {0.0}; Updated on 2022-05-30 at 14:56:47 +0000","title":"PFollowingDebug"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPFollowingDebug/#pfollowingdebug","text":"","title":"PFollowingDebug"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPFollowingDebug/#public-attributes","text":"Name std::string algorithm double cross_track_error double along_track_error double yaw double psi double gamma","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPFollowingDebug/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPFollowingDebug/#variable-algorithm","text":"std::string algorithm;","title":"variable algorithm"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPFollowingDebug/#variable-cross_track_error","text":"double cross_track_error {0.0};","title":"variable cross_track_error"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPFollowingDebug/#variable-along_track_error","text":"double along_track_error {0.0};","title":"variable along_track_error"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPFollowingDebug/#variable-yaw","text":"double yaw {0.0};","title":"variable yaw"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPFollowingDebug/#variable-psi","text":"double psi {0.0};","title":"variable psi"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPFollowingDebug/#variable-gamma","text":"double gamma {0.0}; Updated on 2022-05-30 at 14:56:47 +0000","title":"variable gamma"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/","text":"PathState A structure to hold the data of the path. More... #include <States.h> Public Attributes Name double gamma The value of gamma used in the computations for this values. Eigen::Vector3d pd Desired position and its derivatives. Eigen::Vector3d d_pd Eigen::Vector3d dd_pd double psi Other properties of the path such as the psi, curvature and tangent_norm. double curvature double tangent_norm double vd The desired speed for a given gamma. double d_vd double vehicle_speed double vc The correction speed for gamma (when cooperating with other vehicles. double gamma_min Properties related to the boundaries of the parameterization of the path. double gamma_max Detailed Description struct PathState; A structure to hold the data of the path. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT Public Attributes Documentation variable gamma double gamma {0.0}; The value of gamma used in the computations for this values. variable pd Eigen::Vector3d pd {0.0, 0.0, 0.0}; Desired position and its derivatives. variable d_pd Eigen::Vector3d d_pd {0.0, 0.0, 0.0}; variable dd_pd Eigen::Vector3d dd_pd {0.0, 0.0, 0.0}; variable psi double psi {0.0}; Other properties of the path such as the psi, curvature and tangent_norm. variable curvature double curvature {0.0}; variable tangent_norm double tangent_norm {0.0}; variable vd double vd {0.0}; The desired speed for a given gamma. variable d_vd double d_vd {0.0}; variable vehicle_speed double vehicle_speed {0.0}; variable vc double vc {0.0}; The correction speed for gamma (when cooperating with other vehicles. variable gamma_min double gamma_min {std::numeric_limits<double>::lowest()}; Properties related to the boundaries of the parameterization of the path. variable gamma_max double gamma_max {std::numeric_limits<double>::max()}; Updated on 2022-05-30 at 14:56:47 +0000","title":"PathState"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#pathstate","text":"A structure to hold the data of the path. More... #include <States.h>","title":"PathState"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#public-attributes","text":"Name double gamma The value of gamma used in the computations for this values. Eigen::Vector3d pd Desired position and its derivatives. Eigen::Vector3d d_pd Eigen::Vector3d dd_pd double psi Other properties of the path such as the psi, curvature and tangent_norm. double curvature double tangent_norm double vd The desired speed for a given gamma. double d_vd double vehicle_speed double vc The correction speed for gamma (when cooperating with other vehicles. double gamma_min Properties related to the boundaries of the parameterization of the path. double gamma_max","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#detailed-description","text":"struct PathState; A structure to hold the data of the path. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#variable-gamma","text":"double gamma {0.0}; The value of gamma used in the computations for this values.","title":"variable gamma"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#variable-pd","text":"Eigen::Vector3d pd {0.0, 0.0, 0.0}; Desired position and its derivatives.","title":"variable pd"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#variable-d_pd","text":"Eigen::Vector3d d_pd {0.0, 0.0, 0.0};","title":"variable d_pd"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#variable-dd_pd","text":"Eigen::Vector3d dd_pd {0.0, 0.0, 0.0};","title":"variable dd_pd"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#variable-psi","text":"double psi {0.0}; Other properties of the path such as the psi, curvature and tangent_norm.","title":"variable psi"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#variable-curvature","text":"double curvature {0.0};","title":"variable curvature"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#variable-tangent_norm","text":"double tangent_norm {0.0};","title":"variable tangent_norm"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#variable-vd","text":"double vd {0.0}; The desired speed for a given gamma.","title":"variable vd"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#variable-d_vd","text":"double d_vd {0.0};","title":"variable d_vd"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#variable-vehicle_speed","text":"double vehicle_speed {0.0};","title":"variable vehicle_speed"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#variable-vc","text":"double vc {0.0}; The correction speed for gamma (when cooperating with other vehicles.","title":"variable vc"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#variable-gamma_min","text":"double gamma_min {std::numeric_limits<double>::lowest()}; Properties related to the boundaries of the parameterization of the path.","title":"variable gamma_min"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structPathState/#variable-gamma_max","text":"double gamma_max {std::numeric_limits<double>::max()}; Updated on 2022-05-30 at 14:56:47 +0000","title":"variable gamma_max"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structVehicleState/","text":"VehicleState A structure to hold the state of the vehicle. More... #include <States.h> Public Attributes Name Eigen::Vector3d v1 Velocities in the body frame. Eigen::Vector3d v2 Eigen::Vector3d eta1 Positions and orientations in inertial frame. Eigen::Vector3d eta2 Detailed Description struct VehicleState; A structure to hold the state of the vehicle. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT Public Attributes Documentation variable v1 Eigen::Vector3d v1 {0.0, 0.0, 0.0}; Velocities in the body frame. variable v2 Eigen::Vector3d v2 {0.0, 0.0, 0.0}; variable eta1 Eigen::Vector3d eta1 {0.0, 0.0, 0.0}; Positions and orientations in inertial frame. variable eta2 Eigen::Vector3d eta2 {0.0, 0.0, 0.0}; Updated on 2022-05-30 at 14:56:47 +0000","title":"VehicleState"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structVehicleState/#vehiclestate","text":"A structure to hold the state of the vehicle. More... #include <States.h>","title":"VehicleState"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structVehicleState/#public-attributes","text":"Name Eigen::Vector3d v1 Velocities in the body frame. Eigen::Vector3d v2 Eigen::Vector3d eta1 Positions and orientations in inertial frame. Eigen::Vector3d eta2","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structVehicleState/#detailed-description","text":"struct VehicleState; A structure to hold the state of the vehicle. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structVehicleState/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structVehicleState/#variable-v1","text":"Eigen::Vector3d v1 {0.0, 0.0, 0.0}; Velocities in the body frame.","title":"variable v1"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structVehicleState/#variable-v2","text":"Eigen::Vector3d v2 {0.0, 0.0, 0.0};","title":"variable v2"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structVehicleState/#variable-eta1","text":"Eigen::Vector3d eta1 {0.0, 0.0, 0.0}; Positions and orientations in inertial frame.","title":"variable eta1"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Classes/structVehicleState/#variable-eta2","text":"Eigen::Vector3d eta2 {0.0, 0.0, 0.0}; Updated on 2022-05-30 at 14:56:47 +0000","title":"variable eta2"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Examples/","text":"Examples Updated on 2022-05-30 at 14:56:47 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Examples/#examples","text":"Updated on 2022-05-30 at 14:56:47 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Modules/","text":"Modules Updated on 2022-05-30 at 14:56:47 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Modules/#modules","text":"Updated on 2022-05-30 at 14:56:47 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Namespaces/","text":"Namespaces Updated on 2022-05-30 at 14:56:47 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/path_following/Namespaces/#namespaces","text":"Updated on 2022-05-30 at 14:56:47 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/","text":"Classes struct Output_t Waypoint output struct. Contains orientation and linear and angular velocities. Not everything needs to be used. struct Vehicle_t Vehicle state struct. Contains position, orientation and linear and angular velocities. struct WPref_t Waypoint reference struct. Contains references for poistion and orientations. Not everything needs to be used. class WaypointController Abstract class of a waypoint controller. class WaypointNode ROS node class. class WpHeading Waypoint controller using surge, surge and yaw rate. Not only can go to waypoint and hold its position but can also maintain heading. class WpLoose Waypoint controller similar to standard, using surge and yaw (nose of the vehicle points to the desired position). The difference is that this one limits the rate of yaw reference. class WpStandard Waypoint controller using surge and yaw, where the nose of the vehicle points to the desired position. Updated on 2022-05-30 at 14:56:46 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/#classes","text":"struct Output_t Waypoint output struct. Contains orientation and linear and angular velocities. Not everything needs to be used. struct Vehicle_t Vehicle state struct. Contains position, orientation and linear and angular velocities. struct WPref_t Waypoint reference struct. Contains references for poistion and orientations. Not everything needs to be used. class WaypointController Abstract class of a waypoint controller. class WaypointNode ROS node class. class WpHeading Waypoint controller using surge, surge and yaw rate. Not only can go to waypoint and hold its position but can also maintain heading. class WpLoose Waypoint controller similar to standard, using surge and yaw (nose of the vehicle points to the desired position). The difference is that this one limits the rate of yaw reference. class WpStandard Waypoint controller using surge and yaw, where the nose of the vehicle points to the desired position. Updated on 2022-05-30 at 14:56:46 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/","text":"WaypointController Abstract class of a waypoint controller. #include <wp_controller.h> Inherited by WpHeading , WpLoose , WpStandard Public Functions Name WaypointController () virtual ~WaypointController () void setFrequency (const double & f) Mutator for setting the controller period. void setGains (const std::vector< double > & gains) Mutator for updating the gains. void compute ( Vehicle_t state, WPref_t wp_ref) Computes and publishes the output of the controller. Protected Functions Name virtual void publish () =0 Virtual function to publish the output of the controller. virtual void calculateRef ( Vehicle_t state, WPref_t wp_ref) =0 Virtual function to compute the waypoint controller. double getYawOut () Getter of the yaw reference (output of controller) double getYawrateOut () Getter of the yaw rate reference (output of controller) double getSurgeOut () Getter of the surge reference (output of controller) double getSwayOut () Getter of the sway reference (output of controller) void setYawOut (const double & value) Yaw reference setter (output of controller) void setYawrateOut (const double & value) Yaw rate reference setter (output of controller) void setSurgeOut (const double & value) Surge reference setter (output of controller) void setSwayOut (const double & value) Sway reference setter (output of controller) Protected Attributes Name double ts_ std::vector< double > gains_ Public Functions Documentation function WaypointController inline WaypointController() function ~WaypointController inline virtual ~WaypointController() function setFrequency inline void setFrequency( const double & f ) Mutator for setting the controller period. Parameters : f frequency of the main loop function setGains inline void setGains( const std::vector< double > & gains ) Mutator for updating the gains. Parameters : gains parameters of the waypoiny controller function compute inline void compute( Vehicle_t state, WPref_t wp_ref ) Computes and publishes the output of the controller. Parameters : state wp_ref Protected Functions Documentation function publish virtual void publish() =0 Virtual function to publish the output of the controller. Reimplemented by : WpLoose::publish , WpHeading::publish , WpStandard::publish function calculateRef virtual void calculateRef( Vehicle_t state, WPref_t wp_ref ) =0 Virtual function to compute the waypoint controller. Parameters : state wp_ref Reimplemented by : WpLoose::calculateRef , WpHeading::calculateRef , WpStandard::calculateRef function getYawOut inline double getYawOut() Getter of the yaw reference (output of controller) Return : yaw ref function getYawrateOut inline double getYawrateOut() Getter of the yaw rate reference (output of controller) Return : yaw rate ref function getSurgeOut inline double getSurgeOut() Getter of the surge reference (output of controller) Return : surge ref function getSwayOut inline double getSwayOut() Getter of the sway reference (output of controller) Return : sway ref function setYawOut inline void setYawOut( const double & value ) Yaw reference setter (output of controller) Parameters : value yaw ref function setYawrateOut inline void setYawrateOut( const double & value ) Yaw rate reference setter (output of controller) Parameters : value yaw rate ref function setSurgeOut inline void setSurgeOut( const double & value ) Surge reference setter (output of controller) Parameters : value surge ref function setSwayOut inline void setSwayOut( const double & value ) Sway reference setter (output of controller) Parameters : value sway ref Protected Attributes Documentation variable ts_ double ts_ {0.0}; variable gains_ std::vector< double > gains_; Updated on 2022-05-30 at 14:56:46 +0000","title":"WaypointController"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#waypointcontroller","text":"Abstract class of a waypoint controller. #include <wp_controller.h> Inherited by WpHeading , WpLoose , WpStandard","title":"WaypointController"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#public-functions","text":"Name WaypointController () virtual ~WaypointController () void setFrequency (const double & f) Mutator for setting the controller period. void setGains (const std::vector< double > & gains) Mutator for updating the gains. void compute ( Vehicle_t state, WPref_t wp_ref) Computes and publishes the output of the controller.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#protected-functions","text":"Name virtual void publish () =0 Virtual function to publish the output of the controller. virtual void calculateRef ( Vehicle_t state, WPref_t wp_ref) =0 Virtual function to compute the waypoint controller. double getYawOut () Getter of the yaw reference (output of controller) double getYawrateOut () Getter of the yaw rate reference (output of controller) double getSurgeOut () Getter of the surge reference (output of controller) double getSwayOut () Getter of the sway reference (output of controller) void setYawOut (const double & value) Yaw reference setter (output of controller) void setYawrateOut (const double & value) Yaw rate reference setter (output of controller) void setSurgeOut (const double & value) Surge reference setter (output of controller) void setSwayOut (const double & value) Sway reference setter (output of controller)","title":"Protected Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#protected-attributes","text":"Name double ts_ std::vector< double > gains_","title":"Protected Attributes"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#function-waypointcontroller","text":"inline WaypointController()","title":"function WaypointController"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#function-waypointcontroller_1","text":"inline virtual ~WaypointController()","title":"function ~WaypointController"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#function-setfrequency","text":"inline void setFrequency( const double & f ) Mutator for setting the controller period. Parameters : f frequency of the main loop","title":"function setFrequency"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#function-setgains","text":"inline void setGains( const std::vector< double > & gains ) Mutator for updating the gains. Parameters : gains parameters of the waypoiny controller","title":"function setGains"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#function-compute","text":"inline void compute( Vehicle_t state, WPref_t wp_ref ) Computes and publishes the output of the controller. Parameters : state wp_ref","title":"function compute"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#function-publish","text":"virtual void publish() =0 Virtual function to publish the output of the controller. Reimplemented by : WpLoose::publish , WpHeading::publish , WpStandard::publish","title":"function publish"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#function-calculateref","text":"virtual void calculateRef( Vehicle_t state, WPref_t wp_ref ) =0 Virtual function to compute the waypoint controller. Parameters : state wp_ref Reimplemented by : WpLoose::calculateRef , WpHeading::calculateRef , WpStandard::calculateRef","title":"function calculateRef"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#function-getyawout","text":"inline double getYawOut() Getter of the yaw reference (output of controller) Return : yaw ref","title":"function getYawOut"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#function-getyawrateout","text":"inline double getYawrateOut() Getter of the yaw rate reference (output of controller) Return : yaw rate ref","title":"function getYawrateOut"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#function-getsurgeout","text":"inline double getSurgeOut() Getter of the surge reference (output of controller) Return : surge ref","title":"function getSurgeOut"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#function-getswayout","text":"inline double getSwayOut() Getter of the sway reference (output of controller) Return : sway ref","title":"function getSwayOut"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#function-setyawout","text":"inline void setYawOut( const double & value ) Yaw reference setter (output of controller) Parameters : value yaw ref","title":"function setYawOut"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#function-setyawrateout","text":"inline void setYawrateOut( const double & value ) Yaw rate reference setter (output of controller) Parameters : value yaw rate ref","title":"function setYawrateOut"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#function-setsurgeout","text":"inline void setSurgeOut( const double & value ) Surge reference setter (output of controller) Parameters : value surge ref","title":"function setSurgeOut"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#function-setswayout","text":"inline void setSwayOut( const double & value ) Sway reference setter (output of controller) Parameters : value sway ref","title":"function setSwayOut"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#variable-ts_","text":"double ts_ {0.0};","title":"variable ts_"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointController/#variable-gains_","text":"std::vector< double > gains_; Updated on 2022-05-30 at 14:56:46 +0000","title":"variable gains_"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointNode/","text":"WaypointNode ROS node class. #include <waypoint.h> Public Functions Name WaypointNode (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehanle_private) ~WaypointNode () Public Functions Documentation function WaypointNode WaypointNode( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehanle_private ) function ~WaypointNode ~WaypointNode() Updated on 2022-05-30 at 14:56:46 +0000","title":"WaypointNode"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointNode/#waypointnode","text":"ROS node class. #include <waypoint.h>","title":"WaypointNode"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointNode/#public-functions","text":"Name WaypointNode (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehanle_private) ~WaypointNode ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointNode/#function-waypointnode","text":"WaypointNode( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehanle_private )","title":"function WaypointNode"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWaypointNode/#function-waypointnode_1","text":"~WaypointNode() Updated on 2022-05-30 at 14:56:46 +0000","title":"function ~WaypointNode"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpHeading/","text":"WpHeading Waypoint controller using surge, surge and yaw rate. Not only can go to waypoint and hold its position but can also maintain heading. #include <wp_heading.h> Inherits from WaypointController Public Functions Name WpHeading (ros::Publisher surge_pub, ros::Publisher sway_pub, ros::Publisher yaw_rate_pub) virtual ~WpHeading () Additional inherited members Public Functions inherited from WaypointController Name WaypointController () virtual ~WaypointController () void setFrequency (const double & f) Mutator for setting the controller period. void setGains (const std::vector< double > & gains) Mutator for updating the gains. void compute ( Vehicle_t state, WPref_t wp_ref) Computes and publishes the output of the controller. Protected Functions inherited from WaypointController Name double getYawOut () Getter of the yaw reference (output of controller) double getYawrateOut () Getter of the yaw rate reference (output of controller) double getSurgeOut () Getter of the surge reference (output of controller) double getSwayOut () Getter of the sway reference (output of controller) void setYawOut (const double & value) Yaw reference setter (output of controller) void setYawrateOut (const double & value) Yaw rate reference setter (output of controller) void setSurgeOut (const double & value) Surge reference setter (output of controller) void setSwayOut (const double & value) Sway reference setter (output of controller) Protected Attributes inherited from WaypointController Name double ts_ std::vector< double > gains_ Public Functions Documentation function WpHeading WpHeading( ros::Publisher surge_pub, ros::Publisher sway_pub, ros::Publisher yaw_rate_pub ) function ~WpHeading inline virtual ~WpHeading() Updated on 2022-05-30 at 14:56:46 +0000","title":"WpHeading"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpHeading/#wpheading","text":"Waypoint controller using surge, surge and yaw rate. Not only can go to waypoint and hold its position but can also maintain heading. #include <wp_heading.h> Inherits from WaypointController","title":"WpHeading"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpHeading/#public-functions","text":"Name WpHeading (ros::Publisher surge_pub, ros::Publisher sway_pub, ros::Publisher yaw_rate_pub) virtual ~WpHeading ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpHeading/#additional-inherited-members","text":"Public Functions inherited from WaypointController Name WaypointController () virtual ~WaypointController () void setFrequency (const double & f) Mutator for setting the controller period. void setGains (const std::vector< double > & gains) Mutator for updating the gains. void compute ( Vehicle_t state, WPref_t wp_ref) Computes and publishes the output of the controller. Protected Functions inherited from WaypointController Name double getYawOut () Getter of the yaw reference (output of controller) double getYawrateOut () Getter of the yaw rate reference (output of controller) double getSurgeOut () Getter of the surge reference (output of controller) double getSwayOut () Getter of the sway reference (output of controller) void setYawOut (const double & value) Yaw reference setter (output of controller) void setYawrateOut (const double & value) Yaw rate reference setter (output of controller) void setSurgeOut (const double & value) Surge reference setter (output of controller) void setSwayOut (const double & value) Sway reference setter (output of controller) Protected Attributes inherited from WaypointController Name double ts_ std::vector< double > gains_","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpHeading/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpHeading/#function-wpheading","text":"WpHeading( ros::Publisher surge_pub, ros::Publisher sway_pub, ros::Publisher yaw_rate_pub )","title":"function WpHeading"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpHeading/#function-wpheading_1","text":"inline virtual ~WpHeading() Updated on 2022-05-30 at 14:56:46 +0000","title":"function ~WpHeading"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpLoose/","text":"WpLoose Waypoint controller similar to standard, using surge and yaw (nose of the vehicle points to the desired position). The difference is that this one limits the rate of yaw reference. #include <wp_loose.h> Inherits from WaypointController Public Functions Name WpLoose (ros::Publisher surge_pub, ros::Publisher yaw_pub) virtual ~WpLoose () Additional inherited members Public Functions inherited from WaypointController Name WaypointController () virtual ~WaypointController () void setFrequency (const double & f) Mutator for setting the controller period. void setGains (const std::vector< double > & gains) Mutator for updating the gains. void compute ( Vehicle_t state, WPref_t wp_ref) Computes and publishes the output of the controller. Protected Functions inherited from WaypointController Name double getYawOut () Getter of the yaw reference (output of controller) double getYawrateOut () Getter of the yaw rate reference (output of controller) double getSurgeOut () Getter of the surge reference (output of controller) double getSwayOut () Getter of the sway reference (output of controller) void setYawOut (const double & value) Yaw reference setter (output of controller) void setYawrateOut (const double & value) Yaw rate reference setter (output of controller) void setSurgeOut (const double & value) Surge reference setter (output of controller) void setSwayOut (const double & value) Sway reference setter (output of controller) Protected Attributes inherited from WaypointController Name double ts_ std::vector< double > gains_ Public Functions Documentation function WpLoose WpLoose( ros::Publisher surge_pub, ros::Publisher yaw_pub ) function ~WpLoose inline virtual ~WpLoose() Updated on 2022-05-30 at 14:56:46 +0000","title":"WpLoose"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpLoose/#wploose","text":"Waypoint controller similar to standard, using surge and yaw (nose of the vehicle points to the desired position). The difference is that this one limits the rate of yaw reference. #include <wp_loose.h> Inherits from WaypointController","title":"WpLoose"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpLoose/#public-functions","text":"Name WpLoose (ros::Publisher surge_pub, ros::Publisher yaw_pub) virtual ~WpLoose ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpLoose/#additional-inherited-members","text":"Public Functions inherited from WaypointController Name WaypointController () virtual ~WaypointController () void setFrequency (const double & f) Mutator for setting the controller period. void setGains (const std::vector< double > & gains) Mutator for updating the gains. void compute ( Vehicle_t state, WPref_t wp_ref) Computes and publishes the output of the controller. Protected Functions inherited from WaypointController Name double getYawOut () Getter of the yaw reference (output of controller) double getYawrateOut () Getter of the yaw rate reference (output of controller) double getSurgeOut () Getter of the surge reference (output of controller) double getSwayOut () Getter of the sway reference (output of controller) void setYawOut (const double & value) Yaw reference setter (output of controller) void setYawrateOut (const double & value) Yaw rate reference setter (output of controller) void setSurgeOut (const double & value) Surge reference setter (output of controller) void setSwayOut (const double & value) Sway reference setter (output of controller) Protected Attributes inherited from WaypointController Name double ts_ std::vector< double > gains_","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpLoose/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpLoose/#function-wploose","text":"WpLoose( ros::Publisher surge_pub, ros::Publisher yaw_pub )","title":"function WpLoose"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpLoose/#function-wploose_1","text":"inline virtual ~WpLoose() Updated on 2022-05-30 at 14:56:46 +0000","title":"function ~WpLoose"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpStandard/","text":"WpStandard Waypoint controller using surge and yaw, where the nose of the vehicle points to the desired position. #include <wp_standard.h> Inherits from WaypointController Public Functions Name WpStandard (ros::Publisher surge_pub, ros::Publisher yaw_pub) virtual ~WpStandard () Additional inherited members Public Functions inherited from WaypointController Name WaypointController () virtual ~WaypointController () void setFrequency (const double & f) Mutator for setting the controller period. void setGains (const std::vector< double > & gains) Mutator for updating the gains. void compute ( Vehicle_t state, WPref_t wp_ref) Computes and publishes the output of the controller. Protected Functions inherited from WaypointController Name double getYawOut () Getter of the yaw reference (output of controller) double getYawrateOut () Getter of the yaw rate reference (output of controller) double getSurgeOut () Getter of the surge reference (output of controller) double getSwayOut () Getter of the sway reference (output of controller) void setYawOut (const double & value) Yaw reference setter (output of controller) void setYawrateOut (const double & value) Yaw rate reference setter (output of controller) void setSurgeOut (const double & value) Surge reference setter (output of controller) void setSwayOut (const double & value) Sway reference setter (output of controller) Protected Attributes inherited from WaypointController Name double ts_ std::vector< double > gains_ Public Functions Documentation function WpStandard WpStandard( ros::Publisher surge_pub, ros::Publisher yaw_pub ) function ~WpStandard inline virtual ~WpStandard() Updated on 2022-05-30 at 14:56:46 +0000","title":"WpStandard"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpStandard/#wpstandard","text":"Waypoint controller using surge and yaw, where the nose of the vehicle points to the desired position. #include <wp_standard.h> Inherits from WaypointController","title":"WpStandard"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpStandard/#public-functions","text":"Name WpStandard (ros::Publisher surge_pub, ros::Publisher yaw_pub) virtual ~WpStandard ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpStandard/#additional-inherited-members","text":"Public Functions inherited from WaypointController Name WaypointController () virtual ~WaypointController () void setFrequency (const double & f) Mutator for setting the controller period. void setGains (const std::vector< double > & gains) Mutator for updating the gains. void compute ( Vehicle_t state, WPref_t wp_ref) Computes and publishes the output of the controller. Protected Functions inherited from WaypointController Name double getYawOut () Getter of the yaw reference (output of controller) double getYawrateOut () Getter of the yaw rate reference (output of controller) double getSurgeOut () Getter of the surge reference (output of controller) double getSwayOut () Getter of the sway reference (output of controller) void setYawOut (const double & value) Yaw reference setter (output of controller) void setYawrateOut (const double & value) Yaw rate reference setter (output of controller) void setSurgeOut (const double & value) Surge reference setter (output of controller) void setSwayOut (const double & value) Sway reference setter (output of controller) Protected Attributes inherited from WaypointController Name double ts_ std::vector< double > gains_","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpStandard/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpStandard/#function-wpstandard","text":"WpStandard( ros::Publisher surge_pub, ros::Publisher yaw_pub )","title":"function WpStandard"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/classWpStandard/#function-wpstandard_1","text":"inline virtual ~WpStandard() Updated on 2022-05-30 at 14:56:46 +0000","title":"function ~WpStandard"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structOutput__t/","text":"Output_t Waypoint output struct. Contains orientation and linear and angular velocities. Not everything needs to be used. #include <wp_controller.h> Public Attributes Name Eigen::Vector3d eta2 Eigen::Vector3d v1 Eigen::Vector3d v2 Public Attributes Documentation variable eta2 Eigen::Vector3d eta2 {0.0, 0.0, 0.0}; variable v1 Eigen::Vector3d v1 {0.0, 0.0, 0.0}; variable v2 Eigen::Vector3d v2 {0.0, 0.0, 0.0}; Updated on 2022-05-30 at 14:56:46 +0000","title":"Output_t"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structOutput__t/#output_t","text":"Waypoint output struct. Contains orientation and linear and angular velocities. Not everything needs to be used. #include <wp_controller.h>","title":"Output_t"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structOutput__t/#public-attributes","text":"Name Eigen::Vector3d eta2 Eigen::Vector3d v1 Eigen::Vector3d v2","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structOutput__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structOutput__t/#variable-eta2","text":"Eigen::Vector3d eta2 {0.0, 0.0, 0.0};","title":"variable eta2"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structOutput__t/#variable-v1","text":"Eigen::Vector3d v1 {0.0, 0.0, 0.0};","title":"variable v1"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structOutput__t/#variable-v2","text":"Eigen::Vector3d v2 {0.0, 0.0, 0.0}; Updated on 2022-05-30 at 14:56:46 +0000","title":"variable v2"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structVehicle__t/","text":"Vehicle_t Vehicle state struct. Contains position, orientation and linear and angular velocities. #include <wp_controller.h> Public Attributes Name Eigen::Vector3d eta1 Eigen::Vector3d eta2 Eigen::Vector3d v1 Eigen::Vector3d v2 Public Attributes Documentation variable eta1 Eigen::Vector3d eta1 {0.0, 0.0, 0.0}; variable eta2 Eigen::Vector3d eta2 {0.0, 0.0, 0.0}; variable v1 Eigen::Vector3d v1 {0.0, 0.0, 0.0}; variable v2 Eigen::Vector3d v2 {0.0, 0.0, 0.0}; Updated on 2022-05-30 at 14:56:46 +0000","title":"Vehicle_t"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structVehicle__t/#vehicle_t","text":"Vehicle state struct. Contains position, orientation and linear and angular velocities. #include <wp_controller.h>","title":"Vehicle_t"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structVehicle__t/#public-attributes","text":"Name Eigen::Vector3d eta1 Eigen::Vector3d eta2 Eigen::Vector3d v1 Eigen::Vector3d v2","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structVehicle__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structVehicle__t/#variable-eta1","text":"Eigen::Vector3d eta1 {0.0, 0.0, 0.0};","title":"variable eta1"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structVehicle__t/#variable-eta2","text":"Eigen::Vector3d eta2 {0.0, 0.0, 0.0};","title":"variable eta2"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structVehicle__t/#variable-v1","text":"Eigen::Vector3d v1 {0.0, 0.0, 0.0};","title":"variable v1"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structVehicle__t/#variable-v2","text":"Eigen::Vector3d v2 {0.0, 0.0, 0.0}; Updated on 2022-05-30 at 14:56:46 +0000","title":"variable v2"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structWPref__t/","text":"WPref_t Waypoint reference struct. Contains references for poistion and orientations. Not everything needs to be used. #include <wp_controller.h> Public Attributes Name Eigen::Vector3d eta1 Eigen::Vector3d eta2 Public Attributes Documentation variable eta1 Eigen::Vector3d eta1 {0.0, 0.0, 0.0}; variable eta2 Eigen::Vector3d eta2 {0.0, 0.0, 0.0}; Updated on 2022-05-30 at 14:56:46 +0000","title":"WPref_t"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structWPref__t/#wpref_t","text":"Waypoint reference struct. Contains references for poistion and orientations. Not everything needs to be used. #include <wp_controller.h>","title":"WPref_t"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structWPref__t/#public-attributes","text":"Name Eigen::Vector3d eta1 Eigen::Vector3d eta2","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structWPref__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structWPref__t/#variable-eta1","text":"Eigen::Vector3d eta1 {0.0, 0.0, 0.0};","title":"variable eta1"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Classes/structWPref__t/#variable-eta2","text":"Eigen::Vector3d eta2 {0.0, 0.0, 0.0}; Updated on 2022-05-30 at 14:56:46 +0000","title":"variable eta2"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Examples/","text":"Examples Updated on 2022-05-30 at 14:56:46 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Examples/#examples","text":"Updated on 2022-05-30 at 14:56:46 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Modules/","text":"Modules Updated on 2022-05-30 at 14:56:46 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Modules/#modules","text":"Updated on 2022-05-30 at 14:56:46 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Namespaces/","text":"Namespaces Updated on 2022-05-30 at 14:56:46 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_control/outer_loops_controllers/waypoint/Namespaces/#namespaces","text":"Updated on 2022-05-30 at 14:56:46 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Classes/","text":"Classes class ThrustAllocation ROS implementation of the thrust allocation. Receives forces applied to the vehicle and calculates the desired forces to each thruster based on the pseudo inverse of the thrust allocation matrix. Updated on 2022-05-30 at 14:56:46 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Classes/#classes","text":"class ThrustAllocation ROS implementation of the thrust allocation. Receives forces applied to the vehicle and calculates the desired forces to each thruster based on the pseudo inverse of the thrust allocation matrix. Updated on 2022-05-30 at 14:56:46 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Classes/classThrustAllocation/","text":"ThrustAllocation ROS implementation of the thrust allocation. Receives forces applied to the vehicle and calculates the desired forces to each thruster based on the pseudo inverse of the thrust allocation matrix. #include <thruster_allocation.h> Public Functions Name ThrustAllocation (ros::NodeHandle & nh) Thrust Allocation class constructor. void initializeSubscribers (ros::NodeHandle & nh) Function to initialize subscribers. void initializePublishers (ros::NodeHandle & nh) Function to initialize publishers. void loadParams (ros::NodeHandle & nh) Function to read parameters. Reads the thruster allocation matrix and computes its pseudo inverse. void saturateVector (Eigen::VectorXd & thr_thrust) Given a force vector for each thruster, saturate the norm of the vector based on the maximum force of the thruster. void readTAM (ros::NodeHandle & nh) Function to read a thruster allocation matrix and compute its pseudo inverse. void readCT (ros::NodeHandle & nh) Function to read the ct parameters (conversion from thrust to RPM and vice versa) void readRPMGain (ros::NodeHandle & nh) Function to read the actuators gain (RPM max value / 100). void thrusterAllocation (const auv_msgs::BodyForceRequest & msg) Callback function of the topic with the tau (force request) Public Functions Documentation function ThrustAllocation ThrustAllocation( ros::NodeHandle & nh ) Thrust Allocation class constructor. Parameters : nh ROS nodehandle to publish, subscribe and read relevant parameters function initializeSubscribers void initializeSubscribers( ros::NodeHandle & nh ) Function to initialize subscribers. Parameters : nh ROS nodehandle to publish, subscribe and read relevant function initializePublishers void initializePublishers( ros::NodeHandle & nh ) Function to initialize publishers. Parameters : nh ROS nodehandle to publish, subscribe and read relevant function loadParams void loadParams( ros::NodeHandle & nh ) Function to read parameters. Reads the thruster allocation matrix and computes its pseudo inverse. Parameters : nh ROS nodehandle to publish, subscribe and read relevant function saturateVector void saturateVector( Eigen::VectorXd & thr_thrust ) Given a force vector for each thruster, saturate the norm of the vector based on the maximum force of the thruster. function readTAM void readTAM( ros::NodeHandle & nh ) Function to read a thruster allocation matrix and compute its pseudo inverse. Parameters : nh function readCT void readCT( ros::NodeHandle & nh ) Function to read the ct parameters (conversion from thrust to RPM and vice versa) Parameters : nh function readRPMGain void readRPMGain( ros::NodeHandle & nh ) Function to read the actuators gain (RPM max value / 100). Parameters : nh function thrusterAllocation void thrusterAllocation( const auv_msgs::BodyForceRequest & msg ) Callback function of the topic with the tau (force request) Parameters : msg Variable containing the force request Updated on 2022-05-30 at 14:56:46 +0000","title":"ThrustAllocation"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Classes/classThrustAllocation/#thrustallocation","text":"ROS implementation of the thrust allocation. Receives forces applied to the vehicle and calculates the desired forces to each thruster based on the pseudo inverse of the thrust allocation matrix. #include <thruster_allocation.h>","title":"ThrustAllocation"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Classes/classThrustAllocation/#public-functions","text":"Name ThrustAllocation (ros::NodeHandle & nh) Thrust Allocation class constructor. void initializeSubscribers (ros::NodeHandle & nh) Function to initialize subscribers. void initializePublishers (ros::NodeHandle & nh) Function to initialize publishers. void loadParams (ros::NodeHandle & nh) Function to read parameters. Reads the thruster allocation matrix and computes its pseudo inverse. void saturateVector (Eigen::VectorXd & thr_thrust) Given a force vector for each thruster, saturate the norm of the vector based on the maximum force of the thruster. void readTAM (ros::NodeHandle & nh) Function to read a thruster allocation matrix and compute its pseudo inverse. void readCT (ros::NodeHandle & nh) Function to read the ct parameters (conversion from thrust to RPM and vice versa) void readRPMGain (ros::NodeHandle & nh) Function to read the actuators gain (RPM max value / 100). void thrusterAllocation (const auv_msgs::BodyForceRequest & msg) Callback function of the topic with the tau (force request)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Classes/classThrustAllocation/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Classes/classThrustAllocation/#function-thrustallocation","text":"ThrustAllocation( ros::NodeHandle & nh ) Thrust Allocation class constructor. Parameters : nh ROS nodehandle to publish, subscribe and read relevant parameters","title":"function ThrustAllocation"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Classes/classThrustAllocation/#function-initializesubscribers","text":"void initializeSubscribers( ros::NodeHandle & nh ) Function to initialize subscribers. Parameters : nh ROS nodehandle to publish, subscribe and read relevant","title":"function initializeSubscribers"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Classes/classThrustAllocation/#function-initializepublishers","text":"void initializePublishers( ros::NodeHandle & nh ) Function to initialize publishers. Parameters : nh ROS nodehandle to publish, subscribe and read relevant","title":"function initializePublishers"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Classes/classThrustAllocation/#function-loadparams","text":"void loadParams( ros::NodeHandle & nh ) Function to read parameters. Reads the thruster allocation matrix and computes its pseudo inverse. Parameters : nh ROS nodehandle to publish, subscribe and read relevant","title":"function loadParams"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Classes/classThrustAllocation/#function-saturatevector","text":"void saturateVector( Eigen::VectorXd & thr_thrust ) Given a force vector for each thruster, saturate the norm of the vector based on the maximum force of the thruster.","title":"function saturateVector"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Classes/classThrustAllocation/#function-readtam","text":"void readTAM( ros::NodeHandle & nh ) Function to read a thruster allocation matrix and compute its pseudo inverse. Parameters : nh","title":"function readTAM"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Classes/classThrustAllocation/#function-readct","text":"void readCT( ros::NodeHandle & nh ) Function to read the ct parameters (conversion from thrust to RPM and vice versa) Parameters : nh","title":"function readCT"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Classes/classThrustAllocation/#function-readrpmgain","text":"void readRPMGain( ros::NodeHandle & nh ) Function to read the actuators gain (RPM max value / 100). Parameters : nh","title":"function readRPMGain"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Classes/classThrustAllocation/#function-thrusterallocation","text":"void thrusterAllocation( const auv_msgs::BodyForceRequest & msg ) Callback function of the topic with the tau (force request) Parameters : msg Variable containing the force request Updated on 2022-05-30 at 14:56:46 +0000","title":"function thrusterAllocation"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Examples/","text":"Examples Updated on 2022-05-30 at 14:56:46 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Examples/#examples","text":"Updated on 2022-05-30 at 14:56:46 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Modules/","text":"Modules Updated on 2022-05-30 at 14:56:46 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Modules/#modules","text":"Updated on 2022-05-30 at 14:56:46 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Namespaces/","text":"Namespaces Updated on 2022-05-30 at 14:56:46 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_control/static_thruster_allocation/Namespaces/#namespaces","text":"Updated on 2022-05-30 at 14:56:46 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_control/vehicle_stabilizer/Classes/","text":"Classes class VehicleStabilizerNode Updated on 2022-05-30 at 14:56:46 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_control/vehicle_stabilizer/Classes/#classes","text":"class VehicleStabilizerNode Updated on 2022-05-30 at 14:56:46 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_control/vehicle_stabilizer/Classes/classVehicleStabilizerNode/","text":"VehicleStabilizerNode Public Functions Name VehicleStabilizerNode (ros::NodeHandle * nh, ros::NodeHandle * nh_p) ~VehicleStabilizerNode () Public Functions Documentation function VehicleStabilizerNode VehicleStabilizerNode( ros::NodeHandle * nh, ros::NodeHandle * nh_p ) Parameters : nh The public ROS nodehandle nh_p The private ROS nodehandle function ~VehicleStabilizerNode ~VehicleStabilizerNode() Destructor of the VehicleStabilizerNode class Updated on 2022-05-30 at 14:56:46 +0000","title":"VehicleStabilizerNode"},{"location":"api/markdown/medusa_base/medusa_control/vehicle_stabilizer/Classes/classVehicleStabilizerNode/#vehiclestabilizernode","text":"","title":"VehicleStabilizerNode"},{"location":"api/markdown/medusa_base/medusa_control/vehicle_stabilizer/Classes/classVehicleStabilizerNode/#public-functions","text":"Name VehicleStabilizerNode (ros::NodeHandle * nh, ros::NodeHandle * nh_p) ~VehicleStabilizerNode ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_control/vehicle_stabilizer/Classes/classVehicleStabilizerNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_control/vehicle_stabilizer/Classes/classVehicleStabilizerNode/#function-vehiclestabilizernode","text":"VehicleStabilizerNode( ros::NodeHandle * nh, ros::NodeHandle * nh_p ) Parameters : nh The public ROS nodehandle nh_p The private ROS nodehandle","title":"function VehicleStabilizerNode"},{"location":"api/markdown/medusa_base/medusa_control/vehicle_stabilizer/Classes/classVehicleStabilizerNode/#function-vehiclestabilizernode_1","text":"~VehicleStabilizerNode() Destructor of the VehicleStabilizerNode class Updated on 2022-05-30 at 14:56:46 +0000","title":"function ~VehicleStabilizerNode"},{"location":"api/markdown/medusa_base/medusa_control/vehicle_stabilizer/Examples/","text":"Examples Updated on 2022-05-30 at 14:56:46 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_control/vehicle_stabilizer/Examples/#examples","text":"Updated on 2022-05-30 at 14:56:46 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_control/vehicle_stabilizer/Modules/","text":"Modules Updated on 2022-05-30 at 14:56:46 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_control/vehicle_stabilizer/Modules/#modules","text":"Updated on 2022-05-30 at 14:56:46 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_control/vehicle_stabilizer/Namespaces/","text":"Namespaces Updated on 2022-05-30 at 14:56:46 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_control/vehicle_stabilizer/Namespaces/#namespaces","text":"Updated on 2022-05-30 at 14:56:46 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/","text":"Classes class AuvState2mState class Gnss2Utm class Gnss2UtmOutlier class LowPassFilter class SmoothState class UsblFix2Pos Updated on 2022-05-30 at 14:56:45 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/#classes","text":"class AuvState2mState class Gnss2Utm class Gnss2UtmOutlier class LowPassFilter class SmoothState class UsblFix2Pos Updated on 2022-05-30 at 14:56:45 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classAuvState2mState/","text":"AuvState2mState Public Functions Name AuvState2mState (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~AuvState2mState () Public Functions Documentation function AuvState2mState AuvState2mState( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private ) function ~AuvState2mState ~AuvState2mState() Updated on 2022-05-30 at 14:56:45 +0000","title":"AuvState2mState"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classAuvState2mState/#auvstate2mstate","text":"","title":"AuvState2mState"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classAuvState2mState/#public-functions","text":"Name AuvState2mState (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~AuvState2mState ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classAuvState2mState/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classAuvState2mState/#function-auvstate2mstate","text":"AuvState2mState( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private )","title":"function AuvState2mState"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classAuvState2mState/#function-auvstate2mstate_1","text":"~AuvState2mState() Updated on 2022-05-30 at 14:56:45 +0000","title":"function ~AuvState2mState"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classGnss2Utm/","text":"Gnss2Utm Public Functions Name Gnss2Utm (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~Gnss2Utm () Public Functions Documentation function Gnss2Utm Gnss2Utm( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private ) function ~Gnss2Utm ~Gnss2Utm() Updated on 2022-05-30 at 14:56:45 +0000","title":"Gnss2Utm"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classGnss2Utm/#gnss2utm","text":"","title":"Gnss2Utm"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classGnss2Utm/#public-functions","text":"Name Gnss2Utm (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~Gnss2Utm ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classGnss2Utm/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classGnss2Utm/#function-gnss2utm","text":"Gnss2Utm( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private )","title":"function Gnss2Utm"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classGnss2Utm/#function-gnss2utm_1","text":"~Gnss2Utm() Updated on 2022-05-30 at 14:56:45 +0000","title":"function ~Gnss2Utm"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classGnss2UtmOutlier/","text":"Gnss2UtmOutlier Public Functions Name Gnss2UtmOutlier (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~Gnss2UtmOutlier () Public Functions Documentation function Gnss2UtmOutlier Gnss2UtmOutlier( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private ) function ~Gnss2UtmOutlier ~Gnss2UtmOutlier() Updated on 2022-05-30 at 14:56:45 +0000","title":"Gnss2UtmOutlier"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classGnss2UtmOutlier/#gnss2utmoutlier","text":"","title":"Gnss2UtmOutlier"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classGnss2UtmOutlier/#public-functions","text":"Name Gnss2UtmOutlier (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~Gnss2UtmOutlier ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classGnss2UtmOutlier/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classGnss2UtmOutlier/#function-gnss2utmoutlier","text":"Gnss2UtmOutlier( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private )","title":"function Gnss2UtmOutlier"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classGnss2UtmOutlier/#function-gnss2utmoutlier_1","text":"~Gnss2UtmOutlier() Updated on 2022-05-30 at 14:56:45 +0000","title":"function ~Gnss2UtmOutlier"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/","text":"LowPassFilter Public Functions Name LowPassFilter () LowPassFilter (double wn, double qsi) LowPassFilter (double wn, double qsi, bool initialize_on_first) LowPassFilter (double wn, double qsi, double var_init, double var_dot_init) ~LowPassFilter () std::pair< double, double > update (double measurement) std::pair< double, double > predict () Public Attributes Name bool initialized Protected Attributes Name double wn double qsi double K1 double K2 std::pair< double, double > estimate ros::Time last_Update Public Functions Documentation function LowPassFilter inline LowPassFilter() function LowPassFilter inline LowPassFilter( double wn, double qsi ) function LowPassFilter inline LowPassFilter( double wn, double qsi, bool initialize_on_first ) function LowPassFilter inline LowPassFilter( double wn, double qsi, double var_init, double var_dot_init ) function ~LowPassFilter inline ~LowPassFilter() function update inline std::pair< double, double > update( double measurement ) function predict inline std::pair< double, double > predict() Public Attributes Documentation variable initialized bool initialized; Protected Attributes Documentation variable wn double wn; variable qsi double qsi; variable K1 double K1; variable K2 double K2; variable estimate std::pair< double, double > estimate; variable last_Update ros::Time last_Update; Updated on 2022-05-30 at 14:56:45 +0000","title":"LowPassFilter"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#lowpassfilter","text":"","title":"LowPassFilter"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#public-functions","text":"Name LowPassFilter () LowPassFilter (double wn, double qsi) LowPassFilter (double wn, double qsi, bool initialize_on_first) LowPassFilter (double wn, double qsi, double var_init, double var_dot_init) ~LowPassFilter () std::pair< double, double > update (double measurement) std::pair< double, double > predict ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#public-attributes","text":"Name bool initialized","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#protected-attributes","text":"Name double wn double qsi double K1 double K2 std::pair< double, double > estimate ros::Time last_Update","title":"Protected Attributes"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#function-lowpassfilter","text":"inline LowPassFilter()","title":"function LowPassFilter"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#function-lowpassfilter_1","text":"inline LowPassFilter( double wn, double qsi )","title":"function LowPassFilter"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#function-lowpassfilter_2","text":"inline LowPassFilter( double wn, double qsi, bool initialize_on_first )","title":"function LowPassFilter"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#function-lowpassfilter_3","text":"inline LowPassFilter( double wn, double qsi, double var_init, double var_dot_init )","title":"function LowPassFilter"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#function-lowpassfilter_4","text":"inline ~LowPassFilter()","title":"function ~LowPassFilter"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#function-update","text":"inline std::pair< double, double > update( double measurement )","title":"function update"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#function-predict","text":"inline std::pair< double, double > predict()","title":"function predict"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#variable-initialized","text":"bool initialized;","title":"variable initialized"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#variable-wn","text":"double wn;","title":"variable wn"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#variable-qsi","text":"double qsi;","title":"variable qsi"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#variable-k1","text":"double K1;","title":"variable K1"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#variable-k2","text":"double K2;","title":"variable K2"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#variable-estimate","text":"std::pair< double, double > estimate;","title":"variable estimate"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classLowPassFilter/#variable-last_update","text":"ros::Time last_Update; Updated on 2022-05-30 at 14:56:45 +0000","title":"variable last_Update"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classSmoothState/","text":"SmoothState Public Functions Name SmoothState (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~SmoothState () Public Functions Documentation function SmoothState SmoothState( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private ) function ~SmoothState ~SmoothState() Updated on 2022-05-30 at 14:56:45 +0000","title":"SmoothState"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classSmoothState/#smoothstate","text":"","title":"SmoothState"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classSmoothState/#public-functions","text":"Name SmoothState (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~SmoothState ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classSmoothState/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classSmoothState/#function-smoothstate","text":"SmoothState( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private )","title":"function SmoothState"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classSmoothState/#function-smoothstate_1","text":"~SmoothState() Updated on 2022-05-30 at 14:56:45 +0000","title":"function ~SmoothState"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classUsblFix2Pos/","text":"UsblFix2Pos Public Functions Name UsblFix2Pos (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~UsblFix2Pos () Public Functions Documentation function UsblFix2Pos UsblFix2Pos( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private ) function ~UsblFix2Pos ~UsblFix2Pos() Updated on 2022-05-30 at 14:56:45 +0000","title":"UsblFix2Pos"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classUsblFix2Pos/#usblfix2pos","text":"","title":"UsblFix2Pos"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classUsblFix2Pos/#public-functions","text":"Name UsblFix2Pos (ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private) ~UsblFix2Pos ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classUsblFix2Pos/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classUsblFix2Pos/#function-usblfix2pos","text":"UsblFix2Pos( ros::NodeHandle * nodehandle, ros::NodeHandle * nodehandle_private )","title":"function UsblFix2Pos"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Classes/classUsblFix2Pos/#function-usblfix2pos_1","text":"~UsblFix2Pos() Updated on 2022-05-30 at 14:56:45 +0000","title":"function ~UsblFix2Pos"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Examples/","text":"Examples Updated on 2022-05-30 at 14:56:45 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Examples/#examples","text":"Updated on 2022-05-30 at 14:56:45 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Modules/","text":"Modules Updated on 2022-05-30 at 14:56:45 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Modules/#modules","text":"Updated on 2022-05-30 at 14:56:45 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Namespaces/","text":"Namespaces Updated on 2022-05-30 at 14:56:45 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_nav/nav_tools/Namespaces/#namespaces","text":"Updated on 2022-05-30 at 14:56:45 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/","text":"Classes class DeadReckoning DeadReckoning class. namespace FilterGimmicks FilterGimmicks namespace. struct measurement Define a measurement object. struct predicate_frame_id Predicate to find a giver frame_id among a list of frame_id. class FiltersNode FiltersNode class. class HorizontalFilter Horizontal Filter class. struct config class RotationalFilter This Class estimates the state of the vehicle in the rotational frame. The state includes orientation and angular velocity. The latest state estimate of the filter is obtained using the function computePredict() . Measurement updates to the filter is done using newMeasurement() . struct config class VerticalFilter This Class estimates the state of the vehicle in the horizontal frame. The state includes depth, velocity, altitude, and bouyancy. The latest state estimate of the filter is obtained using the exposed function getEstimate(). Measurement updates to the filter is done either using measCallback(). struct config Updated on 2022-05-30 at 14:56:46 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/#classes","text":"class DeadReckoning DeadReckoning class. namespace FilterGimmicks FilterGimmicks namespace. struct measurement Define a measurement object. struct predicate_frame_id Predicate to find a giver frame_id among a list of frame_id. class FiltersNode FiltersNode class. class HorizontalFilter Horizontal Filter class. struct config class RotationalFilter This Class estimates the state of the vehicle in the rotational frame. The state includes orientation and angular velocity. The latest state estimate of the filter is obtained using the function computePredict() . Measurement updates to the filter is done using newMeasurement() . struct config class VerticalFilter This Class estimates the state of the vehicle in the horizontal frame. The state includes depth, velocity, altitude, and bouyancy. The latest state estimate of the filter is obtained using the exposed function getEstimate(). Measurement updates to the filter is done either using measCallback(). struct config Updated on 2022-05-30 at 14:56:46 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classDeadReckoning/","text":"DeadReckoning DeadReckoning class. More... #include <DeadReckoning.h> Public Functions Name DeadReckoning (ros::NodeHandle * nh, ros::NodeHandle * nh_private) Contructor DeadReckoning . ~DeadReckoning () Desctructor DeadReckoning . void computePredict () Propagate the state to the current time. Detailed Description class DeadReckoning; DeadReckoning class. Note : This node only outputs useful information when dvl is present Every time a new mission is deployed (FLAG=6), the DR is reseted to the current navigation state(x,y) Public Functions Documentation function DeadReckoning DeadReckoning( ros::NodeHandle * nh, ros::NodeHandle * nh_private ) Contructor DeadReckoning . function ~DeadReckoning ~DeadReckoning() Desctructor DeadReckoning . function computePredict void computePredict() Propagate the state to the current time. Return : Success or Failure Updated on 2022-05-30 at 14:56:46 +0000","title":"DeadReckoning"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classDeadReckoning/#deadreckoning","text":"DeadReckoning class. More... #include <DeadReckoning.h>","title":"DeadReckoning"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classDeadReckoning/#public-functions","text":"Name DeadReckoning (ros::NodeHandle * nh, ros::NodeHandle * nh_private) Contructor DeadReckoning . ~DeadReckoning () Desctructor DeadReckoning . void computePredict () Propagate the state to the current time.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classDeadReckoning/#detailed-description","text":"class DeadReckoning; DeadReckoning class. Note : This node only outputs useful information when dvl is present Every time a new mission is deployed (FLAG=6), the DR is reseted to the current navigation state(x,y)","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classDeadReckoning/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classDeadReckoning/#function-deadreckoning","text":"DeadReckoning( ros::NodeHandle * nh, ros::NodeHandle * nh_private ) Contructor DeadReckoning .","title":"function DeadReckoning"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classDeadReckoning/#function-deadreckoning_1","text":"~DeadReckoning() Desctructor DeadReckoning .","title":"function ~DeadReckoning"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classDeadReckoning/#function-computepredict","text":"void computePredict() Propagate the state to the current time. Return : Success or Failure Updated on 2022-05-30 at 14:56:46 +0000","title":"function computePredict"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classFiltersNode/","text":"FiltersNode FiltersNode class. More... #include <FiltersNode.h> Public Functions Name FiltersNode (ros::NodeHandle * nh, ros::NodeHandle * nh_private) Constructor. ~FiltersNode () Destructor. double nodeFrequency () Defines the node frequency. Detailed Description class FiltersNode; FiltersNode class. Note : Read all the parameters for each filter(Horicontal, Rotations, Vertical), and configures them. Takes care of the iteration using timer. Also responsible for controlling the measurement buffer of the horizontal filter. Public Functions Documentation function FiltersNode FiltersNode( ros::NodeHandle * nh, ros::NodeHandle * nh_private ) Constructor. Parameters : nh node handle nh_private node handle private function ~FiltersNode ~FiltersNode() Destructor. function nodeFrequency double nodeFrequency() Defines the node frequency. Return : Node frequency Updated on 2022-05-30 at 14:56:46 +0000","title":"FiltersNode"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classFiltersNode/#filtersnode","text":"FiltersNode class. More... #include <FiltersNode.h>","title":"FiltersNode"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classFiltersNode/#public-functions","text":"Name FiltersNode (ros::NodeHandle * nh, ros::NodeHandle * nh_private) Constructor. ~FiltersNode () Destructor. double nodeFrequency () Defines the node frequency.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classFiltersNode/#detailed-description","text":"class FiltersNode; FiltersNode class. Note : Read all the parameters for each filter(Horicontal, Rotations, Vertical), and configures them. Takes care of the iteration using timer. Also responsible for controlling the measurement buffer of the horizontal filter.","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classFiltersNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classFiltersNode/#function-filtersnode","text":"FiltersNode( ros::NodeHandle * nh, ros::NodeHandle * nh_private ) Constructor. Parameters : nh node handle nh_private node handle private","title":"function FiltersNode"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classFiltersNode/#function-filtersnode_1","text":"~FiltersNode() Destructor.","title":"function ~FiltersNode"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classFiltersNode/#function-nodefrequency","text":"double nodeFrequency() Defines the node frequency. Return : Node frequency Updated on 2022-05-30 at 14:56:46 +0000","title":"function nodeFrequency"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/","text":"HorizontalFilter Horizontal Filter class. More... #include <HorizontalFilter.h> Public Classes Name struct config Public Functions Name HorizontalFilter () Contructor Horizontal Filter. virtual ~HorizontalFilter () =default Desctructor Horizontal Filter. bool computePredict (auv_msgs::NavigationStatus & state, const ros::Time & t_request) Propagate the state to the current time. void configure ( HorizontalFilter::config & configurations) Configure filter variables and set initialization conditions. void newMeasurement ( FilterGimmicks::measurement & m) Tranforms the measurement from the sensor frame to the filter world frame. Calls addMeasurement and forwardPropagation methods. void deleteMeasurementsInBuffer () Clears all measurements older than a timer period defined in save_meas_interval. std::vector< double > getExtimateCurrents () Returns the currents. void resetFilter () Reset horizontal filter. Public Attributes Name const static int MEAS_LEN const static int STATE_LEN Detailed Description class HorizontalFilter; Horizontal Filter class. Note : This Class estimates the state of the vehicle in the horizontal frame. The state includes position, velocity, acceleration and currents. The latest state estimate of the filter is obtained using the exposed function getEstimate(). Measurement updates to the filter is done either using measCallback() and the latest state estimate is accessed using getEstimate(). Water currents are estimated but the output is not exposed to the user. Public Functions Documentation function HorizontalFilter HorizontalFilter() Contructor Horizontal Filter. function ~HorizontalFilter virtual ~HorizontalFilter() =default Desctructor Horizontal Filter. function computePredict bool computePredict( auv_msgs::NavigationStatus & state, const ros::Time & t_request ) Propagate the state to the current time. Parameters : state State vector t_request current time Return : Success or Failure function configure void configure( HorizontalFilter::config & configurations ) Configure filter variables and set initialization conditions. Parameters : configurations function newMeasurement void newMeasurement( FilterGimmicks::measurement & m ) Tranforms the measurement from the sensor frame to the filter world frame. Calls addMeasurement and forwardPropagation methods. Parameters : msg New measurement function deleteMeasurementsInBuffer void deleteMeasurementsInBuffer() Clears all measurements older than a timer period defined in save_meas_interval. function getExtimateCurrents std::vector< double > getExtimateCurrents() Returns the currents. Return : x_current, y_current function resetFilter void resetFilter() Reset horizontal filter. Public Attributes Documentation variable MEAS_LEN static const static int MEAS_LEN = 6; variable STATE_LEN static const static int STATE_LEN = 8; Updated on 2022-05-30 at 14:56:46 +0000","title":"HorizontalFilter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#horizontalfilter","text":"Horizontal Filter class. More... #include <HorizontalFilter.h>","title":"HorizontalFilter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#public-classes","text":"Name struct config","title":"Public Classes"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#public-functions","text":"Name HorizontalFilter () Contructor Horizontal Filter. virtual ~HorizontalFilter () =default Desctructor Horizontal Filter. bool computePredict (auv_msgs::NavigationStatus & state, const ros::Time & t_request) Propagate the state to the current time. void configure ( HorizontalFilter::config & configurations) Configure filter variables and set initialization conditions. void newMeasurement ( FilterGimmicks::measurement & m) Tranforms the measurement from the sensor frame to the filter world frame. Calls addMeasurement and forwardPropagation methods. void deleteMeasurementsInBuffer () Clears all measurements older than a timer period defined in save_meas_interval. std::vector< double > getExtimateCurrents () Returns the currents. void resetFilter () Reset horizontal filter.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#public-attributes","text":"Name const static int MEAS_LEN const static int STATE_LEN","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#detailed-description","text":"class HorizontalFilter; Horizontal Filter class. Note : This Class estimates the state of the vehicle in the horizontal frame. The state includes position, velocity, acceleration and currents. The latest state estimate of the filter is obtained using the exposed function getEstimate(). Measurement updates to the filter is done either using measCallback() and the latest state estimate is accessed using getEstimate(). Water currents are estimated but the output is not exposed to the user.","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#function-horizontalfilter","text":"HorizontalFilter() Contructor Horizontal Filter.","title":"function HorizontalFilter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#function-horizontalfilter_1","text":"virtual ~HorizontalFilter() =default Desctructor Horizontal Filter.","title":"function ~HorizontalFilter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#function-computepredict","text":"bool computePredict( auv_msgs::NavigationStatus & state, const ros::Time & t_request ) Propagate the state to the current time. Parameters : state State vector t_request current time Return : Success or Failure","title":"function computePredict"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#function-configure","text":"void configure( HorizontalFilter::config & configurations ) Configure filter variables and set initialization conditions. Parameters : configurations","title":"function configure"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#function-newmeasurement","text":"void newMeasurement( FilterGimmicks::measurement & m ) Tranforms the measurement from the sensor frame to the filter world frame. Calls addMeasurement and forwardPropagation methods. Parameters : msg New measurement","title":"function newMeasurement"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#function-deletemeasurementsinbuffer","text":"void deleteMeasurementsInBuffer() Clears all measurements older than a timer period defined in save_meas_interval.","title":"function deleteMeasurementsInBuffer"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#function-getextimatecurrents","text":"std::vector< double > getExtimateCurrents() Returns the currents. Return : x_current, y_current","title":"function getExtimateCurrents"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#function-resetfilter","text":"void resetFilter() Reset horizontal filter.","title":"function resetFilter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#variable-meas_len","text":"static const static int MEAS_LEN = 6;","title":"variable MEAS_LEN"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classHorizontalFilter/#variable-state_len","text":"static const static int STATE_LEN = 8; Updated on 2022-05-30 at 14:56:46 +0000","title":"variable STATE_LEN"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classRotationalFilter/","text":"RotationalFilter This Class estimates the state of the vehicle in the rotational frame. The state includes orientation and angular velocity. The latest state estimate of the filter is obtained using the function computePredict() . Measurement updates to the filter is done using newMeasurement() . #include <RotationalFilter.h> Public Classes Name struct config Public Functions Name RotationalFilter () Rotational Filter Constructor. virtual ~RotationalFilter () =default Rotational Filter Destructor. void computePredict (auv_msgs::NavigationStatus & state, const ros::Time & t_request) Progate the state to the time t_request. void configure (const config configurations) configure filter program variables and may initializes the filter void newMeasurement (const FilterGimmicks::measurement & m) Checks and processes a new measurement. void resetFilter () Reset the horizontal filter. Public Attributes Name const int STATE_LEN double PI Public Functions Documentation function RotationalFilter RotationalFilter() Rotational Filter Constructor. function ~RotationalFilter virtual ~RotationalFilter() =default Rotational Filter Destructor. function computePredict void computePredict( auv_msgs::NavigationStatus & state, const ros::Time & t_request ) Progate the state to the time t_request. Parameters : state t_request Note : Why have we used TF here? We want: Rotation of base_link wrt world, i.e. header = world, child = base_link (TFwb). I have: 1. static_tf - Rotation of imu wrt base_link, i.e. header = base_link, child = imu (TFbi); 2. sensor output - Rotation of imu wrt world, i.e. header = world, child = imu (TFwi). Solution: TFwb = TFwi * (TFbi)^-1 function configure void configure( const config configurations ) configure filter program variables and may initializes the filter Parameters : configurations struct to store configurations from yaml file function newMeasurement void newMeasurement( const FilterGimmicks::measurement & m ) Checks and processes a new measurement. Parameters : m measurement function resetFilter void resetFilter() Reset the horizontal filter. Public Attributes Documentation variable STATE_LEN static const int STATE_LEN = 6; variable PI double PI = 3.1415926; Updated on 2022-05-30 at 14:56:46 +0000","title":"RotationalFilter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classRotationalFilter/#rotationalfilter","text":"This Class estimates the state of the vehicle in the rotational frame. The state includes orientation and angular velocity. The latest state estimate of the filter is obtained using the function computePredict() . Measurement updates to the filter is done using newMeasurement() . #include <RotationalFilter.h>","title":"RotationalFilter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classRotationalFilter/#public-classes","text":"Name struct config","title":"Public Classes"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classRotationalFilter/#public-functions","text":"Name RotationalFilter () Rotational Filter Constructor. virtual ~RotationalFilter () =default Rotational Filter Destructor. void computePredict (auv_msgs::NavigationStatus & state, const ros::Time & t_request) Progate the state to the time t_request. void configure (const config configurations) configure filter program variables and may initializes the filter void newMeasurement (const FilterGimmicks::measurement & m) Checks and processes a new measurement. void resetFilter () Reset the horizontal filter.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classRotationalFilter/#public-attributes","text":"Name const int STATE_LEN double PI","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classRotationalFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classRotationalFilter/#function-rotationalfilter","text":"RotationalFilter() Rotational Filter Constructor.","title":"function RotationalFilter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classRotationalFilter/#function-rotationalfilter_1","text":"virtual ~RotationalFilter() =default Rotational Filter Destructor.","title":"function ~RotationalFilter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classRotationalFilter/#function-computepredict","text":"void computePredict( auv_msgs::NavigationStatus & state, const ros::Time & t_request ) Progate the state to the time t_request. Parameters : state t_request Note : Why have we used TF here? We want: Rotation of base_link wrt world, i.e. header = world, child = base_link (TFwb). I have: 1. static_tf - Rotation of imu wrt base_link, i.e. header = base_link, child = imu (TFbi); 2. sensor output - Rotation of imu wrt world, i.e. header = world, child = imu (TFwi). Solution: TFwb = TFwi * (TFbi)^-1","title":"function computePredict"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classRotationalFilter/#function-configure","text":"void configure( const config configurations ) configure filter program variables and may initializes the filter Parameters : configurations struct to store configurations from yaml file","title":"function configure"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classRotationalFilter/#function-newmeasurement","text":"void newMeasurement( const FilterGimmicks::measurement & m ) Checks and processes a new measurement. Parameters : m measurement","title":"function newMeasurement"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classRotationalFilter/#function-resetfilter","text":"void resetFilter() Reset the horizontal filter.","title":"function resetFilter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classRotationalFilter/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classRotationalFilter/#variable-state_len","text":"static const int STATE_LEN = 6;","title":"variable STATE_LEN"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classRotationalFilter/#variable-pi","text":"double PI = 3.1415926; Updated on 2022-05-30 at 14:56:46 +0000","title":"variable PI"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classVerticalFilter/","text":"VerticalFilter This Class estimates the state of the vehicle in the horizontal frame. The state includes depth, velocity, altitude, and bouyancy. The latest state estimate of the filter is obtained using the exposed function getEstimate(). Measurement updates to the filter is done either using measCallback(). More... #include <VerticalFilter.h> Public Classes Name struct config Public Functions Name VerticalFilter () Constructor. virtual ~VerticalFilter () =default Destructor. void configure (const VerticalFilter::config configurations) Configure filter program variables and set initialization conditions. void computePredict (auv_msgs::NavigationStatus & state, ros::Time t_request) Propagate the state to the current time. void newMeasurement (const FilterGimmicks::measurement & m) Checks and processes a new measurement. void resetFilter () Resets the filter, will require re-initialization to start back update again. Public Attributes Name const int MEAS_LEN Measurement length. Detailed Description class VerticalFilter; This Class estimates the state of the vehicle in the horizontal frame. The state includes depth, velocity, altitude, and bouyancy. The latest state estimate of the filter is obtained using the exposed function getEstimate(). Measurement updates to the filter is done either using measCallback(). @Note Bouyancy is estimated but the output is not exposed to the user. Public Functions Documentation function VerticalFilter VerticalFilter() Constructor. function ~VerticalFilter virtual ~VerticalFilter() =default Destructor. function configure void configure( const VerticalFilter::config configurations ) Configure filter program variables and set initialization conditions. Parameters : config_ structure with configurations function computePredict void computePredict( auv_msgs::NavigationStatus & state, ros::Time t_request ) Propagate the state to the current time. Parameters : state State vector t_request current time function newMeasurement void newMeasurement( const FilterGimmicks::measurement & m ) Checks and processes a new measurement. Parameters : m Measurement Return : true if measurement is processed successfully function resetFilter void resetFilter() Resets the filter, will require re-initialization to start back update again. Public Attributes Documentation variable MEAS_LEN static const int MEAS_LEN = 3; Measurement length. Updated on 2022-05-30 at 14:56:46 +0000","title":"VerticalFilter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classVerticalFilter/#verticalfilter","text":"This Class estimates the state of the vehicle in the horizontal frame. The state includes depth, velocity, altitude, and bouyancy. The latest state estimate of the filter is obtained using the exposed function getEstimate(). Measurement updates to the filter is done either using measCallback(). More... #include <VerticalFilter.h>","title":"VerticalFilter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classVerticalFilter/#public-classes","text":"Name struct config","title":"Public Classes"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classVerticalFilter/#public-functions","text":"Name VerticalFilter () Constructor. virtual ~VerticalFilter () =default Destructor. void configure (const VerticalFilter::config configurations) Configure filter program variables and set initialization conditions. void computePredict (auv_msgs::NavigationStatus & state, ros::Time t_request) Propagate the state to the current time. void newMeasurement (const FilterGimmicks::measurement & m) Checks and processes a new measurement. void resetFilter () Resets the filter, will require re-initialization to start back update again.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classVerticalFilter/#public-attributes","text":"Name const int MEAS_LEN Measurement length.","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classVerticalFilter/#detailed-description","text":"class VerticalFilter; This Class estimates the state of the vehicle in the horizontal frame. The state includes depth, velocity, altitude, and bouyancy. The latest state estimate of the filter is obtained using the exposed function getEstimate(). Measurement updates to the filter is done either using measCallback(). @Note Bouyancy is estimated but the output is not exposed to the user.","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classVerticalFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classVerticalFilter/#function-verticalfilter","text":"VerticalFilter() Constructor.","title":"function VerticalFilter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classVerticalFilter/#function-verticalfilter_1","text":"virtual ~VerticalFilter() =default Destructor.","title":"function ~VerticalFilter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classVerticalFilter/#function-configure","text":"void configure( const VerticalFilter::config configurations ) Configure filter program variables and set initialization conditions. Parameters : config_ structure with configurations","title":"function configure"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classVerticalFilter/#function-computepredict","text":"void computePredict( auv_msgs::NavigationStatus & state, ros::Time t_request ) Propagate the state to the current time. Parameters : state State vector t_request current time","title":"function computePredict"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classVerticalFilter/#function-newmeasurement","text":"void newMeasurement( const FilterGimmicks::measurement & m ) Checks and processes a new measurement. Parameters : m Measurement Return : true if measurement is processed successfully","title":"function newMeasurement"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classVerticalFilter/#function-resetfilter","text":"void resetFilter() Resets the filter, will require re-initialization to start back update again.","title":"function resetFilter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classVerticalFilter/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/classVerticalFilter/#variable-meas_len","text":"static const int MEAS_LEN = 3; Measurement length. Updated on 2022-05-30 at 14:56:46 +0000","title":"variable MEAS_LEN"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/","text":"FilterGimmicks::measurement Define a measurement object. More... #include <FilterGimmicks.h> Public Types Name enum measurement_type { Null = 1, CONFIG, VALUE} Public Functions Name void setLength (int length) measurement () measurement (int length) measurement (std::string header_) measurement (std::string frame_id, std::string config_, std::vector< double > noise_, double rejection_threshold_, int reject_counter_, double outlier_increase_) measurement (std::string frame_id, std::vector< double > value_, std::vector< double > noise_) measurement (const dsor_msgs::Measurement & m_) Public Attributes Name bool base_frame std_msgs::Header header Eigen::VectorXd value Eigen::VectorXd noise Eigen::VectorXd config Eigen::VectorXd state_copy Eigen::MatrixXd state_cov_copy std::string sensor_config double outlier_tolerance double time_of_previous_meas double outlier_increase int reject_counter Detailed Description struct FilterGimmicks::measurement; Define a measurement object. Note : measurement struct temporary placed here. To be moved later somewhere Public Types Documentation enum measurement_type Enumerator Value Description Null 1 CONFIG VALUE Public Functions Documentation function setLength inline void setLength( int length ) function measurement inline measurement() function measurement inline measurement( int length ) function measurement inline measurement( std::string header_ ) function measurement inline measurement( std::string frame_id, std::string config_, std::vector< double > noise_, double rejection_threshold_, int reject_counter_, double outlier_increase_ ) function measurement inline measurement( std::string frame_id, std::vector< double > value_, std::vector< double > noise_ ) function measurement inline measurement( const dsor_msgs::Measurement & m_ ) Public Attributes Documentation variable base_frame bool base_frame; variable header std_msgs::Header header; variable value Eigen::VectorXd value; variable noise Eigen::VectorXd noise; variable config Eigen::VectorXd config; variable state_copy Eigen::VectorXd state_copy; variable state_cov_copy Eigen::MatrixXd state_cov_copy; variable sensor_config std::string sensor_config; variable outlier_tolerance double outlier_tolerance; variable time_of_previous_meas double time_of_previous_meas; variable outlier_increase double outlier_increase; variable reject_counter int reject_counter; Updated on 2022-05-30 at 14:56:46 +0000","title":"FilterGimmicks::measurement"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#filtergimmicksmeasurement","text":"Define a measurement object. More... #include <FilterGimmicks.h>","title":"FilterGimmicks::measurement"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#public-types","text":"Name enum measurement_type { Null = 1, CONFIG, VALUE}","title":"Public Types"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#public-functions","text":"Name void setLength (int length) measurement () measurement (int length) measurement (std::string header_) measurement (std::string frame_id, std::string config_, std::vector< double > noise_, double rejection_threshold_, int reject_counter_, double outlier_increase_) measurement (std::string frame_id, std::vector< double > value_, std::vector< double > noise_) measurement (const dsor_msgs::Measurement & m_)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#public-attributes","text":"Name bool base_frame std_msgs::Header header Eigen::VectorXd value Eigen::VectorXd noise Eigen::VectorXd config Eigen::VectorXd state_copy Eigen::MatrixXd state_cov_copy std::string sensor_config double outlier_tolerance double time_of_previous_meas double outlier_increase int reject_counter","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#detailed-description","text":"struct FilterGimmicks::measurement; Define a measurement object. Note : measurement struct temporary placed here. To be moved later somewhere","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#enum-measurement_type","text":"Enumerator Value Description Null 1 CONFIG VALUE","title":"enum measurement_type"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#function-setlength","text":"inline void setLength( int length )","title":"function setLength"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#function-measurement","text":"inline measurement()","title":"function measurement"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#function-measurement_1","text":"inline measurement( int length )","title":"function measurement"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#function-measurement_2","text":"inline measurement( std::string header_ )","title":"function measurement"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#function-measurement_3","text":"inline measurement( std::string frame_id, std::string config_, std::vector< double > noise_, double rejection_threshold_, int reject_counter_, double outlier_increase_ )","title":"function measurement"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#function-measurement_4","text":"inline measurement( std::string frame_id, std::vector< double > value_, std::vector< double > noise_ )","title":"function measurement"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#function-measurement_5","text":"inline measurement( const dsor_msgs::Measurement & m_ )","title":"function measurement"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#variable-base_frame","text":"bool base_frame;","title":"variable base_frame"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#variable-header","text":"std_msgs::Header header;","title":"variable header"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#variable-value","text":"Eigen::VectorXd value;","title":"variable value"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#variable-noise","text":"Eigen::VectorXd noise;","title":"variable noise"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#variable-config","text":"Eigen::VectorXd config;","title":"variable config"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#variable-state_copy","text":"Eigen::VectorXd state_copy;","title":"variable state_copy"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#variable-state_cov_copy","text":"Eigen::MatrixXd state_cov_copy;","title":"variable state_cov_copy"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#variable-sensor_config","text":"std::string sensor_config;","title":"variable sensor_config"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#variable-outlier_tolerance","text":"double outlier_tolerance;","title":"variable outlier_tolerance"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#variable-time_of_previous_meas","text":"double time_of_previous_meas;","title":"variable time_of_previous_meas"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#variable-outlier_increase","text":"double outlier_increase;","title":"variable outlier_increase"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1measurement/#variable-reject_counter","text":"int reject_counter; Updated on 2022-05-30 at 14:56:46 +0000","title":"variable reject_counter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1predicate__frame__id/","text":"FilterGimmicks::predicate_frame_id Predicate to find a giver frame_id among a list of frame_id. #include <FilterGimmicks.h> Public Functions Name predicate_frame_id (std::string target_) bool operator() ( measurement & sensor) Public Attributes Name std::string target Public Functions Documentation function predicate_frame_id inline predicate_frame_id( std::string target_ ) function operator() inline bool operator()( measurement & sensor ) Public Attributes Documentation variable target std::string target; Updated on 2022-05-30 at 14:56:46 +0000","title":"FilterGimmicks::predicate_frame_id"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1predicate__frame__id/#filtergimmickspredicate_frame_id","text":"Predicate to find a giver frame_id among a list of frame_id. #include <FilterGimmicks.h>","title":"FilterGimmicks::predicate_frame_id"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1predicate__frame__id/#public-functions","text":"Name predicate_frame_id (std::string target_) bool operator() ( measurement & sensor)","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1predicate__frame__id/#public-attributes","text":"Name std::string target","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1predicate__frame__id/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1predicate__frame__id/#function-predicate_frame_id","text":"inline predicate_frame_id( std::string target_ )","title":"function predicate_frame_id"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1predicate__frame__id/#function-operator","text":"inline bool operator()( measurement & sensor )","title":"function operator()"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1predicate__frame__id/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structFilterGimmicks_1_1predicate__frame__id/#variable-target","text":"std::string target; Updated on 2022-05-30 at 14:56:46 +0000","title":"variable target"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structHorizontalFilter_1_1config/","text":"HorizontalFilter::config Public Attributes Name bool initialized bool broadcast_tf double reject_counter double init_cov double process_noise double kalman_config std::vector< std::string > frames FilterGimmicks::measurement meas_init std::vector< FilterGimmicks::measurement > sensors tf2_ros::TransformBroadcaster * br_node Public Attributes Documentation variable initialized bool initialized {false}; variable broadcast_tf bool broadcast_tf; variable reject_counter double reject_counter; variable init_cov double init_cov; variable process_noise double process_noise; variable kalman_config double kalman_config; variable frames std::vector< std::string > frames; variable meas_init FilterGimmicks::measurement meas_init; variable sensors std::vector< FilterGimmicks::measurement > sensors; variable br_node tf2_ros::TransformBroadcaster * br_node; Updated on 2022-05-30 at 14:56:46 +0000","title":"HorizontalFilter::config"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structHorizontalFilter_1_1config/#horizontalfilterconfig","text":"","title":"HorizontalFilter::config"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structHorizontalFilter_1_1config/#public-attributes","text":"Name bool initialized bool broadcast_tf double reject_counter double init_cov double process_noise double kalman_config std::vector< std::string > frames FilterGimmicks::measurement meas_init std::vector< FilterGimmicks::measurement > sensors tf2_ros::TransformBroadcaster * br_node","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structHorizontalFilter_1_1config/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structHorizontalFilter_1_1config/#variable-initialized","text":"bool initialized {false};","title":"variable initialized"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structHorizontalFilter_1_1config/#variable-broadcast_tf","text":"bool broadcast_tf;","title":"variable broadcast_tf"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structHorizontalFilter_1_1config/#variable-reject_counter","text":"double reject_counter;","title":"variable reject_counter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structHorizontalFilter_1_1config/#variable-init_cov","text":"double init_cov;","title":"variable init_cov"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structHorizontalFilter_1_1config/#variable-process_noise","text":"double process_noise;","title":"variable process_noise"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structHorizontalFilter_1_1config/#variable-kalman_config","text":"double kalman_config;","title":"variable kalman_config"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structHorizontalFilter_1_1config/#variable-frames","text":"std::vector< std::string > frames;","title":"variable frames"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structHorizontalFilter_1_1config/#variable-meas_init","text":"FilterGimmicks::measurement meas_init;","title":"variable meas_init"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structHorizontalFilter_1_1config/#variable-sensors","text":"std::vector< FilterGimmicks::measurement > sensors;","title":"variable sensors"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structHorizontalFilter_1_1config/#variable-br_node","text":"tf2_ros::TransformBroadcaster * br_node; Updated on 2022-05-30 at 14:56:46 +0000","title":"variable br_node"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structRotationalFilter_1_1config/","text":"RotationalFilter::config Public Attributes Name bool initialized bool bypass_ahrs double reject_counter double init_cov double process_noise double kalman_config std::vector< std::string > frames FilterGimmicks::measurement meas_init std::vector< FilterGimmicks::measurement > sensors tf2_ros::TransformBroadcaster * br_node Public Attributes Documentation variable initialized bool initialized {false}; variable bypass_ahrs bool bypass_ahrs; variable reject_counter double reject_counter; variable init_cov double init_cov; variable process_noise double process_noise; variable kalman_config double kalman_config; variable frames std::vector< std::string > frames; variable meas_init FilterGimmicks::measurement meas_init; variable sensors std::vector< FilterGimmicks::measurement > sensors; variable br_node tf2_ros::TransformBroadcaster * br_node; Updated on 2022-05-30 at 14:56:46 +0000","title":"RotationalFilter::config"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structRotationalFilter_1_1config/#rotationalfilterconfig","text":"","title":"RotationalFilter::config"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structRotationalFilter_1_1config/#public-attributes","text":"Name bool initialized bool bypass_ahrs double reject_counter double init_cov double process_noise double kalman_config std::vector< std::string > frames FilterGimmicks::measurement meas_init std::vector< FilterGimmicks::measurement > sensors tf2_ros::TransformBroadcaster * br_node","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structRotationalFilter_1_1config/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structRotationalFilter_1_1config/#variable-initialized","text":"bool initialized {false};","title":"variable initialized"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structRotationalFilter_1_1config/#variable-bypass_ahrs","text":"bool bypass_ahrs;","title":"variable bypass_ahrs"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structRotationalFilter_1_1config/#variable-reject_counter","text":"double reject_counter;","title":"variable reject_counter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structRotationalFilter_1_1config/#variable-init_cov","text":"double init_cov;","title":"variable init_cov"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structRotationalFilter_1_1config/#variable-process_noise","text":"double process_noise;","title":"variable process_noise"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structRotationalFilter_1_1config/#variable-kalman_config","text":"double kalman_config;","title":"variable kalman_config"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structRotationalFilter_1_1config/#variable-frames","text":"std::vector< std::string > frames;","title":"variable frames"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structRotationalFilter_1_1config/#variable-meas_init","text":"FilterGimmicks::measurement meas_init;","title":"variable meas_init"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structRotationalFilter_1_1config/#variable-sensors","text":"std::vector< FilterGimmicks::measurement > sensors;","title":"variable sensors"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structRotationalFilter_1_1config/#variable-br_node","text":"tf2_ros::TransformBroadcaster * br_node; Updated on 2022-05-30 at 14:56:46 +0000","title":"variable br_node"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structVerticalFilter_1_1config/","text":"VerticalFilter::config Public Attributes Name bool initialized bool broadcast_tf double vertical_drag alpha, beta, bouyancy double reject_counter double init_cov double process_noise double kalman_config std::vector< std::string > frames base_frame, odom_frame, map_frame, world_frame FilterGimmicks::measurement meas_init std::vector< FilterGimmicks::measurement > sensors tf2_ros::TransformBroadcaster * br_node Public Attributes Documentation variable initialized bool initialized {false}; variable broadcast_tf bool broadcast_tf; variable vertical_drag double vertical_drag; alpha, beta, bouyancy variable reject_counter double reject_counter; variable init_cov double init_cov; variable process_noise double process_noise; variable kalman_config double kalman_config; variable frames std::vector< std::string > frames; base_frame, odom_frame, map_frame, world_frame variable meas_init FilterGimmicks::measurement meas_init; variable sensors std::vector< FilterGimmicks::measurement > sensors; variable br_node tf2_ros::TransformBroadcaster * br_node; Updated on 2022-05-30 at 14:56:46 +0000","title":"VerticalFilter::config"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structVerticalFilter_1_1config/#verticalfilterconfig","text":"","title":"VerticalFilter::config"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structVerticalFilter_1_1config/#public-attributes","text":"Name bool initialized bool broadcast_tf double vertical_drag alpha, beta, bouyancy double reject_counter double init_cov double process_noise double kalman_config std::vector< std::string > frames base_frame, odom_frame, map_frame, world_frame FilterGimmicks::measurement meas_init std::vector< FilterGimmicks::measurement > sensors tf2_ros::TransformBroadcaster * br_node","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structVerticalFilter_1_1config/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structVerticalFilter_1_1config/#variable-initialized","text":"bool initialized {false};","title":"variable initialized"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structVerticalFilter_1_1config/#variable-broadcast_tf","text":"bool broadcast_tf;","title":"variable broadcast_tf"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structVerticalFilter_1_1config/#variable-vertical_drag","text":"double vertical_drag; alpha, beta, bouyancy","title":"variable vertical_drag"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structVerticalFilter_1_1config/#variable-reject_counter","text":"double reject_counter;","title":"variable reject_counter"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structVerticalFilter_1_1config/#variable-init_cov","text":"double init_cov;","title":"variable init_cov"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structVerticalFilter_1_1config/#variable-process_noise","text":"double process_noise;","title":"variable process_noise"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structVerticalFilter_1_1config/#variable-kalman_config","text":"double kalman_config;","title":"variable kalman_config"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structVerticalFilter_1_1config/#variable-frames","text":"std::vector< std::string > frames; base_frame, odom_frame, map_frame, world_frame","title":"variable frames"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structVerticalFilter_1_1config/#variable-meas_init","text":"FilterGimmicks::measurement meas_init;","title":"variable meas_init"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structVerticalFilter_1_1config/#variable-sensors","text":"std::vector< FilterGimmicks::measurement > sensors;","title":"variable sensors"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Classes/structVerticalFilter_1_1config/#variable-br_node","text":"tf2_ros::TransformBroadcaster * br_node; Updated on 2022-05-30 at 14:56:46 +0000","title":"variable br_node"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Examples/","text":"Examples Updated on 2022-05-30 at 14:56:46 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Examples/#examples","text":"Updated on 2022-05-30 at 14:56:46 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Modules/","text":"Modules Updated on 2022-05-30 at 14:56:46 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Modules/#modules","text":"Updated on 2022-05-30 at 14:56:46 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Namespaces/","text":"Namespaces namespace FilterGimmicks FilterGimmicks namespace. Updated on 2022-05-30 at 14:56:46 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Namespaces/#namespaces","text":"namespace FilterGimmicks FilterGimmicks namespace. Updated on 2022-05-30 at 14:56:46 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Namespaces/namespaceFilterGimmicks/","text":"FilterGimmicks FilterGimmicks namespace. More... Classes Name struct FilterGimmicks::measurement Define a measurement object. struct FilterGimmicks::predicate_frame_id Predicate to find a giver frame_id among a list of frame_id. Types Name typedef struct FilterGimmicks::measurement measurement Define a measurement object. Functions Name bool isinvalid (const measurement & m, double time) Validates a measurement if time is not negative, measurement or covariance are not nan. Detailed Description FilterGimmicks namespace. Note : gimmicks methods for navigation filters Types Documentation typedef measurement typedef struct FilterGimmicks::measurement FilterGimmicks::measurement; Define a measurement object. Note : measurement struct temporary placed here. To be moved later somewhere Functions Documentation function isinvalid static bool isinvalid( const measurement & m, double time ) Validates a measurement if time is not negative, measurement or covariance are not nan. Parameters : val measurement time Return : true if measurement is invalid false if measurement is valid Updated on 2022-05-30 at 14:56:46 +0000","title":"FilterGimmicks"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Namespaces/namespaceFilterGimmicks/#filtergimmicks","text":"FilterGimmicks namespace. More...","title":"FilterGimmicks"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Namespaces/namespaceFilterGimmicks/#classes","text":"Name struct FilterGimmicks::measurement Define a measurement object. struct FilterGimmicks::predicate_frame_id Predicate to find a giver frame_id among a list of frame_id.","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Namespaces/namespaceFilterGimmicks/#types","text":"Name typedef struct FilterGimmicks::measurement measurement Define a measurement object.","title":"Types"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Namespaces/namespaceFilterGimmicks/#functions","text":"Name bool isinvalid (const measurement & m, double time) Validates a measurement if time is not negative, measurement or covariance are not nan.","title":"Functions"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Namespaces/namespaceFilterGimmicks/#detailed-description","text":"FilterGimmicks namespace. Note : gimmicks methods for navigation filters","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Namespaces/namespaceFilterGimmicks/#types-documentation","text":"","title":"Types Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Namespaces/namespaceFilterGimmicks/#typedef-measurement","text":"typedef struct FilterGimmicks::measurement FilterGimmicks::measurement; Define a measurement object. Note : measurement struct temporary placed here. To be moved later somewhere","title":"typedef measurement"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Namespaces/namespaceFilterGimmicks/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_nav/sensor_fusion/Namespaces/namespaceFilterGimmicks/#function-isinvalid","text":"static bool isinvalid( const measurement & m, double time ) Validates a measurement if time is not negative, measurement or covariance are not nan. Parameters : val measurement time Return : true if measurement is invalid false if measurement is valid Updated on 2022-05-30 at 14:56:46 +0000","title":"function isinvalid"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/","text":"Classes class Arc2D Class that implements a 2D arc section. class Bernoulli Class that implements a 2D Lemniscate of Bernoulli section. class Circle2D Class that implements a 2D Circle section. class ConstRabbitSpeed Class that implements a constant speed value requirement. This class will receive in its constructor the desired velocity for the speed in the path frame. class ConstVehicleSpeed Class that implements a constant speed value requirement. This class will receive in its constructor the desired velocity for the speed in the inertial frame and will implement the corresponding speed in the path frame. class Line Class that implements a 3D line section. class Path The Path class! This class implements all the meethod to get the desired position, derivative, second derivatives, tangent, curvature and derivative norm. class PathNode Implementation of the PathNode . Creates a Path , adds elements to the path and publishes the path data when listening to the path parameter gamma. class PathSection An abstract class that is used as a template for Path Sections. class Polinomial5 Class that implements a 5th order polinomial section. class Polynomial5 Class that implements a 5th order polynomial section. class Sinusoid2D Class that implements a 2D sinusoid section. class Speed Abstract class to serve as the base for speed as a function of gamma. Updated on 2022-05-30 at 14:56:44 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/#classes","text":"class Arc2D Class that implements a 2D arc section. class Bernoulli Class that implements a 2D Lemniscate of Bernoulli section. class Circle2D Class that implements a 2D Circle section. class ConstRabbitSpeed Class that implements a constant speed value requirement. This class will receive in its constructor the desired velocity for the speed in the path frame. class ConstVehicleSpeed Class that implements a constant speed value requirement. This class will receive in its constructor the desired velocity for the speed in the inertial frame and will implement the corresponding speed in the path frame. class Line Class that implements a 3D line section. class Path The Path class! This class implements all the meethod to get the desired position, derivative, second derivatives, tangent, curvature and derivative norm. class PathNode Implementation of the PathNode . Creates a Path , adds elements to the path and publishes the path data when listening to the path parameter gamma. class PathSection An abstract class that is used as a template for Path Sections. class Polinomial5 Class that implements a 5th order polinomial section. class Polynomial5 Class that implements a 5th order polynomial section. class Sinusoid2D Class that implements a 2D sinusoid section. class Speed Abstract class to serve as the base for speed as a function of gamma. Updated on 2022-05-30 at 14:56:44 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classArc2D/","text":"Arc2D Class that implements a 2D arc section. More... #include <Arc2D.h> Inherits from PathSection Public Functions Name Arc2D (Eigen::Vector2d start_point, Eigen::Vector2d end_point, Eigen::Vector2d center_point, int direction, double z) Constructor for the Arc2D class, that receives the desired plane for the arc. Arc2D (Eigen::Vector2d start_point, Eigen::Vector2d end_point, Eigen::Vector2d center_point, int direction) Constructor for the Arc2D class, that receives the desired plane for the arc. Assumes the plane is placed at z=0.0 m. virtual Eigen::Vector3d eq_pd (double t) override The Path section equation. virtual Eigen::Vector3d eq_d_pd (double t) override First derivative of the path section equation with respect to the path parameter t. virtual Eigen::Vector3d eq_dd_pd (double t) override Second derivative of the path section equation with respect to the path parameter t. virtual double curvature (double t) override Compute the curvature in a simple manner. Computed as 1/Radius. virtual double getClosestPointGamma (Eigen::Vector3d & coordinate) override Method for getting the gamma of the closes point to the path in a more efficient manner For an arc it uses a closed form equation to solve this problem. Additional inherited members Public Functions inherited from PathSection Name virtual double tangent (double t) Default method for computing the tangent to the path section. virtual double derivative_norm (double t) Default method for computing the norm of the derivative. bool can_be_composed () Method to return whether a pathSection can be composed with other path sections or not. double limitGamma (double t) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. double getMaxGammaValue () Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. double getMinGammaValue () Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. virtual ~PathSection () Virtual destructor for the abstract class. Protected Functions inherited from PathSection Name PathSection (bool can_be_composed) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . bool setMaxGammaValue (double gamma_max) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. bool setMinGammaValue (double gamma_min) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. double GradientDescent (double gamma_o, Eigen::Vector3d & x_pos, double tolerance) Method that implements the gradient descent to minimize the error of double getInitialGammaEstimate (Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. double bisection (Eigen::Vector3d & x_pos, double a, double b) Method to implement bisection method Detailed Description class Arc2D; Class that implements a 2D arc section. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the sections library Public Functions Documentation function Arc2D Arc2D( Eigen::Vector2d start_point, Eigen::Vector2d end_point, Eigen::Vector2d center_point, int direction, double z ) Constructor for the Arc2D class, that receives the desired plane for the arc. Parameters : start_point The 2D start point of the arc end_point The 2D end point of the arc center_point The 2D coordinate with the center of the arc direction An int (-1 or 1) that represents the direction of the arc z The altitude at which to place the arc Constructor for the Arc2D path. Using this constructor we can specify the plane in which to put the arc function Arc2D Arc2D( Eigen::Vector2d start_point, Eigen::Vector2d end_point, Eigen::Vector2d center_point, int direction ) Constructor for the Arc2D class, that receives the desired plane for the arc. Assumes the plane is placed at z=0.0 m. Parameters : start_point The 2D start point of the arc end_point The 2D end point of the arc center_point The 2D coordinate with the center of the arc direction An int (-1 or 1) that represents the direction of the arc The constructors for the Arc2D paths Using this constructor we assume the path is place in the plane z = 0 function eq_pd virtual Eigen::Vector3d eq_pd( double t ) override The Path section equation. Parameters : t The path parameter Return : An Eigen::Vector3d with the equation of the path with respect to the path parameter Reimplements : PathSection::eq_pd function eq_d_pd virtual Eigen::Vector3d eq_d_pd( double t ) override First derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter t Return : An Eigen::Vector3d with the equation of the partial derivative with respect to the path parameter Reimplements : PathSection::eq_d_pd function eq_dd_pd virtual Eigen::Vector3d eq_dd_pd( double t ) override Second derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter t Return : An Eigen::Vector3d with the equation of the second order partial derivative with respect to the path parameter Reimplements : PathSection::eq_dd_pd function curvature virtual double curvature( double t ) override Compute the curvature in a simple manner. Computed as 1/Radius. Parameters : t The path parameter t Return : A double with the curvature in of that section (1/radius) Reimplements : PathSection::curvature function getClosestPointGamma virtual double getClosestPointGamma( Eigen::Vector3d & coordinate ) override Method for getting the gamma of the closes point to the path in a more efficient manner For an arc it uses a closed form equation to solve this problem. Parameters : coordinate The coordinate of the vehicle in the 3D space Return : A double with the gamma corresponding to the closest point in the path Reimplements : PathSection::getClosestPointGamma Updated on 2022-05-30 at 14:56:44 +0000","title":"Arc2D"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classArc2D/#arc2d","text":"Class that implements a 2D arc section. More... #include <Arc2D.h> Inherits from PathSection","title":"Arc2D"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classArc2D/#public-functions","text":"Name Arc2D (Eigen::Vector2d start_point, Eigen::Vector2d end_point, Eigen::Vector2d center_point, int direction, double z) Constructor for the Arc2D class, that receives the desired plane for the arc. Arc2D (Eigen::Vector2d start_point, Eigen::Vector2d end_point, Eigen::Vector2d center_point, int direction) Constructor for the Arc2D class, that receives the desired plane for the arc. Assumes the plane is placed at z=0.0 m. virtual Eigen::Vector3d eq_pd (double t) override The Path section equation. virtual Eigen::Vector3d eq_d_pd (double t) override First derivative of the path section equation with respect to the path parameter t. virtual Eigen::Vector3d eq_dd_pd (double t) override Second derivative of the path section equation with respect to the path parameter t. virtual double curvature (double t) override Compute the curvature in a simple manner. Computed as 1/Radius. virtual double getClosestPointGamma (Eigen::Vector3d & coordinate) override Method for getting the gamma of the closes point to the path in a more efficient manner For an arc it uses a closed form equation to solve this problem.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classArc2D/#additional-inherited-members","text":"Public Functions inherited from PathSection Name virtual double tangent (double t) Default method for computing the tangent to the path section. virtual double derivative_norm (double t) Default method for computing the norm of the derivative. bool can_be_composed () Method to return whether a pathSection can be composed with other path sections or not. double limitGamma (double t) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. double getMaxGammaValue () Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. double getMinGammaValue () Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. virtual ~PathSection () Virtual destructor for the abstract class. Protected Functions inherited from PathSection Name PathSection (bool can_be_composed) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . bool setMaxGammaValue (double gamma_max) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. bool setMinGammaValue (double gamma_min) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. double GradientDescent (double gamma_o, Eigen::Vector3d & x_pos, double tolerance) Method that implements the gradient descent to minimize the error of double getInitialGammaEstimate (Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. double bisection (Eigen::Vector3d & x_pos, double a, double b) Method to implement bisection method","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classArc2D/#detailed-description","text":"class Arc2D; Class that implements a 2D arc section. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the sections library","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classArc2D/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classArc2D/#function-arc2d","text":"Arc2D( Eigen::Vector2d start_point, Eigen::Vector2d end_point, Eigen::Vector2d center_point, int direction, double z ) Constructor for the Arc2D class, that receives the desired plane for the arc. Parameters : start_point The 2D start point of the arc end_point The 2D end point of the arc center_point The 2D coordinate with the center of the arc direction An int (-1 or 1) that represents the direction of the arc z The altitude at which to place the arc Constructor for the Arc2D path. Using this constructor we can specify the plane in which to put the arc","title":"function Arc2D"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classArc2D/#function-arc2d_1","text":"Arc2D( Eigen::Vector2d start_point, Eigen::Vector2d end_point, Eigen::Vector2d center_point, int direction ) Constructor for the Arc2D class, that receives the desired plane for the arc. Assumes the plane is placed at z=0.0 m. Parameters : start_point The 2D start point of the arc end_point The 2D end point of the arc center_point The 2D coordinate with the center of the arc direction An int (-1 or 1) that represents the direction of the arc The constructors for the Arc2D paths Using this constructor we assume the path is place in the plane z = 0","title":"function Arc2D"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classArc2D/#function-eq_pd","text":"virtual Eigen::Vector3d eq_pd( double t ) override The Path section equation. Parameters : t The path parameter Return : An Eigen::Vector3d with the equation of the path with respect to the path parameter Reimplements : PathSection::eq_pd","title":"function eq_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classArc2D/#function-eq_d_pd","text":"virtual Eigen::Vector3d eq_d_pd( double t ) override First derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter t Return : An Eigen::Vector3d with the equation of the partial derivative with respect to the path parameter Reimplements : PathSection::eq_d_pd","title":"function eq_d_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classArc2D/#function-eq_dd_pd","text":"virtual Eigen::Vector3d eq_dd_pd( double t ) override Second derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter t Return : An Eigen::Vector3d with the equation of the second order partial derivative with respect to the path parameter Reimplements : PathSection::eq_dd_pd","title":"function eq_dd_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classArc2D/#function-curvature","text":"virtual double curvature( double t ) override Compute the curvature in a simple manner. Computed as 1/Radius. Parameters : t The path parameter t Return : A double with the curvature in of that section (1/radius) Reimplements : PathSection::curvature","title":"function curvature"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classArc2D/#function-getclosestpointgamma","text":"virtual double getClosestPointGamma( Eigen::Vector3d & coordinate ) override Method for getting the gamma of the closes point to the path in a more efficient manner For an arc it uses a closed form equation to solve this problem. Parameters : coordinate The coordinate of the vehicle in the 3D space Return : A double with the gamma corresponding to the closest point in the path Reimplements : PathSection::getClosestPointGamma Updated on 2022-05-30 at 14:56:44 +0000","title":"function getClosestPointGamma"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classBernoulli/","text":"Bernoulli Class that implements a 2D Lemniscate of Bernoulli section. More... #include <Bernoulli.h> Inherits from PathSection Public Functions Name Bernoulli (double radius, double center_x, double center_y) Constructor for the path section that assumes the plane in which the path is placed is z=0. Bernoulli (double radius, double center_x, double center_y, double z) Constructor for the path section. virtual Eigen::Vector3d eq_pd (double t) override Path section equation. virtual Eigen::Vector3d eq_d_pd (double t) override First derivative of the path section equation with respect to the path parameter t. virtual Eigen::Vector3d eq_dd_pd (double t) override Second derivative of the path section equation with respect to the path parameter t. virtual double curvature (double t) override Compute the curvature using the direct formula. virtual double getClosestPointGamma (Eigen::Vector3d & coordinate) override Method for getting the gamma of the closest point. In this implementation the closest point is computed iteratively using Gradient Descent Method. For the first iteration, to get a good initialization, the section is divided into N partitions between [0, 2*PI] and the minimum is computed for each partition. The gamma with the minimum distance will be used to initialize the algorithm. Additional inherited members Public Functions inherited from PathSection Name virtual double tangent (double t) Default method for computing the tangent to the path section. virtual double derivative_norm (double t) Default method for computing the norm of the derivative. bool can_be_composed () Method to return whether a pathSection can be composed with other path sections or not. double limitGamma (double t) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. double getMaxGammaValue () Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. double getMinGammaValue () Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. virtual ~PathSection () Virtual destructor for the abstract class. Protected Functions inherited from PathSection Name PathSection (bool can_be_composed) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . bool setMaxGammaValue (double gamma_max) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. bool setMinGammaValue (double gamma_min) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. double GradientDescent (double gamma_o, Eigen::Vector3d & x_pos, double tolerance) Method that implements the gradient descent to minimize the error of double getInitialGammaEstimate (Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. double bisection (Eigen::Vector3d & x_pos, double a, double b) Method to implement bisection method Detailed Description class Bernoulli; Class that implements a 2D Lemniscate of Bernoulli section. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the sections library Public Functions Documentation function Bernoulli Bernoulli( double radius, double center_x, double center_y ) Constructor for the path section that assumes the plane in which the path is placed is z=0. Parameters : radius The radius of the bernoulli lamniscaste section center_x The x coordinate of the center of the bernoulli center_y The y coordinate of the center of the bernoulli function Bernoulli Bernoulli( double radius, double center_x, double center_y, double z ) Constructor for the path section. Parameters : radius The radius of the bernoulli lamniscaste section center_x The x coordinate of the center of the bernoulli center_y The y coordinate of the center of the bernoulli z The altitude in m in which to place the bernoulli function eq_pd virtual Eigen::Vector3d eq_pd( double t ) override Path section equation. Parameters : t The path parameter Return : An Eigen::Vector3d with the value of the equation of the path Reimplements : PathSection::eq_pd function eq_d_pd virtual Eigen::Vector3d eq_d_pd( double t ) override First derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter Return : An Eigen::Vector3d with the value of the derivate of the equation of the path Reimplements : PathSection::eq_d_pd function eq_dd_pd virtual Eigen::Vector3d eq_dd_pd( double t ) override Second derivative of the path section equation with respect to the path parameter t. Parameters : t The path paramter Return : An Eigen::Vector3d with the value of the derivative of the equation of the path Reimplements : PathSection::eq_dd_pd function curvature virtual double curvature( double t ) override Compute the curvature using the direct formula. Parameters : t The path parameter Return : a double with the curvature of the section Reimplements : PathSection::curvature function getClosestPointGamma virtual double getClosestPointGamma( Eigen::Vector3d & coordinate ) override Method for getting the gamma of the closest point. In this implementation the closest point is computed iteratively using Gradient Descent Method. For the first iteration, to get a good initialization, the section is divided into N partitions between [0, 2*PI] and the minimum is computed for each partition. The gamma with the minimum distance will be used to initialize the algorithm. Parameters : coordinate An Eigen::Vector3d with the coordinate of the vehicle Return : a double with the gamma corresponding to the closest point Reimplements : PathSection::getClosestPointGamma Method to return the closest point to the path By default just calls the Gradient Descent algorithm Updated on 2022-05-30 at 14:56:44 +0000","title":"Bernoulli"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classBernoulli/#bernoulli","text":"Class that implements a 2D Lemniscate of Bernoulli section. More... #include <Bernoulli.h> Inherits from PathSection","title":"Bernoulli"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classBernoulli/#public-functions","text":"Name Bernoulli (double radius, double center_x, double center_y) Constructor for the path section that assumes the plane in which the path is placed is z=0. Bernoulli (double radius, double center_x, double center_y, double z) Constructor for the path section. virtual Eigen::Vector3d eq_pd (double t) override Path section equation. virtual Eigen::Vector3d eq_d_pd (double t) override First derivative of the path section equation with respect to the path parameter t. virtual Eigen::Vector3d eq_dd_pd (double t) override Second derivative of the path section equation with respect to the path parameter t. virtual double curvature (double t) override Compute the curvature using the direct formula. virtual double getClosestPointGamma (Eigen::Vector3d & coordinate) override Method for getting the gamma of the closest point. In this implementation the closest point is computed iteratively using Gradient Descent Method. For the first iteration, to get a good initialization, the section is divided into N partitions between [0, 2*PI] and the minimum is computed for each partition. The gamma with the minimum distance will be used to initialize the algorithm.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classBernoulli/#additional-inherited-members","text":"Public Functions inherited from PathSection Name virtual double tangent (double t) Default method for computing the tangent to the path section. virtual double derivative_norm (double t) Default method for computing the norm of the derivative. bool can_be_composed () Method to return whether a pathSection can be composed with other path sections or not. double limitGamma (double t) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. double getMaxGammaValue () Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. double getMinGammaValue () Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. virtual ~PathSection () Virtual destructor for the abstract class. Protected Functions inherited from PathSection Name PathSection (bool can_be_composed) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . bool setMaxGammaValue (double gamma_max) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. bool setMinGammaValue (double gamma_min) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. double GradientDescent (double gamma_o, Eigen::Vector3d & x_pos, double tolerance) Method that implements the gradient descent to minimize the error of double getInitialGammaEstimate (Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. double bisection (Eigen::Vector3d & x_pos, double a, double b) Method to implement bisection method","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classBernoulli/#detailed-description","text":"class Bernoulli; Class that implements a 2D Lemniscate of Bernoulli section. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the sections library","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classBernoulli/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classBernoulli/#function-bernoulli","text":"Bernoulli( double radius, double center_x, double center_y ) Constructor for the path section that assumes the plane in which the path is placed is z=0. Parameters : radius The radius of the bernoulli lamniscaste section center_x The x coordinate of the center of the bernoulli center_y The y coordinate of the center of the bernoulli","title":"function Bernoulli"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classBernoulli/#function-bernoulli_1","text":"Bernoulli( double radius, double center_x, double center_y, double z ) Constructor for the path section. Parameters : radius The radius of the bernoulli lamniscaste section center_x The x coordinate of the center of the bernoulli center_y The y coordinate of the center of the bernoulli z The altitude in m in which to place the bernoulli","title":"function Bernoulli"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classBernoulli/#function-eq_pd","text":"virtual Eigen::Vector3d eq_pd( double t ) override Path section equation. Parameters : t The path parameter Return : An Eigen::Vector3d with the value of the equation of the path Reimplements : PathSection::eq_pd","title":"function eq_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classBernoulli/#function-eq_d_pd","text":"virtual Eigen::Vector3d eq_d_pd( double t ) override First derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter Return : An Eigen::Vector3d with the value of the derivate of the equation of the path Reimplements : PathSection::eq_d_pd","title":"function eq_d_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classBernoulli/#function-eq_dd_pd","text":"virtual Eigen::Vector3d eq_dd_pd( double t ) override Second derivative of the path section equation with respect to the path parameter t. Parameters : t The path paramter Return : An Eigen::Vector3d with the value of the derivative of the equation of the path Reimplements : PathSection::eq_dd_pd","title":"function eq_dd_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classBernoulli/#function-curvature","text":"virtual double curvature( double t ) override Compute the curvature using the direct formula. Parameters : t The path parameter Return : a double with the curvature of the section Reimplements : PathSection::curvature","title":"function curvature"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classBernoulli/#function-getclosestpointgamma","text":"virtual double getClosestPointGamma( Eigen::Vector3d & coordinate ) override Method for getting the gamma of the closest point. In this implementation the closest point is computed iteratively using Gradient Descent Method. For the first iteration, to get a good initialization, the section is divided into N partitions between [0, 2*PI] and the minimum is computed for each partition. The gamma with the minimum distance will be used to initialize the algorithm. Parameters : coordinate An Eigen::Vector3d with the coordinate of the vehicle Return : a double with the gamma corresponding to the closest point Reimplements : PathSection::getClosestPointGamma Method to return the closest point to the path By default just calls the Gradient Descent algorithm Updated on 2022-05-30 at 14:56:44 +0000","title":"function getClosestPointGamma"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classCircle2D/","text":"Circle2D Class that implements a 2D Circle section. More... #include <Circle2D.h> Inherits from PathSection Public Functions Name Circle2D (double radius, double center_x, double center_y) Constructor for the path section that assumes the plane in which the path is placed is z=0. Circle2D (double radius, double center_x, double center_y, double z) Constructor for the path section. virtual Eigen::Vector3d eq_pd (double t) override Path Section equation. virtual Eigen::Vector3d eq_d_pd (double t) override First derivative of the path section equation with respect to the path parameter. virtual Eigen::Vector3d eq_dd_pd (double t) override Second derivative of the path section equation with respect to the path parameter t. virtual double curvature (double t) override Compute the curvature using only the radius. Computed as 1/Radius. virtual double getClosestPointGamma (Eigen::Vector3d & coordinate) override Method for getting the gamma of the closest point. Additional inherited members Public Functions inherited from PathSection Name virtual double tangent (double t) Default method for computing the tangent to the path section. virtual double derivative_norm (double t) Default method for computing the norm of the derivative. bool can_be_composed () Method to return whether a pathSection can be composed with other path sections or not. double limitGamma (double t) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. double getMaxGammaValue () Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. double getMinGammaValue () Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. virtual ~PathSection () Virtual destructor for the abstract class. Protected Functions inherited from PathSection Name PathSection (bool can_be_composed) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . bool setMaxGammaValue (double gamma_max) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. bool setMinGammaValue (double gamma_min) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. double GradientDescent (double gamma_o, Eigen::Vector3d & x_pos, double tolerance) Method that implements the gradient descent to minimize the error of double getInitialGammaEstimate (Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. double bisection (Eigen::Vector3d & x_pos, double a, double b) Method to implement bisection method Detailed Description class Circle2D; Class that implements a 2D Circle section. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the sections library Public Functions Documentation function Circle2D Circle2D( double radius, double center_x, double center_y ) Constructor for the path section that assumes the plane in which the path is placed is z=0. Parameters : radius The radius in m of the Circle center_x The x coordinate of the center of the circle center_y The y coordinate of the center of the circle function Circle2D Circle2D( double radius, double center_x, double center_y, double z ) Constructor for the path section. Parameters : radius The radius in m of the Circle center_x The x coordinate of the center of the circle center_y The y coordinate of the center of the circle z The z axis where to place the circle function eq_pd virtual Eigen::Vector3d eq_pd( double t ) override Path Section equation. Parameters : t The path parameter Return : An Eigen::Vector3d with the values from the equation of the path Reimplements : PathSection::eq_pd function eq_d_pd virtual Eigen::Vector3d eq_d_pd( double t ) override First derivative of the path section equation with respect to the path parameter. Parameters : t The path parameter Return : An Eigen::Vector3d with the values from the derivative of the equation Reimplements : PathSection::eq_d_pd function eq_dd_pd virtual Eigen::Vector3d eq_dd_pd( double t ) override Second derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter Return : An Eigen::Vector3d with the values from the second derivative of the equation Reimplements : PathSection::eq_dd_pd function curvature virtual double curvature( double t ) override Compute the curvature using only the radius. Computed as 1/Radius. Parameters : t The path paramter Return : A double with the curvature of that section (1/radius) Reimplements : PathSection::curvature function getClosestPointGamma virtual double getClosestPointGamma( Eigen::Vector3d & coordinate ) override Method for getting the gamma of the closest point. Parameters : coordinate The vehicle position Return : A double with the gamma corresponding to the closest point in the path Reimplements : PathSection::getClosestPointGamma Method to return the closest point to the path By default just calls the Gradient Descent algorithm Updated on 2022-05-30 at 14:56:44 +0000","title":"Circle2D"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classCircle2D/#circle2d","text":"Class that implements a 2D Circle section. More... #include <Circle2D.h> Inherits from PathSection","title":"Circle2D"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classCircle2D/#public-functions","text":"Name Circle2D (double radius, double center_x, double center_y) Constructor for the path section that assumes the plane in which the path is placed is z=0. Circle2D (double radius, double center_x, double center_y, double z) Constructor for the path section. virtual Eigen::Vector3d eq_pd (double t) override Path Section equation. virtual Eigen::Vector3d eq_d_pd (double t) override First derivative of the path section equation with respect to the path parameter. virtual Eigen::Vector3d eq_dd_pd (double t) override Second derivative of the path section equation with respect to the path parameter t. virtual double curvature (double t) override Compute the curvature using only the radius. Computed as 1/Radius. virtual double getClosestPointGamma (Eigen::Vector3d & coordinate) override Method for getting the gamma of the closest point.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classCircle2D/#additional-inherited-members","text":"Public Functions inherited from PathSection Name virtual double tangent (double t) Default method for computing the tangent to the path section. virtual double derivative_norm (double t) Default method for computing the norm of the derivative. bool can_be_composed () Method to return whether a pathSection can be composed with other path sections or not. double limitGamma (double t) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. double getMaxGammaValue () Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. double getMinGammaValue () Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. virtual ~PathSection () Virtual destructor for the abstract class. Protected Functions inherited from PathSection Name PathSection (bool can_be_composed) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . bool setMaxGammaValue (double gamma_max) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. bool setMinGammaValue (double gamma_min) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. double GradientDescent (double gamma_o, Eigen::Vector3d & x_pos, double tolerance) Method that implements the gradient descent to minimize the error of double getInitialGammaEstimate (Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. double bisection (Eigen::Vector3d & x_pos, double a, double b) Method to implement bisection method","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classCircle2D/#detailed-description","text":"class Circle2D; Class that implements a 2D Circle section. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the sections library","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classCircle2D/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classCircle2D/#function-circle2d","text":"Circle2D( double radius, double center_x, double center_y ) Constructor for the path section that assumes the plane in which the path is placed is z=0. Parameters : radius The radius in m of the Circle center_x The x coordinate of the center of the circle center_y The y coordinate of the center of the circle","title":"function Circle2D"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classCircle2D/#function-circle2d_1","text":"Circle2D( double radius, double center_x, double center_y, double z ) Constructor for the path section. Parameters : radius The radius in m of the Circle center_x The x coordinate of the center of the circle center_y The y coordinate of the center of the circle z The z axis where to place the circle","title":"function Circle2D"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classCircle2D/#function-eq_pd","text":"virtual Eigen::Vector3d eq_pd( double t ) override Path Section equation. Parameters : t The path parameter Return : An Eigen::Vector3d with the values from the equation of the path Reimplements : PathSection::eq_pd","title":"function eq_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classCircle2D/#function-eq_d_pd","text":"virtual Eigen::Vector3d eq_d_pd( double t ) override First derivative of the path section equation with respect to the path parameter. Parameters : t The path parameter Return : An Eigen::Vector3d with the values from the derivative of the equation Reimplements : PathSection::eq_d_pd","title":"function eq_d_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classCircle2D/#function-eq_dd_pd","text":"virtual Eigen::Vector3d eq_dd_pd( double t ) override Second derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter Return : An Eigen::Vector3d with the values from the second derivative of the equation Reimplements : PathSection::eq_dd_pd","title":"function eq_dd_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classCircle2D/#function-curvature","text":"virtual double curvature( double t ) override Compute the curvature using only the radius. Computed as 1/Radius. Parameters : t The path paramter Return : A double with the curvature of that section (1/radius) Reimplements : PathSection::curvature","title":"function curvature"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classCircle2D/#function-getclosestpointgamma","text":"virtual double getClosestPointGamma( Eigen::Vector3d & coordinate ) override Method for getting the gamma of the closest point. Parameters : coordinate The vehicle position Return : A double with the gamma corresponding to the closest point in the path Reimplements : PathSection::getClosestPointGamma Method to return the closest point to the path By default just calls the Gradient Descent algorithm Updated on 2022-05-30 at 14:56:44 +0000","title":"function getClosestPointGamma"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstRabbitSpeed/","text":"ConstRabbitSpeed Class that implements a constant speed value requirement. This class will receive in its constructor the desired velocity for the speed in the path frame. More... #include <ConstRabbitSpeed.h> Inherits from Speed Public Functions Name ConstRabbitSpeed (double rabbit_speed, double default_val) Constructor for the ConstVehicleSpeed class. Receives as a parameter a double which represents the desired speed of the vehicle in the inertial frame. virtual double getVd (double gamma, double tangent_norm) override Method to get the desired velocity for the virtual target on the path given the path parameter (given by the value of gamma) virtual double get_d_Vd (double gamma, double tangent_norm) override Method to get the desired acceleration for the virtual target on the path given the path parameter (given by the value of gamma) virtual double getDefaultVd (double gamma, double tangent_norm) override Method to get the default desired velocity for safety when we are doing path following and want to have a backup value. Additional inherited members Public Functions inherited from Speed Name virtual ~Speed () Virtual destructor for the abstract class. Detailed Description class ConstRabbitSpeed; Class that implements a constant speed value requirement. This class will receive in its constructor the desired velocity for the speed in the path frame. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the speeds library Public Functions Documentation function ConstRabbitSpeed ConstRabbitSpeed( double rabbit_speed, double default_val ) Constructor for the ConstVehicleSpeed class. Receives as a parameter a double which represents the desired speed of the vehicle in the inertial frame. Parameters : rabbit_speed The speed of the path parameter (in the path frame) default_val The default value of the path parameter (if outside the parameterization bounds) function getVd virtual double getVd( double gamma, double tangent_norm ) override Method to get the desired velocity for the virtual target on the path given the path parameter (given by the value of gamma) Parameters : gamma The path parameter tangent_norm The norm of the tangent to the path Return : A double with the desired speed Reimplements : Speed::getVd function get_d_Vd virtual double get_d_Vd( double gamma, double tangent_norm ) override Method to get the desired acceleration for the virtual target on the path given the path parameter (given by the value of gamma) Parameters : gamma The value of the path parameter tangent_norm The norm of the tangent to the path Return : A double with the desired acceleration Reimplements : Speed::get_d_Vd function getDefaultVd virtual double getDefaultVd( double gamma, double tangent_norm ) override Method to get the default desired velocity for safety when we are doing path following and want to have a backup value. Parameters : gamma The value of the path parameter tangent_norm The norm of the tangent to the path in gamma Return : A double with the default desired speed Reimplements : Speed::getDefaultVd Updated on 2022-05-30 at 14:56:44 +0000","title":"ConstRabbitSpeed"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstRabbitSpeed/#constrabbitspeed","text":"Class that implements a constant speed value requirement. This class will receive in its constructor the desired velocity for the speed in the path frame. More... #include <ConstRabbitSpeed.h> Inherits from Speed","title":"ConstRabbitSpeed"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstRabbitSpeed/#public-functions","text":"Name ConstRabbitSpeed (double rabbit_speed, double default_val) Constructor for the ConstVehicleSpeed class. Receives as a parameter a double which represents the desired speed of the vehicle in the inertial frame. virtual double getVd (double gamma, double tangent_norm) override Method to get the desired velocity for the virtual target on the path given the path parameter (given by the value of gamma) virtual double get_d_Vd (double gamma, double tangent_norm) override Method to get the desired acceleration for the virtual target on the path given the path parameter (given by the value of gamma) virtual double getDefaultVd (double gamma, double tangent_norm) override Method to get the default desired velocity for safety when we are doing path following and want to have a backup value.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstRabbitSpeed/#additional-inherited-members","text":"Public Functions inherited from Speed Name virtual ~Speed () Virtual destructor for the abstract class.","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstRabbitSpeed/#detailed-description","text":"class ConstRabbitSpeed; Class that implements a constant speed value requirement. This class will receive in its constructor the desired velocity for the speed in the path frame. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the speeds library","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstRabbitSpeed/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstRabbitSpeed/#function-constrabbitspeed","text":"ConstRabbitSpeed( double rabbit_speed, double default_val ) Constructor for the ConstVehicleSpeed class. Receives as a parameter a double which represents the desired speed of the vehicle in the inertial frame. Parameters : rabbit_speed The speed of the path parameter (in the path frame) default_val The default value of the path parameter (if outside the parameterization bounds)","title":"function ConstRabbitSpeed"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstRabbitSpeed/#function-getvd","text":"virtual double getVd( double gamma, double tangent_norm ) override Method to get the desired velocity for the virtual target on the path given the path parameter (given by the value of gamma) Parameters : gamma The path parameter tangent_norm The norm of the tangent to the path Return : A double with the desired speed Reimplements : Speed::getVd","title":"function getVd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstRabbitSpeed/#function-get_d_vd","text":"virtual double get_d_Vd( double gamma, double tangent_norm ) override Method to get the desired acceleration for the virtual target on the path given the path parameter (given by the value of gamma) Parameters : gamma The value of the path parameter tangent_norm The norm of the tangent to the path Return : A double with the desired acceleration Reimplements : Speed::get_d_Vd","title":"function get_d_Vd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstRabbitSpeed/#function-getdefaultvd","text":"virtual double getDefaultVd( double gamma, double tangent_norm ) override Method to get the default desired velocity for safety when we are doing path following and want to have a backup value. Parameters : gamma The value of the path parameter tangent_norm The norm of the tangent to the path in gamma Return : A double with the default desired speed Reimplements : Speed::getDefaultVd Updated on 2022-05-30 at 14:56:44 +0000","title":"function getDefaultVd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstVehicleSpeed/","text":"ConstVehicleSpeed Class that implements a constant speed value requirement. This class will receive in its constructor the desired velocity for the speed in the inertial frame and will implement the corresponding speed in the path frame. More... #include <ConstVehicleSpeed.h> Inherits from Speed Public Functions Name ConstVehicleSpeed (double vehicle_speed, double default_val) Constructor for the ConstVehicleSpeed class. Receives as a parameter a double which represents the desired speed of the vehicle in the inertial frame. virtual double getVd (double gamma, double tangent_norm) override Method to get the desired velocity for the virtual target on the path given the path parameter (given by the value of gamma) virtual double get_d_Vd (double gamma, double tangent_norm) override Method to get the desired acceleration for the virtual target on the path given the path parameter (given by the value of gamma) virtual double getDefaultVd (double gamma, double tangent_norm) override Method to get the default desired velocity for safety when we are doing path following and want to have a backup value. Additional inherited members Public Functions inherited from Speed Name virtual ~Speed () Virtual destructor for the abstract class. Detailed Description class ConstVehicleSpeed; Class that implements a constant speed value requirement. This class will receive in its constructor the desired velocity for the speed in the inertial frame and will implement the corresponding speed in the path frame. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the speeds library Public Functions Documentation function ConstVehicleSpeed ConstVehicleSpeed( double vehicle_speed, double default_val ) Constructor for the ConstVehicleSpeed class. Receives as a parameter a double which represents the desired speed of the vehicle in the inertial frame. Parameters : vehicle_speed The desired speed for the vehicle in m/s default_val The desired default_value when the vehicle is outside the gamma range function getVd virtual double getVd( double gamma, double tangent_norm ) override Method to get the desired velocity for the virtual target on the path given the path parameter (given by the value of gamma) Parameters : gamma The path parameter tangent_norm The norm of the tangent to the path Return : A double with the desired speed Reimplements : Speed::getVd function get_d_Vd virtual double get_d_Vd( double gamma, double tangent_norm ) override Method to get the desired acceleration for the virtual target on the path given the path parameter (given by the value of gamma) Parameters : gamma The value of the path parameter tangent_norm The norm of the tangent to the path Return : A double with the desired acceleration Reimplements : Speed::get_d_Vd function getDefaultVd virtual double getDefaultVd( double gamma, double tangent_norm ) override Method to get the default desired velocity for safety when we are doing path following and want to have a backup value. Parameters : gamma The value of the path parameter tangent_norm The norm of the tangent to the path in gamma Return : A double with the default desired speed Reimplements : Speed::getDefaultVd Updated on 2022-05-30 at 14:56:44 +0000","title":"ConstVehicleSpeed"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstVehicleSpeed/#constvehiclespeed","text":"Class that implements a constant speed value requirement. This class will receive in its constructor the desired velocity for the speed in the inertial frame and will implement the corresponding speed in the path frame. More... #include <ConstVehicleSpeed.h> Inherits from Speed","title":"ConstVehicleSpeed"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstVehicleSpeed/#public-functions","text":"Name ConstVehicleSpeed (double vehicle_speed, double default_val) Constructor for the ConstVehicleSpeed class. Receives as a parameter a double which represents the desired speed of the vehicle in the inertial frame. virtual double getVd (double gamma, double tangent_norm) override Method to get the desired velocity for the virtual target on the path given the path parameter (given by the value of gamma) virtual double get_d_Vd (double gamma, double tangent_norm) override Method to get the desired acceleration for the virtual target on the path given the path parameter (given by the value of gamma) virtual double getDefaultVd (double gamma, double tangent_norm) override Method to get the default desired velocity for safety when we are doing path following and want to have a backup value.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstVehicleSpeed/#additional-inherited-members","text":"Public Functions inherited from Speed Name virtual ~Speed () Virtual destructor for the abstract class.","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstVehicleSpeed/#detailed-description","text":"class ConstVehicleSpeed; Class that implements a constant speed value requirement. This class will receive in its constructor the desired velocity for the speed in the inertial frame and will implement the corresponding speed in the path frame. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the speeds library","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstVehicleSpeed/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstVehicleSpeed/#function-constvehiclespeed","text":"ConstVehicleSpeed( double vehicle_speed, double default_val ) Constructor for the ConstVehicleSpeed class. Receives as a parameter a double which represents the desired speed of the vehicle in the inertial frame. Parameters : vehicle_speed The desired speed for the vehicle in m/s default_val The desired default_value when the vehicle is outside the gamma range","title":"function ConstVehicleSpeed"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstVehicleSpeed/#function-getvd","text":"virtual double getVd( double gamma, double tangent_norm ) override Method to get the desired velocity for the virtual target on the path given the path parameter (given by the value of gamma) Parameters : gamma The path parameter tangent_norm The norm of the tangent to the path Return : A double with the desired speed Reimplements : Speed::getVd","title":"function getVd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstVehicleSpeed/#function-get_d_vd","text":"virtual double get_d_Vd( double gamma, double tangent_norm ) override Method to get the desired acceleration for the virtual target on the path given the path parameter (given by the value of gamma) Parameters : gamma The value of the path parameter tangent_norm The norm of the tangent to the path Return : A double with the desired acceleration Reimplements : Speed::get_d_Vd","title":"function get_d_Vd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classConstVehicleSpeed/#function-getdefaultvd","text":"virtual double getDefaultVd( double gamma, double tangent_norm ) override Method to get the default desired velocity for safety when we are doing path following and want to have a backup value. Parameters : gamma The value of the path parameter tangent_norm The norm of the tangent to the path in gamma Return : A double with the default desired speed Reimplements : Speed::getDefaultVd Updated on 2022-05-30 at 14:56:44 +0000","title":"function getDefaultVd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classLine/","text":"Line Class that implements a 3D line section. More... #include <Line.h> Inherits from PathSection Public Functions Name Line (Eigen::Vector3d start_point, Eigen::Vector3d end_point) Constructor for the 3DLine class. It assumes that the reference for the frame is (0, 0, 0) Line (Eigen::Vector3d start_point, Eigen::Vector3d end_point, Eigen::Vector3d ref_point) Constructor for the 3DLine class. virtual Eigen::Vector3d eq_pd (double t) override Path section equation. virtual Eigen::Vector3d eq_d_pd (double t) override First derivative of the path section equation with respect to the path parameter t. virtual Eigen::Vector3d eq_dd_pd (double t) override Second derivative of the path section equation with respect to the path parameter t. virtual double curvature (double t) override The curvature of a line is constant, therefore we can make the computation really efficient. virtual double getClosestPointGamma (Eigen::Vector3d & coordinate) override Method for getting the gamma of the closes point to the path in a more efficient manner For a line it uses a closed form equation to solve this problem. Additional inherited members Public Functions inherited from PathSection Name virtual double tangent (double t) Default method for computing the tangent to the path section. virtual double derivative_norm (double t) Default method for computing the norm of the derivative. bool can_be_composed () Method to return whether a pathSection can be composed with other path sections or not. double limitGamma (double t) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. double getMaxGammaValue () Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. double getMinGammaValue () Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. virtual ~PathSection () Virtual destructor for the abstract class. Protected Functions inherited from PathSection Name PathSection (bool can_be_composed) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . bool setMaxGammaValue (double gamma_max) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. bool setMinGammaValue (double gamma_min) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. double GradientDescent (double gamma_o, Eigen::Vector3d & x_pos, double tolerance) Method that implements the gradient descent to minimize the error of double getInitialGammaEstimate (Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. double bisection (Eigen::Vector3d & x_pos, double a, double b) Method to implement bisection method Detailed Description class Line; Class that implements a 3D line section. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the sections library Public Functions Documentation function Line Line( Eigen::Vector3d start_point, Eigen::Vector3d end_point ) Constructor for the 3DLine class. It assumes that the reference for the frame is (0, 0, 0) Parameters : start_point The starting point in the 3D space end_point The end point in the 3D space function Line Line( Eigen::Vector3d start_point, Eigen::Vector3d end_point, Eigen::Vector3d ref_point ) Constructor for the 3DLine class. Parameters : start_point The starting point in the 3D space end_point The end point in the 3D space ref_point The ref_point in the 3D to draw the line relative to this reference function eq_pd virtual Eigen::Vector3d eq_pd( double t ) override Path section equation. Parameters : t The path parameter Return : An Eigen::Vector3d with the value of the equation of the path Reimplements : PathSection::eq_pd function eq_d_pd virtual Eigen::Vector3d eq_d_pd( double t ) override First derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter Return : An Eigen::Vector3d with the value of the derivative of the path equation Reimplements : PathSection::eq_d_pd function eq_dd_pd virtual Eigen::Vector3d eq_dd_pd( double t ) override Second derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter Return : An Eigen::Vector3d with the value of the second derivative of the path equation Reimplements : PathSection::eq_dd_pd function curvature virtual double curvature( double t ) override The curvature of a line is constant, therefore we can make the computation really efficient. Parameters : t The path parameter Return : A double = 0 (since a line has no curvature) Reimplements : PathSection::curvature function getClosestPointGamma virtual double getClosestPointGamma( Eigen::Vector3d & coordinate ) override Method for getting the gamma of the closes point to the path in a more efficient manner For a line it uses a closed form equation to solve this problem. Parameters : coordinate The vehicle coordinate Return : A double with the gamma corresponding to the cloest point in the path. Reimplements : PathSection::getClosestPointGamma Updated on 2022-05-30 at 14:56:44 +0000","title":"Line"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classLine/#line","text":"Class that implements a 3D line section. More... #include <Line.h> Inherits from PathSection","title":"Line"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classLine/#public-functions","text":"Name Line (Eigen::Vector3d start_point, Eigen::Vector3d end_point) Constructor for the 3DLine class. It assumes that the reference for the frame is (0, 0, 0) Line (Eigen::Vector3d start_point, Eigen::Vector3d end_point, Eigen::Vector3d ref_point) Constructor for the 3DLine class. virtual Eigen::Vector3d eq_pd (double t) override Path section equation. virtual Eigen::Vector3d eq_d_pd (double t) override First derivative of the path section equation with respect to the path parameter t. virtual Eigen::Vector3d eq_dd_pd (double t) override Second derivative of the path section equation with respect to the path parameter t. virtual double curvature (double t) override The curvature of a line is constant, therefore we can make the computation really efficient. virtual double getClosestPointGamma (Eigen::Vector3d & coordinate) override Method for getting the gamma of the closes point to the path in a more efficient manner For a line it uses a closed form equation to solve this problem.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classLine/#additional-inherited-members","text":"Public Functions inherited from PathSection Name virtual double tangent (double t) Default method for computing the tangent to the path section. virtual double derivative_norm (double t) Default method for computing the norm of the derivative. bool can_be_composed () Method to return whether a pathSection can be composed with other path sections or not. double limitGamma (double t) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. double getMaxGammaValue () Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. double getMinGammaValue () Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. virtual ~PathSection () Virtual destructor for the abstract class. Protected Functions inherited from PathSection Name PathSection (bool can_be_composed) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . bool setMaxGammaValue (double gamma_max) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. bool setMinGammaValue (double gamma_min) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. double GradientDescent (double gamma_o, Eigen::Vector3d & x_pos, double tolerance) Method that implements the gradient descent to minimize the error of double getInitialGammaEstimate (Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. double bisection (Eigen::Vector3d & x_pos, double a, double b) Method to implement bisection method","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classLine/#detailed-description","text":"class Line; Class that implements a 3D line section. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the sections library","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classLine/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classLine/#function-line","text":"Line( Eigen::Vector3d start_point, Eigen::Vector3d end_point ) Constructor for the 3DLine class. It assumes that the reference for the frame is (0, 0, 0) Parameters : start_point The starting point in the 3D space end_point The end point in the 3D space","title":"function Line"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classLine/#function-line_1","text":"Line( Eigen::Vector3d start_point, Eigen::Vector3d end_point, Eigen::Vector3d ref_point ) Constructor for the 3DLine class. Parameters : start_point The starting point in the 3D space end_point The end point in the 3D space ref_point The ref_point in the 3D to draw the line relative to this reference","title":"function Line"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classLine/#function-eq_pd","text":"virtual Eigen::Vector3d eq_pd( double t ) override Path section equation. Parameters : t The path parameter Return : An Eigen::Vector3d with the value of the equation of the path Reimplements : PathSection::eq_pd","title":"function eq_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classLine/#function-eq_d_pd","text":"virtual Eigen::Vector3d eq_d_pd( double t ) override First derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter Return : An Eigen::Vector3d with the value of the derivative of the path equation Reimplements : PathSection::eq_d_pd","title":"function eq_d_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classLine/#function-eq_dd_pd","text":"virtual Eigen::Vector3d eq_dd_pd( double t ) override Second derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter Return : An Eigen::Vector3d with the value of the second derivative of the path equation Reimplements : PathSection::eq_dd_pd","title":"function eq_dd_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classLine/#function-curvature","text":"virtual double curvature( double t ) override The curvature of a line is constant, therefore we can make the computation really efficient. Parameters : t The path parameter Return : A double = 0 (since a line has no curvature) Reimplements : PathSection::curvature","title":"function curvature"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classLine/#function-getclosestpointgamma","text":"virtual double getClosestPointGamma( Eigen::Vector3d & coordinate ) override Method for getting the gamma of the closes point to the path in a more efficient manner For a line it uses a closed form equation to solve this problem. Parameters : coordinate The vehicle coordinate Return : A double with the gamma corresponding to the cloest point in the path. Reimplements : PathSection::getClosestPointGamma Updated on 2022-05-30 at 14:56:44 +0000","title":"function getClosestPointGamma"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/","text":"Path The Path class! This class implements all the meethod to get the desired position, derivative, second derivatives, tangent, curvature and derivative norm. More... #include <Path.h> Public Functions Name Path () The constructor for the path class. ~Path () The destructor for the path class. Frees all the memory allocated for each path section inside the vector of section. bool isEmpty () Method to check wether the path contains path sections or not. bool addPathSection ( PathSection * path_section) Method to add a path section to the path. bool addSpeedSection ( Speed * speed_section) * Method to add a speed section to the path std::tuple< PathSection *, double > getPathSection (double gamma) Method to get the path section corresponding to a given gamma. std::optional< Eigen::Vector3d > eq_pd (double gamma) * Method to retrieve the position in the path given the path parameter gamma std::optional< Eigen::Vector3d > eq_d_pd (double gamma) * Method to retrieve the derivative of the position in the path given the path parameter gamma std::optional< Eigen::Vector3d > eq_dd_pd (double gamma) * Method to retrieve the second derivative of the position in the path given the path parameter gamma std::optional< double > tangent (double gamma) * Get the tangent to the path, given the gamma parameter std::optional< double > curvature (double gamma) * The curvature of the path, given the gamma parameter std::optional< double > derivative_norm (double gamma) * The norm of the derivative of the path std::optional< double > eq_vd (double gamma) Method to get the desired speed profile for a particular part of the path given the path parameter gamma. std::optional< double > eq_d_vd (double gamma) Method to get the desired acceleration profile for a paritcular part of the path given the path parameter. std::pair< double, double > getMinMaxGamma () Method to retrieve the minimum and maximum gamma values allowed for the current path. std::optional< double > getClosestGamma (Eigen::Vector3d & coordinate) Method to get the gamma corresponding to the closest point on the path, relative to the coordinate passed as argument. Public Attributes Name std::vector< PathSection * > sections_ List of PathSections to follow. Detailed Description class Path; The Path class! This class implements all the meethod to get the desired position, derivative, second derivatives, tangent, curvature and derivative norm. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class stores a list of sections, and switches between sections based on the gamma value passed to the functions This class has the option to have a single section (for example, appropriate for a Bernoulli ) and the option to have multiple section (for example, lines and arcs to make lawnmowers) Public Functions Documentation function Path Path() The constructor for the path class. function ~Path ~Path() The destructor for the path class. Frees all the memory allocated for each path section inside the vector of section. Destructor for the Path object. Deletes the memory allocated for each path section inside the vector of sections. function isEmpty bool isEmpty() Method to check wether the path contains path sections or not. Return : A boolean true if the path contains path sections in the vector function addPathSection bool addPathSection( PathSection * path_section ) Method to add a path section to the path. Parameters : *path_section A Pointer to a PathSection object (can be Line , Arc2D , Bernoulli , etc...) Return : true if path was added with success or false if not function addSpeedSection bool addSpeedSection( Speed * speed_section ) Method to add a speed section to the path Parameters : speed_section A Pointer to a SpeedSection object (can be ConstRabbitSpeed , ConstVehicleSpeed , ...) Return : true if the speed was added with success or false if not function getPathSection std::tuple< PathSection *, double > getPathSection( double gamma ) Method to get the path section corresponding to a given gamma. Parameters : gamma - A double with the path parameter Return : The PathSection object corresponding to the given gamma and the internal gamma corresponding to that path section function eq_pd std::optional< Eigen::Vector3d > eq_pd( double gamma ) Method to retrieve the position in the path given the path parameter gamma Parameters : gamma - A double with the path parameter Return : A vector (3x1) with [x(gamma), y(gamma), z(gamma)] function eq_d_pd std::optional< Eigen::Vector3d > eq_d_pd( double gamma ) Method to retrieve the derivative of the position in the path given the path parameter gamma Parameters : gamma - A double with the path parameter Return : A vector (3x1) with [x_dot(gamma, y_dot(gamma), z_dot(gamma)] function eq_dd_pd std::optional< Eigen::Vector3d > eq_dd_pd( double gamma ) Method to retrieve the second derivative of the position in the path given the path parameter gamma Parameters : gamma - A double with the path parameter Return : A vector (3x1) with [x_ddot(gamma), y_ddot(gamma), z_ddot(gamma)] function tangent std::optional< double > tangent( double gamma ) Get the tangent to the path, given the gamma parameter Parameters : gamma - A double with the path parameter Return : A double with the tangent size function curvature std::optional< double > curvature( double gamma ) The curvature of the path, given the gamma parameter Parameters : gamma - A double with the path parameter Return : A double with the curvature of the path function derivative_norm std::optional< double > derivative_norm( double gamma ) The norm of the derivative of the path Parameters : gamma - A double with the path parameter Return : A double with the norm of the derivative of the path function eq_vd std::optional< double > eq_vd( double gamma ) Method to get the desired speed profile for a particular part of the path given the path parameter gamma. Parameters : gamma A double with the path parameter Return : A double with the value of vd function eq_d_vd std::optional< double > eq_d_vd( double gamma ) Method to get the desired acceleration profile for a paritcular part of the path given the path parameter. Parameters : gamma A double with the path parameter Return : A double with the valud of d_vd function getMinMaxGamma std::pair< double, double > getMinMaxGamma() Method to retrieve the minimum and maximum gamma values allowed for the current path. Return : A pair with 2 doubles with the first being the minimum value and the second the maximum value Method to return the minimum and maximum value that gamma can achive in the path. function getClosestGamma std::optional< double > getClosestGamma( Eigen::Vector3d & coordinate ) Method to get the gamma corresponding to the closest point on the path, relative to the coordinate passed as argument. Parameters : coordinate The coordinate of the vehicle Return : A double with the gamma of the path corresponding to the closest point on the path Public Attributes Documentation variable sections_ std::vector< PathSection * > sections_; List of PathSections to follow. Updated on 2022-05-30 at 14:56:44 +0000","title":"Path"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#path","text":"The Path class! This class implements all the meethod to get the desired position, derivative, second derivatives, tangent, curvature and derivative norm. More... #include <Path.h>","title":"Path"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#public-functions","text":"Name Path () The constructor for the path class. ~Path () The destructor for the path class. Frees all the memory allocated for each path section inside the vector of section. bool isEmpty () Method to check wether the path contains path sections or not. bool addPathSection ( PathSection * path_section) Method to add a path section to the path. bool addSpeedSection ( Speed * speed_section) * Method to add a speed section to the path std::tuple< PathSection *, double > getPathSection (double gamma) Method to get the path section corresponding to a given gamma. std::optional< Eigen::Vector3d > eq_pd (double gamma) * Method to retrieve the position in the path given the path parameter gamma std::optional< Eigen::Vector3d > eq_d_pd (double gamma) * Method to retrieve the derivative of the position in the path given the path parameter gamma std::optional< Eigen::Vector3d > eq_dd_pd (double gamma) * Method to retrieve the second derivative of the position in the path given the path parameter gamma std::optional< double > tangent (double gamma) * Get the tangent to the path, given the gamma parameter std::optional< double > curvature (double gamma) * The curvature of the path, given the gamma parameter std::optional< double > derivative_norm (double gamma) * The norm of the derivative of the path std::optional< double > eq_vd (double gamma) Method to get the desired speed profile for a particular part of the path given the path parameter gamma. std::optional< double > eq_d_vd (double gamma) Method to get the desired acceleration profile for a paritcular part of the path given the path parameter. std::pair< double, double > getMinMaxGamma () Method to retrieve the minimum and maximum gamma values allowed for the current path. std::optional< double > getClosestGamma (Eigen::Vector3d & coordinate) Method to get the gamma corresponding to the closest point on the path, relative to the coordinate passed as argument.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#public-attributes","text":"Name std::vector< PathSection * > sections_ List of PathSections to follow.","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#detailed-description","text":"class Path; The Path class! This class implements all the meethod to get the desired position, derivative, second derivatives, tangent, curvature and derivative norm. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class stores a list of sections, and switches between sections based on the gamma value passed to the functions This class has the option to have a single section (for example, appropriate for a Bernoulli ) and the option to have multiple section (for example, lines and arcs to make lawnmowers)","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#function-path","text":"Path() The constructor for the path class.","title":"function Path"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#function-path_1","text":"~Path() The destructor for the path class. Frees all the memory allocated for each path section inside the vector of section. Destructor for the Path object. Deletes the memory allocated for each path section inside the vector of sections.","title":"function ~Path"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#function-isempty","text":"bool isEmpty() Method to check wether the path contains path sections or not. Return : A boolean true if the path contains path sections in the vector","title":"function isEmpty"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#function-addpathsection","text":"bool addPathSection( PathSection * path_section ) Method to add a path section to the path. Parameters : *path_section A Pointer to a PathSection object (can be Line , Arc2D , Bernoulli , etc...) Return : true if path was added with success or false if not","title":"function addPathSection"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#function-addspeedsection","text":"bool addSpeedSection( Speed * speed_section ) Method to add a speed section to the path Parameters : speed_section A Pointer to a SpeedSection object (can be ConstRabbitSpeed , ConstVehicleSpeed , ...) Return : true if the speed was added with success or false if not","title":"function addSpeedSection"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#function-getpathsection","text":"std::tuple< PathSection *, double > getPathSection( double gamma ) Method to get the path section corresponding to a given gamma. Parameters : gamma - A double with the path parameter Return : The PathSection object corresponding to the given gamma and the internal gamma corresponding to that path section","title":"function getPathSection"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#function-eq_pd","text":"std::optional< Eigen::Vector3d > eq_pd( double gamma ) Method to retrieve the position in the path given the path parameter gamma Parameters : gamma - A double with the path parameter Return : A vector (3x1) with [x(gamma), y(gamma), z(gamma)]","title":"function eq_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#function-eq_d_pd","text":"std::optional< Eigen::Vector3d > eq_d_pd( double gamma ) Method to retrieve the derivative of the position in the path given the path parameter gamma Parameters : gamma - A double with the path parameter Return : A vector (3x1) with [x_dot(gamma, y_dot(gamma), z_dot(gamma)]","title":"function eq_d_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#function-eq_dd_pd","text":"std::optional< Eigen::Vector3d > eq_dd_pd( double gamma ) Method to retrieve the second derivative of the position in the path given the path parameter gamma Parameters : gamma - A double with the path parameter Return : A vector (3x1) with [x_ddot(gamma), y_ddot(gamma), z_ddot(gamma)]","title":"function eq_dd_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#function-tangent","text":"std::optional< double > tangent( double gamma ) Get the tangent to the path, given the gamma parameter Parameters : gamma - A double with the path parameter Return : A double with the tangent size","title":"function tangent"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#function-curvature","text":"std::optional< double > curvature( double gamma ) The curvature of the path, given the gamma parameter Parameters : gamma - A double with the path parameter Return : A double with the curvature of the path","title":"function curvature"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#function-derivative_norm","text":"std::optional< double > derivative_norm( double gamma ) The norm of the derivative of the path Parameters : gamma - A double with the path parameter Return : A double with the norm of the derivative of the path","title":"function derivative_norm"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#function-eq_vd","text":"std::optional< double > eq_vd( double gamma ) Method to get the desired speed profile for a particular part of the path given the path parameter gamma. Parameters : gamma A double with the path parameter Return : A double with the value of vd","title":"function eq_vd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#function-eq_d_vd","text":"std::optional< double > eq_d_vd( double gamma ) Method to get the desired acceleration profile for a paritcular part of the path given the path parameter. Parameters : gamma A double with the path parameter Return : A double with the valud of d_vd","title":"function eq_d_vd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#function-getminmaxgamma","text":"std::pair< double, double > getMinMaxGamma() Method to retrieve the minimum and maximum gamma values allowed for the current path. Return : A pair with 2 doubles with the first being the minimum value and the second the maximum value Method to return the minimum and maximum value that gamma can achive in the path.","title":"function getMinMaxGamma"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#function-getclosestgamma","text":"std::optional< double > getClosestGamma( Eigen::Vector3d & coordinate ) Method to get the gamma corresponding to the closest point on the path, relative to the coordinate passed as argument. Parameters : coordinate The coordinate of the vehicle Return : A double with the gamma of the path corresponding to the closest point on the path","title":"function getClosestGamma"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPath/#variable-sections_","text":"std::vector< PathSection * > sections_; List of PathSections to follow. Updated on 2022-05-30 at 14:56:44 +0000","title":"variable sections_"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathNode/","text":"PathNode Implementation of the PathNode . Creates a Path , adds elements to the path and publishes the path data when listening to the path parameter gamma. More... #include <PathNode.h> Public Functions Name PathNode (ros::NodeHandle * nh, ros::NodeHandle * nh_p) Constructor of the PathNode class. ~PathNode () Destructor of the PathNode class. Detailed Description class PathNode; Implementation of the PathNode . Creates a Path , adds elements to the path and publishes the path data when listening to the path parameter gamma. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT Public Functions Documentation function PathNode PathNode( ros::NodeHandle * nh, ros::NodeHandle * nh_p ) Constructor of the PathNode class. Parameters : nh Pointer to a public ROS NodeHandle nh_p Pointer to a private ROS NodeHandle nh A pointer to the public ROS node handle nh_p A pointer to the private ROS node handle PathNode constructor. Receives the ROS node handles as inputs and initializes the subscribers, publishers, timers, parameters, etc... function ~PathNode ~PathNode() Destructor of the PathNode class. Class destructor. Called when deleting the class object. Updated on 2022-05-30 at 14:56:43 +0000","title":"PathNode"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathNode/#pathnode","text":"Implementation of the PathNode . Creates a Path , adds elements to the path and publishes the path data when listening to the path parameter gamma. More... #include <PathNode.h>","title":"PathNode"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathNode/#public-functions","text":"Name PathNode (ros::NodeHandle * nh, ros::NodeHandle * nh_p) Constructor of the PathNode class. ~PathNode () Destructor of the PathNode class.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathNode/#detailed-description","text":"class PathNode; Implementation of the PathNode . Creates a Path , adds elements to the path and publishes the path data when listening to the path parameter gamma. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathNode/#function-pathnode","text":"PathNode( ros::NodeHandle * nh, ros::NodeHandle * nh_p ) Constructor of the PathNode class. Parameters : nh Pointer to a public ROS NodeHandle nh_p Pointer to a private ROS NodeHandle nh A pointer to the public ROS node handle nh_p A pointer to the private ROS node handle PathNode constructor. Receives the ROS node handles as inputs and initializes the subscribers, publishers, timers, parameters, etc...","title":"function PathNode"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathNode/#function-pathnode_1","text":"~PathNode() Destructor of the PathNode class. Class destructor. Called when deleting the class object. Updated on 2022-05-30 at 14:56:43 +0000","title":"function ~PathNode"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/","text":"PathSection An abstract class that is used as a template for Path Sections. More... #include <PathSection.h> Inherited by Arc2D , Bernoulli , Circle2D , Line , Polinomial5 , Polynomial5 , Sinusoid2D Public Functions Name virtual Eigen::Vector3d eq_pd (double t) =0 The Path section equation. virtual Eigen::Vector3d eq_d_pd (double t) =0 First derivative of the path section equation with respect to path parameter t. virtual Eigen::Vector3d eq_dd_pd (double t) =0 Second derivative of the path section equation with respect to the path parameter t. virtual double tangent (double t) Default method for computing the tangent to the path section. virtual double curvature (double t) Default method for computing the curvature. The default implementation implements the general formula to compute the curvature based on the derivative equations of the path. virtual double derivative_norm (double t) Default method for computing the norm of the derivative. virtual double getClosestPointGamma (Eigen::Vector3d & coordinate) Default method for getting the gamma of the closed point to the path. By default this method uses gradient Descent algorithm to compute the closest point in the path with the initial guess of gamma=0.0. bool can_be_composed () Method to return whether a pathSection can be composed with other path sections or not. double limitGamma (double t) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. double getMaxGammaValue () Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. double getMinGammaValue () Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. virtual ~PathSection () Virtual destructor for the abstract class. Protected Functions Name PathSection (bool can_be_composed) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . bool setMaxGammaValue (double gamma_max) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. bool setMinGammaValue (double gamma_min) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. double GradientDescent (double gamma_o, Eigen::Vector3d & x_pos, double tolerance) Method that implements the gradient descent to minimize the error of double getInitialGammaEstimate (Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. double bisection (Eigen::Vector3d & x_pos, double a, double b) Method to implement bisection method Detailed Description class PathSection; An abstract class that is used as a template for Path Sections. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT For path sections that can_be_composed the minimum value of gamma will be defaulted to 0 (and cannot be changed) in order not to mess with the Path section switching algorithm. The maximum value can be any greater than 0. For path sections where can_be_composed = false, the minimum value for gamma if -inf an the maximum value if +inf (but these can be changed) Public Functions Documentation function eq_pd virtual Eigen::Vector3d eq_pd( double t ) =0 The Path section equation. Parameters : t The path parameter Return : An Eigen::Vector3d with the equation of the path with respect to the path parameter Reimplemented by : Polinomial5::eq_pd , Polynomial5::eq_pd , Line::eq_pd , Sinusoid2D::eq_pd , Circle2D::eq_pd , Bernoulli::eq_pd , Arc2D::eq_pd function eq_d_pd virtual Eigen::Vector3d eq_d_pd( double t ) =0 First derivative of the path section equation with respect to path parameter t. Parameters : t The path parameter Return : An Eigen::Vector3d with the first derivative of the path equation with respect to the path parameter Reimplemented by : Polinomial5::eq_d_pd , Polynomial5::eq_d_pd , Line::eq_d_pd , Sinusoid2D::eq_d_pd , Circle2D::eq_d_pd , Bernoulli::eq_d_pd , Arc2D::eq_d_pd function eq_dd_pd virtual Eigen::Vector3d eq_dd_pd( double t ) =0 Second derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter Return : An Eigen::Vector3d with the second derivative of the path equation with respect to the path paramter Reimplemented by : Polinomial5::eq_dd_pd , Polynomial5::eq_dd_pd , Line::eq_dd_pd , Circle2D::eq_dd_pd , Bernoulli::eq_dd_pd , Sinusoid2D::eq_dd_pd , Arc2D::eq_dd_pd function tangent virtual double tangent( double t ) Default method for computing the tangent to the path section. Parameters : t The path parameter Return : A double with the angle of the tangent to the path function curvature virtual double curvature( double t ) Default method for computing the curvature. The default implementation implements the general formula to compute the curvature based on the derivative equations of the path. Parameters : t The path parameter Return : A double with the path curvature Reimplemented by : Line::curvature , Circle2D::curvature , Bernoulli::curvature , Arc2D::curvature function derivative_norm virtual double derivative_norm( double t ) Default method for computing the norm of the derivative. Parameters : t The path parameter Return : A double with the norm of the derivative of the path position pd function getClosestPointGamma virtual double getClosestPointGamma( Eigen::Vector3d & coordinate ) Default method for getting the gamma of the closed point to the path. By default this method uses gradient Descent algorithm to compute the closest point in the path with the initial guess of gamma=0.0. Parameters : coordinate A Eigen::Vector3d with the coordinates of the vehicle Return : A double with the closest point in the path Reimplemented by : Polinomial5::getClosestPointGamma , Polynomial5::getClosestPointGamma , Sinusoid2D::getClosestPointGamma , Line::getClosestPointGamma , Circle2D::getClosestPointGamma , Bernoulli::getClosestPointGamma , Arc2D::getClosestPointGamma This is not the most efficient way to compute the closest point for several kinds of paths, but it is the most general, hence used as the default one Method to return the closest point to the path By default just calls the Gradient Descent algorithm function can_be_composed bool can_be_composed() Method to return whether a pathSection can be composed with other path sections or not. Return : A boolean indicating wether the pathsection can be composed with other sections or not function limitGamma double limitGamma( double t ) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. Parameters : t The path parameter also known as gamma Return : A double with the path parameter limited between the valid bounds function getMaxGammaValue double getMaxGammaValue() Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. Return : A double with the maximum value that can be achieved with gamma function getMinGammaValue double getMinGammaValue() Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. Return : A double with the minimum value the can be achieved with gamma function ~PathSection virtual ~PathSection() Virtual destructor for the abstract class. Protected Functions Documentation function PathSection PathSection( bool can_be_composed ) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . Parameters : can_be_composed A boolean that indicated that if this kind of path can be composed with other path sections or not function setMaxGammaValue bool setMaxGammaValue( double gamma_max ) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. Parameters : gamma_max The desired max value for gamma Return : True if new value was accepted function setMinGammaValue bool setMinGammaValue( double gamma_min ) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. Parameters : gamma_min The desired min value for gamma Return : True if the new value was accepted NOTE: for paths where can_be_composed == true, this function always returns false as it is required for those kinds of segments to start with 0 (but no limit is put on gamma max) function GradientDescent double GradientDescent( double gamma_o, Eigen::Vector3d & x_pos, double tolerance ) Method that implements the gradient descent to minimize the error of ||pd(gamma) - p_vehicle||. Parameters : gamma_o The initial guess for the path paramter x_pos The position of the vehicle tolerance A constant tweaking parameter Return : the estimated gamma value that minimizes the error function getInitialGammaEstimate double getInitialGammaEstimate( Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val ) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. Parameters : x_pos The position of the vehicle num_partitions The number of divisions to make on the path min_val The minimum boundary to search in gamma max_val The maximum boundary to search in gamma Return : A double with a good gamma to use as an initialization for the estimation Then grabs the gamma that minimizes the most from all sections function bisection double bisection( Eigen::Vector3d & x_pos, double a, double b ) Method to implement bisection method Parameters : x_pos The position of the vehicle a The left bound for the gamma value b The right bound for the gamma value Return : The most likely value of gamma Updated on 2022-05-30 at 14:56:43 +0000","title":"PathSection"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#pathsection","text":"An abstract class that is used as a template for Path Sections. More... #include <PathSection.h> Inherited by Arc2D , Bernoulli , Circle2D , Line , Polinomial5 , Polynomial5 , Sinusoid2D","title":"PathSection"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#public-functions","text":"Name virtual Eigen::Vector3d eq_pd (double t) =0 The Path section equation. virtual Eigen::Vector3d eq_d_pd (double t) =0 First derivative of the path section equation with respect to path parameter t. virtual Eigen::Vector3d eq_dd_pd (double t) =0 Second derivative of the path section equation with respect to the path parameter t. virtual double tangent (double t) Default method for computing the tangent to the path section. virtual double curvature (double t) Default method for computing the curvature. The default implementation implements the general formula to compute the curvature based on the derivative equations of the path. virtual double derivative_norm (double t) Default method for computing the norm of the derivative. virtual double getClosestPointGamma (Eigen::Vector3d & coordinate) Default method for getting the gamma of the closed point to the path. By default this method uses gradient Descent algorithm to compute the closest point in the path with the initial guess of gamma=0.0. bool can_be_composed () Method to return whether a pathSection can be composed with other path sections or not. double limitGamma (double t) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. double getMaxGammaValue () Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. double getMinGammaValue () Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. virtual ~PathSection () Virtual destructor for the abstract class.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#protected-functions","text":"Name PathSection (bool can_be_composed) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . bool setMaxGammaValue (double gamma_max) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. bool setMinGammaValue (double gamma_min) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. double GradientDescent (double gamma_o, Eigen::Vector3d & x_pos, double tolerance) Method that implements the gradient descent to minimize the error of double getInitialGammaEstimate (Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. double bisection (Eigen::Vector3d & x_pos, double a, double b) Method to implement bisection method","title":"Protected Functions"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#detailed-description","text":"class PathSection; An abstract class that is used as a template for Path Sections. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT For path sections that can_be_composed the minimum value of gamma will be defaulted to 0 (and cannot be changed) in order not to mess with the Path section switching algorithm. The maximum value can be any greater than 0. For path sections where can_be_composed = false, the minimum value for gamma if -inf an the maximum value if +inf (but these can be changed)","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-eq_pd","text":"virtual Eigen::Vector3d eq_pd( double t ) =0 The Path section equation. Parameters : t The path parameter Return : An Eigen::Vector3d with the equation of the path with respect to the path parameter Reimplemented by : Polinomial5::eq_pd , Polynomial5::eq_pd , Line::eq_pd , Sinusoid2D::eq_pd , Circle2D::eq_pd , Bernoulli::eq_pd , Arc2D::eq_pd","title":"function eq_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-eq_d_pd","text":"virtual Eigen::Vector3d eq_d_pd( double t ) =0 First derivative of the path section equation with respect to path parameter t. Parameters : t The path parameter Return : An Eigen::Vector3d with the first derivative of the path equation with respect to the path parameter Reimplemented by : Polinomial5::eq_d_pd , Polynomial5::eq_d_pd , Line::eq_d_pd , Sinusoid2D::eq_d_pd , Circle2D::eq_d_pd , Bernoulli::eq_d_pd , Arc2D::eq_d_pd","title":"function eq_d_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-eq_dd_pd","text":"virtual Eigen::Vector3d eq_dd_pd( double t ) =0 Second derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter Return : An Eigen::Vector3d with the second derivative of the path equation with respect to the path paramter Reimplemented by : Polinomial5::eq_dd_pd , Polynomial5::eq_dd_pd , Line::eq_dd_pd , Circle2D::eq_dd_pd , Bernoulli::eq_dd_pd , Sinusoid2D::eq_dd_pd , Arc2D::eq_dd_pd","title":"function eq_dd_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-tangent","text":"virtual double tangent( double t ) Default method for computing the tangent to the path section. Parameters : t The path parameter Return : A double with the angle of the tangent to the path","title":"function tangent"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-curvature","text":"virtual double curvature( double t ) Default method for computing the curvature. The default implementation implements the general formula to compute the curvature based on the derivative equations of the path. Parameters : t The path parameter Return : A double with the path curvature Reimplemented by : Line::curvature , Circle2D::curvature , Bernoulli::curvature , Arc2D::curvature","title":"function curvature"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-derivative_norm","text":"virtual double derivative_norm( double t ) Default method for computing the norm of the derivative. Parameters : t The path parameter Return : A double with the norm of the derivative of the path position pd","title":"function derivative_norm"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-getclosestpointgamma","text":"virtual double getClosestPointGamma( Eigen::Vector3d & coordinate ) Default method for getting the gamma of the closed point to the path. By default this method uses gradient Descent algorithm to compute the closest point in the path with the initial guess of gamma=0.0. Parameters : coordinate A Eigen::Vector3d with the coordinates of the vehicle Return : A double with the closest point in the path Reimplemented by : Polinomial5::getClosestPointGamma , Polynomial5::getClosestPointGamma , Sinusoid2D::getClosestPointGamma , Line::getClosestPointGamma , Circle2D::getClosestPointGamma , Bernoulli::getClosestPointGamma , Arc2D::getClosestPointGamma This is not the most efficient way to compute the closest point for several kinds of paths, but it is the most general, hence used as the default one Method to return the closest point to the path By default just calls the Gradient Descent algorithm","title":"function getClosestPointGamma"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-can_be_composed","text":"bool can_be_composed() Method to return whether a pathSection can be composed with other path sections or not. Return : A boolean indicating wether the pathsection can be composed with other sections or not","title":"function can_be_composed"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-limitgamma","text":"double limitGamma( double t ) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. Parameters : t The path parameter also known as gamma Return : A double with the path parameter limited between the valid bounds","title":"function limitGamma"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-getmaxgammavalue","text":"double getMaxGammaValue() Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. Return : A double with the maximum value that can be achieved with gamma","title":"function getMaxGammaValue"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-getmingammavalue","text":"double getMinGammaValue() Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. Return : A double with the minimum value the can be achieved with gamma","title":"function getMinGammaValue"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-pathsection","text":"virtual ~PathSection() Virtual destructor for the abstract class.","title":"function ~PathSection"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-pathsection_1","text":"PathSection( bool can_be_composed ) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . Parameters : can_be_composed A boolean that indicated that if this kind of path can be composed with other path sections or not","title":"function PathSection"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-setmaxgammavalue","text":"bool setMaxGammaValue( double gamma_max ) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. Parameters : gamma_max The desired max value for gamma Return : True if new value was accepted","title":"function setMaxGammaValue"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-setmingammavalue","text":"bool setMinGammaValue( double gamma_min ) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. Parameters : gamma_min The desired min value for gamma Return : True if the new value was accepted NOTE: for paths where can_be_composed == true, this function always returns false as it is required for those kinds of segments to start with 0 (but no limit is put on gamma max)","title":"function setMinGammaValue"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-gradientdescent","text":"double GradientDescent( double gamma_o, Eigen::Vector3d & x_pos, double tolerance ) Method that implements the gradient descent to minimize the error of ||pd(gamma) - p_vehicle||. Parameters : gamma_o The initial guess for the path paramter x_pos The position of the vehicle tolerance A constant tweaking parameter Return : the estimated gamma value that minimizes the error","title":"function GradientDescent"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-getinitialgammaestimate","text":"double getInitialGammaEstimate( Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val ) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. Parameters : x_pos The position of the vehicle num_partitions The number of divisions to make on the path min_val The minimum boundary to search in gamma max_val The maximum boundary to search in gamma Return : A double with a good gamma to use as an initialization for the estimation Then grabs the gamma that minimizes the most from all sections","title":"function getInitialGammaEstimate"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPathSection/#function-bisection","text":"double bisection( Eigen::Vector3d & x_pos, double a, double b ) Method to implement bisection method Parameters : x_pos The position of the vehicle a The left bound for the gamma value b The right bound for the gamma value Return : The most likely value of gamma Updated on 2022-05-30 at 14:56:43 +0000","title":"function bisection"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolinomial5/","text":"Polinomial5 Class that implements a 5th order polinomial section. More... #include <Polinomial5.h> Inherits from PathSection Public Functions Name Polinomial5 (std::array< double, 5 > a, std::array< double, 5 > b, double c) Constructor for the Polinomial5 class, that receives the desired plane for the polinomial. virtual Eigen::Vector3d eq_pd (double t) override The Path section equation. virtual Eigen::Vector3d eq_d_pd (double t) override First derivative of the path section equation with respect to the path parameter t. virtual Eigen::Vector3d eq_dd_pd (double t) override Second derivative of the path section equation with respect to the path parameter t. virtual double getClosestPointGamma (Eigen::Vector3d & coordinate) override Method for getting the gamma of the closes point to the path. Additional inherited members Public Functions inherited from PathSection Name virtual double tangent (double t) Default method for computing the tangent to the path section. virtual double curvature (double t) Default method for computing the curvature. The default implementation implements the general formula to compute the curvature based on the derivative equations of the path. virtual double derivative_norm (double t) Default method for computing the norm of the derivative. bool can_be_composed () Method to return whether a pathSection can be composed with other path sections or not. double limitGamma (double t) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. double getMaxGammaValue () Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. double getMinGammaValue () Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. virtual ~PathSection () Virtual destructor for the abstract class. Protected Functions inherited from PathSection Name PathSection (bool can_be_composed) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . bool setMaxGammaValue (double gamma_max) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. bool setMinGammaValue (double gamma_min) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. double GradientDescent (double gamma_o, Eigen::Vector3d & x_pos, double tolerance) Method that implements the gradient descent to minimize the error of double getInitialGammaEstimate (Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. double bisection (Eigen::Vector3d & x_pos, double a, double b) Method to implement bisection method Detailed Description class Polinomial5; Class that implements a 5th order polinomial section. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the sections library Public Functions Documentation function Polinomial5 Polinomial5( std::array< double, 5 > a, std::array< double, 5 > b, double c ) Constructor for the Polinomial5 class, that receives the desired plane for the polinomial. Parameters : offset The 2D start point of the arc function eq_pd virtual Eigen::Vector3d eq_pd( double t ) override The Path section equation. Parameters : t The path parameter Return : An Eigen::Vector3d with the equation of the path with respect to the path parameter Reimplements : PathSection::eq_pd function eq_d_pd virtual Eigen::Vector3d eq_d_pd( double t ) override First derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter t Return : An Eigen::Vector3d with the equation of the partial derivative with respect to the path parameter Reimplements : PathSection::eq_d_pd function eq_dd_pd virtual Eigen::Vector3d eq_dd_pd( double t ) override Second derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter t Return : An Eigen::Vector3d with the equation of the second order partial derivative with respect to the path parameter Reimplements : PathSection::eq_dd_pd function getClosestPointGamma virtual double getClosestPointGamma( Eigen::Vector3d & coordinate ) override Method for getting the gamma of the closes point to the path. Parameters : The coordinate of the vehicle in the 3D space Return : A double with the gamma corresponding to the closest point in the path Reimplements : PathSection::getClosestPointGamma Updated on 2022-05-30 at 14:56:43 +0000","title":"Polinomial5"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolinomial5/#polinomial5","text":"Class that implements a 5th order polinomial section. More... #include <Polinomial5.h> Inherits from PathSection","title":"Polinomial5"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolinomial5/#public-functions","text":"Name Polinomial5 (std::array< double, 5 > a, std::array< double, 5 > b, double c) Constructor for the Polinomial5 class, that receives the desired plane for the polinomial. virtual Eigen::Vector3d eq_pd (double t) override The Path section equation. virtual Eigen::Vector3d eq_d_pd (double t) override First derivative of the path section equation with respect to the path parameter t. virtual Eigen::Vector3d eq_dd_pd (double t) override Second derivative of the path section equation with respect to the path parameter t. virtual double getClosestPointGamma (Eigen::Vector3d & coordinate) override Method for getting the gamma of the closes point to the path.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolinomial5/#additional-inherited-members","text":"Public Functions inherited from PathSection Name virtual double tangent (double t) Default method for computing the tangent to the path section. virtual double curvature (double t) Default method for computing the curvature. The default implementation implements the general formula to compute the curvature based on the derivative equations of the path. virtual double derivative_norm (double t) Default method for computing the norm of the derivative. bool can_be_composed () Method to return whether a pathSection can be composed with other path sections or not. double limitGamma (double t) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. double getMaxGammaValue () Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. double getMinGammaValue () Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. virtual ~PathSection () Virtual destructor for the abstract class. Protected Functions inherited from PathSection Name PathSection (bool can_be_composed) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . bool setMaxGammaValue (double gamma_max) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. bool setMinGammaValue (double gamma_min) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. double GradientDescent (double gamma_o, Eigen::Vector3d & x_pos, double tolerance) Method that implements the gradient descent to minimize the error of double getInitialGammaEstimate (Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. double bisection (Eigen::Vector3d & x_pos, double a, double b) Method to implement bisection method","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolinomial5/#detailed-description","text":"class Polinomial5; Class that implements a 5th order polinomial section. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the sections library","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolinomial5/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolinomial5/#function-polinomial5","text":"Polinomial5( std::array< double, 5 > a, std::array< double, 5 > b, double c ) Constructor for the Polinomial5 class, that receives the desired plane for the polinomial. Parameters : offset The 2D start point of the arc","title":"function Polinomial5"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolinomial5/#function-eq_pd","text":"virtual Eigen::Vector3d eq_pd( double t ) override The Path section equation. Parameters : t The path parameter Return : An Eigen::Vector3d with the equation of the path with respect to the path parameter Reimplements : PathSection::eq_pd","title":"function eq_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolinomial5/#function-eq_d_pd","text":"virtual Eigen::Vector3d eq_d_pd( double t ) override First derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter t Return : An Eigen::Vector3d with the equation of the partial derivative with respect to the path parameter Reimplements : PathSection::eq_d_pd","title":"function eq_d_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolinomial5/#function-eq_dd_pd","text":"virtual Eigen::Vector3d eq_dd_pd( double t ) override Second derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter t Return : An Eigen::Vector3d with the equation of the second order partial derivative with respect to the path parameter Reimplements : PathSection::eq_dd_pd","title":"function eq_dd_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolinomial5/#function-getclosestpointgamma","text":"virtual double getClosestPointGamma( Eigen::Vector3d & coordinate ) override Method for getting the gamma of the closes point to the path. Parameters : The coordinate of the vehicle in the 3D space Return : A double with the gamma corresponding to the closest point in the path Reimplements : PathSection::getClosestPointGamma Updated on 2022-05-30 at 14:56:43 +0000","title":"function getClosestPointGamma"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolynomial5/","text":"Polynomial5 Class that implements a 5th order polynomial section. More... #include <Polynomial5.h> Inherits from PathSection Public Functions Name Polynomial5 (Eigen::Matrix< double, 6, 1 > & a, Eigen::Matrix< double, 6, 1 > & b, double c, double offset_x, double offset_y) Constructor for the Polynomial5 class, that receives the desired plane for the polynomial. virtual Eigen::Vector3d eq_pd (double t) override The Path section equation. virtual Eigen::Vector3d eq_d_pd (double t) override First derivative of the path section equation with respect to the path parameter t. virtual Eigen::Vector3d eq_dd_pd (double t) override Second derivative of the path section equation with respect to the path parameter t. virtual double getClosestPointGamma (Eigen::Vector3d & coordinate) override Method for getting the gamma of the closes point to the path. Additional inherited members Public Functions inherited from PathSection Name virtual double tangent (double t) Default method for computing the tangent to the path section. virtual double curvature (double t) Default method for computing the curvature. The default implementation implements the general formula to compute the curvature based on the derivative equations of the path. virtual double derivative_norm (double t) Default method for computing the norm of the derivative. bool can_be_composed () Method to return whether a pathSection can be composed with other path sections or not. double limitGamma (double t) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. double getMaxGammaValue () Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. double getMinGammaValue () Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. virtual ~PathSection () Virtual destructor for the abstract class. Protected Functions inherited from PathSection Name PathSection (bool can_be_composed) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . bool setMaxGammaValue (double gamma_max) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. bool setMinGammaValue (double gamma_min) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. double GradientDescent (double gamma_o, Eigen::Vector3d & x_pos, double tolerance) Method that implements the gradient descent to minimize the error of double getInitialGammaEstimate (Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. double bisection (Eigen::Vector3d & x_pos, double a, double b) Method to implement bisection method Detailed Description class Polynomial5; Class that implements a 5th order polynomial section. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the sections library Public Functions Documentation function Polynomial5 Polynomial5( Eigen::Matrix< double, 6, 1 > & a, Eigen::Matrix< double, 6, 1 > & b, double c, double offset_x, double offset_y ) Constructor for the Polynomial5 class, that receives the desired plane for the polynomial. Parameters : a A vector with 6 elements for the polynomial equation b A vector with 6 elements for the polynomial equation c A double for the polynomial equation offset_x A double with the x_offset offset_y A double with the y_offset function eq_pd virtual Eigen::Vector3d eq_pd( double t ) override The Path section equation. Parameters : t The path parameter Return : An Eigen::Vector3d with the equation of the path with respect to the path parameter Reimplements : PathSection::eq_pd function eq_d_pd virtual Eigen::Vector3d eq_d_pd( double t ) override First derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter t Return : An Eigen::Vector3d with the equation of the partial derivative with respect to the path parameter Reimplements : PathSection::eq_d_pd function eq_dd_pd virtual Eigen::Vector3d eq_dd_pd( double t ) override Second derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter t Return : An Eigen::Vector3d with the equation of the second order partial derivative with respect to the path parameter Reimplements : PathSection::eq_dd_pd function getClosestPointGamma virtual double getClosestPointGamma( Eigen::Vector3d & coordinate ) override Method for getting the gamma of the closes point to the path. Parameters : The coordinate of the vehicle in the 3D space Return : A double with the gamma corresponding to the closest point in the path Reimplements : PathSection::getClosestPointGamma Updated on 2022-05-30 at 14:56:43 +0000","title":"Polynomial5"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolynomial5/#polynomial5","text":"Class that implements a 5th order polynomial section. More... #include <Polynomial5.h> Inherits from PathSection","title":"Polynomial5"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolynomial5/#public-functions","text":"Name Polynomial5 (Eigen::Matrix< double, 6, 1 > & a, Eigen::Matrix< double, 6, 1 > & b, double c, double offset_x, double offset_y) Constructor for the Polynomial5 class, that receives the desired plane for the polynomial. virtual Eigen::Vector3d eq_pd (double t) override The Path section equation. virtual Eigen::Vector3d eq_d_pd (double t) override First derivative of the path section equation with respect to the path parameter t. virtual Eigen::Vector3d eq_dd_pd (double t) override Second derivative of the path section equation with respect to the path parameter t. virtual double getClosestPointGamma (Eigen::Vector3d & coordinate) override Method for getting the gamma of the closes point to the path.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolynomial5/#additional-inherited-members","text":"Public Functions inherited from PathSection Name virtual double tangent (double t) Default method for computing the tangent to the path section. virtual double curvature (double t) Default method for computing the curvature. The default implementation implements the general formula to compute the curvature based on the derivative equations of the path. virtual double derivative_norm (double t) Default method for computing the norm of the derivative. bool can_be_composed () Method to return whether a pathSection can be composed with other path sections or not. double limitGamma (double t) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. double getMaxGammaValue () Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. double getMinGammaValue () Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. virtual ~PathSection () Virtual destructor for the abstract class. Protected Functions inherited from PathSection Name PathSection (bool can_be_composed) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . bool setMaxGammaValue (double gamma_max) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. bool setMinGammaValue (double gamma_min) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. double GradientDescent (double gamma_o, Eigen::Vector3d & x_pos, double tolerance) Method that implements the gradient descent to minimize the error of double getInitialGammaEstimate (Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. double bisection (Eigen::Vector3d & x_pos, double a, double b) Method to implement bisection method","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolynomial5/#detailed-description","text":"class Polynomial5; Class that implements a 5th order polynomial section. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the sections library","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolynomial5/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolynomial5/#function-polynomial5","text":"Polynomial5( Eigen::Matrix< double, 6, 1 > & a, Eigen::Matrix< double, 6, 1 > & b, double c, double offset_x, double offset_y ) Constructor for the Polynomial5 class, that receives the desired plane for the polynomial. Parameters : a A vector with 6 elements for the polynomial equation b A vector with 6 elements for the polynomial equation c A double for the polynomial equation offset_x A double with the x_offset offset_y A double with the y_offset","title":"function Polynomial5"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolynomial5/#function-eq_pd","text":"virtual Eigen::Vector3d eq_pd( double t ) override The Path section equation. Parameters : t The path parameter Return : An Eigen::Vector3d with the equation of the path with respect to the path parameter Reimplements : PathSection::eq_pd","title":"function eq_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolynomial5/#function-eq_d_pd","text":"virtual Eigen::Vector3d eq_d_pd( double t ) override First derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter t Return : An Eigen::Vector3d with the equation of the partial derivative with respect to the path parameter Reimplements : PathSection::eq_d_pd","title":"function eq_d_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolynomial5/#function-eq_dd_pd","text":"virtual Eigen::Vector3d eq_dd_pd( double t ) override Second derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter t Return : An Eigen::Vector3d with the equation of the second order partial derivative with respect to the path parameter Reimplements : PathSection::eq_dd_pd","title":"function eq_dd_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classPolynomial5/#function-getclosestpointgamma","text":"virtual double getClosestPointGamma( Eigen::Vector3d & coordinate ) override Method for getting the gamma of the closes point to the path. Parameters : The coordinate of the vehicle in the 3D space Return : A double with the gamma corresponding to the closest point in the path Reimplements : PathSection::getClosestPointGamma Updated on 2022-05-30 at 14:56:43 +0000","title":"function getClosestPointGamma"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSinusoid2D/","text":"Sinusoid2D Class that implements a 2D sinusoid section. More... #include <Sinusoid2D.h> Inherits from PathSection Public Functions Name Sinusoid2D (Eigen::Vector2d & offset, double z) Constructor for the Sinusoid2D class, that receives the desired plane for the sinudoid. Sinusoid2D (Eigen::Vector2d & offset) Constructor for the Sinudoid2D class, that receives the desired plane for the sinudoid. Assumes the plane is placed at z=0.0. virtual Eigen::Vector3d eq_pd (double t) override The Path section equation. virtual Eigen::Vector3d eq_d_pd (double t) override First derivative of the path section equation with respect to the path parameter t. virtual Eigen::Vector3d eq_dd_pd (double t) override Second derivative of the path section equation with respect to the path parameter t. virtual double getClosestPointGamma (Eigen::Vector3d & coordinate) override Method for getting the gamma of the closes point to the path. Additional inherited members Public Functions inherited from PathSection Name virtual double tangent (double t) Default method for computing the tangent to the path section. virtual double curvature (double t) Default method for computing the curvature. The default implementation implements the general formula to compute the curvature based on the derivative equations of the path. virtual double derivative_norm (double t) Default method for computing the norm of the derivative. bool can_be_composed () Method to return whether a pathSection can be composed with other path sections or not. double limitGamma (double t) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. double getMaxGammaValue () Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. double getMinGammaValue () Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. virtual ~PathSection () Virtual destructor for the abstract class. Protected Functions inherited from PathSection Name PathSection (bool can_be_composed) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . bool setMaxGammaValue (double gamma_max) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. bool setMinGammaValue (double gamma_min) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. double GradientDescent (double gamma_o, Eigen::Vector3d & x_pos, double tolerance) Method that implements the gradient descent to minimize the error of double getInitialGammaEstimate (Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. double bisection (Eigen::Vector3d & x_pos, double a, double b) Method to implement bisection method Detailed Description class Sinusoid2D; Class that implements a 2D sinusoid section. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the sections library Public Functions Documentation function Sinusoid2D Sinusoid2D( Eigen::Vector2d & offset, double z ) Constructor for the Sinusoid2D class, that receives the desired plane for the sinudoid. Parameters : offset The 2D start point of the arc z The altitude at which to place the arc function Sinusoid2D Sinusoid2D( Eigen::Vector2d & offset ) Constructor for the Sinudoid2D class, that receives the desired plane for the sinudoid. Assumes the plane is placed at z=0.0. Parameters : offset The 2D offset for the Sinudoid of the sinusoid function eq_pd virtual Eigen::Vector3d eq_pd( double t ) override The Path section equation. Parameters : t The path parameter Return : An Eigen::Vector3d with the equation of the path with respect to the path parameter Reimplements : PathSection::eq_pd function eq_d_pd virtual Eigen::Vector3d eq_d_pd( double t ) override First derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter t Return : An Eigen::Vector3d with the equation of the partial derivative with respect to the path parameter Reimplements : PathSection::eq_d_pd function eq_dd_pd virtual Eigen::Vector3d eq_dd_pd( double t ) override Second derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter t Return : An Eigen::Vector3d with the equation of the second order partial derivative with respect to the path parameter Reimplements : PathSection::eq_dd_pd function getClosestPointGamma virtual double getClosestPointGamma( Eigen::Vector3d & coordinate ) override Method for getting the gamma of the closes point to the path. Parameters : The coordinate of the vehicle in the 3D space Return : A double with the gamma corresponding to the closest point in the path Reimplements : PathSection::getClosestPointGamma Updated on 2022-05-30 at 14:56:43 +0000","title":"Sinusoid2D"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSinusoid2D/#sinusoid2d","text":"Class that implements a 2D sinusoid section. More... #include <Sinusoid2D.h> Inherits from PathSection","title":"Sinusoid2D"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSinusoid2D/#public-functions","text":"Name Sinusoid2D (Eigen::Vector2d & offset, double z) Constructor for the Sinusoid2D class, that receives the desired plane for the sinudoid. Sinusoid2D (Eigen::Vector2d & offset) Constructor for the Sinudoid2D class, that receives the desired plane for the sinudoid. Assumes the plane is placed at z=0.0. virtual Eigen::Vector3d eq_pd (double t) override The Path section equation. virtual Eigen::Vector3d eq_d_pd (double t) override First derivative of the path section equation with respect to the path parameter t. virtual Eigen::Vector3d eq_dd_pd (double t) override Second derivative of the path section equation with respect to the path parameter t. virtual double getClosestPointGamma (Eigen::Vector3d & coordinate) override Method for getting the gamma of the closes point to the path.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSinusoid2D/#additional-inherited-members","text":"Public Functions inherited from PathSection Name virtual double tangent (double t) Default method for computing the tangent to the path section. virtual double curvature (double t) Default method for computing the curvature. The default implementation implements the general formula to compute the curvature based on the derivative equations of the path. virtual double derivative_norm (double t) Default method for computing the norm of the derivative. bool can_be_composed () Method to return whether a pathSection can be composed with other path sections or not. double limitGamma (double t) Method to limit the gamma between the minimum and maximum value By default the maximum gamma is a very high number. double getMaxGammaValue () Method used to get the maximum gamma allowed by the path section By the default is the maximum valid number possible in c++. double getMinGammaValue () Method used to get the minimum gamma allowed by the path section By default is the minimum valid number possible in c++. virtual ~PathSection () Virtual destructor for the abstract class. Protected Functions inherited from PathSection Name PathSection (bool can_be_composed) Constructor for the abstract class i NOTE: this class is virtual, therefore an object of type PathSection cannot be instantiated in memory. Only derivatives of the class PathSection . bool setMaxGammaValue (double gamma_max) Method to update the max of the gamma parameter Validates if the value received is greater than gamma_min. bool setMinGammaValue (double gamma_min) Method to update the min value of the gamma parameter Validades if the value is received is smaller than gamma_max. double GradientDescent (double gamma_o, Eigen::Vector3d & x_pos, double tolerance) Method that implements the gradient descent to minimize the error of double getInitialGammaEstimate (Eigen::Vector3d & x_pos, int num_partitions, double min_val, double max_val) Method to get an initial estimate for the gamma. It divides the section into n sections and search for local minimums in the function that computes the distance of the vehicle inside those sections. double bisection (Eigen::Vector3d & x_pos, double a, double b) Method to implement bisection method","title":"Additional inherited members"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSinusoid2D/#detailed-description","text":"class Sinusoid2D; Class that implements a 2D sinusoid section. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT This class is used as a part of the sections library","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSinusoid2D/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSinusoid2D/#function-sinusoid2d","text":"Sinusoid2D( Eigen::Vector2d & offset, double z ) Constructor for the Sinusoid2D class, that receives the desired plane for the sinudoid. Parameters : offset The 2D start point of the arc z The altitude at which to place the arc","title":"function Sinusoid2D"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSinusoid2D/#function-sinusoid2d_1","text":"Sinusoid2D( Eigen::Vector2d & offset ) Constructor for the Sinudoid2D class, that receives the desired plane for the sinudoid. Assumes the plane is placed at z=0.0. Parameters : offset The 2D offset for the Sinudoid of the sinusoid","title":"function Sinusoid2D"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSinusoid2D/#function-eq_pd","text":"virtual Eigen::Vector3d eq_pd( double t ) override The Path section equation. Parameters : t The path parameter Return : An Eigen::Vector3d with the equation of the path with respect to the path parameter Reimplements : PathSection::eq_pd","title":"function eq_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSinusoid2D/#function-eq_d_pd","text":"virtual Eigen::Vector3d eq_d_pd( double t ) override First derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter t Return : An Eigen::Vector3d with the equation of the partial derivative with respect to the path parameter Reimplements : PathSection::eq_d_pd","title":"function eq_d_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSinusoid2D/#function-eq_dd_pd","text":"virtual Eigen::Vector3d eq_dd_pd( double t ) override Second derivative of the path section equation with respect to the path parameter t. Parameters : t The path parameter t Return : An Eigen::Vector3d with the equation of the second order partial derivative with respect to the path parameter Reimplements : PathSection::eq_dd_pd","title":"function eq_dd_pd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSinusoid2D/#function-getclosestpointgamma","text":"virtual double getClosestPointGamma( Eigen::Vector3d & coordinate ) override Method for getting the gamma of the closes point to the path. Parameters : The coordinate of the vehicle in the 3D space Return : A double with the gamma corresponding to the closest point in the path Reimplements : PathSection::getClosestPointGamma Updated on 2022-05-30 at 14:56:43 +0000","title":"function getClosestPointGamma"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSpeed/","text":"Speed Abstract class to serve as the base for speed as a function of gamma. More... #include <Speed.h> Inherited by ConstRabbitSpeed , ConstVehicleSpeed Public Functions Name virtual double getVd (double gamma, double tangent_norm) =0 Method to get the desired velocity for the virtual target on the path given the path parameter (given by the value of gamma) virtual double get_d_Vd (double gamma, double tangent_norm) =0 Method to get the desired acceleration for the virtual target on the path given the path parameter (given by the value of gamma) virtual double getDefaultVd (double gamma, double tangent_norm) =0 Method to get the default desired velocity for safety when we are doing path following and want to have a backup value. virtual ~Speed () Virtual destructor for the abstract class. Detailed Description class Speed; Abstract class to serve as the base for speed as a function of gamma. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT Since this class is abstract it cannot be instantiated. It must be inherited. Public Functions Documentation function getVd virtual double getVd( double gamma, double tangent_norm ) =0 Method to get the desired velocity for the virtual target on the path given the path parameter (given by the value of gamma) Parameters : gamma The path parameter tangent_norm The norm of the tangent to the path in gamma Return : A double with the desired speed Reimplemented by : ConstRabbitSpeed::getVd , ConstVehicleSpeed::getVd NOTE: This method is pure virtual which means it must be implemented by a class that inherits Speed function get_d_Vd virtual double get_d_Vd( double gamma, double tangent_norm ) =0 Method to get the desired acceleration for the virtual target on the path given the path parameter (given by the value of gamma) Parameters : gamma The value of the path parameter tangent_norm The norm of the tangent to the path in gamma Return : A double with the desired acceleration Reimplemented by : ConstRabbitSpeed::get_d_Vd , ConstVehicleSpeed::get_d_Vd NOTE: This method is pure virtual which means it must be implemented by a class that inherits Speed function getDefaultVd virtual double getDefaultVd( double gamma, double tangent_norm ) =0 Method to get the default desired velocity for safety when we are doing path following and want to have a backup value. Parameters : gamma The value of the path parameter tangent_norm The norm of the tangent to the path in gamma Return : A double with the default desired speed Reimplemented by : ConstRabbitSpeed::getDefaultVd , ConstVehicleSpeed::getDefaultVd NOTE: THis method is pura virtual which means it must be implemented by a class that inherits Speed function ~Speed virtual ~Speed() Virtual destructor for the abstract class. Updated on 2022-05-30 at 14:56:43 +0000","title":"Speed"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSpeed/#speed","text":"Abstract class to serve as the base for speed as a function of gamma. More... #include <Speed.h> Inherited by ConstRabbitSpeed , ConstVehicleSpeed","title":"Speed"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSpeed/#public-functions","text":"Name virtual double getVd (double gamma, double tangent_norm) =0 Method to get the desired velocity for the virtual target on the path given the path parameter (given by the value of gamma) virtual double get_d_Vd (double gamma, double tangent_norm) =0 Method to get the desired acceleration for the virtual target on the path given the path parameter (given by the value of gamma) virtual double getDefaultVd (double gamma, double tangent_norm) =0 Method to get the default desired velocity for safety when we are doing path following and want to have a backup value. virtual ~Speed () Virtual destructor for the abstract class.","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSpeed/#detailed-description","text":"class Speed; Abstract class to serve as the base for speed as a function of gamma. Author : Marcelo Jacinto Joao Quintas Joao Cruz Hung Tuan Version : 1.0a Date : 2021 Copyright : MIT Since this class is abstract it cannot be instantiated. It must be inherited.","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSpeed/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSpeed/#function-getvd","text":"virtual double getVd( double gamma, double tangent_norm ) =0 Method to get the desired velocity for the virtual target on the path given the path parameter (given by the value of gamma) Parameters : gamma The path parameter tangent_norm The norm of the tangent to the path in gamma Return : A double with the desired speed Reimplemented by : ConstRabbitSpeed::getVd , ConstVehicleSpeed::getVd NOTE: This method is pure virtual which means it must be implemented by a class that inherits Speed","title":"function getVd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSpeed/#function-get_d_vd","text":"virtual double get_d_Vd( double gamma, double tangent_norm ) =0 Method to get the desired acceleration for the virtual target on the path given the path parameter (given by the value of gamma) Parameters : gamma The value of the path parameter tangent_norm The norm of the tangent to the path in gamma Return : A double with the desired acceleration Reimplemented by : ConstRabbitSpeed::get_d_Vd , ConstVehicleSpeed::get_d_Vd NOTE: This method is pure virtual which means it must be implemented by a class that inherits Speed","title":"function get_d_Vd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSpeed/#function-getdefaultvd","text":"virtual double getDefaultVd( double gamma, double tangent_norm ) =0 Method to get the default desired velocity for safety when we are doing path following and want to have a backup value. Parameters : gamma The value of the path parameter tangent_norm The norm of the tangent to the path in gamma Return : A double with the default desired speed Reimplemented by : ConstRabbitSpeed::getDefaultVd , ConstVehicleSpeed::getDefaultVd NOTE: THis method is pura virtual which means it must be implemented by a class that inherits Speed","title":"function getDefaultVd"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Classes/classSpeed/#function-speed","text":"virtual ~Speed() Virtual destructor for the abstract class. Updated on 2022-05-30 at 14:56:43 +0000","title":"function ~Speed"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Examples/","text":"Examples Updated on 2022-05-30 at 14:56:44 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Examples/#examples","text":"Updated on 2022-05-30 at 14:56:44 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Modules/","text":"Modules Updated on 2022-05-30 at 14:56:44 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Modules/#modules","text":"Updated on 2022-05-30 at 14:56:44 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Namespaces/","text":"Namespaces Updated on 2022-05-30 at 14:56:44 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_planning/dsor_paths/Namespaces/#namespaces","text":"Updated on 2022-05-30 at 14:56:44 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/","text":"Classes class AUV AUV class - implements a Matlab-like simulation of an AUV in C++. class SimulationNode SimulationNode class - implements the ROS interface to actually perform an AUV simulation. struct State State class - used to save the state of a vehicle (using SNAME convention) Updated on 2022-05-30 at 14:56:41 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/#classes","text":"class AUV AUV class - implements a Matlab-like simulation of an AUV in C++. class SimulationNode SimulationNode class - implements the ROS interface to actually perform an AUV simulation. struct State State class - used to save the state of a vehicle (using SNAME convention) Updated on 2022-05-30 at 14:56:41 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classAUV/","text":"AUV AUV class - implements a Matlab-like simulation of an AUV in C++. More... #include <AUV.h> Public Functions Name AUV (double mass, double fluid_density, double zg, double vehicle_density, const Eigen::Vector3d & inertia_tensor, const Eigen::Matrix< double, 6, 1 > & linear_damping_tensor, const Eigen::Matrix< double, 6, 1 > & quadratic_damping_tensor, const Eigen::Matrix< double, 6, 1 > & added_mass_tensor, const Eigen::MatrixXd & allocation_matrix, const Eigen::Vector3d & lump_param_positive, const Eigen::Vector3d & lump_param_negative, const Eigen::Vector2d & min_max_thruster_input, double thrusters_gain, double thrusters_pole, double thrusters_delay, double sampling_period, const Eigen::Vector3d & disturbance_mean, const Eigen::Vector3d & disturbance_sigma, const Eigen::Vector3d & disturbance_minimum, const Eigen::Vector3d & disturbance_maximum) void update (double dt, const Eigen::VectorXd & thrust) State getState () void setState (const State & state) unsigned int getNumberThrusters () Detailed Description class AUV; AUV class - implements a Matlab-like simulation of an AUV in C++. Author : Marcelo Jacinto Version : 1.0.0 Date : 2021/11/12 Copyright : MIT Public Functions Documentation function AUV AUV( double mass, double fluid_density, double zg, double vehicle_density, const Eigen::Vector3d & inertia_tensor, const Eigen::Matrix< double, 6, 1 > & linear_damping_tensor, const Eigen::Matrix< double, 6, 1 > & quadratic_damping_tensor, const Eigen::Matrix< double, 6, 1 > & added_mass_tensor, const Eigen::MatrixXd & allocation_matrix, const Eigen::Vector3d & lump_param_positive, const Eigen::Vector3d & lump_param_negative, const Eigen::Vector2d & min_max_thruster_input, double thrusters_gain, double thrusters_pole, double thrusters_delay, double sampling_period, const Eigen::Vector3d & disturbance_mean, const Eigen::Vector3d & disturbance_sigma, const Eigen::Vector3d & disturbance_minimum, const Eigen::Vector3d & disturbance_maximum ) Parameters : mass The mass of the vehicle in Kg fluid_density The density of the fluid the vehicle is in (a.k.a water density) zg The center of gravity of the (sphere-like) vehicle vehicle_density The density of the vehicle (Kg/m^3) inertia_tensor A vector of 3 elements with the diagonal of the inertia matrix linear_damping_tensor A vector of 6 elements with the diagonal of the linear damping matrix quadratic_damping_tensor A vector of 6 elements with the diagonal of the quadratic damping matrix added_mass_tensor A vector of 6 elements with the diagonal of the added mass matrix allocation_matrix A matrix with the contributions of each thruster to the forces in X,Y and Z and the arms for computing the moments of inertia later [Fx, Fy, Fz, lx, ly, lz] (each line represents one thruster) lump_param_positive The thrust curve parameters for the right side of the curve lump_param_negative The thrust curve parameters for the left side of the curve min_max_thruster_input The minimum and maximum normalized thruster inputs [min_input, max_input]^T thrusters_gain thrusters_pole thrusters_delay sampling_period An approximated sampling period (s) at which the simulation will run (NOTE: this is needed to discretize the thrusters model only and the integration of the dynamics of the vehicle will use the dt variable provided through the update method) disturbance_mean A vector with the mean of the ocean disturbances (gaussian process) disturbance_sigma A vector with the standard deviation of the ocean disturbances (gaussian process) disturbance_minimum A vector with the minimum values for the ocean disturbances disturbance_maximum A vector with the maximum values for the ocean disturbances MedusaAUV class constructor function update void update( double dt, const Eigen::VectorXd & thrust ) Parameters : dt The time difference (in seconds) between the last function call and the disturbance function call thrust A vector of n elements with the thrust to apply to each of the n vehicle thursters (normalized between 0 and 1) Method to update the state of the vehicle given the thrust applied to each individual thruster. This method verifies if (dt >= 0) and the size of thrust vector is the same as the number of thrusters of the model. If some of these conditions does not verify, a std::invalid_argument exception is thrown function getState inline State getState() Return : A state object with the state of the vehicle Method that returns a copy of the disturbance state of the vehicle function setState inline void setState( const State & state ) Parameters : state A state reference that contains the desired state of the vehicle Method that sets the disturbance state of the vehicle to a new pre-defined state function getNumberThrusters inline unsigned int getNumberThrusters() Return : The number of thrusters of the AUV Method that returns the number of thrusters of the AUV based on the number of lines of the allocation matrix received by the constructor upon object construction Updated on 2022-05-30 at 14:56:41 +0000","title":"AUV"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classAUV/#auv","text":"AUV class - implements a Matlab-like simulation of an AUV in C++. More... #include <AUV.h>","title":"AUV"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classAUV/#public-functions","text":"Name AUV (double mass, double fluid_density, double zg, double vehicle_density, const Eigen::Vector3d & inertia_tensor, const Eigen::Matrix< double, 6, 1 > & linear_damping_tensor, const Eigen::Matrix< double, 6, 1 > & quadratic_damping_tensor, const Eigen::Matrix< double, 6, 1 > & added_mass_tensor, const Eigen::MatrixXd & allocation_matrix, const Eigen::Vector3d & lump_param_positive, const Eigen::Vector3d & lump_param_negative, const Eigen::Vector2d & min_max_thruster_input, double thrusters_gain, double thrusters_pole, double thrusters_delay, double sampling_period, const Eigen::Vector3d & disturbance_mean, const Eigen::Vector3d & disturbance_sigma, const Eigen::Vector3d & disturbance_minimum, const Eigen::Vector3d & disturbance_maximum) void update (double dt, const Eigen::VectorXd & thrust) State getState () void setState (const State & state) unsigned int getNumberThrusters ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classAUV/#detailed-description","text":"class AUV; AUV class - implements a Matlab-like simulation of an AUV in C++. Author : Marcelo Jacinto Version : 1.0.0 Date : 2021/11/12 Copyright : MIT","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classAUV/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classAUV/#function-auv","text":"AUV( double mass, double fluid_density, double zg, double vehicle_density, const Eigen::Vector3d & inertia_tensor, const Eigen::Matrix< double, 6, 1 > & linear_damping_tensor, const Eigen::Matrix< double, 6, 1 > & quadratic_damping_tensor, const Eigen::Matrix< double, 6, 1 > & added_mass_tensor, const Eigen::MatrixXd & allocation_matrix, const Eigen::Vector3d & lump_param_positive, const Eigen::Vector3d & lump_param_negative, const Eigen::Vector2d & min_max_thruster_input, double thrusters_gain, double thrusters_pole, double thrusters_delay, double sampling_period, const Eigen::Vector3d & disturbance_mean, const Eigen::Vector3d & disturbance_sigma, const Eigen::Vector3d & disturbance_minimum, const Eigen::Vector3d & disturbance_maximum ) Parameters : mass The mass of the vehicle in Kg fluid_density The density of the fluid the vehicle is in (a.k.a water density) zg The center of gravity of the (sphere-like) vehicle vehicle_density The density of the vehicle (Kg/m^3) inertia_tensor A vector of 3 elements with the diagonal of the inertia matrix linear_damping_tensor A vector of 6 elements with the diagonal of the linear damping matrix quadratic_damping_tensor A vector of 6 elements with the diagonal of the quadratic damping matrix added_mass_tensor A vector of 6 elements with the diagonal of the added mass matrix allocation_matrix A matrix with the contributions of each thruster to the forces in X,Y and Z and the arms for computing the moments of inertia later [Fx, Fy, Fz, lx, ly, lz] (each line represents one thruster) lump_param_positive The thrust curve parameters for the right side of the curve lump_param_negative The thrust curve parameters for the left side of the curve min_max_thruster_input The minimum and maximum normalized thruster inputs [min_input, max_input]^T thrusters_gain thrusters_pole thrusters_delay sampling_period An approximated sampling period (s) at which the simulation will run (NOTE: this is needed to discretize the thrusters model only and the integration of the dynamics of the vehicle will use the dt variable provided through the update method) disturbance_mean A vector with the mean of the ocean disturbances (gaussian process) disturbance_sigma A vector with the standard deviation of the ocean disturbances (gaussian process) disturbance_minimum A vector with the minimum values for the ocean disturbances disturbance_maximum A vector with the maximum values for the ocean disturbances MedusaAUV class constructor","title":"function AUV"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classAUV/#function-update","text":"void update( double dt, const Eigen::VectorXd & thrust ) Parameters : dt The time difference (in seconds) between the last function call and the disturbance function call thrust A vector of n elements with the thrust to apply to each of the n vehicle thursters (normalized between 0 and 1) Method to update the state of the vehicle given the thrust applied to each individual thruster. This method verifies if (dt >= 0) and the size of thrust vector is the same as the number of thrusters of the model. If some of these conditions does not verify, a std::invalid_argument exception is thrown","title":"function update"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classAUV/#function-getstate","text":"inline State getState() Return : A state object with the state of the vehicle Method that returns a copy of the disturbance state of the vehicle","title":"function getState"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classAUV/#function-setstate","text":"inline void setState( const State & state ) Parameters : state A state reference that contains the desired state of the vehicle Method that sets the disturbance state of the vehicle to a new pre-defined state","title":"function setState"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classAUV/#function-getnumberthrusters","text":"inline unsigned int getNumberThrusters() Return : The number of thrusters of the AUV Method that returns the number of thrusters of the AUV based on the number of lines of the allocation matrix received by the constructor upon object construction Updated on 2022-05-30 at 14:56:41 +0000","title":"function getNumberThrusters"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classSimulationNode/","text":"SimulationNode SimulationNode class - implements the ROS interface to actually perform an AUV simulation. More... #include <SimulationNode.h> Public Functions Name SimulationNode (ros::NodeHandle * nh, ros::NodeHandle * nh_p) ~SimulationNode () Detailed Description class SimulationNode; SimulationNode class - implements the ROS interface to actually perform an AUV simulation. Author : Marcelo Jacinto Version : 1.0.0 Date : 2021/11/12 Copyright : MIT Public Functions Documentation function SimulationNode SimulationNode( ros::NodeHandle * nh, ros::NodeHandle * nh_p ) function ~SimulationNode ~SimulationNode() Updated on 2022-05-30 at 14:56:41 +0000","title":"SimulationNode"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classSimulationNode/#simulationnode","text":"SimulationNode class - implements the ROS interface to actually perform an AUV simulation. More... #include <SimulationNode.h>","title":"SimulationNode"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classSimulationNode/#public-functions","text":"Name SimulationNode (ros::NodeHandle * nh, ros::NodeHandle * nh_p) ~SimulationNode ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classSimulationNode/#detailed-description","text":"class SimulationNode; SimulationNode class - implements the ROS interface to actually perform an AUV simulation. Author : Marcelo Jacinto Version : 1.0.0 Date : 2021/11/12 Copyright : MIT","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classSimulationNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classSimulationNode/#function-simulationnode","text":"SimulationNode( ros::NodeHandle * nh, ros::NodeHandle * nh_p )","title":"function SimulationNode"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/classSimulationNode/#function-simulationnode_1","text":"~SimulationNode() Updated on 2022-05-30 at 14:56:41 +0000","title":"function ~SimulationNode"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/structState/","text":"State State class - used to save the state of a vehicle (using SNAME convention) More... #include <State.h> Public Attributes Name Eigen::Vector3d eta1 Eigen::Vector3d eta2 Eigen::Vector3d v1 Eigen::Vector3d v2 Detailed Description struct State; State class - used to save the state of a vehicle (using SNAME convention) Author : Marcelo Jacinto Version : 1.0.0 Date : 2021/11/12 Copyright : MIT Public Attributes Documentation variable eta1 Eigen::Vector3d eta1 {0.0, 0.0, 0.0}; The position of the vehicle expressed in the inertial frame eta1=[x,y,z]^T variable eta2 Eigen::Vector3d eta2 {0.0, 0.0, 0.0}; The orientation of the vehicle expressed in the inertial frame, using euler angles eta2=[roll, pitch, yaw]^T variable v1 Eigen::Vector3d v1 {0.0, 0.0, 0.0}; The body velocity of the vehicle v1=[u,v,w]^T variable v2 Eigen::Vector3d v2 {0.0, 0.0, 0.0}; The body angular velocity of the vehicle v2=[p,q,r]^T Updated on 2022-05-30 at 14:56:41 +0000","title":"State"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/structState/#state","text":"State class - used to save the state of a vehicle (using SNAME convention) More... #include <State.h>","title":"State"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/structState/#public-attributes","text":"Name Eigen::Vector3d eta1 Eigen::Vector3d eta2 Eigen::Vector3d v1 Eigen::Vector3d v2","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/structState/#detailed-description","text":"struct State; State class - used to save the state of a vehicle (using SNAME convention) Author : Marcelo Jacinto Version : 1.0.0 Date : 2021/11/12 Copyright : MIT","title":"Detailed Description"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/structState/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/structState/#variable-eta1","text":"Eigen::Vector3d eta1 {0.0, 0.0, 0.0}; The position of the vehicle expressed in the inertial frame eta1=[x,y,z]^T","title":"variable eta1"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/structState/#variable-eta2","text":"Eigen::Vector3d eta2 {0.0, 0.0, 0.0}; The orientation of the vehicle expressed in the inertial frame, using euler angles eta2=[roll, pitch, yaw]^T","title":"variable eta2"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/structState/#variable-v1","text":"Eigen::Vector3d v1 {0.0, 0.0, 0.0}; The body velocity of the vehicle v1=[u,v,w]^T","title":"variable v1"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Classes/structState/#variable-v2","text":"Eigen::Vector3d v2 {0.0, 0.0, 0.0}; The body angular velocity of the vehicle v2=[p,q,r]^T Updated on 2022-05-30 at 14:56:41 +0000","title":"variable v2"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Examples/","text":"Examples Updated on 2022-05-30 at 14:56:41 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Examples/#examples","text":"Updated on 2022-05-30 at 14:56:41 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Modules/","text":"Modules Updated on 2022-05-30 at 14:56:41 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Modules/#modules","text":"Updated on 2022-05-30 at 14:56:41 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Namespaces/","text":"Namespaces Updated on 2022-05-30 at 14:56:41 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_sim/auv_sim/Namespaces/#namespaces","text":"Updated on 2022-05-30 at 14:56:41 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/","text":"Classes class SensorSim struct Sensor Updated on 2022-05-30 at 14:56:46 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/#classes","text":"class SensorSim struct Sensor Updated on 2022-05-30 at 14:56:46 +0000","title":"Classes"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/classSensorSim/","text":"SensorSim Public Functions Name SensorSim (ros::NodeHandle * nh, ros::NodeHandle * nh_private) ~SensorSim () double nodeFrequency () Public Functions Documentation function SensorSim SensorSim( ros::NodeHandle * nh, ros::NodeHandle * nh_private ) function ~SensorSim ~SensorSim() function nodeFrequency double nodeFrequency() Updated on 2022-05-30 at 14:56:46 +0000","title":"SensorSim"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/classSensorSim/#sensorsim","text":"","title":"SensorSim"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/classSensorSim/#public-functions","text":"Name SensorSim (ros::NodeHandle * nh, ros::NodeHandle * nh_private) ~SensorSim () double nodeFrequency ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/classSensorSim/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/classSensorSim/#function-sensorsim","text":"SensorSim( ros::NodeHandle * nh, ros::NodeHandle * nh_private )","title":"function SensorSim"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/classSensorSim/#function-sensorsim_1","text":"~SensorSim()","title":"function ~SensorSim"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/classSensorSim/#function-nodefrequency","text":"double nodeFrequency() Updated on 2022-05-30 at 14:56:46 +0000","title":"function nodeFrequency"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/","text":"SensorSim::Sensor Public Types Name enum Type { null, AHRS, DVL_BT, DVL_WT, DEPTH, ALTIMETER, GNSS, RANGE, MODEL} Public Functions Name Sensor () Public Attributes Name Type type std::string frame_id bool debug int count int thresh double last_update double frequency double variance double noise double beacon int zone bool northp double altitude std::map< std::string, Type > enum_map Public Types Documentation enum Type Enumerator Value Description null AHRS DVL_BT DVL_WT DEPTH ALTIMETER GNSS RANGE MODEL Public Functions Documentation function Sensor inline Sensor() Public Attributes Documentation variable type Type type; variable frame_id std::string frame_id; variable debug bool debug; variable count int count; variable thresh int thresh; variable last_update double last_update; variable frequency double frequency; variable variance double variance; variable noise double noise; variable beacon double beacon; variable zone int zone; variable northp bool northp; variable altitude double altitude; variable enum_map std::map< std::string, Type > enum_map; Updated on 2022-05-30 at 14:56:46 +0000","title":"SensorSim::Sensor"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#sensorsimsensor","text":"","title":"SensorSim::Sensor"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#public-types","text":"Name enum Type { null, AHRS, DVL_BT, DVL_WT, DEPTH, ALTIMETER, GNSS, RANGE, MODEL}","title":"Public Types"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#public-functions","text":"Name Sensor ()","title":"Public Functions"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#public-attributes","text":"Name Type type std::string frame_id bool debug int count int thresh double last_update double frequency double variance double noise double beacon int zone bool northp double altitude std::map< std::string, Type > enum_map","title":"Public Attributes"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#enum-type","text":"Enumerator Value Description null AHRS DVL_BT DVL_WT DEPTH ALTIMETER GNSS RANGE MODEL","title":"enum Type"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#function-sensor","text":"inline Sensor()","title":"function Sensor"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#variable-type","text":"Type type;","title":"variable type"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#variable-frame_id","text":"std::string frame_id;","title":"variable frame_id"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#variable-debug","text":"bool debug;","title":"variable debug"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#variable-count","text":"int count;","title":"variable count"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#variable-thresh","text":"int thresh;","title":"variable thresh"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#variable-last_update","text":"double last_update;","title":"variable last_update"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#variable-frequency","text":"double frequency;","title":"variable frequency"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#variable-variance","text":"double variance;","title":"variable variance"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#variable-noise","text":"double noise;","title":"variable noise"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#variable-beacon","text":"double beacon;","title":"variable beacon"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#variable-zone","text":"int zone;","title":"variable zone"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#variable-northp","text":"bool northp;","title":"variable northp"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#variable-altitude","text":"double altitude;","title":"variable altitude"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Classes/structSensorSim_1_1Sensor/#variable-enum_map","text":"std::map< std::string, Type > enum_map; Updated on 2022-05-30 at 14:56:46 +0000","title":"variable enum_map"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Examples/","text":"Examples Updated on 2022-05-30 at 14:56:46 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Examples/#examples","text":"Updated on 2022-05-30 at 14:56:46 +0000","title":"Examples"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Modules/","text":"Modules Updated on 2022-05-30 at 14:56:46 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Modules/#modules","text":"Updated on 2022-05-30 at 14:56:46 +0000","title":"Modules"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Namespaces/","text":"Namespaces Updated on 2022-05-30 at 14:56:46 +0000","title":"Namespaces"},{"location":"api/markdown/medusa_base/medusa_sim/sensor_sim/Namespaces/#namespaces","text":"Updated on 2022-05-30 at 14:56:46 +0000","title":"Namespaces"},{"location":"auv-simulation/","text":"","title":"Reference"},{"location":"bringup-system/","text":"","title":"Reference"},{"location":"comms-ros-messages/","text":"","title":"Reference"},{"location":"console-path-parser/","text":"Console path parser package Console path parser is a ROS package written in C++ responsible for parsing a mission/path string from an external source to a format that can be interpreted by the path following algorithms of the Medusa Vx stack. Rationale Mission/path string format The format of the mission for a single vehicle comes from the console in a string like the following: #Version 3 #Xrefpoint Yrefpoint UTM Zone 491890.163 4290832.905 29S # LINE xInit yInit xEnd yEnd velocity <nVehicle> <gamma> <user data> # ARC xInit yInit xCenter yCenter xEnd yEnd velocity adirection radius <nVehicle> <gamma> <user data> # POINT xInit yInit radius velocity heading time <nVehicle> <gamma> <user data> # DEPTH depth time <nVehicle> <gamma> <user data> # ALT altitude time <nVehicle> <gamma> <user data> Example of lawn mower maneuver for a single vehicle # Mission from vehicle -1 LINE -20.26 -20.26 -20.26 10.13 0.30 -1 ARC -20.26 10.13 -10.13 10.13 0.00 10.13 0.30 -1 10.13 -1 LINE 0.00 10.13 0.00 -10.13 0.30 -1 ARC 0.00 -10.13 10.13 -10.13 20.26 -10.13 0.30 1 10.13 -1 LINE 20.26 -10.13 20.26 20.26 0.30 -1 For case where cooperative path following is desired the mission is adapted as seen in the example bellow: #Version 3 #Xrefpoint Yrefpoint UTM Zone 491854.338 4290819.848 29S # FORMATION ID1 x_dist y_dist ID2 x_dist y_dist ID3 x_dist y_dist FORMATION 1 0 -3 2 0 0 3 0 3 # LINE xInit yInit xEnd yEnd velocity <nVehicle> <gamma> <user data> # ARC xInit yInit xCenter yCenter xEnd yEnd velocity adirection radius <nVehicle> <gamma> <user data> # POINT xInit yInit radius velocity heading time <nVehicle> <gamma> <user data> # DEPTH depth time <nVehicle> <gamma> <user data> # ALT altitude time <nVehicle> <gamma> <user data> # Mission from vehicle -1 LINE -24.57 -24.57 -24.57 12.29 0.30 -1 ARC -24.57 12.29 -12.29 12.29 0.00 12.29 0.30 -1 12.29 -1 LINE 0.00 12.29 0.00 -12.29 0.30 -1 ARC 0.00 -12.29 12.29 -12.29 24.57 -12.29 0.30 1 12.29 -1 LINE 24.57 -12.29 24.57 24.57 0.30 -1 Note that the only difference is the addition of a FORMATION line. Console path parser will read this information and save in a vector of sections ( Mission ). The section structure can be seen below. Path following sections format SECTION() { Type = 0; # Line / Arc / Point / Depth / ALT xi = 0; # initial x of section yi = 0; # initial y of section xc = -1; # x of center of arc (-1 if line or point) yc = -1; # y of center of arc (-1 if line or point) xe = 0; # ending x of section ye = 0; # ending y of section velocity = 0; # velocity desired of the vehicle adirection = 0; # -1 if vehicle is turning clockwise, -1 otherwise (only applied to arcs) radius = 0; # radius of the arc heading = -1; time = -1; nVehicle = -1; Gamma_s = 0; # Starting gamma (not normalized) Gamma_e = 0, # Ending gamma (not normalized) depth = 0.0; } The console path parser will then publish the first section (topic /path_section ) of the vector while subscribing to the topic /Gamma which contains a the value of the parameter gamma (see path following theory) not normalized. When the received gamma surpasses the ending gamma ( Gamma_e ) of the section, it will then update its section and publish it. It will do this process for the amount of sections in Mission . Note that /Gamma is being published by the path following node, where there is a conversion of the gamma from normalized to not normalized. Package Content Code documentation source Using console path parser Examples Requirements Yebisu - creates the mission to be parsed console_server - receives the mission and sends it here folder to save path - ex: ROS_BAG_FOLDER/paths_from_console path following algorithms - receive sections of the mission","title":"Reference"},{"location":"console-path-parser/#console-path-parser-package","text":"Console path parser is a ROS package written in C++ responsible for parsing a mission/path string from an external source to a format that can be interpreted by the path following algorithms of the Medusa Vx stack.","title":"Console path parser package"},{"location":"console-path-parser/#rationale","text":"","title":"Rationale"},{"location":"console-path-parser/#missionpath-string-format","text":"The format of the mission for a single vehicle comes from the console in a string like the following: #Version 3 #Xrefpoint Yrefpoint UTM Zone 491890.163 4290832.905 29S # LINE xInit yInit xEnd yEnd velocity <nVehicle> <gamma> <user data> # ARC xInit yInit xCenter yCenter xEnd yEnd velocity adirection radius <nVehicle> <gamma> <user data> # POINT xInit yInit radius velocity heading time <nVehicle> <gamma> <user data> # DEPTH depth time <nVehicle> <gamma> <user data> # ALT altitude time <nVehicle> <gamma> <user data> Example of lawn mower maneuver for a single vehicle # Mission from vehicle -1 LINE -20.26 -20.26 -20.26 10.13 0.30 -1 ARC -20.26 10.13 -10.13 10.13 0.00 10.13 0.30 -1 10.13 -1 LINE 0.00 10.13 0.00 -10.13 0.30 -1 ARC 0.00 -10.13 10.13 -10.13 20.26 -10.13 0.30 1 10.13 -1 LINE 20.26 -10.13 20.26 20.26 0.30 -1 For case where cooperative path following is desired the mission is adapted as seen in the example bellow: #Version 3 #Xrefpoint Yrefpoint UTM Zone 491854.338 4290819.848 29S # FORMATION ID1 x_dist y_dist ID2 x_dist y_dist ID3 x_dist y_dist FORMATION 1 0 -3 2 0 0 3 0 3 # LINE xInit yInit xEnd yEnd velocity <nVehicle> <gamma> <user data> # ARC xInit yInit xCenter yCenter xEnd yEnd velocity adirection radius <nVehicle> <gamma> <user data> # POINT xInit yInit radius velocity heading time <nVehicle> <gamma> <user data> # DEPTH depth time <nVehicle> <gamma> <user data> # ALT altitude time <nVehicle> <gamma> <user data> # Mission from vehicle -1 LINE -24.57 -24.57 -24.57 12.29 0.30 -1 ARC -24.57 12.29 -12.29 12.29 0.00 12.29 0.30 -1 12.29 -1 LINE 0.00 12.29 0.00 -12.29 0.30 -1 ARC 0.00 -12.29 12.29 -12.29 24.57 -12.29 0.30 1 12.29 -1 LINE 24.57 -12.29 24.57 24.57 0.30 -1 Note that the only difference is the addition of a FORMATION line. Console path parser will read this information and save in a vector of sections ( Mission ). The section structure can be seen below.","title":"Mission/path string format"},{"location":"console-path-parser/#path-following-sections-format","text":"SECTION() { Type = 0; # Line / Arc / Point / Depth / ALT xi = 0; # initial x of section yi = 0; # initial y of section xc = -1; # x of center of arc (-1 if line or point) yc = -1; # y of center of arc (-1 if line or point) xe = 0; # ending x of section ye = 0; # ending y of section velocity = 0; # velocity desired of the vehicle adirection = 0; # -1 if vehicle is turning clockwise, -1 otherwise (only applied to arcs) radius = 0; # radius of the arc heading = -1; time = -1; nVehicle = -1; Gamma_s = 0; # Starting gamma (not normalized) Gamma_e = 0, # Ending gamma (not normalized) depth = 0.0; } The console path parser will then publish the first section (topic /path_section ) of the vector while subscribing to the topic /Gamma which contains a the value of the parameter gamma (see path following theory) not normalized. When the received gamma surpasses the ending gamma ( Gamma_e ) of the section, it will then update its section and publish it. It will do this process for the amount of sections in Mission . Note that /Gamma is being published by the path following node, where there is a conversion of the gamma from normalized to not normalized.","title":"Path following sections format"},{"location":"console-path-parser/#package-content","text":"","title":"Package Content"},{"location":"console-path-parser/#code-documentation","text":"source","title":"Code documentation"},{"location":"console-path-parser/#using-console-path-parser","text":"Examples","title":"Using console path parser"},{"location":"console-path-parser/#requirements","text":"Yebisu - creates the mission to be parsed console_server - receives the mission and sends it here folder to save path - ex: ROS_BAG_FOLDER/paths_from_console path following algorithms - receive sections of the mission","title":"Requirements"},{"location":"console-path-parser/configuration/medusaVxConfig/","text":"medusa_vx config - console_path_parser Run This package is launched with medusa stack ex: roslaunch medusa_bringup medusa_bringup.launch name:= mvector docks:=missions Please check if console_path_parser is set to true in the vehicle configurations. For this, please check the following block in medusa_bringup/config/docks/mvector/process.yaml file: - name: 'addons' launch_on_startup: true delay_before_start: 0.0 cmd: 'roslaunch medusa_bringup addons.launch' args: - aggregator:= true - **console_path_parser:= true** - console_server:= true - wifi_acoustic_safety:= true - rosbridge_server:= false Launch file You have a main launch ( medusa_bringup.launch ) that calls a node ( medusa_bringup_node ) responsible to manage all the processes in a proecss.yaml file. The node while running is responsible to launch a subset of other launch files located at /medusa_bringup/launch/dev_launch . Among the exisitng ones, here the focus is in the addons.launch where console_path_parser is present. Looking in some detail to the file we point out the key points: <arg name=\"name\" /> <arg name=\"mission\" default=\"example\" /> <arg name=\"wifi_acoustic_safety\" default=\"false\" /> <!-- safety features --> **<arg name=\"console_path_parser\" default=\"false\" />** <arg name=\"http_server\" default=\"false\" /> <arg name=\"aggregator\" default=\"false\" /> <arg name=\"rosbridge_server\" default=\"false\" /> <arg name=\"websocket_port\" default=\"9090\" /> <!-- arg to use in http--> By default all the nodes in the medusa_addons package are set to false and won't run if you don't change the corresponding boolean in the process.yaml like in the previous section. <group ns=\"addons\"> Every addon is part of the group addons , which means that topics will be someting like /addons/node/some_topic , here /addons/console_path_parser/some_topic . <!-- ############################ --> <!-- Console Path Parser --> <!-- ############################ --> <group if=\"$(arg console_path_parser)\"> <node pkg=\"console_path_parser\" type=\"console_path_parser_node\" name=\"console_path_parser\" respawn=\"false\" output=\"screen\"> <param name=\"path_folder\" value=\"$(env ROS_BAG_FOLDER)/paths_from_console\"/> </node> </group As you can see the if guarantees that the node only starts if in the process.yaml , console_path_parsert is set to true. Configurations Configuration is divided between two files. The first one, medusa_bringup/config/dev_configs/ros.yaml , is responsible with ros node items (frequency and topics names). Below, the section of console_path_parser : addons/console_path_parser: node_frequency: 5 topics: subscribers: Mission_String: /addons/Mission_String state: /nav/filter/state flag: /Flag gamma: /controls/gamma #ID: /ID publishers: Path_Section: /addons/path_section Formation: /addons/formation biased_formation: /addons/biased_formation WPRef: /addons/WPRef DepthRef: /ref/depth AltRef: /ref/altitude FullMission: /addons/full_mission The second file, /medusa_bringup/config/mission/vehicle/addons.yaml , accommodates items more related with the node inner-workings. Below, the section of console_path_parser : *file, ex: /medusa_bringup/config/docks/mvector/addons.yaml console_path_parser: path_folder: \"../paths_from_console\" vehicle_id: 3","title":"medusa_vx config - console_path_parser"},{"location":"console-path-parser/configuration/medusaVxConfig/#medusa_vx-config-console_path_parser","text":"","title":"medusa_vx config - console_path_parser"},{"location":"console-path-parser/configuration/medusaVxConfig/#run","text":"This package is launched with medusa stack ex: roslaunch medusa_bringup medusa_bringup.launch name:= mvector docks:=missions Please check if console_path_parser is set to true in the vehicle configurations. For this, please check the following block in medusa_bringup/config/docks/mvector/process.yaml file: - name: 'addons' launch_on_startup: true delay_before_start: 0.0 cmd: 'roslaunch medusa_bringup addons.launch' args: - aggregator:= true - **console_path_parser:= true** - console_server:= true - wifi_acoustic_safety:= true - rosbridge_server:= false","title":"Run"},{"location":"console-path-parser/configuration/medusaVxConfig/#launch-file","text":"You have a main launch ( medusa_bringup.launch ) that calls a node ( medusa_bringup_node ) responsible to manage all the processes in a proecss.yaml file. The node while running is responsible to launch a subset of other launch files located at /medusa_bringup/launch/dev_launch . Among the exisitng ones, here the focus is in the addons.launch where console_path_parser is present. Looking in some detail to the file we point out the key points: <arg name=\"name\" /> <arg name=\"mission\" default=\"example\" /> <arg name=\"wifi_acoustic_safety\" default=\"false\" /> <!-- safety features --> **<arg name=\"console_path_parser\" default=\"false\" />** <arg name=\"http_server\" default=\"false\" /> <arg name=\"aggregator\" default=\"false\" /> <arg name=\"rosbridge_server\" default=\"false\" /> <arg name=\"websocket_port\" default=\"9090\" /> <!-- arg to use in http--> By default all the nodes in the medusa_addons package are set to false and won't run if you don't change the corresponding boolean in the process.yaml like in the previous section. <group ns=\"addons\"> Every addon is part of the group addons , which means that topics will be someting like /addons/node/some_topic , here /addons/console_path_parser/some_topic . <!-- ############################ --> <!-- Console Path Parser --> <!-- ############################ --> <group if=\"$(arg console_path_parser)\"> <node pkg=\"console_path_parser\" type=\"console_path_parser_node\" name=\"console_path_parser\" respawn=\"false\" output=\"screen\"> <param name=\"path_folder\" value=\"$(env ROS_BAG_FOLDER)/paths_from_console\"/> </node> </group As you can see the if guarantees that the node only starts if in the process.yaml , console_path_parsert is set to true.","title":"Launch file"},{"location":"console-path-parser/configuration/medusaVxConfig/#configurations","text":"Configuration is divided between two files. The first one, medusa_bringup/config/dev_configs/ros.yaml , is responsible with ros node items (frequency and topics names). Below, the section of console_path_parser : addons/console_path_parser: node_frequency: 5 topics: subscribers: Mission_String: /addons/Mission_String state: /nav/filter/state flag: /Flag gamma: /controls/gamma #ID: /ID publishers: Path_Section: /addons/path_section Formation: /addons/formation biased_formation: /addons/biased_formation WPRef: /addons/WPRef DepthRef: /ref/depth AltRef: /ref/altitude FullMission: /addons/full_mission The second file, /medusa_bringup/config/mission/vehicle/addons.yaml , accommodates items more related with the node inner-workings. Below, the section of console_path_parser : *file, ex: /medusa_bringup/config/docks/mvector/addons.yaml console_path_parser: path_folder: \"../paths_from_console\" vehicle_id: 3","title":"Configurations"},{"location":"console-path-parser/configuration/soloPackageConfig/","text":"Solo Package - console_path_parser Run roslaunch console_path_parser console_path_parser.launch Launch file launch/console_path_parser.launch <?xml version=\"1.0\"?> <launch> <!-- small description about your node --> <!--<node pkg=\"my_package_name\" type=\"my_node_name\" name=\"my_node_name\" respawn=\"false\" output=\"screen\" args=\"$(find console_path_parser)/config/my_arg_file.yaml\"/>--> <node pkg=\"console_path_parser\" type=\"console_path_parser_node\" name=\"console_path_parser\" respawn=\"false\" output=\"screen\"> <rosparam command=\"load\" file=\"$(find console_path_parser)/config/config_console_path_parser.yaml\"/> <param name=\"path_folder\" value=\"$(env ROS_BAG_FOLDER)/paths_from_console\"/> <remap from=\"ID\" to=\"ID_Comms\"/> </node> </launch> Configurations node_frequency: 5 path_folder: \"../paths_from_console\" vehicle_id: 1 topics: subscribers: Mission_String: /Mission_String state: /nav_filter/state flag: /Flag gamma: /Gamma ID: /ID publishers: Path_Section: /Path_Section Formation: /Formation biased_formation: /biased_formation WPRef: /WPRef DepthRef: /ref/depth AltRef: /ref/altitude FullMission: /FullMission","title":"Solo Package - console_path_parser"},{"location":"console-path-parser/configuration/soloPackageConfig/#solo-package-console_path_parser","text":"","title":"Solo Package - console_path_parser"},{"location":"console-path-parser/configuration/soloPackageConfig/#run","text":"roslaunch console_path_parser console_path_parser.launch","title":"Run"},{"location":"console-path-parser/configuration/soloPackageConfig/#launch-file","text":"launch/console_path_parser.launch <?xml version=\"1.0\"?> <launch> <!-- small description about your node --> <!--<node pkg=\"my_package_name\" type=\"my_node_name\" name=\"my_node_name\" respawn=\"false\" output=\"screen\" args=\"$(find console_path_parser)/config/my_arg_file.yaml\"/>--> <node pkg=\"console_path_parser\" type=\"console_path_parser_node\" name=\"console_path_parser\" respawn=\"false\" output=\"screen\"> <rosparam command=\"load\" file=\"$(find console_path_parser)/config/config_console_path_parser.yaml\"/> <param name=\"path_folder\" value=\"$(env ROS_BAG_FOLDER)/paths_from_console\"/> <remap from=\"ID\" to=\"ID_Comms\"/> </node> </launch>","title":"Launch file"},{"location":"console-path-parser/configuration/soloPackageConfig/#configurations","text":"node_frequency: 5 path_folder: \"../paths_from_console\" vehicle_id: 1 topics: subscribers: Mission_String: /Mission_String state: /nav_filter/state flag: /Flag gamma: /Gamma ID: /ID publishers: Path_Section: /Path_Section Formation: /Formation biased_formation: /biased_formation WPRef: /WPRef DepthRef: /ref/depth AltRef: /ref/altitude FullMission: /FullMission","title":"Configurations"},{"location":"cooperative-path-following/","text":"Cooperative Path Following Documentation A package that implements the controller responsible for synchronizing the path following controllers between multiple vehicles in a network. Authors: - Marcelo Jacinto - Jo\u00e3o Quintas - Jo\u00e3o Cruz - Hung Tuan Maintainer: Marcelo Jacinto Email: marcelo.jacinto@tecnico.ulisboa.pt Creation Date: April/2021 Version: 1.0.0 Last Update: April/2021 Cooperative Path Following (CPF) This controllers are only responsible for computing the correction speed for the path following virtual target and when to send information to other vehicles. The general idea is shown in the image bellow. In order to provide a structured way to provide several different implementations of the Cooperative Controller, the following class structured was adopted: - CPFControl - Abstract class every CPF controller should inherit from - EventTriggered - A class that implement CPF with event triggered communications In the image bellow we see the idea in a more graphical way. The cooperative abstract class ( CPFControl ) requris every class that inherits it to provide an implementation for the methods: - coordinationController - the cooperative control law - updateVehicleInformation - method to receive relevant data from the vehicles and store it a way relevant for the type of CPF in use - publishCurrentGamma - method that should return true if we should publish the current vehicle's gamma (virtual target) value to the network. All the other methos are auxiliar and already implemented. See picture bellow for a more in-depth overview. Since that for now we only have one algorithm implement, there is still no service provided to switch between algorithms. Maybe in the future it will make sense and we follow an approach similar to the one used in the path following package. For now we provide the services: - Start - Stop - ChangeTopology - to change the adjency matrix of the network, in order to simulated vehicles losing connection to each other The default configurations for this node can be found in the next figure.","title":"Reference"},{"location":"cooperative-path-following/#cooperative-path-following-documentation","text":"A package that implements the controller responsible for synchronizing the path following controllers between multiple vehicles in a network. Authors: - Marcelo Jacinto - Jo\u00e3o Quintas - Jo\u00e3o Cruz - Hung Tuan Maintainer: Marcelo Jacinto Email: marcelo.jacinto@tecnico.ulisboa.pt Creation Date: April/2021 Version: 1.0.0 Last Update: April/2021","title":"Cooperative Path Following Documentation"},{"location":"cooperative-path-following/#cooperative-path-following-cpf","text":"This controllers are only responsible for computing the correction speed for the path following virtual target and when to send information to other vehicles. The general idea is shown in the image bellow. In order to provide a structured way to provide several different implementations of the Cooperative Controller, the following class structured was adopted: - CPFControl - Abstract class every CPF controller should inherit from - EventTriggered - A class that implement CPF with event triggered communications In the image bellow we see the idea in a more graphical way. The cooperative abstract class ( CPFControl ) requris every class that inherits it to provide an implementation for the methods: - coordinationController - the cooperative control law - updateVehicleInformation - method to receive relevant data from the vehicles and store it a way relevant for the type of CPF in use - publishCurrentGamma - method that should return true if we should publish the current vehicle's gamma (virtual target) value to the network. All the other methos are auxiliar and already implemented. See picture bellow for a more in-depth overview. Since that for now we only have one algorithm implement, there is still no service provided to switch between algorithms. Maybe in the future it will make sense and we follow an approach similar to the one used in the path following package. For now we provide the services: - Start - Stop - ChangeTopology - to change the adjency matrix of the network, in order to simulated vehicles losing connection to each other The default configurations for this node can be found in the next figure.","title":"Cooperative Path Following (CPF)"},{"location":"cpf-gamma/","text":"","title":"Reference"},{"location":"data-serializer/","text":"","title":"Reference"},{"location":"dsor-paths/","text":"Dsor Paths Documentation A package that implements the equations of paths parameterized by a path parameter (gamma). By default we provide several path sections, from arcs to bernoulli lemnicaste. Authors: - Marcelo Jacinto - Jo\u00e3o Quintas - Jo\u00e3o Cruz - Hung Tuan Maintainer: Marcelo Jacinto Email: marcelo.jacinto@tecnico.ulisboa.pt Creation Date: April/2021 Version: 1.0.0 Last Update: April/2021 Path Sections We start by providing a set of sections. Each section inherits the class PathSection . As we see, every section, even though different is implemented in the same structured manner. The number of sections implemented will grow with time. To see all path available check the provided classes API. Here is an example of some of them provided (see image bellow). The goal is for you to keep building on top of this library and add your own costume sections. But how is a path section made? Well you are only required to be able to implement the path position, it's derivative and second derivative given the path parameter (gamma). The rest is done for you (but of course you can always override default implementations). In the image bellow we can check an example of this. For example, in the Line implementation we are only required to implement the functions: - eq_pd(gamma) - path equation (evaluated at gamma) - eq_d_pd(gamma) - derivative of the path equation (evaluated at gamma) - eq_dd_pd(gamma) - second derivative of the path equation (evaluated at gamma) But since the curvature is constant for a line, there is no need to compute it using the standard way for a line. We can just override the standard implementation and just return 0. The same applies to the getClosestPointGamma method. The default implementation uses an iterative method to compute this point in the path (gradient descent). But, for a line we have a closed form solution. This is why we override the function and implement a better solution that exists for this kind of section (see image bellow). In addition you must specify what are the bounds of your section. By default it is [-infinity, +infinity] but that might not make sense for your section. Furthermore, you must also define if you section can be composed or not. These parameters should be setup in the constructor of your path section. See Arc2D section for a detailed example . But, once again, what does this it mean for a section to be able to be composed? Well when you define a section you must also pass to the constructor of PathSection whether you allow this section to be used with more sections or not. For example, for a Line and an Arc it makes sense for them to be composed (in order to generate paths like lawnmowers). On the other hand it makes no sense for a Bernoulli to be composed with other sections, as it is a closed shape in which bounds vary from [-inf, inf]. Speed Sections Similar to the path sections we also implement speed sections. By default the speed sections are even simpler to implement (but we only provide constant speeds). Feel free to add more types of speed profiles! For an example on how to implement one, check the class API. Putting sections together In order to glue the sections together we provide the class Path . This class basically stores a vector of sections (if the first section added can be composed ). This class also stores a vector of speed sections. The number of speeds asked to the path must be the same or lower than the number of path sections. What does this mean in practise? Well, if you add a line section, only then you can add a speed section (or not - speed sections are optional). Let's imagine we add a line and an arc. We can then add a 2 speed sections or 1. By default, if you only add one, the speed that will be desired after the first section finishes is given by the default value specificied in the speed section. The goal of this class is that all the dirty logic and abstraction is already provided to the developer. Therefore, people only have to focus on implementing costume sections for their algorithms to follow. In the image bellow, we can see all the API provided by the Path class. In practise, users do not need to worry about this path. As long as new sections inherit SpeedSection or PathSection they will work with the path class. How to interface this library with ROS The introduced library is completely independent from ROS. Therefore, in order to interface the library with ROS we use services . For every path section and speed section we create a ROS Service . For example, for a Bernouli we provide a service of the type /SpawnBernoulli . The same applies for lines, arcs,... (see image bellow) To create a service is almost the same as creating a message in ROS. Here is an example for a SpawnBernoulli.srv : float64 radius float64 center_x float64 center_y float64 z --- bool success In the service callback implementation we just receive the data necessary to initialize the section and create a new object of that section. Afterward we just need to call the method to add that section to the path and voila! It's done! By the way, all of this is done in the PathServices.cpp and PathNode.h . See the image bellow for a concrete example. Modes of operation Since some path following algorithms require us to use the cloest point of the vehicle in the path, we need to be able to compute this. Therefore we implement the getClosestPointGamma(coordinate) method. This method is supposed to receive the coordinates of the vehicle and give the gamma of the path that encodes the closest point. With that gamma value we can compute anything. Modes of operation: - Listen to a gamma (default) - Closest Point To change between modes we provide a service /SetMode . To reset the path we also provide the service /ResetPath . When we reset the path all the section that are inside are clean (both speed and path sections). In addition the mode of operation is also reset to its default value (listen to gamma) and publish the data. Data published by the ROS node In order to publish all the relevant data from a path evaluated at a specific value of gamma we provide a new ROS message - PathData.msg : Header header float64[3] pd # Path position float64[3] d_pd # First derivative float64[3] dd_pd # Second derivative float64 curvature float64 tangent float64 derivative_norm float64 vd # Desired speed for gamma float64 d_vd # Desired accel. for gamma float64 vehicle_speed # Desired vehicle speed float64 gamma_min # Min gamma of the path float64 gamma_max # Max gamma of the path","title":"Reference"},{"location":"dsor-paths/#dsor-paths-documentation","text":"A package that implements the equations of paths parameterized by a path parameter (gamma). By default we provide several path sections, from arcs to bernoulli lemnicaste. Authors: - Marcelo Jacinto - Jo\u00e3o Quintas - Jo\u00e3o Cruz - Hung Tuan Maintainer: Marcelo Jacinto Email: marcelo.jacinto@tecnico.ulisboa.pt Creation Date: April/2021 Version: 1.0.0 Last Update: April/2021","title":"Dsor Paths Documentation"},{"location":"dsor-paths/#path-sections","text":"We start by providing a set of sections. Each section inherits the class PathSection . As we see, every section, even though different is implemented in the same structured manner. The number of sections implemented will grow with time. To see all path available check the provided classes API. Here is an example of some of them provided (see image bellow). The goal is for you to keep building on top of this library and add your own costume sections. But how is a path section made? Well you are only required to be able to implement the path position, it's derivative and second derivative given the path parameter (gamma). The rest is done for you (but of course you can always override default implementations). In the image bellow we can check an example of this. For example, in the Line implementation we are only required to implement the functions: - eq_pd(gamma) - path equation (evaluated at gamma) - eq_d_pd(gamma) - derivative of the path equation (evaluated at gamma) - eq_dd_pd(gamma) - second derivative of the path equation (evaluated at gamma) But since the curvature is constant for a line, there is no need to compute it using the standard way for a line. We can just override the standard implementation and just return 0. The same applies to the getClosestPointGamma method. The default implementation uses an iterative method to compute this point in the path (gradient descent). But, for a line we have a closed form solution. This is why we override the function and implement a better solution that exists for this kind of section (see image bellow). In addition you must specify what are the bounds of your section. By default it is [-infinity, +infinity] but that might not make sense for your section. Furthermore, you must also define if you section can be composed or not. These parameters should be setup in the constructor of your path section. See Arc2D section for a detailed example . But, once again, what does this it mean for a section to be able to be composed? Well when you define a section you must also pass to the constructor of PathSection whether you allow this section to be used with more sections or not. For example, for a Line and an Arc it makes sense for them to be composed (in order to generate paths like lawnmowers). On the other hand it makes no sense for a Bernoulli to be composed with other sections, as it is a closed shape in which bounds vary from [-inf, inf].","title":"Path Sections"},{"location":"dsor-paths/#speed-sections","text":"Similar to the path sections we also implement speed sections. By default the speed sections are even simpler to implement (but we only provide constant speeds). Feel free to add more types of speed profiles! For an example on how to implement one, check the class API.","title":"Speed Sections"},{"location":"dsor-paths/#putting-sections-together","text":"In order to glue the sections together we provide the class Path . This class basically stores a vector of sections (if the first section added can be composed ). This class also stores a vector of speed sections. The number of speeds asked to the path must be the same or lower than the number of path sections. What does this mean in practise? Well, if you add a line section, only then you can add a speed section (or not - speed sections are optional). Let's imagine we add a line and an arc. We can then add a 2 speed sections or 1. By default, if you only add one, the speed that will be desired after the first section finishes is given by the default value specificied in the speed section. The goal of this class is that all the dirty logic and abstraction is already provided to the developer. Therefore, people only have to focus on implementing costume sections for their algorithms to follow. In the image bellow, we can see all the API provided by the Path class. In practise, users do not need to worry about this path. As long as new sections inherit SpeedSection or PathSection they will work with the path class.","title":"Putting sections together"},{"location":"dsor-paths/#how-to-interface-this-library-with-ros","text":"The introduced library is completely independent from ROS. Therefore, in order to interface the library with ROS we use services . For every path section and speed section we create a ROS Service . For example, for a Bernouli we provide a service of the type /SpawnBernoulli . The same applies for lines, arcs,... (see image bellow) To create a service is almost the same as creating a message in ROS. Here is an example for a SpawnBernoulli.srv : float64 radius float64 center_x float64 center_y float64 z --- bool success In the service callback implementation we just receive the data necessary to initialize the section and create a new object of that section. Afterward we just need to call the method to add that section to the path and voila! It's done! By the way, all of this is done in the PathServices.cpp and PathNode.h . See the image bellow for a concrete example.","title":"How to interface this library with ROS"},{"location":"dsor-paths/#modes-of-operation","text":"Since some path following algorithms require us to use the cloest point of the vehicle in the path, we need to be able to compute this. Therefore we implement the getClosestPointGamma(coordinate) method. This method is supposed to receive the coordinates of the vehicle and give the gamma of the path that encodes the closest point. With that gamma value we can compute anything. Modes of operation: - Listen to a gamma (default) - Closest Point To change between modes we provide a service /SetMode . To reset the path we also provide the service /ResetPath . When we reset the path all the section that are inside are clean (both speed and path sections). In addition the mode of operation is also reset to its default value (listen to gamma) and publish the data.","title":"Modes of operation"},{"location":"dsor-paths/#data-published-by-the-ros-node","text":"In order to publish all the relevant data from a path evaluated at a specific value of gamma we provide a new ROS message - PathData.msg : Header header float64[3] pd # Path position float64[3] d_pd # First derivative float64[3] dd_pd # Second derivative float64 curvature float64 tangent float64 derivative_norm float64 vd # Desired speed for gamma float64 d_vd # Desired accel. for gamma float64 vehicle_speed # Desired vehicle speed float64 gamma_min # Min gamma of the path float64 gamma_max # Max gamma of the path","title":"Data published by the ROS node"},{"location":"dsor-ros-messages/","text":"DSOR Messages","title":"Reference"},{"location":"dsor-utility-functions/","text":"Math TODO - create documentation for this API Rotations TODO - create documentation for this API Frames This library implements a set of templates to convert between ENU frame and NED frames, both for angles expressed in the inertial frame and in the body frame of a vehicle. Conventions on quaternion rotations between frames In ROS a quaternion expresses a rotation of the body frame of the vehicle (which is ENU, i.e. ENU_base_link) with respect to (w.r.t) the inertial frame of reference in ENU (i.e. ENU_inertial_frame). Note that in ENU_base_link, the X-axis comes out of the front of the vehicle and a Z-axis that goes \"out of the vehicle in upwards direction\". On the other hand, in marine and aerial vehicles it is typical to consider a body frame which is expressed in NED_base_link, where the X-axis also comes out of the front of the vehicle but the Z-axis goes \"out of the vehicle in downwards direction\", according to the following figure (adapted from PX4 website). Therefore, according to the literature, a quaternion should express a rotation of the body frame of the vehicle (which is NED, i.e. NED_base_link) with respect to (w.r.t) the inertial frame of reference in NED (i.e. NED_inertial_frame). From the Figure it is trivial to conclude that rotating ENU_base_link <-> NED_base_link is different then rotating ENU_inertial_frame <-> NED_inertial_frame. This comes from the fact that in the body frame, both ENU and NED conventions arbitrate that the X axis comes forwards of the vehicle (this axis does not change), while in the inertial frame you can see from the figure above that it does change. Now that we have explained both the rotations in the body and inertial frames, let's see how to perform them: Inertial Frame 1.1) To convert a rotation expressed in ENU to a rotation expressed in NED, we must apply the following rotation (using Z-Y-X convention): - Rotate 90\u00ba about Z-axis - Rotate 0\u00ba about Y-axis - Rotate 180\u00ba about X-axis 1.2) To convert a rotation expressed in NED to a rotation expressed in ENU, we must apply the following rotation (using Z-Y-X convention): - Rotate -90\u00ba about Z-axis - Rotate 180\u00ba about Y-axis - Rotate 0\u00ba about X-axis Body Frame (a.k.a ROS base_link) 2.1) To convert a rotation expressed in the ENU body frame (ROS base_link) to a rotation expressed in NED body frame (the typical body frame adopted for aerial and marine crafts), we must apply the following rotation (using Z-Y-X convention): - Rotate 0\u00ba about Z-axis - Rotate 0\u00ba about Y-axis - Rotate 180\u00ba about X-axis 2.2) To convert a rotation expressed in the NED body frame (the typical body frame adopted for aerial and marine crafts) to a rotation expressed in the ENU body frame (ROS base_link), we must apply the following rotation (using Z-Y-X convention): - Rotate 0\u00ba about Z-axis - Rotate 0\u00ba about Y-axis - Rotate -180\u00ba about X-axis Given this knowledge, we can now convert a ROS quaternion/rotation expressed in ENU_inertial_frame w.r.t. ENU_base_link to a \"regular\" quaternion expressed in NED_inertial_frame w.r.t. NED_base_link. ROS -> \"regular\" - State: rotation in ENU w.r.t. ENU_base_link - Action: Apply body frame rotation (operation 2.1) - State: rotation in ENU w.r.t. NED_base_link - Action: Apply inertial frame rotation (operation 1.1) - State: rotation in NED w.r.t. NED_base_link \"regular\" -> ROS - State: rotation in NED w.r.t. NED_base_link - Action: Apply body frame rotation (operation 2.2) - State: rotation in NED w.r.t. ENU_base_link - Action: Apply inertial frame rotation (operation 1.2) - State: rotation in ENU w.r.t. ENU_base_link Transform vectors and covariances between frames For vectors w.r.t body or inertial frames expressed in ENU (Forward, Left, Up) , the transformation to express them in NED (Forward, Right, Down) depends on their respective frame of reference. To transform vectors w.r.t the body-frame the conversion is quite simple and only requires us to: - apply an 180\u00ba rotation around X (Forward) axis To transform vectors w.r.t the inertial-frame the conversion is different and is made in the following way: - Switch XY axis - Invert the Z axis Regarding coordinate frame conversion for covariance matrices, the principle is similar, however, the computations are slightly different as shown on the following image. Spherical Coordinates TODO - create documentation for this API","title":"Reference"},{"location":"dsor-utility-functions/#math","text":"TODO - create documentation for this API","title":"Math"},{"location":"dsor-utility-functions/#rotations","text":"TODO - create documentation for this API","title":"Rotations"},{"location":"dsor-utility-functions/#frames","text":"This library implements a set of templates to convert between ENU frame and NED frames, both for angles expressed in the inertial frame and in the body frame of a vehicle.","title":"Frames"},{"location":"dsor-utility-functions/#conventions-on-quaternion-rotations-between-frames","text":"In ROS a quaternion expresses a rotation of the body frame of the vehicle (which is ENU, i.e. ENU_base_link) with respect to (w.r.t) the inertial frame of reference in ENU (i.e. ENU_inertial_frame). Note that in ENU_base_link, the X-axis comes out of the front of the vehicle and a Z-axis that goes \"out of the vehicle in upwards direction\". On the other hand, in marine and aerial vehicles it is typical to consider a body frame which is expressed in NED_base_link, where the X-axis also comes out of the front of the vehicle but the Z-axis goes \"out of the vehicle in downwards direction\", according to the following figure (adapted from PX4 website). Therefore, according to the literature, a quaternion should express a rotation of the body frame of the vehicle (which is NED, i.e. NED_base_link) with respect to (w.r.t) the inertial frame of reference in NED (i.e. NED_inertial_frame). From the Figure it is trivial to conclude that rotating ENU_base_link <-> NED_base_link is different then rotating ENU_inertial_frame <-> NED_inertial_frame. This comes from the fact that in the body frame, both ENU and NED conventions arbitrate that the X axis comes forwards of the vehicle (this axis does not change), while in the inertial frame you can see from the figure above that it does change. Now that we have explained both the rotations in the body and inertial frames, let's see how to perform them: Inertial Frame 1.1) To convert a rotation expressed in ENU to a rotation expressed in NED, we must apply the following rotation (using Z-Y-X convention): - Rotate 90\u00ba about Z-axis - Rotate 0\u00ba about Y-axis - Rotate 180\u00ba about X-axis 1.2) To convert a rotation expressed in NED to a rotation expressed in ENU, we must apply the following rotation (using Z-Y-X convention): - Rotate -90\u00ba about Z-axis - Rotate 180\u00ba about Y-axis - Rotate 0\u00ba about X-axis Body Frame (a.k.a ROS base_link) 2.1) To convert a rotation expressed in the ENU body frame (ROS base_link) to a rotation expressed in NED body frame (the typical body frame adopted for aerial and marine crafts), we must apply the following rotation (using Z-Y-X convention): - Rotate 0\u00ba about Z-axis - Rotate 0\u00ba about Y-axis - Rotate 180\u00ba about X-axis 2.2) To convert a rotation expressed in the NED body frame (the typical body frame adopted for aerial and marine crafts) to a rotation expressed in the ENU body frame (ROS base_link), we must apply the following rotation (using Z-Y-X convention): - Rotate 0\u00ba about Z-axis - Rotate 0\u00ba about Y-axis - Rotate -180\u00ba about X-axis Given this knowledge, we can now convert a ROS quaternion/rotation expressed in ENU_inertial_frame w.r.t. ENU_base_link to a \"regular\" quaternion expressed in NED_inertial_frame w.r.t. NED_base_link. ROS -> \"regular\" - State: rotation in ENU w.r.t. ENU_base_link - Action: Apply body frame rotation (operation 2.1) - State: rotation in ENU w.r.t. NED_base_link - Action: Apply inertial frame rotation (operation 1.1) - State: rotation in NED w.r.t. NED_base_link \"regular\" -> ROS - State: rotation in NED w.r.t. NED_base_link - Action: Apply body frame rotation (operation 2.2) - State: rotation in NED w.r.t. ENU_base_link - Action: Apply inertial frame rotation (operation 1.2) - State: rotation in ENU w.r.t. ENU_base_link","title":"Conventions on quaternion rotations between frames"},{"location":"dsor-utility-functions/#transform-vectors-and-covariances-between-frames","text":"For vectors w.r.t body or inertial frames expressed in ENU (Forward, Left, Up) , the transformation to express them in NED (Forward, Right, Down) depends on their respective frame of reference. To transform vectors w.r.t the body-frame the conversion is quite simple and only requires us to: - apply an 180\u00ba rotation around X (Forward) axis To transform vectors w.r.t the inertial-frame the conversion is different and is made in the following way: - Switch XY axis - Invert the Z axis Regarding coordinate frame conversion for covariance matrices, the principle is similar, however, the computations are slightly different as shown on the following image.","title":"Transform vectors and covariances between frames"},{"location":"dsor-utility-functions/#spherical-coordinates","text":"TODO - create documentation for this API","title":"Spherical Coordinates"},{"location":"evo-tools/","text":"","title":"Reference"},{"location":"http-server/","text":"http_server package http_server is a ROS package written in Python responsible for exchaning information between a web console (Yebisu) and a vehicle. Rationale A vehicle runs an http server and is responsible to send and read http requests. It also creates a simple html web page displaying relevant vehicle information. NOTE: More details later, maybe the stack will move to rosbridge. Package Content Code documentation source Using http_server Examples Requirements http server web console (Yebisu)","title":"Reference"},{"location":"http-server/#http_server-package","text":"http_server is a ROS package written in Python responsible for exchaning information between a web console (Yebisu) and a vehicle.","title":"http_server package"},{"location":"http-server/#rationale","text":"A vehicle runs an http server and is responsible to send and read http requests. It also creates a simple html web page displaying relevant vehicle information. NOTE: More details later, maybe the stack will move to rosbridge.","title":"Rationale"},{"location":"http-server/#package-content","text":"","title":"Package Content"},{"location":"http-server/#code-documentation","text":"source","title":"Code documentation"},{"location":"http-server/#using-http_server","text":"Examples","title":"Using http_server"},{"location":"http-server/#requirements","text":"http server web console (Yebisu)","title":"Requirements"},{"location":"http-server/configuration/medusaVxConfig/","text":"medusa_vx config - http_server Run Vehicle Side This package is launched with medusa stack ex: roslaunch medusa_bringup medusa_bringup.launch name:= mvector docks:=missions Please check if console_server is set to true in the vehicle configurations. For this, please check the following block in medusa_bringup/config/docks/mvector/process.yaml file: - name: 'addons' launch_on_startup: true delay_before_start: 0.0 cmd: 'roslaunch medusa_bringup addons.launch' args: - aggregator:= true - console_path_parser:= true - **console_server:= true** - wifi_acoustic_safety:= true - rosbridge_server:= false Launch file You have a main launch ( medusa_bringup.launch ) that calls a node ( medusa_bringup_node ) responsible to manage all the processes in a proecss.yaml file. The node while running is responsible to launch a subset of other launch files located at /medusa_bringup/launch/dev_launch . Among the exisitng ones, here the focus is in the addons.launch where console_server is present. Looking in some detail to the file we point out the key points: <arg name=\"name\" /> <arg name=\"mission\" default=\"example\" /> **<arg name=\"wifi_acoustic_safety\" default=\"false\" />** <!-- safety features --> <arg name=\"console_path_parser\" default=\"false\" /> <arg name=\"console_server\" default=\"false\" /> <arg name=\"aggregator\" default=\"false\" /> <arg name=\"rosbridge_server\" default=\"false\" /> <arg name=\"websocket_port\" default=\"9090\" /> <!-- arg to use in http--> By default all the nodes in the medusa_addons package are set to false and won't run if you don't change the corresponding boolean in the process.yaml like in the previous section. <group ns=\"addons\"> Every addon is part of the group addons , which means that almost all topics will be someting like /addons/node/some_topic , here /addons/http_server/some_topic . <!-- ############################ --> <!-- HTTP Server for Console --> <!-- ############################ --> <group if=\"$(arg console_server)\"> <node pkg=\"http_server\" type=\"console.py\" name=\"console_server\" args=\"console\" output=\"screen\"> <param name=\"Mission_Folder\" value=\"$(find http_server)/../../Missions_FOLDER\" /> <param name=\"pages_folder\" value=\"$(find http_server)/pages/\" /> </node> </group> As you can see the if guarantees that the node only starts if in the process.yaml , console_server is set to true. Configurations Note that some configurations, in this case, are set in the launch file: <param name=\"Mission_Folder\" value=\"$(find http_server)/../../Missions_FOLDER\" /> <param name=\"pages_folder\" value=\"$(find http_server)/pages/\" /> Other configurations are at /medusa_bringup/config/mission/vehicle/addons.yaml : *file, ex: /medusa_bringup/config/docks/mvector/addons.yaml console_server: PORT: 7080 ROOT_NAMESPACE: true","title":"medusa_vx config - http_server"},{"location":"http-server/configuration/medusaVxConfig/#medusa_vx-config-http_server","text":"","title":"medusa_vx config - http_server"},{"location":"http-server/configuration/medusaVxConfig/#run","text":"","title":"Run"},{"location":"http-server/configuration/medusaVxConfig/#vehicle-side","text":"This package is launched with medusa stack ex: roslaunch medusa_bringup medusa_bringup.launch name:= mvector docks:=missions Please check if console_server is set to true in the vehicle configurations. For this, please check the following block in medusa_bringup/config/docks/mvector/process.yaml file: - name: 'addons' launch_on_startup: true delay_before_start: 0.0 cmd: 'roslaunch medusa_bringup addons.launch' args: - aggregator:= true - console_path_parser:= true - **console_server:= true** - wifi_acoustic_safety:= true - rosbridge_server:= false","title":"Vehicle Side"},{"location":"http-server/configuration/medusaVxConfig/#launch-file","text":"You have a main launch ( medusa_bringup.launch ) that calls a node ( medusa_bringup_node ) responsible to manage all the processes in a proecss.yaml file. The node while running is responsible to launch a subset of other launch files located at /medusa_bringup/launch/dev_launch . Among the exisitng ones, here the focus is in the addons.launch where console_server is present. Looking in some detail to the file we point out the key points: <arg name=\"name\" /> <arg name=\"mission\" default=\"example\" /> **<arg name=\"wifi_acoustic_safety\" default=\"false\" />** <!-- safety features --> <arg name=\"console_path_parser\" default=\"false\" /> <arg name=\"console_server\" default=\"false\" /> <arg name=\"aggregator\" default=\"false\" /> <arg name=\"rosbridge_server\" default=\"false\" /> <arg name=\"websocket_port\" default=\"9090\" /> <!-- arg to use in http--> By default all the nodes in the medusa_addons package are set to false and won't run if you don't change the corresponding boolean in the process.yaml like in the previous section. <group ns=\"addons\"> Every addon is part of the group addons , which means that almost all topics will be someting like /addons/node/some_topic , here /addons/http_server/some_topic . <!-- ############################ --> <!-- HTTP Server for Console --> <!-- ############################ --> <group if=\"$(arg console_server)\"> <node pkg=\"http_server\" type=\"console.py\" name=\"console_server\" args=\"console\" output=\"screen\"> <param name=\"Mission_Folder\" value=\"$(find http_server)/../../Missions_FOLDER\" /> <param name=\"pages_folder\" value=\"$(find http_server)/pages/\" /> </node> </group> As you can see the if guarantees that the node only starts if in the process.yaml , console_server is set to true.","title":"Launch file"},{"location":"http-server/configuration/medusaVxConfig/#configurations","text":"Note that some configurations, in this case, are set in the launch file: <param name=\"Mission_Folder\" value=\"$(find http_server)/../../Missions_FOLDER\" /> <param name=\"pages_folder\" value=\"$(find http_server)/pages/\" /> Other configurations are at /medusa_bringup/config/mission/vehicle/addons.yaml : *file, ex: /medusa_bringup/config/docks/mvector/addons.yaml console_server: PORT: 7080 ROOT_NAMESPACE: true","title":"Configurations"},{"location":"interrogation-scheme/","text":"","title":"Reference"},{"location":"medusa-diagnostics-library/","text":"Medusa Gimmicks Library Description Collection of methods to ease the use of ROS diagnostics package. Important Sources The library was built following the steps in this link Also an important note about implementing template methods here . Basically this avoids linking errors with the library. How to use the library in a new node CmakeLists.txt Add library to find package find_package(catkin REQUIRED COMPONENTS roscpp medusa_diagnostics_lirabry ) package.xml Add the following <depend>medusa_diagnostics_lirabry</depend> Include the library in your new node #include <medusa_diagnostics_library/MedusaDiagnostics.h> Use in your code MedusaDiagnostics::method_to_use(...) Package Content Code documentation source","title":"Reference"},{"location":"medusa-diagnostics-library/#medusa-gimmicks-library","text":"","title":"Medusa Gimmicks Library"},{"location":"medusa-diagnostics-library/#description","text":"Collection of methods to ease the use of ROS diagnostics package.","title":"Description"},{"location":"medusa-diagnostics-library/#important-sources","text":"The library was built following the steps in this link Also an important note about implementing template methods here . Basically this avoids linking errors with the library.","title":"Important Sources"},{"location":"medusa-diagnostics-library/#how-to-use-the-library-in-a-new-node","text":"","title":"How to use the library in a new node"},{"location":"medusa-diagnostics-library/#cmakeliststxt","text":"Add library to find package find_package(catkin REQUIRED COMPONENTS roscpp medusa_diagnostics_lirabry )","title":"CmakeLists.txt"},{"location":"medusa-diagnostics-library/#packagexml","text":"Add the following <depend>medusa_diagnostics_lirabry</depend>","title":"package.xml"},{"location":"medusa-diagnostics-library/#include-the-library-in-your-new-node","text":"#include <medusa_diagnostics_library/MedusaDiagnostics.h>","title":"Include the library in your new node"},{"location":"medusa-diagnostics-library/#use-in-your-code","text":"MedusaDiagnostics::method_to_use(...)","title":"Use in your code"},{"location":"medusa-diagnostics-library/#package-content","text":"","title":"Package Content"},{"location":"medusa-diagnostics-library/#code-documentation","text":"source","title":"Code documentation"},{"location":"medusa-gimmicks-library/","text":"Medusa Gimmicks Library Description Collection of methods to be used by several nodes in the Medusa stack. Important Sources The library was built following the steps in this link Also an important note about implementing template methods here . Basically this avoids linking errors with the library. How to use the library in a new package/node CmakeLists.txt Add library to find package find_package(catkin REQUIRED COMPONENTS roscpp medusa_gimmicks_lirabry ) package.xml Add the following <depend>medusa_gimmicks_lirabry</depend> Include the library in your new node #include <medusa_gimmicks_library/MedusaGimmicks.h> Use in your code MedusaGimmicks::method_to_use(...) Package Content Code documentation source","title":"Reference"},{"location":"medusa-gimmicks-library/#medusa-gimmicks-library","text":"","title":"Medusa Gimmicks Library"},{"location":"medusa-gimmicks-library/#description","text":"Collection of methods to be used by several nodes in the Medusa stack.","title":"Description"},{"location":"medusa-gimmicks-library/#important-sources","text":"The library was built following the steps in this link Also an important note about implementing template methods here . Basically this avoids linking errors with the library.","title":"Important Sources"},{"location":"medusa-gimmicks-library/#how-to-use-the-library-in-a-new-packagenode","text":"","title":"How to use the library in a new package/node"},{"location":"medusa-gimmicks-library/#cmakeliststxt","text":"Add library to find package find_package(catkin REQUIRED COMPONENTS roscpp medusa_gimmicks_lirabry )","title":"CmakeLists.txt"},{"location":"medusa-gimmicks-library/#packagexml","text":"Add the following <depend>medusa_gimmicks_lirabry</depend>","title":"package.xml"},{"location":"medusa-gimmicks-library/#include-the-library-in-your-new-node","text":"#include <medusa_gimmicks_library/MedusaGimmicks.h>","title":"Include the library in your new node"},{"location":"medusa-gimmicks-library/#use-in-your-code","text":"MedusaGimmicks::method_to_use(...)","title":"Use in your code"},{"location":"medusa-gimmicks-library/#package-content","text":"","title":"Package Content"},{"location":"medusa-gimmicks-library/#code-documentation","text":"source","title":"Code documentation"},{"location":"medusa-navigation/overview/","text":"Description medusa_nav is a meta-package to house all the software packages required to construct a navigation system for an unmanned underwater vehicle. This package has the following features Deploy vehicle state estimation node for dead-reckoning Deploy vehicle state estimation node with position fixes from one or multiple sources Implement Single-beacon and USBL range based navigation algorithm Convert WGS84 input in to UTM NED in Convert State in to State in Convert State in to State in Implements tools and techniques used in geophysical navigation. Getting Started Prerequisite Information Before getting started, the reader is recommended to get familiarized with the following concepts - Kalman and Extended Kalman Filter - Range based navigation techniques such as Single-beacon (EKF) and USBL - Reference Frames and Transformations - ROS and Linux operations - Key Libraries include TF2, Geographic Lib, Eigen Conventions Assume that the best practices laid down by P\u00e9ter Fankhauser, ANYbotics are followed unless other stated. Deviations - AUV World reference frame is North-East-Down - Input Angles are in Radians, Output Angles are in Degrees - Following coordinate frames are used - base_link: Body-fixed rigid frame attached to the COM of the vehicle - odom: World-fixed frame where position evolves smoothly, without discrete jumps but with drifts. - map : World-fixed frame where position evolves with discrete jumps, but with little drifts. Inspirations Work done in this package draws heavily from the following two packages - medusa-ros/medusa_control/filters_medusa - cra-ros-pkg/robot_localization ! Follow the Guidelines and Development Lifecycle defined for medusa_vx stack Project Directory sensor_fusion A general-purpose kalman filter for vehicle state estimation. For documentation, refer the links below - Readme.md - Developer Notes - Theory nav_tools Contains handy tools used to convert measurements and state messages. Also contains range-based measurement nodes. medusa_gn Geo-physical navigation","title":"Overview"},{"location":"medusa-navigation/overview/#description","text":"medusa_nav is a meta-package to house all the software packages required to construct a navigation system for an unmanned underwater vehicle. This package has the following features Deploy vehicle state estimation node for dead-reckoning Deploy vehicle state estimation node with position fixes from one or multiple sources Implement Single-beacon and USBL range based navigation algorithm Convert WGS84 input in to UTM NED in Convert State in to State in Convert State in to State in Implements tools and techniques used in geophysical navigation.","title":"Description"},{"location":"medusa-navigation/overview/#getting-started","text":"","title":"Getting Started"},{"location":"medusa-navigation/overview/#prerequisite-information","text":"Before getting started, the reader is recommended to get familiarized with the following concepts - Kalman and Extended Kalman Filter - Range based navigation techniques such as Single-beacon (EKF) and USBL - Reference Frames and Transformations - ROS and Linux operations - Key Libraries include TF2, Geographic Lib, Eigen","title":"Prerequisite Information"},{"location":"medusa-navigation/overview/#conventions","text":"Assume that the best practices laid down by P\u00e9ter Fankhauser, ANYbotics are followed unless other stated. Deviations - AUV World reference frame is North-East-Down - Input Angles are in Radians, Output Angles are in Degrees - Following coordinate frames are used - base_link: Body-fixed rigid frame attached to the COM of the vehicle - odom: World-fixed frame where position evolves smoothly, without discrete jumps but with drifts. - map : World-fixed frame where position evolves with discrete jumps, but with little drifts.","title":"Conventions"},{"location":"medusa-navigation/overview/#inspirations","text":"Work done in this package draws heavily from the following two packages - medusa-ros/medusa_control/filters_medusa - cra-ros-pkg/robot_localization ! Follow the Guidelines and Development Lifecycle defined for medusa_vx stack","title":"Inspirations"},{"location":"medusa-navigation/overview/#project-directory","text":"","title":"Project Directory"},{"location":"medusa-navigation/overview/#sensor_fusion","text":"A general-purpose kalman filter for vehicle state estimation. For documentation, refer the links below - Readme.md - Developer Notes - Theory","title":"sensor_fusion"},{"location":"medusa-navigation/overview/#nav_tools","text":"Contains handy tools used to convert measurements and state messages. Also contains range-based measurement nodes.","title":"nav_tools"},{"location":"medusa-navigation/overview/#medusa_gn","text":"Geo-physical navigation","title":"medusa_gn"},{"location":"medusa-ros-messages/","text":"Medusa messages stack mDummy.msg -> Messages with an m are used in all vehicles dDummy.msg -> Messages with a d are only used in Delfim","title":"Reference"},{"location":"medusa-ros-messages/#medusa-messages-stack","text":"mDummy.msg -> Messages with an m are used in all vehicles dDummy.msg -> Messages with a d are only used in Delfim","title":"Medusa messages stack"},{"location":"medusa-scripts/","text":"","title":"Reference"},{"location":"medusa-simulation-bringup-system/","text":"","title":"Overview"},{"location":"nav-tools/nav_tools/","text":"Nav tools Project Description This package contains tools to convert msgs between data types. Currently, it also houses range-based positioning tools. This package has the following highlights Convert data in WGS84 from sensor_msgs::NavSatFix to data in UTM NED & medusa_msgs::Measurement Convert state from auv_msgs::NavigationStatus to medusa_msgs::mState Convert state from auv_msgs::NavigationStatus to nav_msgs::Odometry Convert Ranges from single-beacon to position update using EKF Convert Georeferenced USBL position fix to position update Getting Started Installation Pkg nav_tools comes as part of the medusa_vx stack. Gnss2Utm This node converts data in WGS84 from sensor_msgs::NavSatFix to UTM NED medusa_msgs::Measurement format Configuration This section explains how to write the node configuration file. A sample is given below node_frequency: 10 topics: subscribers: [ \"/measurement/gnss\" ] publishers: [ \"/measurement/position\" ] ROS Node Parameters node_frequency : parameter of type double Define the node output frequency topics/subscribers : parameter of type string[1] Defines the input topic to receive position in Lat/Lon, WGS84 format. topics/publishers : parameters of type string[1] Defines topic to output position in UTM NED Launching the Nodes An example launch file is provided below where nav_tools/gnss2utm node is being launched. <?xml version=\"1.0\"?> <launch> <node pkg=\"nav_tools\" type=\"gnss_to_utm\" name=\"gnss2utm\" respawn=\"true\" output=\"screen\"> <rosparam command=\"load\" file=\"$(find nav_tools)/config/gnss2utm.yaml\"/> </node> </launch> AuvState2mState This node converts state in auv_msgs::NavigationStatus to state in medusa_msgs::mState . Also need inside_pressure data for mState. Configuration This section explains how to write the node configuration file. A sample is given below node_frequency: 10 topics: subscribers: [ \"/nav/filter/state\", \"/drivers/inside_pressure/data\" ] publishers: [ \"/State\" ] node_frequency : node output frequency topics/subscribers: parameter of type string[2] topic[1] - state: receives state of type auv_msgs::NavigationStatu topic[2] - inside_pressure: receives inside_pressure data topics/publishers: parameter of type string[1] topic[1] - state: publishes state of type medusa_msgs::mState Launching the Nodes An example launch file is provided below where nav_tools/auvstate2mstate node is being launched. <?xml version=\"1.0\"?> <launch> <node pkg=\"nav_tools\" type=\"auvstate_to_mstate\" name=\"auvstate2mstate\" respawn=\"true\" output=\"screen\"> <rosparam command=\"load\" file=\"$(find nav_tools)/config/auvstate2mstate.yaml\"/> </node> </launch> AuvState2Odom This node converts state in auv_msgs::NavigationStatus to nav_msgs::Odometry . Configuration This section explains how to write the node configuration file. A sample is given below node_frequency: 10 topics: subscribers: [ \"/nav_filter/state\" ] publishers: [ \"/nav_filter/state_odom\" ] node_frequency : node output frequency topics/subscribers: parameter of type string[1] receives state of type auv_msgs::NavigationStatus topics/publishers: parameter of type string[1] publishes state of type nav_msgs::Odometry Launching the Nodes An example launch file is provided below where nav_tools/auvstate2odom node is being launched. <?xml version=\"1.0\"?> <launch> <node pkg=\"nav_tools\" type=\"auvstate_to_odom\" name=\"auvstate2odom\" respawn=\"true\" output=\"screen\"> <rosparam command=\"load\" file=\"$(find nav_tools)/config/auvstate2odom.yaml\"/> </node> </launch> Usbl2Pos This node takes in georeferences usbl position fix and converts it to position updates of the filter. It can be deployed in two ways Scenario 1: Inverted-USBL In this scenario, the underwater vehicle localizes itself with respect to an anchor, whose precise global position is known. The usbl onboard the vehicle receives the georeferenced position of the anchor and the usbl-fix. The vehicle uses these two information to estimate its position using simple geometry. Scenario 2: Tracking with USBL In this scenario, the anchor, whose precise global position is known, tracks underwater vehicles using USBL fixes. The anchor receives the usbl-fix of the underwater vehicle and uses its own position to estimate the position of the underwater vehicle. Configuration node_frequency: 10 topics: subscribers: [ \"/acomms/measurement/usbl_fix\", \"/acomms/convert/state\" ] publishers: [ \"/measurement/position\" ] t_sync: 2 fix_type: false meas_noise: 0.001 node_frequency : node output frequency topics/subscribers: parameter of type string[2] defines the input topics - usblfix topic to receive USBL position fixes in medusa_msgs::mUSBLFix state topic to receive the state of the vehicle or anchor state in auv_msgs::NavigationStatus t_sync: parameter of type double time (secs) after which \"Range Only\" and \"Bearing/Elevation\" medusa_msgs::mUSBLFix fixes go out of sync fix_type: parameter of type bool if set false, vehicle acts as an achor, estimates other vehicles position i.e. scenario 1 if set true, vehicle estimates its position with respect to an anchor i.e. scenario 2 Launching the Nodes An example launch file is provided below where nav_tools/usblfix2pos node is being launched. <?xml version=\"1.0\"?> <launch> <node pkg=\"nav_tools\" type=\"usblfix_to_pos\" name=\"usblfix2pos\" respawn=\"true\" output=\"screen\"> <rosparam command=\"load\" file=\"$(find nav_tools)/config/usblfix2pos.yaml\"/> </node> </launch> Range2Pos This node converts ranges from a single beacon to a position measurement using an Extended Kalman Filter. Configuration This section explains how to write the node configuration file. A sample is given below node_frequency: 10 t_sync: 2 topics: subscribers: [ \"/sensors/usbl\", \"/nav/filter/state\" ] publishers: [ \"/measurement/position\" ] beacon: position: [4290771, 491886] node_frequency : node output frequency topics/subscribers: parameter of type string[3] Defines the input topics - range topic to receive range only USBL fixes in medusa_msgs::mUSBLFix state topic to receive state from navigation system in auv_msgs::NavigationStatus beacon topic to receive beacon state topics/publishers: parameter of type string[1] publishes position update of type medusa_msgs::Measurement beacon/position : State of stationary beacon position in UTM NED Launching the Nodes An example launch file is provided below where nav_tools/auvstate2mstate node is being launched. <?xml version=\"1.0\"?> <launch> <node pkg=\"nav_tools\" type=\"usblfix_to_pos\" name=\"range2pos\" respawn=\"true\" output=\"screen\"> <rosparam command=\"load\" file=\"$(find nav_tools)/config/range2pos.yaml\"/> </node> </launch>","title":"Overview"},{"location":"nav-tools/nav_tools/#nav-tools","text":"","title":"Nav tools"},{"location":"nav-tools/nav_tools/#project-description","text":"This package contains tools to convert msgs between data types. Currently, it also houses range-based positioning tools. This package has the following highlights Convert data in WGS84 from sensor_msgs::NavSatFix to data in UTM NED & medusa_msgs::Measurement Convert state from auv_msgs::NavigationStatus to medusa_msgs::mState Convert state from auv_msgs::NavigationStatus to nav_msgs::Odometry Convert Ranges from single-beacon to position update using EKF Convert Georeferenced USBL position fix to position update","title":"Project Description"},{"location":"nav-tools/nav_tools/#getting-started","text":"","title":"Getting Started"},{"location":"nav-tools/nav_tools/#installation","text":"Pkg nav_tools comes as part of the medusa_vx stack.","title":"Installation"},{"location":"nav-tools/nav_tools/#gnss2utm","text":"This node converts data in WGS84 from sensor_msgs::NavSatFix to UTM NED medusa_msgs::Measurement format","title":"Gnss2Utm"},{"location":"nav-tools/nav_tools/#configuration","text":"This section explains how to write the node configuration file. A sample is given below node_frequency: 10 topics: subscribers: [ \"/measurement/gnss\" ] publishers: [ \"/measurement/position\" ] ROS Node Parameters node_frequency : parameter of type double Define the node output frequency topics/subscribers : parameter of type string[1] Defines the input topic to receive position in Lat/Lon, WGS84 format. topics/publishers : parameters of type string[1] Defines topic to output position in UTM NED","title":"Configuration"},{"location":"nav-tools/nav_tools/#launching-the-nodes","text":"An example launch file is provided below where nav_tools/gnss2utm node is being launched. <?xml version=\"1.0\"?> <launch> <node pkg=\"nav_tools\" type=\"gnss_to_utm\" name=\"gnss2utm\" respawn=\"true\" output=\"screen\"> <rosparam command=\"load\" file=\"$(find nav_tools)/config/gnss2utm.yaml\"/> </node> </launch>","title":"Launching the Nodes"},{"location":"nav-tools/nav_tools/#auvstate2mstate","text":"This node converts state in auv_msgs::NavigationStatus to state in medusa_msgs::mState . Also need inside_pressure data for mState.","title":"AuvState2mState"},{"location":"nav-tools/nav_tools/#configuration_1","text":"This section explains how to write the node configuration file. A sample is given below node_frequency: 10 topics: subscribers: [ \"/nav/filter/state\", \"/drivers/inside_pressure/data\" ] publishers: [ \"/State\" ] node_frequency : node output frequency topics/subscribers: parameter of type string[2] topic[1] - state: receives state of type auv_msgs::NavigationStatu topic[2] - inside_pressure: receives inside_pressure data topics/publishers: parameter of type string[1] topic[1] - state: publishes state of type medusa_msgs::mState","title":"Configuration"},{"location":"nav-tools/nav_tools/#launching-the-nodes_1","text":"An example launch file is provided below where nav_tools/auvstate2mstate node is being launched. <?xml version=\"1.0\"?> <launch> <node pkg=\"nav_tools\" type=\"auvstate_to_mstate\" name=\"auvstate2mstate\" respawn=\"true\" output=\"screen\"> <rosparam command=\"load\" file=\"$(find nav_tools)/config/auvstate2mstate.yaml\"/> </node> </launch>","title":"Launching the Nodes"},{"location":"nav-tools/nav_tools/#auvstate2odom","text":"This node converts state in auv_msgs::NavigationStatus to nav_msgs::Odometry .","title":"AuvState2Odom"},{"location":"nav-tools/nav_tools/#configuration_2","text":"This section explains how to write the node configuration file. A sample is given below node_frequency: 10 topics: subscribers: [ \"/nav_filter/state\" ] publishers: [ \"/nav_filter/state_odom\" ] node_frequency : node output frequency topics/subscribers: parameter of type string[1] receives state of type auv_msgs::NavigationStatus topics/publishers: parameter of type string[1] publishes state of type nav_msgs::Odometry","title":"Configuration"},{"location":"nav-tools/nav_tools/#launching-the-nodes_2","text":"An example launch file is provided below where nav_tools/auvstate2odom node is being launched. <?xml version=\"1.0\"?> <launch> <node pkg=\"nav_tools\" type=\"auvstate_to_odom\" name=\"auvstate2odom\" respawn=\"true\" output=\"screen\"> <rosparam command=\"load\" file=\"$(find nav_tools)/config/auvstate2odom.yaml\"/> </node> </launch>","title":"Launching the Nodes"},{"location":"nav-tools/nav_tools/#usbl2pos","text":"This node takes in georeferences usbl position fix and converts it to position updates of the filter. It can be deployed in two ways Scenario 1: Inverted-USBL In this scenario, the underwater vehicle localizes itself with respect to an anchor, whose precise global position is known. The usbl onboard the vehicle receives the georeferenced position of the anchor and the usbl-fix. The vehicle uses these two information to estimate its position using simple geometry. Scenario 2: Tracking with USBL In this scenario, the anchor, whose precise global position is known, tracks underwater vehicles using USBL fixes. The anchor receives the usbl-fix of the underwater vehicle and uses its own position to estimate the position of the underwater vehicle.","title":"Usbl2Pos"},{"location":"nav-tools/nav_tools/#configuration_3","text":"node_frequency: 10 topics: subscribers: [ \"/acomms/measurement/usbl_fix\", \"/acomms/convert/state\" ] publishers: [ \"/measurement/position\" ] t_sync: 2 fix_type: false meas_noise: 0.001 node_frequency : node output frequency topics/subscribers: parameter of type string[2] defines the input topics - usblfix topic to receive USBL position fixes in medusa_msgs::mUSBLFix state topic to receive the state of the vehicle or anchor state in auv_msgs::NavigationStatus t_sync: parameter of type double time (secs) after which \"Range Only\" and \"Bearing/Elevation\" medusa_msgs::mUSBLFix fixes go out of sync fix_type: parameter of type bool if set false, vehicle acts as an achor, estimates other vehicles position i.e. scenario 1 if set true, vehicle estimates its position with respect to an anchor i.e. scenario 2","title":"Configuration"},{"location":"nav-tools/nav_tools/#launching-the-nodes_3","text":"An example launch file is provided below where nav_tools/usblfix2pos node is being launched. <?xml version=\"1.0\"?> <launch> <node pkg=\"nav_tools\" type=\"usblfix_to_pos\" name=\"usblfix2pos\" respawn=\"true\" output=\"screen\"> <rosparam command=\"load\" file=\"$(find nav_tools)/config/usblfix2pos.yaml\"/> </node> </launch>","title":"Launching the Nodes"},{"location":"nav-tools/nav_tools/#range2pos","text":"This node converts ranges from a single beacon to a position measurement using an Extended Kalman Filter.","title":"Range2Pos"},{"location":"nav-tools/nav_tools/#configuration_4","text":"This section explains how to write the node configuration file. A sample is given below node_frequency: 10 t_sync: 2 topics: subscribers: [ \"/sensors/usbl\", \"/nav/filter/state\" ] publishers: [ \"/measurement/position\" ] beacon: position: [4290771, 491886] node_frequency : node output frequency topics/subscribers: parameter of type string[3] Defines the input topics - range topic to receive range only USBL fixes in medusa_msgs::mUSBLFix state topic to receive state from navigation system in auv_msgs::NavigationStatus beacon topic to receive beacon state topics/publishers: parameter of type string[1] publishes position update of type medusa_msgs::Measurement beacon/position : State of stationary beacon position in UTM NED","title":"Configuration"},{"location":"nav-tools/nav_tools/#launching-the-nodes_4","text":"An example launch file is provided below where nav_tools/auvstate2mstate node is being launched. <?xml version=\"1.0\"?> <launch> <node pkg=\"nav_tools\" type=\"usblfix_to_pos\" name=\"range2pos\" respawn=\"true\" output=\"screen\"> <rosparam command=\"load\" file=\"$(find nav_tools)/config/range2pos.yaml\"/> </node> </launch>","title":"Launching the Nodes"},{"location":"open-loop-control/","text":"","title":"Reference"},{"location":"pages/Acknowledgments/","text":"The Medusa project results from the work and dedication of many. Share the love \u2764\ufe0f with the following members that came before you did! Active Developers Jo\u00e3o Quintas jquintas@gmail.com Marcelo Jacinto marcelo.jacinto@tecnico.ulisboa.pt David Souto david.souto@tecnico.ulisboa.pt Andr\u00e9 Potes andre.potes@tecnico.ulisboa.pt Francisco Rego ffcrego@gmail.com David Cabecinhas dcabecinhas@isr.tecnico.ulisboa.pt We also welcome the new members to the DSOR team Eduardo Cunha Daniel Rosa Previous contributors which left us with some precious legacy Jo\u00e3o Cruz Hung Tuan Shubham Garg Jorge Ribeiro Miguel Ribeiro Henrique Silva Jo\u00e3o Botelho Filipa Almeida Omnipresent members Prof. Ant\u00f3nio Pascoal Prof. Carlos Silvestre Prof. Rita Cunha Prof. Bruno Guerreiro Prof. Pedro Batista Lu\u00eds Sebasti\u00e3o Manuel Rufino Pedro Gois Helena Santana And never forget, we stand on the shoulders of giants!","title":"Acknowledgments"},{"location":"pages/Acknowledgments/#active-developers","text":"Jo\u00e3o Quintas jquintas@gmail.com Marcelo Jacinto marcelo.jacinto@tecnico.ulisboa.pt David Souto david.souto@tecnico.ulisboa.pt Andr\u00e9 Potes andre.potes@tecnico.ulisboa.pt Francisco Rego ffcrego@gmail.com David Cabecinhas dcabecinhas@isr.tecnico.ulisboa.pt","title":"Active Developers"},{"location":"pages/Acknowledgments/#we-also-welcome-the-new-members-to-the-dsor-team","text":"Eduardo Cunha Daniel Rosa","title":"We also welcome the new members to the DSOR team"},{"location":"pages/Acknowledgments/#previous-contributors-which-left-us-with-some-precious-legacy","text":"Jo\u00e3o Cruz Hung Tuan Shubham Garg Jorge Ribeiro Miguel Ribeiro Henrique Silva Jo\u00e3o Botelho Filipa Almeida","title":"Previous contributors which left us with some precious legacy"},{"location":"pages/Acknowledgments/#omnipresent-members","text":"Prof. Ant\u00f3nio Pascoal Prof. Carlos Silvestre Prof. Rita Cunha Prof. Bruno Guerreiro Prof. Pedro Batista Lu\u00eds Sebasti\u00e3o Manuel Rufino Pedro Gois Helena Santana And never forget, we stand on the shoulders of giants!","title":"Omnipresent members"},{"location":"pages/CHANGELOG/","text":"Changelog v1.1 First version of medusa_base repository with automatic documentation generation","title":"Changelog"},{"location":"pages/CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"pages/CHANGELOG/#v11","text":"First version of medusa_base repository with automatic documentation generation","title":"v1.1"},{"location":"pages/CODE_OF_CONDUCT/","text":"Contributor Covenant Code of Conduct Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at jquintas@gmail.com. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Code of Conduct"},{"location":"pages/CODE_OF_CONDUCT/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"pages/CODE_OF_CONDUCT/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"pages/CODE_OF_CONDUCT/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"pages/CODE_OF_CONDUCT/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"pages/CODE_OF_CONDUCT/#scope","text":"This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"pages/CODE_OF_CONDUCT/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at jquintas@gmail.com. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"pages/CODE_OF_CONDUCT/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Attribution"},{"location":"pages/CONTRIBUTING/","text":"TODO","title":"Contributing"},{"location":"pages/CONTRIBUTING/#todo","text":"","title":"TODO"},{"location":"pages/LICENSE/","text":"MIT License Copyright (c) 2022 dsor-isr Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"pages/get_started/Build-the-Code/","text":"","title":"Build the Code"},{"location":"pages/get_started/Install-Guide/","text":"1. Ubuntu and ROS installation: 1. Install Ubuntu 20.04LTS (https://releases.ubuntu.com/20.04) 2. Install ROS 1 Noetic (http://wiki.ros.org/noetic/Installation/Ubuntu) 3. Add the following Functions and Alias to your .bashrc file, to make development easier \ud83e\udd13 1. Create a file to store the latest catkin workspace (if it does not exist) and put in the first line the default name, i.e. catkin_ws ``` if [ ! -f ~/.catkin_ws_config ]; then touch ~/.catkin_ws_config && echo catkin_ws > ~/.catkin_ws_config ;fi ``` 2. Set the variable CATKIN_PACKAGE with the workspace in the catkin_ws_config file ``` export CATKIN_PACKAGE=$(head -n 1 ~/.catkin_ws_config) ``` 3. Function to update the default catkin workspace variable and store the last setting in the file ``` set_catkin_ws_function() { #set CATKIN_PACKAGE according the an input parameter export CATKIN_PACKAGE=catkin_ws_$1 echo CATKIN_PACKAGE = ${CATKIN_PACKAGE} # save into a hidden file the catkin workspace setting echo $CATKIN_PACKAGE > ~/.catkin_ws_config source ~/.bashrc } ``` 4. This is required (to source the ROS and medusa files) ``` source /opt/ros/noetic/setup.bash export CATKIN_ROOT=${HOME}/<path_to_workspace> export ROS_WORKSPACE=${CATKIN_ROOT}/${CATKIN_PACKAGE} export MEDUSA_SCRIPTS=$(find ${ROS_WORKSPACE}/src/ -type d -iname medusa_scripts | head -n 1) source ${MEDUSA_SCRIPTS}/medusa_easy_alias/medusa_permanent_alias/alias.sh ``` NOTE: replace /<path_to_workspace> with the folder where you put you catkin_ws inside (for example /dsor ). If you put in your home folder, then this variable should be left empty! Create a catkin_ws directory 2. Downloading the repository: Start by cloning the repository with git clone --recursive https://github.com/dsor-isr/medusa_base . If the repository was cloned non-recursively previously, use git submodule update --init to clone the necessary submodules. 3. Configuring the dependencies: Run the installation bash script using ./","title":"Install Guide"},{"location":"pages/get_started/Repository-Structure/","text":"","title":"Repository Structure"},{"location":"path-following/","text":"Path Following Documentation A package that implements the differente path following algorithm described in the literature. By default we provide several algorithms, from Line of Sight (LOS-Fossen) to more sophisticated ones such as Lapierre. Authors: - Marcelo Jacinto - Jo\u00e3o Quintas - Jo\u00e3o Cruz - Hung Tuan Maintainer: Marcelo Jacinto Email: marcelo.jacinto@tecnico.ulisboa.pt Creation Date: April/2021 Version: 1.0.0 Last Update: April/2021 Path Following We start by providing a set of path following algorithms. Each algorithm inherits the class PathFollowing . As we see, every algorithm, even though different is implemented in the same structured manner. Some control surge and yaw . Others control yaw rate and other control sway . Some use the closest point to the path in the computations, and some use an adptive virtual target . The number of algorithms implemented is expected to grow with time. To see all the current path following algorithms implemented check the provided classes API. Here is an example of some of them provided (see image bellow). In order to implement a path following algorithm must implement the method callPFController where the actual control law implementation is done. The publish method serves the purpose of publishing the relevant control signals to the relevant topics (received in the constructor of the concrete path following we are implementing - more on that later). The start , stop and reset methods are auxiliar and their names I believe are self explanatory. The setPFgains is used to receive a vector of gains and map to controller gains (which might be different for each controller). Bellow we show a particular example applied to the Aguiar controller. The constructor of this clas receives the controller gains and the 3 publishers: - A surge publisher - A yaw rate publisher - A rabbit publisher (virtual target) The reason we pass ROS publishers or services as arguments (and we are not able to provide the same level of abstraction as in paths) is that every controller migh publish different kinds of references signals. On the paths class the published data is all the same. In Aguiar's case, since the mode of operation required for the path is the default (given a gamma, publish path data), we only need to publish at start (in start method) the initial gamma (in order to initiate the loop in which the path sends us data back). For example, in Fossen's case, since the mode of operation is closest point, we need to receive in the constructor the service used to change the mode of operatin of the path (and call it in the start method). I invite you to checkout the start method in these 2 implementations to understand the conceptual differences. How to interface with ROS We have already got a glimpse on how to interface with ROS. We pass as arguments to the constructor of the class the publishers that we need. Similar to the paths class, we also have services to change between controllers. One service for each controller. Furthermore we also develop one callback for each service (see image bellow). In order to implement a service we can use the picture bellow as a blueprint. It is almost always the same. We only need to: clear the previous control define a set of publishers save the publisher into the publisher vector (this step is import as this vector is cleared every time we change between controllers). The old publishers are de-registered we read the controller gains from the parameter server instantiate the controller node we desired return success! Bellow we provide a sample implementation applied to the case of Brevik algorithm.","title":"Reference"},{"location":"path-following/#path-following-documentation","text":"A package that implements the differente path following algorithm described in the literature. By default we provide several algorithms, from Line of Sight (LOS-Fossen) to more sophisticated ones such as Lapierre. Authors: - Marcelo Jacinto - Jo\u00e3o Quintas - Jo\u00e3o Cruz - Hung Tuan Maintainer: Marcelo Jacinto Email: marcelo.jacinto@tecnico.ulisboa.pt Creation Date: April/2021 Version: 1.0.0 Last Update: April/2021","title":"Path Following Documentation"},{"location":"path-following/#path-following","text":"We start by providing a set of path following algorithms. Each algorithm inherits the class PathFollowing . As we see, every algorithm, even though different is implemented in the same structured manner. Some control surge and yaw . Others control yaw rate and other control sway . Some use the closest point to the path in the computations, and some use an adptive virtual target . The number of algorithms implemented is expected to grow with time. To see all the current path following algorithms implemented check the provided classes API. Here is an example of some of them provided (see image bellow). In order to implement a path following algorithm must implement the method callPFController where the actual control law implementation is done. The publish method serves the purpose of publishing the relevant control signals to the relevant topics (received in the constructor of the concrete path following we are implementing - more on that later). The start , stop and reset methods are auxiliar and their names I believe are self explanatory. The setPFgains is used to receive a vector of gains and map to controller gains (which might be different for each controller). Bellow we show a particular example applied to the Aguiar controller. The constructor of this clas receives the controller gains and the 3 publishers: - A surge publisher - A yaw rate publisher - A rabbit publisher (virtual target) The reason we pass ROS publishers or services as arguments (and we are not able to provide the same level of abstraction as in paths) is that every controller migh publish different kinds of references signals. On the paths class the published data is all the same. In Aguiar's case, since the mode of operation required for the path is the default (given a gamma, publish path data), we only need to publish at start (in start method) the initial gamma (in order to initiate the loop in which the path sends us data back). For example, in Fossen's case, since the mode of operation is closest point, we need to receive in the constructor the service used to change the mode of operatin of the path (and call it in the start method). I invite you to checkout the start method in these 2 implementations to understand the conceptual differences.","title":"Path Following"},{"location":"path-following/#how-to-interface-with-ros","text":"We have already got a glimpse on how to interface with ROS. We pass as arguments to the constructor of the class the publishers that we need. Similar to the paths class, we also have services to change between controllers. One service for each controller. Furthermore we also develop one callback for each service (see image bellow). In order to implement a service we can use the picture bellow as a blueprint. It is almost always the same. We only need to: clear the previous control define a set of publishers save the publisher into the publisher vector (this step is import as this vector is cleared every time we change between controllers). The old publishers are de-registered we read the controller gains from the parameter server instantiate the controller node we desired return success! Bellow we provide a sample implementation applied to the case of Brevik algorithm.","title":"How to interface with ROS"},{"location":"pid-inner-loops/innerloops/","text":"Inner Loops Sources From\\ dos Santos Ribeiro, Jorge Miguel. \"Motion control of single and multiple autonomous marine vehicles.\" PhD diss., MS thesis, Dept. Elect. Comput. Eng., Inst. Superior T\u00e9cnico, Lisbon, Portugal, 2011. Resendes Maia, Ana Cristina. \"Sensor-Based Formation Control of Autonomous Robotic Vehicles.\" PhD diss., MS thesis, Dept. Elect. Comput. Eng., Inst. Superior T\u00e9cnico, Lisbon, Portugal, 2013. P. C. Abreu et al., \"The MEDUSA class of autonomous marine vehicles and their role in EU projects,\" OCEANS 2016 - Shanghai, Shanghai, 2016, pp. 1-10. Description Speed Controller Theory The speed controller is a PI controller responsible to compute a common mode command for the two longitudinal thrusters as $$ CM = -k_p \\tilde{u} - k_i \\int_0^t \\tilde{u} (\\tau) d\\tau, $$ $$ \\tilde{u} = \\hat{u}-u_d $$ where $\\hat{u}$ is the estimate and $u_d$ is the reference to be tracked. In code * Reference $u_d$ is limited between [-0.5; 1.2] (m/s) * Aceleration of the reference is limited to 0.04 (m/s^2). * Common Mode is saturated between [-40; 60]. Heading Controller Theory The Heading controller is a PID responsible to compute a differential mode for the two longitudinal thrusters. $$ DM = k_p\\tilde{\\psi} - k_d\\dot{\\tilde{\\psi}} +k_i\\int_0^t\\tilde{\\psi}(\\tau)d\\tau, $$ $$ \\tilde{\\psi} = \\hat{\\psi}-\\psi_d $$ where $\\hat{\\psi}$ is the estimate and $\\psi_d$ is the reference to be tracked. In code * Saturating the Reference Derivative: Since the vehicle can not do more that 25 degrees per sec, the yaw rate given by the previous reference and the new reference is limited by 5 (ts=0.2). In mathematical terms, $$ \\dot{\\tilde{\\psi}} = \\dot{\\hat{\\psi}} - \\dot{\\psi}_d $$ $$ \\dot{\\psi} d = (\\psi {d|k}-\\psi_{d|k-1})/t_s,\\quad \\dot{\\psi} \\in [-5;5] $$ Not integrating if the error is too big: If $|\\tilde{\\psi}|$ > 20 then there is no integration. Reducing the surge speed if the yaw err is big: If $|\\tilde{\\psi}| \\in [20;90]$, u_ref_gain is given by: $$ u_ref_gain = (\\sin(-|\\frac{\\tilde{\\psi}}{90-20}| + \\frac{90}{90-20} - 90) + 1) *0.5/2.0 + 0.5 $$ This component will be multiplied by the reference going into the speed controller. Note: If $\\tilde{\\psi}$ is below 20 the gain is 1 and if it is above 90 the gain is 0.5. The diffential mode is saturated between [-(80*80);(80*80)], and in case a saturation occurs the integration component is reverted to the old value (it is not updated). Heading Rate Controller Theory The heading rate controller is a PI with feedforward responsible to compute a differential mode for the longitudinal thrusters. $$ DM = k_{f}\\dot{\\psi_d} + k_p\\dot{\\tilde{\\psi}}-k_i\\int_0^t\\dot{\\tilde{\\psi}}(\\tau)d\\tau, $$ In code * The error $\\tilde{\\psi}$ is saturated between [-20;20]. * The diffential mode is saturated between [-(80*80);(80*80)], and in case a saturation occurs the integration is is reverted to the old value (it is not updated). Z Controller Theory The Z controller is a PID with feedforward acceleration controller responsible to compute a common mode for the vertical thrusters. $$ CM_{vertical} = k_p\\tilde{z} + k_d\\dot{\\tilde{z}} +k_i\\int_0^t\\tilde{z}(\\tau)d\\tau + \\frac{\\ddot{\\tilde{z}}_d - \\alpha\\dot{z} - \\beta\\dot{z}|\\dot{z}|}{\\gamma}, $$ In code * If depth references exist then it will work as a depth controller, otherwise if altitude references exist it will work as a altitude controller. * Safety features: Depth If the water column minus the depth reference is smaller than our minimum altitude reference then it automatically goes to altitude control with a reference of our minimum altitude. It goes back to depth control when the water column minus the reference is bigger than 2m. * Safety features: Altitude Limitates to our minimum altitude reference If the water column minus the altitude reference is bigger than our maximum depth then it is limited by that value. * Pre filter: Reference Rate saturation: the reference is saturated taking into account the maximum reference rate (0.2*Ts). Calculation of: $$ \\ddot{\\tilde{z}} d = \\omega _n^2 (\\tilde{z} d - \\tilde{z} {d|k-1}) - 2\\xi\\omega_n \\ddot{\\tilde{z}} {d|k-1} $$ $$ \\dot{\\tilde{z}}_d = \\ddot{\\tilde{z}}_d + \\ddot{\\tilde{z}}_d t_s $$ $$ \\tilde{z} {d} = \\tilde{z} {d|k-1} + \\dot{\\tilde{z}}_d t_s $$ CM is saturated between [-60,60]. Roll Controller - NOT BEING USED The roll controller is a PD responsible to return a differential mode for the vertical thrusters. If roll is bigger than 60 degrees then the controller will stop. Note: The CM and DM are defined as a percentage of the maximum RPM: $$ CM = \\frac{Left\\ RPM (\\%) + right\\ RPM (\\%)}{2} $$ $$ DM = \\frac{Left\\ RPM (\\%) - right\\ RPM (\\%)}{2} $$ Code description Controller_interface Every controller inherits a ControllerInterface Class (controller_interface.c/h) composed by the following atributes: kp_ - proporcional gain ki_ - integral gain kd_ - integral gain ref_old_ - old reference qsi_old_ - saves the integration value and the following methods: int execute([arguments]); - executes the pid controll void reset(); - resets the filter In this interface, a Saturation struct was created to ease the operation of saturation. Basically, it is only necessary to create a Saturation object in the controller constructor defining the minimum and maximum value. To saturate a value we just need to call the function {clip} from the Saturation object. Innerloops main loop In the innerloops::timerCallback we find the logic to apply these controllers; 1 - If a yaw reference exists, the heading controller will compute a DM for the horizontal thrusters. otherwise if a yaw rate ref exists the heading controller will be reset and the yaw rate controller will compute the DM. If none of the above cases happen it will check if we have an open loop value for DM otherwise it will reset the heading controller and the heading rate controller. 2 - If a speed reference exists, the speed controller will multiply it by the u_ref_gain (see heading controller) to compute a Common Mode for the longitudinal thrusters. Otherwise it will check if we have an open loop value for CM. If none of the above occur, the speed controller is reset. 3 - If in full power up, the vertical Common Mode will be equal to -60. Else it will check if we have a depth reference to compute de CM. After that it will check if we have a open loop CM and only then will it check if we have a altitude reference. If none of the above occur, the filter is reset. 4 - Roll is actuated in open loop. 5 - Saturating common mode: the horizontal common mode is saturated between [-(60*60);(60*60)].","title":"Overview"},{"location":"pid-inner-loops/innerloops/#inner-loops","text":"","title":"Inner Loops"},{"location":"pid-inner-loops/innerloops/#sources","text":"From\\ dos Santos Ribeiro, Jorge Miguel. \"Motion control of single and multiple autonomous marine vehicles.\" PhD diss., MS thesis, Dept. Elect. Comput. Eng., Inst. Superior T\u00e9cnico, Lisbon, Portugal, 2011. Resendes Maia, Ana Cristina. \"Sensor-Based Formation Control of Autonomous Robotic Vehicles.\" PhD diss., MS thesis, Dept. Elect. Comput. Eng., Inst. Superior T\u00e9cnico, Lisbon, Portugal, 2013. P. C. Abreu et al., \"The MEDUSA class of autonomous marine vehicles and their role in EU projects,\" OCEANS 2016 - Shanghai, Shanghai, 2016, pp. 1-10.","title":"Sources"},{"location":"pid-inner-loops/innerloops/#description","text":"","title":"Description"},{"location":"pid-inner-loops/innerloops/#speed-controller","text":"Theory The speed controller is a PI controller responsible to compute a common mode command for the two longitudinal thrusters as $$ CM = -k_p \\tilde{u} - k_i \\int_0^t \\tilde{u} (\\tau) d\\tau, $$ $$ \\tilde{u} = \\hat{u}-u_d $$ where $\\hat{u}$ is the estimate and $u_d$ is the reference to be tracked. In code * Reference $u_d$ is limited between [-0.5; 1.2] (m/s) * Aceleration of the reference is limited to 0.04 (m/s^2). * Common Mode is saturated between [-40; 60].","title":"Speed Controller"},{"location":"pid-inner-loops/innerloops/#heading-controller","text":"Theory The Heading controller is a PID responsible to compute a differential mode for the two longitudinal thrusters. $$ DM = k_p\\tilde{\\psi} - k_d\\dot{\\tilde{\\psi}} +k_i\\int_0^t\\tilde{\\psi}(\\tau)d\\tau, $$ $$ \\tilde{\\psi} = \\hat{\\psi}-\\psi_d $$ where $\\hat{\\psi}$ is the estimate and $\\psi_d$ is the reference to be tracked. In code * Saturating the Reference Derivative: Since the vehicle can not do more that 25 degrees per sec, the yaw rate given by the previous reference and the new reference is limited by 5 (ts=0.2). In mathematical terms, $$ \\dot{\\tilde{\\psi}} = \\dot{\\hat{\\psi}} - \\dot{\\psi}_d $$ $$ \\dot{\\psi} d = (\\psi {d|k}-\\psi_{d|k-1})/t_s,\\quad \\dot{\\psi} \\in [-5;5] $$ Not integrating if the error is too big: If $|\\tilde{\\psi}|$ > 20 then there is no integration. Reducing the surge speed if the yaw err is big: If $|\\tilde{\\psi}| \\in [20;90]$, u_ref_gain is given by: $$ u_ref_gain = (\\sin(-|\\frac{\\tilde{\\psi}}{90-20}| + \\frac{90}{90-20} - 90) + 1) *0.5/2.0 + 0.5 $$ This component will be multiplied by the reference going into the speed controller. Note: If $\\tilde{\\psi}$ is below 20 the gain is 1 and if it is above 90 the gain is 0.5. The diffential mode is saturated between [-(80*80);(80*80)], and in case a saturation occurs the integration component is reverted to the old value (it is not updated).","title":"Heading Controller"},{"location":"pid-inner-loops/innerloops/#heading-rate-controller","text":"Theory The heading rate controller is a PI with feedforward responsible to compute a differential mode for the longitudinal thrusters. $$ DM = k_{f}\\dot{\\psi_d} + k_p\\dot{\\tilde{\\psi}}-k_i\\int_0^t\\dot{\\tilde{\\psi}}(\\tau)d\\tau, $$ In code * The error $\\tilde{\\psi}$ is saturated between [-20;20]. * The diffential mode is saturated between [-(80*80);(80*80)], and in case a saturation occurs the integration is is reverted to the old value (it is not updated).","title":"Heading Rate Controller"},{"location":"pid-inner-loops/innerloops/#z-controller","text":"Theory The Z controller is a PID with feedforward acceleration controller responsible to compute a common mode for the vertical thrusters. $$ CM_{vertical} = k_p\\tilde{z} + k_d\\dot{\\tilde{z}} +k_i\\int_0^t\\tilde{z}(\\tau)d\\tau + \\frac{\\ddot{\\tilde{z}}_d - \\alpha\\dot{z} - \\beta\\dot{z}|\\dot{z}|}{\\gamma}, $$ In code * If depth references exist then it will work as a depth controller, otherwise if altitude references exist it will work as a altitude controller. * Safety features: Depth If the water column minus the depth reference is smaller than our minimum altitude reference then it automatically goes to altitude control with a reference of our minimum altitude. It goes back to depth control when the water column minus the reference is bigger than 2m. * Safety features: Altitude Limitates to our minimum altitude reference If the water column minus the altitude reference is bigger than our maximum depth then it is limited by that value. * Pre filter: Reference Rate saturation: the reference is saturated taking into account the maximum reference rate (0.2*Ts). Calculation of: $$ \\ddot{\\tilde{z}} d = \\omega _n^2 (\\tilde{z} d - \\tilde{z} {d|k-1}) - 2\\xi\\omega_n \\ddot{\\tilde{z}} {d|k-1} $$ $$ \\dot{\\tilde{z}}_d = \\ddot{\\tilde{z}}_d + \\ddot{\\tilde{z}}_d t_s $$ $$ \\tilde{z} {d} = \\tilde{z} {d|k-1} + \\dot{\\tilde{z}}_d t_s $$ CM is saturated between [-60,60].","title":"Z Controller"},{"location":"pid-inner-loops/innerloops/#roll-controller-not-being-used","text":"The roll controller is a PD responsible to return a differential mode for the vertical thrusters. If roll is bigger than 60 degrees then the controller will stop.","title":"Roll Controller - NOT BEING USED"},{"location":"pid-inner-loops/innerloops/#note","text":"The CM and DM are defined as a percentage of the maximum RPM: $$ CM = \\frac{Left\\ RPM (\\%) + right\\ RPM (\\%)}{2} $$ $$ DM = \\frac{Left\\ RPM (\\%) - right\\ RPM (\\%)}{2} $$","title":"Note:"},{"location":"pid-inner-loops/innerloops/#code-description","text":"","title":"Code description"},{"location":"pid-inner-loops/innerloops/#controller_interface","text":"Every controller inherits a ControllerInterface Class (controller_interface.c/h) composed by the following atributes: kp_ - proporcional gain ki_ - integral gain kd_ - integral gain ref_old_ - old reference qsi_old_ - saves the integration value and the following methods: int execute([arguments]); - executes the pid controll void reset(); - resets the filter In this interface, a Saturation struct was created to ease the operation of saturation. Basically, it is only necessary to create a Saturation object in the controller constructor defining the minimum and maximum value. To saturate a value we just need to call the function {clip} from the Saturation object.","title":"Controller_interface"},{"location":"pid-inner-loops/innerloops/#innerloops-main-loop","text":"In the innerloops::timerCallback we find the logic to apply these controllers; 1 - If a yaw reference exists, the heading controller will compute a DM for the horizontal thrusters. otherwise if a yaw rate ref exists the heading controller will be reset and the yaw rate controller will compute the DM. If none of the above cases happen it will check if we have an open loop value for DM otherwise it will reset the heading controller and the heading rate controller. 2 - If a speed reference exists, the speed controller will multiply it by the u_ref_gain (see heading controller) to compute a Common Mode for the longitudinal thrusters. Otherwise it will check if we have an open loop value for CM. If none of the above occur, the speed controller is reset. 3 - If in full power up, the vertical Common Mode will be equal to -60. Else it will check if we have a depth reference to compute de CM. After that it will check if we have a open loop CM and only then will it check if we have a altitude reference. If none of the above occur, the filter is reset. 4 - Roll is actuated in open loop. 5 - Saturating common mode: the horizontal common mode is saturated between [-(60*60);(60*60)].","title":"Innerloops main loop"},{"location":"remote-controller/","text":"","title":"Reference"},{"location":"safety-feature/","text":"safety_feature package safety_feature is a ROS package written in C++ that works as an communication watchdog. Rationale The package checks if the vehicle has some kind of communication channel, wifi or acoustic. In the absence of any communication link the thrusters are stopped. In more detail, we always check for wifi communication in surface vehicles. In the case of AUV, we need to have at least one surface vehicle that communicates via acoustic with the ones underwater. In the situation we lost wifi connection with the surface, this one is responsible to send an acoustic abort to the the underwater vehicles. NOTE: This package will need a major review later. The amount of if's else's is beyond normal. Package Content Code documentation source Using safety_feature Examples Requirements","title":"Reference"},{"location":"safety-feature/#safety_feature-package","text":"safety_feature is a ROS package written in C++ that works as an communication watchdog.","title":"safety_feature package"},{"location":"safety-feature/#rationale","text":"The package checks if the vehicle has some kind of communication channel, wifi or acoustic. In the absence of any communication link the thrusters are stopped. In more detail, we always check for wifi communication in surface vehicles. In the case of AUV, we need to have at least one surface vehicle that communicates via acoustic with the ones underwater. In the situation we lost wifi connection with the surface, this one is responsible to send an acoustic abort to the the underwater vehicles. NOTE: This package will need a major review later. The amount of if's else's is beyond normal.","title":"Rationale"},{"location":"safety-feature/#package-content","text":"","title":"Package Content"},{"location":"safety-feature/#code-documentation","text":"source","title":"Code documentation"},{"location":"safety-feature/#using-safety_feature","text":"Examples","title":"Using safety_feature"},{"location":"safety-feature/#requirements","text":"","title":"Requirements"},{"location":"safety-feature/configurations/medusaVxConfig/","text":"medusa_vx config - wifi_acoustic_safety Run Vehicle Side This package is launched with medusa stack ex: roslaunch medusa_bringup medusa_bringup.launch name:= mvector docks:=missions Please check if wifi_acoustic_safety is set to true in the vehicle configurations. For this, please check the following block in medusa_bringup/config/docks/mvector/process.yaml file: - name: 'addons' launch_on_startup: true delay_before_start: 0.0 cmd: 'roslaunch medusa_bringup addons.launch' args: - aggregator:= true - console_path_parser:= true - console_server:= true - **wifi_acoustic_safety:= true** - rosbridge_server:= false Launch file You have a main launch ( medusa_bringup.launch ) that calls a node ( medusa_bringup_node ) responsible to manage all the processes in a proecss.yaml file. The node while running is responsible to launch a subset of other launch files located at /medusa_bringup/launch/dev_launch . Among the exisitng ones, here the focus is in the addons.launch where wifi_acoustic_safety is present. Looking in some detail to the file we point out the key points: <arg name=\"name\" /> <arg name=\"mission\" default=\"example\" /> **<arg name=\"wifi_acoustic_safety\" default=\"false\" />** <!-- safety features --> <arg name=\"console_path_parser\" default=\"false\" /> <arg name=\"http_server\" default=\"false\" /> <arg name=\"aggregator\" default=\"false\" /> <arg name=\"rosbridge_server\" default=\"false\" /> <arg name=\"websocket_port\" default=\"9090\" /> <!-- arg to use in http--> By default all the nodes in the medusa_addons package are set to false and won't run if you don't change the corresponding boolean in the process.yaml like in the previous section. <group ns=\"addons\"> Every addon is part of the group addons , which means that almost all topics will be someting like /addons/node/some_topic , here /addons/wifi_acoustic_safety/some_topic . <!-- ############################ --> <!-- Acoustic Safety --> <!-- ############################ --> <group if=\"$(arg wifi_acoustic_safety)\"> <node pkg=\"safety_feature\" type=\"wifi_acoustic_safety\" name=\"wifi_acoustic_safety\" output=\"screen\"> <param name=\"name\" value=\"$(arg name)\" /> <param name=\"surface_vehicle\" value=\"dummy\"/> </node> </group>p As you can see the if guarantees that the node only starts if in the process.yaml , wifi_acoustic_safety is set to true. Configurations Configuration is divided between two files. The first one, medusa_bringup/config/mission/vehicle.yaml .Below, the section of wifi_acoustic_safety , for the docks mission and mvector vehicle: wifi_acoustic_safety: SAFETY_PORT: 10111 RATE: 1.0 The second file, /medusa_bringup/config/mission/vehicle/common.yaml , accommodates the delay times for wifi and acoustic. Below, the important parameter for of wifi_acoustic_safety : *file, ex: /medusa_bringup/config/docks/mvector/common.yaml safety_features: max_depth: 5.0 # [m] min_altitude: 1.0 # [m] min_altitude_ref: 1.5 # [m] **wifi_timeout: 10.0 # [s]** **acoustic_timeout: 15.0 # [s]** Client Side In a console pc please run: rosrun safety_feature SafetyFeatureCLT ip_vehicle or catkin_ws/src/medusa_vx/medusa_addons/safety_feature/src/Client/SafetyFeatureCLT ip_vehicle ex: mvector rosrun safety_feature SafetyFeatureCLT 192.168.1.33 This will guarantee that the safety is disable(0), as soon you losse connection with vehicle it will enable safety(1) and thrusters will stop.","title":"medusa_vx config - wifi_acoustic_safety"},{"location":"safety-feature/configurations/medusaVxConfig/#medusa_vx-config-wifi_acoustic_safety","text":"","title":"medusa_vx config - wifi_acoustic_safety"},{"location":"safety-feature/configurations/medusaVxConfig/#run","text":"","title":"Run"},{"location":"safety-feature/configurations/medusaVxConfig/#vehicle-side","text":"This package is launched with medusa stack ex: roslaunch medusa_bringup medusa_bringup.launch name:= mvector docks:=missions Please check if wifi_acoustic_safety is set to true in the vehicle configurations. For this, please check the following block in medusa_bringup/config/docks/mvector/process.yaml file: - name: 'addons' launch_on_startup: true delay_before_start: 0.0 cmd: 'roslaunch medusa_bringup addons.launch' args: - aggregator:= true - console_path_parser:= true - console_server:= true - **wifi_acoustic_safety:= true** - rosbridge_server:= false","title":"Vehicle Side"},{"location":"safety-feature/configurations/medusaVxConfig/#launch-file","text":"You have a main launch ( medusa_bringup.launch ) that calls a node ( medusa_bringup_node ) responsible to manage all the processes in a proecss.yaml file. The node while running is responsible to launch a subset of other launch files located at /medusa_bringup/launch/dev_launch . Among the exisitng ones, here the focus is in the addons.launch where wifi_acoustic_safety is present. Looking in some detail to the file we point out the key points: <arg name=\"name\" /> <arg name=\"mission\" default=\"example\" /> **<arg name=\"wifi_acoustic_safety\" default=\"false\" />** <!-- safety features --> <arg name=\"console_path_parser\" default=\"false\" /> <arg name=\"http_server\" default=\"false\" /> <arg name=\"aggregator\" default=\"false\" /> <arg name=\"rosbridge_server\" default=\"false\" /> <arg name=\"websocket_port\" default=\"9090\" /> <!-- arg to use in http--> By default all the nodes in the medusa_addons package are set to false and won't run if you don't change the corresponding boolean in the process.yaml like in the previous section. <group ns=\"addons\"> Every addon is part of the group addons , which means that almost all topics will be someting like /addons/node/some_topic , here /addons/wifi_acoustic_safety/some_topic . <!-- ############################ --> <!-- Acoustic Safety --> <!-- ############################ --> <group if=\"$(arg wifi_acoustic_safety)\"> <node pkg=\"safety_feature\" type=\"wifi_acoustic_safety\" name=\"wifi_acoustic_safety\" output=\"screen\"> <param name=\"name\" value=\"$(arg name)\" /> <param name=\"surface_vehicle\" value=\"dummy\"/> </node> </group>p As you can see the if guarantees that the node only starts if in the process.yaml , wifi_acoustic_safety is set to true.","title":"Launch file"},{"location":"safety-feature/configurations/medusaVxConfig/#configurations","text":"Configuration is divided between two files. The first one, medusa_bringup/config/mission/vehicle.yaml .Below, the section of wifi_acoustic_safety , for the docks mission and mvector vehicle: wifi_acoustic_safety: SAFETY_PORT: 10111 RATE: 1.0 The second file, /medusa_bringup/config/mission/vehicle/common.yaml , accommodates the delay times for wifi and acoustic. Below, the important parameter for of wifi_acoustic_safety : *file, ex: /medusa_bringup/config/docks/mvector/common.yaml safety_features: max_depth: 5.0 # [m] min_altitude: 1.0 # [m] min_altitude_ref: 1.5 # [m] **wifi_timeout: 10.0 # [s]** **acoustic_timeout: 15.0 # [s]**","title":"Configurations"},{"location":"safety-feature/configurations/medusaVxConfig/#client-side","text":"In a console pc please run: rosrun safety_feature SafetyFeatureCLT ip_vehicle or catkin_ws/src/medusa_vx/medusa_addons/safety_feature/src/Client/SafetyFeatureCLT ip_vehicle ex: mvector rosrun safety_feature SafetyFeatureCLT 192.168.1.33 This will guarantee that the safety is disable(0), as soon you losse connection with vehicle it will enable safety(1) and thrusters will stop.","title":"Client Side"},{"location":"sensor-fusion-kalman-filter/developer_notes/","text":"Developer Notes Project Directory . \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 config \u2502 \u251c\u2500\u2500 map.yaml \u2502 \u2514\u2500\u2500 odom.yaml \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 figs \u2502 \u251c\u2500\u2500 readme.md \u2502 \u251c\u2500\u2500 theory.md \u2502 \u2514\u2500\u2500 developernotes.md \u251c\u2500\u2500 include \u2502 \u251c\u2500\u2500 algorithms \u2502 \u2502 \u251c\u2500\u2500 HorizontalFilter.h \u2502 \u2502 \u251c\u2500\u2500 RotationalFilter.h \u2502 \u2502 \u2514\u2500\u2500 VerticalFilter.h \u2502 \u2514\u2500\u2500 ros \u2502 \u2514\u2500\u2500 FiltersNode.h \u251c\u2500\u2500 launch \u2502 \u2514\u2500\u2500 sensor_fusion.launch \u251c\u2500\u2500 package.xml \u251c\u2500\u2500 scripts \u2502 \u2514\u2500\u2500 filtersScript \u251c\u2500\u2500 src \u2502 \u251c\u2500\u2500 algorithms \u2502 \u2502 \u251c\u2500\u2500 HorizontalFilter.cpp \u2502 \u2502 \u251c\u2500\u2500 RotationalFilter.cpp \u2502 \u2502 \u2514\u2500\u2500 VerticalFilter.cpp \u2502 \u2514\u2500\u2500 ros \u2502 \u2514\u2500\u2500 FiltersNode.cpp \u2514\u2500\u2500 test \u2514\u2500\u2500 filters_test.cpp Pkg sensor_fusion follows the code methodology adapated for the medusa_vx stack and hence seperates the code into algorithm and node class. The \"algorithm\" section implements the kalman filter based sensor fusion and the \"node\" section implements all things required for integration with ROS. config : contains sample config files for and filters docs : contains documentation for the pkg include : contains header files class and node class launch : contains sample launch files src : contains the main code for algorithm and node class Pkg contains no scripts or tests yet. Algorithm Class This class implements a generic kalman based sensor fusion system which fuses input from an arbitary number of sources to estimate the state of a vehicle. To make things simpler, the kalman filter is divided into three seperate filters which estimate the horizontal, vertical and rotational state respectively. HorizontalFilter.h & HorizontalFilter.cpp Time-delayed Kalman-Filter to estimate position (x, y), velocity (vx, vy), acceleration (ax, ay) and currents (cx, cy) Dynamic model: Constant Acceleration measCallback() : Receives measurements in the horizontal plane addMeasurement() : Adds valid measurements to a measurement list forwardPropagation() : Estimates and updates the state vector from the point of time when the measurement was received. predict() : Predict Stage of the Kalman Filter update() : Update Stage of the Kalman Filter configure() : public method Configure the filter using loaded parameters getEstimate() : public method Returns the latest state estimate VerticalFilter.h & VerticalFilter.cpp Kalman-Filter to estimate position (z), Altitude, velocity (vz) and Bouyancy (B) Dynamic model: ? RotationalFilter.h & RotationalFilter.cpp Kalman-filter to estimate rotation (r, p, h) and rotation rate (vr, vp, vh) Measurements can be treated as inputs which bypasses the whole filter Estimates from individual filters are fused inside the node class to produce the net result. ROS Class This class implements ROS functionalities that are Parameters : Used to configure the three filters Publishers : state_pub : Publishes state estimate Subscribers : measCallback(medusa_msgs::Measurements) : Multiple topics use a single generic callback which processes, transforms and distributes the input to the three algorithm classes. Timers : stateTimerCallback() : Gets the latest state estimate from all three algorithm class listTimerCallback() : Clears the previous measurements from the list in HorizontalFilter","title":"Developer Notes"},{"location":"sensor-fusion-kalman-filter/developer_notes/#developer-notes","text":"","title":"Developer Notes"},{"location":"sensor-fusion-kalman-filter/developer_notes/#project-directory","text":". \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 config \u2502 \u251c\u2500\u2500 map.yaml \u2502 \u2514\u2500\u2500 odom.yaml \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 figs \u2502 \u251c\u2500\u2500 readme.md \u2502 \u251c\u2500\u2500 theory.md \u2502 \u2514\u2500\u2500 developernotes.md \u251c\u2500\u2500 include \u2502 \u251c\u2500\u2500 algorithms \u2502 \u2502 \u251c\u2500\u2500 HorizontalFilter.h \u2502 \u2502 \u251c\u2500\u2500 RotationalFilter.h \u2502 \u2502 \u2514\u2500\u2500 VerticalFilter.h \u2502 \u2514\u2500\u2500 ros \u2502 \u2514\u2500\u2500 FiltersNode.h \u251c\u2500\u2500 launch \u2502 \u2514\u2500\u2500 sensor_fusion.launch \u251c\u2500\u2500 package.xml \u251c\u2500\u2500 scripts \u2502 \u2514\u2500\u2500 filtersScript \u251c\u2500\u2500 src \u2502 \u251c\u2500\u2500 algorithms \u2502 \u2502 \u251c\u2500\u2500 HorizontalFilter.cpp \u2502 \u2502 \u251c\u2500\u2500 RotationalFilter.cpp \u2502 \u2502 \u2514\u2500\u2500 VerticalFilter.cpp \u2502 \u2514\u2500\u2500 ros \u2502 \u2514\u2500\u2500 FiltersNode.cpp \u2514\u2500\u2500 test \u2514\u2500\u2500 filters_test.cpp Pkg sensor_fusion follows the code methodology adapated for the medusa_vx stack and hence seperates the code into algorithm and node class. The \"algorithm\" section implements the kalman filter based sensor fusion and the \"node\" section implements all things required for integration with ROS. config : contains sample config files for and filters docs : contains documentation for the pkg include : contains header files class and node class launch : contains sample launch files src : contains the main code for algorithm and node class Pkg contains no scripts or tests yet.","title":"Project Directory"},{"location":"sensor-fusion-kalman-filter/developer_notes/#algorithm-class","text":"This class implements a generic kalman based sensor fusion system which fuses input from an arbitary number of sources to estimate the state of a vehicle. To make things simpler, the kalman filter is divided into three seperate filters which estimate the horizontal, vertical and rotational state respectively. HorizontalFilter.h & HorizontalFilter.cpp Time-delayed Kalman-Filter to estimate position (x, y), velocity (vx, vy), acceleration (ax, ay) and currents (cx, cy) Dynamic model: Constant Acceleration measCallback() : Receives measurements in the horizontal plane addMeasurement() : Adds valid measurements to a measurement list forwardPropagation() : Estimates and updates the state vector from the point of time when the measurement was received. predict() : Predict Stage of the Kalman Filter update() : Update Stage of the Kalman Filter configure() : public method Configure the filter using loaded parameters getEstimate() : public method Returns the latest state estimate VerticalFilter.h & VerticalFilter.cpp Kalman-Filter to estimate position (z), Altitude, velocity (vz) and Bouyancy (B) Dynamic model: ? RotationalFilter.h & RotationalFilter.cpp Kalman-filter to estimate rotation (r, p, h) and rotation rate (vr, vp, vh) Measurements can be treated as inputs which bypasses the whole filter Estimates from individual filters are fused inside the node class to produce the net result.","title":"Algorithm Class"},{"location":"sensor-fusion-kalman-filter/developer_notes/#ros-class","text":"This class implements ROS functionalities that are Parameters : Used to configure the three filters Publishers : state_pub : Publishes state estimate Subscribers : measCallback(medusa_msgs::Measurements) : Multiple topics use a single generic callback which processes, transforms and distributes the input to the three algorithm classes. Timers : stateTimerCallback() : Gets the latest state estimate from all three algorithm class listTimerCallback() : Clears the previous measurements from the list in HorizontalFilter","title":"ROS Class"},{"location":"sensor-fusion-kalman-filter/theory/","text":"Theory Kalman filter A Kalman filter, also known as Linear Quadratic Estimator (LQE) uses a series of noisy measurements to produce estimates of unknown state variables. A Kalman filter provides an optimum solution to many tracking and data prediction tasks and finds excellent use in control, navigation and guidance. The algorithm works in a two-step process. In the \"predict\" step, the Kalman filter looks one-step forward in time to predict the estimates of the current state vector and state covariance using an inner dynamic model. In the second step, known as \"update\", a \"kalman gain matrix\" is calculated using the state covariances and measurement covariance. This matrix is then used to update the state of the vehicle as shown below. One key advantage of Kalman filter is that it can run efficiently in real-time. For a more comprehensive literature on the subject, the reader is recommended to consult [1]. Consult [2] for an excellent introductory article on KFs. Predict Let xkxk be the state vector and PkPk be the state covariance. The state equation is written as $$ \\hat{x} {k|k-1} = A_k \\hat{x} {k-1|k-1} + B_k u_k + w_k \\ \\ P_{k|k-1} = A_k P_{k-1|k-1} A_k^T + Q_k $$ where, $A_k$ = State Transition Matrix $B_k$ = Control-Input Model $u_k$ = Input Vector $w_k$ = Zero-mean Gaussian Process Noise $Q_k$ = Covariance of the Process Noise Update Let $\\tilde{y_k}$ be the innovation factor vector, i.e. the difference between the predicted state output and the measured state output. $$ \\tilde{y} = z_k - C_k\\hat{x} {k|k-1} \\ \\ S_k = C_k P {k|k-1} C_k^T + R_k \\ \\ K_k = P_{k|k-1} C_k^T S_k^{-1} \\ \\ \\hat{x} {k|k} = \\hat{x} {k|k-1} + K_k \\tilde{y} k \\ \\ P {k|k-1} = (1 - k_k C_k)P_{k|k-1} $$ where, $z_k$ = Measurement Vector $C_k$ = Observation Matrix $R_k$ = Measurement Covariance $S_k$ = Innovation Covariance $K_l$ = Kalman Gain Matrix The variables $z_k$, $C_k$, $R_k$ are derived from the incoming measurement. Filter Model Horizontal filter $$ x = \\begin{bmatrix} x \\ y \\ \\dot{x} \\ \\dot{y} \\ \\ddot{x} \\ \\ddot{y} \\ \\dot{x_c} \\ \\dot{x_y} \\end{bmatrix}, $$ $$ A_k = \\begin{bmatrix} 1 & 0 & \\delta t & 0 & 0.5 \\delta t^2 & 0 & 0 & 0\\ 0 & 1 & 0 & \\delta t & 0 & 0.5 \\delta t^2 & 0 & 0\\ 0 & 0 & 1 & 0 & \\delta t & 0 & 0 & 0\\ 0 & 0 & 0 & 1 & 0 & \\delta t & 0 & 0\\ 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\ 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\ 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\ \\end{bmatrix}, $$ $$ B_k = \\begin{bmatrix} 0 \\end{bmatrix}, w_k = \\begin{bmatrix} 0 \\end{bmatrix} $$ where $\\delta_t$ = predict_period Vertical Filter $$ x = \\begin{bmatrix} z \\ \\dot{z} \\ A \\ B \\end{bmatrix}, $$ $$ A_k = \\begin{bmatrix} 1 & \\delta t & 0 & 0 \\ 0 & 1 + \\alpha\\delta{t} & 0 & \\delta{t} \\ 0 & -\\delta{t} & 1 & 0 \\ 0 & 0 & 0 & 1 \\ \\end{bmatrix}, $$ $$ B_k = \\begin{bmatrix} 0 \\end{bmatrix}, $$ $$ w_k = \\begin{bmatrix} 0 \\end{bmatrix} $$ where, $\\delta_t$ = predict period $A$ = altitude $B$ = buoyancy Rotation Filter $$ x = \\begin{bmatrix} \\psi \\ \\theta \\ \\gamma \\ \\dot{\\psi} \\ \\dot{\\theta} \\ \\dot{\\gamma} \\end{bmatrix}, $$ $$ A_k = \\begin{bmatrix} 1 & 0 & 0 & \\delta{t} & 0 & 0 \\ 0 & 1 & 0 & 0 & \\delta{t} & 0 \\ 0 & 0 & 1 & 0 & 0 & \\delta{t} \\ 0 & 0 & 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 & 0 & 1 \\ \\end{bmatrix}, $$ $$ B_k = \\begin{bmatrix} 0 \\end{bmatrix}, $$ $$ w_k = \\begin{bmatrix} 0 \\end{bmatrix} $$ where $\\delta_t$ = predict_period Outlier Detection $$ e_n = \\tilde{y}_k^T S_k^{-1} \\tilde{y}_k $$ $$ e_n < th_{outlier} $$ where $e_n$ = normalized error $th_{outlier}$ = threshold outlier rejection parameter References Rhudy, Matthew & Salguero, Roger & Holappa, Keaton. (2017). A Kalman Filtering Tutorial for Undergraduate Students. International Journal of Computer Science & Engineering Survey. 08. 01-18. 10.5121/ijcses.2017.8101. https://towardsdatascience.com/kalman-filter-an-algorithm-for-making-sense-from-the-insights-of-various-sensors-fused-together-ddf67597f35e","title":"Theory"},{"location":"sensor-fusion-kalman-filter/theory/#theory","text":"","title":"Theory"},{"location":"sensor-fusion-kalman-filter/theory/#kalman-filter","text":"A Kalman filter, also known as Linear Quadratic Estimator (LQE) uses a series of noisy measurements to produce estimates of unknown state variables. A Kalman filter provides an optimum solution to many tracking and data prediction tasks and finds excellent use in control, navigation and guidance. The algorithm works in a two-step process. In the \"predict\" step, the Kalman filter looks one-step forward in time to predict the estimates of the current state vector and state covariance using an inner dynamic model. In the second step, known as \"update\", a \"kalman gain matrix\" is calculated using the state covariances and measurement covariance. This matrix is then used to update the state of the vehicle as shown below. One key advantage of Kalman filter is that it can run efficiently in real-time. For a more comprehensive literature on the subject, the reader is recommended to consult [1]. Consult [2] for an excellent introductory article on KFs. Predict Let xkxk be the state vector and PkPk be the state covariance. The state equation is written as $$ \\hat{x} {k|k-1} = A_k \\hat{x} {k-1|k-1} + B_k u_k + w_k \\ \\ P_{k|k-1} = A_k P_{k-1|k-1} A_k^T + Q_k $$ where, $A_k$ = State Transition Matrix $B_k$ = Control-Input Model $u_k$ = Input Vector $w_k$ = Zero-mean Gaussian Process Noise $Q_k$ = Covariance of the Process Noise Update Let $\\tilde{y_k}$ be the innovation factor vector, i.e. the difference between the predicted state output and the measured state output. $$ \\tilde{y} = z_k - C_k\\hat{x} {k|k-1} \\ \\ S_k = C_k P {k|k-1} C_k^T + R_k \\ \\ K_k = P_{k|k-1} C_k^T S_k^{-1} \\ \\ \\hat{x} {k|k} = \\hat{x} {k|k-1} + K_k \\tilde{y} k \\ \\ P {k|k-1} = (1 - k_k C_k)P_{k|k-1} $$ where, $z_k$ = Measurement Vector $C_k$ = Observation Matrix $R_k$ = Measurement Covariance $S_k$ = Innovation Covariance $K_l$ = Kalman Gain Matrix The variables $z_k$, $C_k$, $R_k$ are derived from the incoming measurement. Filter Model Horizontal filter $$ x = \\begin{bmatrix} x \\ y \\ \\dot{x} \\ \\dot{y} \\ \\ddot{x} \\ \\ddot{y} \\ \\dot{x_c} \\ \\dot{x_y} \\end{bmatrix}, $$ $$ A_k = \\begin{bmatrix} 1 & 0 & \\delta t & 0 & 0.5 \\delta t^2 & 0 & 0 & 0\\ 0 & 1 & 0 & \\delta t & 0 & 0.5 \\delta t^2 & 0 & 0\\ 0 & 0 & 1 & 0 & \\delta t & 0 & 0 & 0\\ 0 & 0 & 0 & 1 & 0 & \\delta t & 0 & 0\\ 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\ 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\ 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\ \\end{bmatrix}, $$ $$ B_k = \\begin{bmatrix} 0 \\end{bmatrix}, w_k = \\begin{bmatrix} 0 \\end{bmatrix} $$ where $\\delta_t$ = predict_period Vertical Filter $$ x = \\begin{bmatrix} z \\ \\dot{z} \\ A \\ B \\end{bmatrix}, $$ $$ A_k = \\begin{bmatrix} 1 & \\delta t & 0 & 0 \\ 0 & 1 + \\alpha\\delta{t} & 0 & \\delta{t} \\ 0 & -\\delta{t} & 1 & 0 \\ 0 & 0 & 0 & 1 \\ \\end{bmatrix}, $$ $$ B_k = \\begin{bmatrix} 0 \\end{bmatrix}, $$ $$ w_k = \\begin{bmatrix} 0 \\end{bmatrix} $$ where, $\\delta_t$ = predict period $A$ = altitude $B$ = buoyancy Rotation Filter $$ x = \\begin{bmatrix} \\psi \\ \\theta \\ \\gamma \\ \\dot{\\psi} \\ \\dot{\\theta} \\ \\dot{\\gamma} \\end{bmatrix}, $$ $$ A_k = \\begin{bmatrix} 1 & 0 & 0 & \\delta{t} & 0 & 0 \\ 0 & 1 & 0 & 0 & \\delta{t} & 0 \\ 0 & 0 & 1 & 0 & 0 & \\delta{t} \\ 0 & 0 & 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 & 0 & 1 \\ \\end{bmatrix}, $$ $$ B_k = \\begin{bmatrix} 0 \\end{bmatrix}, $$ $$ w_k = \\begin{bmatrix} 0 \\end{bmatrix} $$ where $\\delta_t$ = predict_period Outlier Detection $$ e_n = \\tilde{y}_k^T S_k^{-1} \\tilde{y}_k $$ $$ e_n < th_{outlier} $$ where $e_n$ = normalized error $th_{outlier}$ = threshold outlier rejection parameter","title":"Kalman filter"},{"location":"sensor-fusion-kalman-filter/theory/#references","text":"Rhudy, Matthew & Salguero, Roger & Holappa, Keaton. (2017). A Kalman Filtering Tutorial for Undergraduate Students. International Journal of Computer Science & Engineering Survey. 08. 01-18. 10.5121/ijcses.2017.8101. https://towardsdatascience.com/kalman-filter-an-algorithm-for-making-sense-from-the-insights-of-various-sensors-fused-together-ddf67597f35e","title":"References"},{"location":"sensor-fusion-kalman-filter/user_guide/","text":"User-Guide Getting Started Installation Pkg sensor_fusion comes as part of the medusa_vx stack. Configuration This section explains how to write the node configuration file. A sample is given below ROS Node Parameters node_frequency: 10 # ROS node output rate topics: subscribers: [ # std::string containing topics < reset, position, velocity, orientation> \"reset\", \"/measurement/position\", \"/measurement/velocity\", \"/measurement/orientation\" ] publishers: [ # std::string containing topics <state, debug> \"state\", \"debug\" ] Class Node Parameters tf: # TF publishers broadcast: true # flag to publish node TF frames frames: [ # std::string containing frame <base_link, odom, map, world> \"base_link\", \"odom\", \"map\", \"map\" ] kalman_filter: config: [0.1, 5.0, 16] # predict period, save measurement interval, outlier rejection threshold reject_counter: [8, 5, 12, 3, 3, 3] # outlier reject counters for position, velocity, angle, angle rate, acceleration, altitude process_covariance: [0.03, 0.015, 0.85, 1.2, 0.9, 0.12] # process noise for position, velocity, angles, angle rate, acceleration, altitude vertical_drag: [-0.1287, -0.4097, -0.013] # alpha, beta, bouyancy bypass_ahrs: false # Set True to treat AHRS as input initialize: # Define initialization condition trigger: false # Set true to initialize at start meas: # If trigger is set to true, define initial position and state. If it is set to false, define initial state except position frame_id: \"gnss\" # If trigger is set to false, define measurement frame used for initialization value: [0, 0, 0, # Position - x, y, z 0, 0, 0, # Velocity - vx, vy, vz 0, 0, 0, # Orientation - r, p, h 0, 0, 0, # Orientation Rate - dr, dp, vh 0, 0, 0] # Acceleration & Altitude - ax, ay, A noise: [1000, 1000, 1000, # If trigger is set to true, define initial position and state covariance. 0.1 , 0.1 , 0.1 , # If trigger is set to false, define initial state covariance except position 1 , 1 , 1 , # Array format is same as above 0.1 , 0.1 , 0.1 , 0.01, 0.01, 1000] sensors: # Define sensors as input here. Any sensor frame ids not defined here will be ignored by the filter - frame_id: \"gnss\" # Example Sensor 1: Sat Nav Input config: [true, true, false, # frame_id takes in the frame_id associated with the input measurement false, false, false, # Config is a 15-state bool array that defines the input measurement false, false, false, # The number of inputs should be equal to the no of \"true\" flags in the config array false, false, false, # For sensor providing position (x, y) input, config has two flags triggered as shown false, false, false] # noise: [0.5, 0.5, 0.0, # Noise if an optional 15-state double array that overrides incoming measurement noise 0.0, 0.0, 0.0, # Filter will always take 0.5 as measurement noise during update stage of the kalman filter here 0.0, 0.0, 0.0, # 0.0, 0.0, 0.0, 0.0, 0.0, 0.0] - frame_id: \"dvl_bt\" # Example Sensor 2: DVL Bottom Track config: [false, false, false, # Sensor updates inertial position of the vehicle true, true, false, # For sensor providing velocity (vx, vy) input, config has two flags triggered as shown false, false, false, # Filter takes in noise measurement from the input, ignore the input if there is none false, false, false, false, false, false] - frame_id: \"depth\" # Example Sensor 3: Depth Sensor config: [false, false, true, # Sensor updates depth of the vehicle false, false, false, # For sensor providing Depth (z) input, config has one flag triggered as shown false, false, false, false, false, false, false, false, false] noise: [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0] - frame_id: \"ahrs\" # Example Sensor 4: AHRS Sensor config: [false, false, false, # Sensor updates inertial position of the vehicle false, false, false, # For sensor providing rotation (r, p, h, vr, vp, vh) input, config has 6 flags triggered as shown true, true, true, true, true, true, false, false, false] noise: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0] Config Breakdown ROS Node Parameters** Name Type Function node_frequency int Filter output frequency topics/subscribers string[4] Input topics for reset, position, velocity and orientation topics/publishers string[2] Output topics for state estimate and debug info Remarks - position, velocity, orientation topics subscribe to input of type medusa_msgs::Measurement - state topic publishes state estimate in auv_msgs::NavigationStatus - topic debug publishes debug information in std::string Class Parameters TF Name Type Function tf/broadcast bool Flag to trigger state broadcast to ros::tfs tf/frames string[4] Frame names from base_link, odom, map and world frame Remarks - If dead reckoning is not needed, set odom frame as \"null\" - If tf/broadcast flag is set to true while odom frame is not set, filter will publish the tf tree as: base_link -> map -> world - If tf/broadcast flag is set to true while odom frame is set, filter will publish the tf tree as: base_link -> odom -> map -> world Kalman Parameters Name Type Function kalman_filter/config double[3] Set parameters for predict period, save measurement interval, outlier rejection threshold kalman_filter/reject_counter int[6] Set outlier reject counters for position, velocity, angle, angle rate, acceleration and altitude kalman_filter/process_covariance double[6] Set process noise for position, velocity, angles, angle rate, acceleration and altitude kalman_filter/vertical_drag double[3] Set alpha, beta, bouyancy for vertical filter kalman_filter/bypass_ahrs bool Trigger to treat AHRS as an Input Remarks - predict period defines the frequency of kalman filter predicts stage - save measurement interval sets the interval over which measurements are rejected by the filter. If no input is received for more than twice this interval, filter resets. - outlier rejection threshold sets the threshold for outlier measurement rejection. - reject counter defines the no of measurements to reject before accepting outliers as the input Initialization Parameters `` Defines the initial covariance of the state vector Defines the drag parameters used in the state model of vertical filter. Flag to treat inputs to the rotation filter as input. If set to true, any input sent to the node bypasses the filter and is output directly. Initialization Parameters Name Type Function kalman_filter/initialize/. ./trigger bool Flag to trigger initialization at startup ./meas/frame_id string Sensor frame to initialize filter with ./meas/value double[15] Defines the initial state of the vessel ./meas/noise bool[15] Defines the initial state covariance Remarks - If trigger is set to false, filter will initialize horizontal position with a measurement with frame ./meas/frame_id . The rest is set by the ./meas Sensor Input Input sensors to the filter are described as a list of type <XmlRpc::XmlRpcValue> . Any number of sensors may be defined following the format described below. Name Type Function kalman_filter/sensors/. - frame_id, config, noise frame_id string Defines the name of the sensor frame. config bool[15] Defines the observation matrix of the kalman filter noise (optional) double[15] Defines the noise associated with the measurement. Remarks - Each sensor to the filter must have a unique frame_id and a static TF to base_link associated with it. - Incoming measurement must always contain the same no of inputs, as described in the observation matrix. - If the noise in input measurement is zero or invalid, filter will ignore the measurement. Launching the Nodes An example launch file is provided below where two sensor_fusion/sensor_fusion nodes are being launched, named filter and filter_dr. <?xml version=\"1.0\"?> <launch> <env name=\"ROSCONSOLE_FORMAT\" value=\"[${severity}] [${time}]: ${node}: ${message}\"/> <!-- ######################## --> <!-- Parameters and Arguments --> <!-- ######################## --> <arg name=\"map\" default=\"map\" /> <!-- name of config file for node ~filter --> <arg name=\"odom\" default=\"odom\" /> <!-- name of config file for node ~filter_dr --> <group ns=\"nav\"> <!-- ############################ --> <!-- filters_dr: Estimates the position of the vehicle in <odom> frame. --> <!-- ############################ --> <node pkg=\"sensor_fusion\" type=\"sensor_fusion\" name=\"filter_dr\" respawn=\"false\"> <rosparam command=\"load\" file=\"$(find medusa_bringup)/config/$(arg odom).yaml\" /> </node> <!-- ############################ --> <!-- filters: Estimates the position of the vehicle in <map> frame. --> <!-- ############################ --> <node pkg=\"sensor_fusion\" type=\"sensor_fusion\" name=\"filter\" respawn=\"false\" output=\"screen\"> <rosparam command=\"load\" file=\"$(find medusa_bringup)/config/$(arg map).yaml\" /> </node> </group> </launch>","title":"Overview"},{"location":"sensor-fusion-kalman-filter/user_guide/#user-guide","text":"","title":"User-Guide"},{"location":"sensor-fusion-kalman-filter/user_guide/#getting-started","text":"","title":"Getting Started"},{"location":"sensor-fusion-kalman-filter/user_guide/#installation","text":"Pkg sensor_fusion comes as part of the medusa_vx stack.","title":"Installation"},{"location":"sensor-fusion-kalman-filter/user_guide/#configuration","text":"This section explains how to write the node configuration file. A sample is given below","title":"Configuration"},{"location":"sensor-fusion-kalman-filter/user_guide/#ros-node-parameters","text":"node_frequency: 10 # ROS node output rate topics: subscribers: [ # std::string containing topics < reset, position, velocity, orientation> \"reset\", \"/measurement/position\", \"/measurement/velocity\", \"/measurement/orientation\" ] publishers: [ # std::string containing topics <state, debug> \"state\", \"debug\" ]","title":"ROS Node Parameters"},{"location":"sensor-fusion-kalman-filter/user_guide/#class-node-parameters","text":"tf: # TF publishers broadcast: true # flag to publish node TF frames frames: [ # std::string containing frame <base_link, odom, map, world> \"base_link\", \"odom\", \"map\", \"map\" ] kalman_filter: config: [0.1, 5.0, 16] # predict period, save measurement interval, outlier rejection threshold reject_counter: [8, 5, 12, 3, 3, 3] # outlier reject counters for position, velocity, angle, angle rate, acceleration, altitude process_covariance: [0.03, 0.015, 0.85, 1.2, 0.9, 0.12] # process noise for position, velocity, angles, angle rate, acceleration, altitude vertical_drag: [-0.1287, -0.4097, -0.013] # alpha, beta, bouyancy bypass_ahrs: false # Set True to treat AHRS as input initialize: # Define initialization condition trigger: false # Set true to initialize at start meas: # If trigger is set to true, define initial position and state. If it is set to false, define initial state except position frame_id: \"gnss\" # If trigger is set to false, define measurement frame used for initialization value: [0, 0, 0, # Position - x, y, z 0, 0, 0, # Velocity - vx, vy, vz 0, 0, 0, # Orientation - r, p, h 0, 0, 0, # Orientation Rate - dr, dp, vh 0, 0, 0] # Acceleration & Altitude - ax, ay, A noise: [1000, 1000, 1000, # If trigger is set to true, define initial position and state covariance. 0.1 , 0.1 , 0.1 , # If trigger is set to false, define initial state covariance except position 1 , 1 , 1 , # Array format is same as above 0.1 , 0.1 , 0.1 , 0.01, 0.01, 1000] sensors: # Define sensors as input here. Any sensor frame ids not defined here will be ignored by the filter - frame_id: \"gnss\" # Example Sensor 1: Sat Nav Input config: [true, true, false, # frame_id takes in the frame_id associated with the input measurement false, false, false, # Config is a 15-state bool array that defines the input measurement false, false, false, # The number of inputs should be equal to the no of \"true\" flags in the config array false, false, false, # For sensor providing position (x, y) input, config has two flags triggered as shown false, false, false] # noise: [0.5, 0.5, 0.0, # Noise if an optional 15-state double array that overrides incoming measurement noise 0.0, 0.0, 0.0, # Filter will always take 0.5 as measurement noise during update stage of the kalman filter here 0.0, 0.0, 0.0, # 0.0, 0.0, 0.0, 0.0, 0.0, 0.0] - frame_id: \"dvl_bt\" # Example Sensor 2: DVL Bottom Track config: [false, false, false, # Sensor updates inertial position of the vehicle true, true, false, # For sensor providing velocity (vx, vy) input, config has two flags triggered as shown false, false, false, # Filter takes in noise measurement from the input, ignore the input if there is none false, false, false, false, false, false] - frame_id: \"depth\" # Example Sensor 3: Depth Sensor config: [false, false, true, # Sensor updates depth of the vehicle false, false, false, # For sensor providing Depth (z) input, config has one flag triggered as shown false, false, false, false, false, false, false, false, false] noise: [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0] - frame_id: \"ahrs\" # Example Sensor 4: AHRS Sensor config: [false, false, false, # Sensor updates inertial position of the vehicle false, false, false, # For sensor providing rotation (r, p, h, vr, vp, vh) input, config has 6 flags triggered as shown true, true, true, true, true, true, false, false, false] noise: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0]","title":"Class Node Parameters"},{"location":"sensor-fusion-kalman-filter/user_guide/#config-breakdown","text":"","title":"Config Breakdown"},{"location":"sensor-fusion-kalman-filter/user_guide/#ros-node-parameters_1","text":"Name Type Function node_frequency int Filter output frequency topics/subscribers string[4] Input topics for reset, position, velocity and orientation topics/publishers string[2] Output topics for state estimate and debug info Remarks - position, velocity, orientation topics subscribe to input of type medusa_msgs::Measurement - state topic publishes state estimate in auv_msgs::NavigationStatus - topic debug publishes debug information in std::string","title":"ROS Node Parameters**"},{"location":"sensor-fusion-kalman-filter/user_guide/#class-parameters","text":"TF Name Type Function tf/broadcast bool Flag to trigger state broadcast to ros::tfs tf/frames string[4] Frame names from base_link, odom, map and world frame Remarks - If dead reckoning is not needed, set odom frame as \"null\" - If tf/broadcast flag is set to true while odom frame is not set, filter will publish the tf tree as: base_link -> map -> world - If tf/broadcast flag is set to true while odom frame is set, filter will publish the tf tree as: base_link -> odom -> map -> world Kalman Parameters Name Type Function kalman_filter/config double[3] Set parameters for predict period, save measurement interval, outlier rejection threshold kalman_filter/reject_counter int[6] Set outlier reject counters for position, velocity, angle, angle rate, acceleration and altitude kalman_filter/process_covariance double[6] Set process noise for position, velocity, angles, angle rate, acceleration and altitude kalman_filter/vertical_drag double[3] Set alpha, beta, bouyancy for vertical filter kalman_filter/bypass_ahrs bool Trigger to treat AHRS as an Input Remarks - predict period defines the frequency of kalman filter predicts stage - save measurement interval sets the interval over which measurements are rejected by the filter. If no input is received for more than twice this interval, filter resets. - outlier rejection threshold sets the threshold for outlier measurement rejection. - reject counter defines the no of measurements to reject before accepting outliers as the input Initialization Parameters `` Defines the initial covariance of the state vector Defines the drag parameters used in the state model of vertical filter. Flag to treat inputs to the rotation filter as input. If set to true, any input sent to the node bypasses the filter and is output directly. Initialization Parameters Name Type Function kalman_filter/initialize/. ./trigger bool Flag to trigger initialization at startup ./meas/frame_id string Sensor frame to initialize filter with ./meas/value double[15] Defines the initial state of the vessel ./meas/noise bool[15] Defines the initial state covariance Remarks - If trigger is set to false, filter will initialize horizontal position with a measurement with frame ./meas/frame_id . The rest is set by the ./meas Sensor Input Input sensors to the filter are described as a list of type <XmlRpc::XmlRpcValue> . Any number of sensors may be defined following the format described below. Name Type Function kalman_filter/sensors/. - frame_id, config, noise frame_id string Defines the name of the sensor frame. config bool[15] Defines the observation matrix of the kalman filter noise (optional) double[15] Defines the noise associated with the measurement. Remarks - Each sensor to the filter must have a unique frame_id and a static TF to base_link associated with it. - Incoming measurement must always contain the same no of inputs, as described in the observation matrix. - If the noise in input measurement is zero or invalid, filter will ignore the measurement.","title":"Class Parameters"},{"location":"sensor-fusion-kalman-filter/user_guide/#launching-the-nodes","text":"An example launch file is provided below where two sensor_fusion/sensor_fusion nodes are being launched, named filter and filter_dr. <?xml version=\"1.0\"?> <launch> <env name=\"ROSCONSOLE_FORMAT\" value=\"[${severity}] [${time}]: ${node}: ${message}\"/> <!-- ######################## --> <!-- Parameters and Arguments --> <!-- ######################## --> <arg name=\"map\" default=\"map\" /> <!-- name of config file for node ~filter --> <arg name=\"odom\" default=\"odom\" /> <!-- name of config file for node ~filter_dr --> <group ns=\"nav\"> <!-- ############################ --> <!-- filters_dr: Estimates the position of the vehicle in <odom> frame. --> <!-- ############################ --> <node pkg=\"sensor_fusion\" type=\"sensor_fusion\" name=\"filter_dr\" respawn=\"false\"> <rosparam command=\"load\" file=\"$(find medusa_bringup)/config/$(arg odom).yaml\" /> </node> <!-- ############################ --> <!-- filters: Estimates the position of the vehicle in <map> frame. --> <!-- ############################ --> <node pkg=\"sensor_fusion\" type=\"sensor_fusion\" name=\"filter\" respawn=\"false\" output=\"screen\"> <rosparam command=\"load\" file=\"$(find medusa_bringup)/config/$(arg map).yaml\" /> </node> </group> </launch>","title":"Launching the Nodes"},{"location":"sensors-simulation/sensor_sim/","text":"Sensor Sim: readme.md Project Description This package implements basic sensor models for an underwater/surface vehicles. It has the following features - Simulate GPS, Depth, DVL (Bottom Track and Water Track), Altitude, AHRS, Ranges - Control Gaussian Noise and Measurement Noise - Control Sensor Publish Frequency - Publish State output of the dynamic model in auv_msgs::NavigationStatus format Getting Started Installation Pkg sensor_sim comes as part of the medusa_vx stack. Configuration This section explains how to write the node configuration file. Sample are given below topics: subscribers: [ \"/dynamics_sim/position\"] publishers : [ \"/measurement/position\", \"/measurement/velocity\", \"/measurement/orientation\", \"/sensors/gnss\", \"/sensors/range\", \"/sim/dynamics/model\", \"/diagnostics/thrusterStatus\" ] water_column: 100 sensors: - type : \"GNSS\" frame_id : \"gnss\" frequency: 1.0 count : 500 noise : 0.0 variance : 0.03 debug : false - type : \"DVL_BT\" frame_id : \"dvl_bt\" frequency: 5.0 noise : 0.015 variance : 0.001 altitude : 30.0 debug : true - type : \"DVL_WT\" frame_id : \"dvl_wt\" frequency: 5.0 noise : 0.01 variance : 0.0 altitude : 110.0 - type : \"AHRS\" frame_id : \"ahrs\" frequency: 10.0 noise : [0, 0] variance : 0.000001 - type : \"DEPTH\" frame_id : \"depth\" frequency: 10.0 noise : 0.01 variance : 0.005 - type : \"ALTIMETER\" frame_id : \"altimeter\" frequency: 5.0 noise : 0.1 variance : 0.1 - type : \"MODEL\" frequency: 10.0 topics/publishers: parameter of type string[7] Defines the output topics - [position, velocity, orientation, gnss, range, model, thruster] position topic is used to publish DEPTH & ALTIMETER measurements of type medusa_msgs::Measurement velocity topic is used to publish DVL_BT, DVL_WT measurements of type medusa_msgs::Measurement orientation topic is used to publish AHRS measurements of type medusa_msgs::Measurement gnss topic is used for GNSS measurements in WGS84 of type sensor_msgs::NavSatFix range topic is used for single beacon measurements of type medusa_msgs::mUSBLFix topics/subscribers: parameter of type string[1] position topic to receive the dynamic state of the vehicle in nav_msgs::Odometry water_column : Length of water column (We assume that water column is constant) sensors : Sensors to be simulated are described as a list of type . Any number of sensors may be defined following the format described below. type: parameter of type string Defines the type of sensor to be simulated. Current available sensors are \"GNSS\", \"DVL_WT\", \"DVL_BT\", \"AHRS\", \"DEPTH\", \"ALTIMETER\", \"RANGE\", \"MODEL\" frame_id: parameter of type string Frame id of the simulated sensor, must be unique frequency: parameter of type double Controls how often the sensor publishes data count: parameter of type int Sensor stops publishing after this many outputs Put 0 for infinite noise: parameter of type double gaussian noise added to the sensor variance: parameter of type double In addition to the gaussian noise, a constant value is added while publishing the sensor value and variance. Its main purpose is to easily tune the measurement noise being fed to the filter This value has no effect while adding noise to the sensor! Launching the Node An example launch file is provided below where sensor_sim/sensor_sim . <?xml version=\"1.0\"?> <launch> <arg name=\"name\" default=\"myellow\"/> <node pkg=\"sensor_sim\" type=\"sensor_sim\" name=\"sensor_sim\" respawn=\"false\" output=\"screen\"> <rosparam command=\"load\" file=\"$(find sensor_sim)/config/sensors.yaml\"/> </node> </launch>","title":"Overview"},{"location":"sensors-simulation/sensor_sim/#sensor-sim-readmemd","text":"","title":"Sensor Sim: readme.md"},{"location":"sensors-simulation/sensor_sim/#project-description","text":"This package implements basic sensor models for an underwater/surface vehicles. It has the following features - Simulate GPS, Depth, DVL (Bottom Track and Water Track), Altitude, AHRS, Ranges - Control Gaussian Noise and Measurement Noise - Control Sensor Publish Frequency - Publish State output of the dynamic model in auv_msgs::NavigationStatus format","title":"Project Description"},{"location":"sensors-simulation/sensor_sim/#getting-started","text":"","title":"Getting Started"},{"location":"sensors-simulation/sensor_sim/#installation","text":"Pkg sensor_sim comes as part of the medusa_vx stack.","title":"Installation"},{"location":"sensors-simulation/sensor_sim/#configuration","text":"This section explains how to write the node configuration file. Sample are given below topics: subscribers: [ \"/dynamics_sim/position\"] publishers : [ \"/measurement/position\", \"/measurement/velocity\", \"/measurement/orientation\", \"/sensors/gnss\", \"/sensors/range\", \"/sim/dynamics/model\", \"/diagnostics/thrusterStatus\" ] water_column: 100 sensors: - type : \"GNSS\" frame_id : \"gnss\" frequency: 1.0 count : 500 noise : 0.0 variance : 0.03 debug : false - type : \"DVL_BT\" frame_id : \"dvl_bt\" frequency: 5.0 noise : 0.015 variance : 0.001 altitude : 30.0 debug : true - type : \"DVL_WT\" frame_id : \"dvl_wt\" frequency: 5.0 noise : 0.01 variance : 0.0 altitude : 110.0 - type : \"AHRS\" frame_id : \"ahrs\" frequency: 10.0 noise : [0, 0] variance : 0.000001 - type : \"DEPTH\" frame_id : \"depth\" frequency: 10.0 noise : 0.01 variance : 0.005 - type : \"ALTIMETER\" frame_id : \"altimeter\" frequency: 5.0 noise : 0.1 variance : 0.1 - type : \"MODEL\" frequency: 10.0 topics/publishers: parameter of type string[7] Defines the output topics - [position, velocity, orientation, gnss, range, model, thruster] position topic is used to publish DEPTH & ALTIMETER measurements of type medusa_msgs::Measurement velocity topic is used to publish DVL_BT, DVL_WT measurements of type medusa_msgs::Measurement orientation topic is used to publish AHRS measurements of type medusa_msgs::Measurement gnss topic is used for GNSS measurements in WGS84 of type sensor_msgs::NavSatFix range topic is used for single beacon measurements of type medusa_msgs::mUSBLFix topics/subscribers: parameter of type string[1] position topic to receive the dynamic state of the vehicle in nav_msgs::Odometry water_column : Length of water column (We assume that water column is constant) sensors : Sensors to be simulated are described as a list of type . Any number of sensors may be defined following the format described below. type: parameter of type string Defines the type of sensor to be simulated. Current available sensors are \"GNSS\", \"DVL_WT\", \"DVL_BT\", \"AHRS\", \"DEPTH\", \"ALTIMETER\", \"RANGE\", \"MODEL\" frame_id: parameter of type string Frame id of the simulated sensor, must be unique frequency: parameter of type double Controls how often the sensor publishes data count: parameter of type int Sensor stops publishing after this many outputs Put 0 for infinite noise: parameter of type double gaussian noise added to the sensor variance: parameter of type double In addition to the gaussian noise, a constant value is added while publishing the sensor value and variance. Its main purpose is to easily tune the measurement noise being fed to the filter This value has no effect while adding noise to the sensor!","title":"Configuration"},{"location":"sensors-simulation/sensor_sim/#launching-the-node","text":"An example launch file is provided below where sensor_sim/sensor_sim . <?xml version=\"1.0\"?> <launch> <arg name=\"name\" default=\"myellow\"/> <node pkg=\"sensor_sim\" type=\"sensor_sim\" name=\"sensor_sim\" respawn=\"false\" output=\"screen\"> <rosparam command=\"load\" file=\"$(find sensor_sim)/config/sensors.yaml\"/> </node> </launch>","title":"Launching the Node"},{"location":"simple-bringup-system/","text":"","title":"Overview"},{"location":"static-thruster-allocation/","text":"","title":"Reference"},{"location":"status-aggregator/","text":"status_aggregator package status_aggregator is a ROS package responsible for aggregating diagnostic status messages of the system and publish them on the /diagnostics_agg topic. Important Sources By far the best explanation about ROS diagnostics, kudos to Nick Lamprianidis. source 01 source 02 Rationale ROS diagnostics is a tool to monitor your system. In a nutshell, status messages of the system are published on the /diagnostics topic and are then categorized and published for easy monitoring on the /diagnostics_agg topic. As you can guess, two separate components are needed for the final result: updater and aggregator . The former publishes diagnostic status messages on the /diagnostics topic, using tasks . While the latter subscribes the /diagnostics topic, aggregates and categorize the diagnostic status messages and publishes the results on the /diagnostics_agg topic, using analyzers . Updater and task A robot system pocesses multiple updaters , which are generally associated to some device (computer, motors, sensors, batteries). Each updater gets the relevant status information of a device through tasks , that function as an interface between an updater and a device. The sequence of operations is as follows: * Device send data into a task; * Updater forwards a status message to the task; * Task populates status message; When the update receives all the status messages from all the tasks it manages, it publishes them to the /diagnostics topic. The information by now has no hierarchy, difficulting the monotorization of the data. NOTE: In our stack we discarded the use of the tasks, and directly populate the statuses messages in the devices. Here is where Aggregator plays an important role. Example updater Aggregator and analyzer Aggregator comes to fathom out the messy output of the updaters . Basically it collects, categorizes, and groups the status messages from all the updaters of the system. It does so by using analyzers . Each status message received by the aggregator is forward to all of the analyzers it manages. The status messages are only analyzed if its name matches some criteria of one of the analyzers . The aggregator is then responsible to request a report from each analyzer and publish it on the /diagnostics_add topic. The report is just a list of status messages, one for each status item that the analyzer is responsible for, and one for the parent level that summarizes the state of its children statuses. Exmple aggregator Package Content Code documentation source Using status_aggregator Examples Requirements ROS diagnostics Information on /diagnostics topic","title":"Reference"},{"location":"status-aggregator/#status_aggregator-package","text":"status_aggregator is a ROS package responsible for aggregating diagnostic status messages of the system and publish them on the /diagnostics_agg topic.","title":"status_aggregator package"},{"location":"status-aggregator/#important-sources","text":"By far the best explanation about ROS diagnostics, kudos to Nick Lamprianidis. source 01 source 02","title":"Important Sources"},{"location":"status-aggregator/#rationale","text":"ROS diagnostics is a tool to monitor your system. In a nutshell, status messages of the system are published on the /diagnostics topic and are then categorized and published for easy monitoring on the /diagnostics_agg topic. As you can guess, two separate components are needed for the final result: updater and aggregator . The former publishes diagnostic status messages on the /diagnostics topic, using tasks . While the latter subscribes the /diagnostics topic, aggregates and categorize the diagnostic status messages and publishes the results on the /diagnostics_agg topic, using analyzers .","title":"Rationale"},{"location":"status-aggregator/#updater-and-task","text":"A robot system pocesses multiple updaters , which are generally associated to some device (computer, motors, sensors, batteries). Each updater gets the relevant status information of a device through tasks , that function as an interface between an updater and a device. The sequence of operations is as follows: * Device send data into a task; * Updater forwards a status message to the task; * Task populates status message; When the update receives all the status messages from all the tasks it manages, it publishes them to the /diagnostics topic. The information by now has no hierarchy, difficulting the monotorization of the data. NOTE: In our stack we discarded the use of the tasks, and directly populate the statuses messages in the devices. Here is where Aggregator plays an important role. Example updater","title":"Updater and task"},{"location":"status-aggregator/#aggregator-and-analyzer","text":"Aggregator comes to fathom out the messy output of the updaters . Basically it collects, categorizes, and groups the status messages from all the updaters of the system. It does so by using analyzers . Each status message received by the aggregator is forward to all of the analyzers it manages. The status messages are only analyzed if its name matches some criteria of one of the analyzers . The aggregator is then responsible to request a report from each analyzer and publish it on the /diagnostics_add topic. The report is just a list of status messages, one for each status item that the analyzer is responsible for, and one for the parent level that summarizes the state of its children statuses. Exmple aggregator","title":"Aggregator and analyzer"},{"location":"status-aggregator/#package-content","text":"","title":"Package Content"},{"location":"status-aggregator/#code-documentation","text":"source","title":"Code documentation"},{"location":"status-aggregator/#using-status_aggregator","text":"Examples","title":"Using status_aggregator"},{"location":"status-aggregator/#requirements","text":"ROS diagnostics Information on /diagnostics topic","title":"Requirements"},{"location":"status-aggregator/configurations/aggregator_example/","text":"Aggregator Example For the aggregator present some hierarchy, you have to specify a yaml file with the analyzers. /status_aggregator/config/mvector pub_rate: 2.0 analyzers: sensors: type: diagnostic_aggregator/StatusAnalyzer path: Sensors analyzers: leaks: type: diagnostic_aggregator/GenericAnalyzer path: Leaks contains: Leaks pressure: type: diagnostic_aggregator/GenericAnalyzer path: Pressure contains: Pressure temp: type: diagnostic_aggregator/GenericAnalyzer path: Temperature contains: Temperature imu: type: diagnostic_aggregator/GenericAnalyzer path: IMU contains: IMU gps: type: diagnostic_aggregator/GenericAnalyzer path: GPS contains: GPS altimeter: type: diagnostic_aggregator/GenericAnalyzer path: Altimeter contains: Altimeter depth_cell: type: diagnostic_aggregator/GenericAnalyzer path: DepthCell contains: DepthCell dvl: type: diagnostic_aggregator/GenericAnalyzer path: DVL contains: DVL actuators: type: diagnostic_aggregator/StatusAnalyzer path: Actuators analyzers: thruster_0: type: diagnostic_aggregator/GenericAnalyzer path: Thruster0 contains: Thruster0 thruster_1: type: diagnostic_aggregator/GenericAnalyzer path: Thruster1 contains: Thruster1 thruster_3: type: diagnostic_aggregator/GenericAnalyzer path: Thruster3 contains: Thruster3 thruster_2: type: diagnostic_aggregator/GenericAnalyzer path: Thruster2 contains: Thruster2 thruster_4: type: diagnostic_aggregator/GenericAnalyzer path: Thruster4 contains: Thruster4 thruster_5: type: diagnostic_aggregator/GenericAnalyzer path: Thruster5 contains: Thruster5 power_system: type: diagnostic_aggregator/StatusAnalyzer path: Power System analyzers: batmonit: type: diagnostic_aggregator/GenericAnalyzer path: Batmonit contains: Batmonit This yaml file can have 3 parameters: The pub_rate which is the frequency at which the aggregator publishes to the /diagnostics_agg topic. The base_path (and a secret one, path) which adds an additional root level in the hierarchy (e.g. /MyRobot/Sensors/IMU/\u2026). But it\u2019s useless, since there can only be one aggregator in the system, and so the separation between different robots cannot happen at this level. Thus, you can simply ignore it! The analyzers which is a list of\u2026 you guessed it, analyzers. The analyzers have a type, a name (a.k.a. path), and several options for matching criteria. The type can be GenericAnalyzer which does a grouping of status items based on their name or StatusAnalyzer which does a categorization of analyzers (e.g. Sensors/..., Actuators/..., Power System/...). Now, comes the interesting part. What if we want to react to an error? We\u2019ll have to write an analyzer that does this. But we won\u2019t just write an analyzer. Since the categorization offered by the default analyzers is always relevant, we\u2019ll extend the generic or group analyzers so that we maintain their functionality. The analyzers have two methods that can be of interest: The analyze method which can be useful for processing the data of a status message before we store it. The report method which can be used to make a decision based on the status messages to be reported by the analyzer. In the accompanying code, there are two analyzers. One is based on the GroupAnalyzer and the other is based on the GenericAnalyzer . They both rely on the report method. They look at the reported statuses by their parent class and they publish a message if a condition is met. The StatusAnalyzer finds a group (/Sensors, /Actuator, or Power System) status and reacts when its level transitions from OK to something else. The GenericAnalyzer is the default one, but you can have specific ones for your needs. Any required parameters are provided in the yaml file. Extending an analyzer First make a analyzer_plugins.xml file, like the following: <library path=\"lib/libstatus_aggregator_analyzers\"> <class name=\"diagnostic_aggregator/StatusAnalyzer\" type=\"diagnostic_aggregator::StatusAnalyzer\" base_class_type=\"diagnostic_aggregator::Analyzer\"> <description> StatusAnalyzer is a diagnostic analyzer for a group of devices (sensors, actuators, power system). </description> </class> </library> In the include file ( include/status_aggregator_ros/StatusAnalyzer.h ) you should inherit the base class AnalyzerGroup and override the methods init() and report() : class StatusAnalyzer : public AnalyzerGroup { public: StatusAnalyzer(); bool init(const std::string base_path, const ros::NodeHandle &n) override; std::vector<diagnostic_msgs::DiagnosticStatusPtr> report() override; In the cpp file ( src/status_aggregator_ros/StatusAnalyzer.cpp ) change the methods accordingly your needs.","title":"Aggregator Example"},{"location":"status-aggregator/configurations/aggregator_example/#aggregator-example","text":"For the aggregator present some hierarchy, you have to specify a yaml file with the analyzers. /status_aggregator/config/mvector pub_rate: 2.0 analyzers: sensors: type: diagnostic_aggregator/StatusAnalyzer path: Sensors analyzers: leaks: type: diagnostic_aggregator/GenericAnalyzer path: Leaks contains: Leaks pressure: type: diagnostic_aggregator/GenericAnalyzer path: Pressure contains: Pressure temp: type: diagnostic_aggregator/GenericAnalyzer path: Temperature contains: Temperature imu: type: diagnostic_aggregator/GenericAnalyzer path: IMU contains: IMU gps: type: diagnostic_aggregator/GenericAnalyzer path: GPS contains: GPS altimeter: type: diagnostic_aggregator/GenericAnalyzer path: Altimeter contains: Altimeter depth_cell: type: diagnostic_aggregator/GenericAnalyzer path: DepthCell contains: DepthCell dvl: type: diagnostic_aggregator/GenericAnalyzer path: DVL contains: DVL actuators: type: diagnostic_aggregator/StatusAnalyzer path: Actuators analyzers: thruster_0: type: diagnostic_aggregator/GenericAnalyzer path: Thruster0 contains: Thruster0 thruster_1: type: diagnostic_aggregator/GenericAnalyzer path: Thruster1 contains: Thruster1 thruster_3: type: diagnostic_aggregator/GenericAnalyzer path: Thruster3 contains: Thruster3 thruster_2: type: diagnostic_aggregator/GenericAnalyzer path: Thruster2 contains: Thruster2 thruster_4: type: diagnostic_aggregator/GenericAnalyzer path: Thruster4 contains: Thruster4 thruster_5: type: diagnostic_aggregator/GenericAnalyzer path: Thruster5 contains: Thruster5 power_system: type: diagnostic_aggregator/StatusAnalyzer path: Power System analyzers: batmonit: type: diagnostic_aggregator/GenericAnalyzer path: Batmonit contains: Batmonit This yaml file can have 3 parameters: The pub_rate which is the frequency at which the aggregator publishes to the /diagnostics_agg topic. The base_path (and a secret one, path) which adds an additional root level in the hierarchy (e.g. /MyRobot/Sensors/IMU/\u2026). But it\u2019s useless, since there can only be one aggregator in the system, and so the separation between different robots cannot happen at this level. Thus, you can simply ignore it! The analyzers which is a list of\u2026 you guessed it, analyzers. The analyzers have a type, a name (a.k.a. path), and several options for matching criteria. The type can be GenericAnalyzer which does a grouping of status items based on their name or StatusAnalyzer which does a categorization of analyzers (e.g. Sensors/..., Actuators/..., Power System/...). Now, comes the interesting part. What if we want to react to an error? We\u2019ll have to write an analyzer that does this. But we won\u2019t just write an analyzer. Since the categorization offered by the default analyzers is always relevant, we\u2019ll extend the generic or group analyzers so that we maintain their functionality. The analyzers have two methods that can be of interest: The analyze method which can be useful for processing the data of a status message before we store it. The report method which can be used to make a decision based on the status messages to be reported by the analyzer. In the accompanying code, there are two analyzers. One is based on the GroupAnalyzer and the other is based on the GenericAnalyzer . They both rely on the report method. They look at the reported statuses by their parent class and they publish a message if a condition is met. The StatusAnalyzer finds a group (/Sensors, /Actuator, or Power System) status and reacts when its level transitions from OK to something else. The GenericAnalyzer is the default one, but you can have specific ones for your needs. Any required parameters are provided in the yaml file.","title":"Aggregator Example"},{"location":"status-aggregator/configurations/aggregator_example/#extending-an-analyzer","text":"First make a analyzer_plugins.xml file, like the following: <library path=\"lib/libstatus_aggregator_analyzers\"> <class name=\"diagnostic_aggregator/StatusAnalyzer\" type=\"diagnostic_aggregator::StatusAnalyzer\" base_class_type=\"diagnostic_aggregator::Analyzer\"> <description> StatusAnalyzer is a diagnostic analyzer for a group of devices (sensors, actuators, power system). </description> </class> </library> In the include file ( include/status_aggregator_ros/StatusAnalyzer.h ) you should inherit the base class AnalyzerGroup and override the methods init() and report() : class StatusAnalyzer : public AnalyzerGroup { public: StatusAnalyzer(); bool init(const std::string base_path, const ros::NodeHandle &n) override; std::vector<diagnostic_msgs::DiagnosticStatusPtr> report() override; In the cpp file ( src/status_aggregator_ros/StatusAnalyzer.cpp ) change the methods accordingly your needs.","title":"Extending an analyzer"},{"location":"status-aggregator/configurations/medusaVxConfig/","text":"medusa_vx config - status_aggregator Run This package is launched with medusa stack. ex: roslaunch medusa_bringup medusa_bringup.launch name:= mvector docks:=missions Please check if aggregator is set to true in the vehicle configurations. For this, please check the following block in medusa_bringup/config/docks/mvector/process.yaml file: - name: 'addons' launch_on_startup: true delay_before_start: 0.0 cmd: 'roslaunch medusa_bringup addons.launch' args: - **aggregator:= true** - console_path_parser:= true - console_server:= true - wifi_acoustic_safety:= true - rosbridge_server:= false Launch file You have a main launch ( medusa_bringup.launch ) that calls a node ( medusa_bringup_node ) responsible to manage all the processes in a proecss.yaml file. The node while running is responsible to launch a subset of other launch files located at /medusa_bringup/launch/dev_launch . Among the exisitng ones, here the focus is in the addons.launch where aggregator is present. Looking in some detail to the file we point out the key points: <arg name=\"name\" /> <arg name=\"mission\" default=\"example\" /> <arg name=\"wifi_acoustic_safety\" default=\"false\" /> <!-- safety features --> **<arg name=\"console_path_parser\" default=\"false\" />** <arg name=\"http_server\" default=\"false\" /> <arg name=\"aggregator\" default=\"false\" /> <arg name=\"rosbridge_server\" default=\"false\" /> <arg name=\"websocket_port\" default=\"9090\" /> <!-- arg to use in http--> By default all the nodes in the medusa_addons package are set to false and won't run if you don't change the corresponding boolean in the process.yaml like in the previous section. <group ns=\"addons\"> Every addon is part of the group addons , which means that topics will be someting like /addons/node/some_topic , here /addons/aggregator/some_topic . <group if=\"$(arg aggregator)\"> <node pkg=\"diagnostic_aggregator\" type=\"aggregator_node\" name=\"aggregator\" output=\"screen\" /> </group> As you can see the if guarantees that the node only starts if in the process.yaml , aggregator is set to true. Configurations Configuration is divided between two files. The first one, medusa_bringup/config/dev_configs/ros.yaml , is responsible with ros node items (frequency and topics names). Below, the section of console_path_parser : addons/aggregator: pub_rate: 2.0 The second file, /medusa_bringup/config/mission/vehicle/addons.yaml , accommodates items more related with the node inner-workings. Below, the section of aggregator : *file, ex: /medusa_bringup/config/docks/mvector/addons.yaml aggregator: analyzers: sensors: type: diagnostic_aggregator/StatusAnalyzer path: Sensors analyzers: leaks: type: diagnostic_aggregator/GenericAnalyzer path: Leaks contains: Leaks pressure: type: diagnostic_aggregator/GenericAnalyzer path: Pressure contains: Pressure temp: type: diagnostic_aggregator/GenericAnalyzer path: Temperature contains: Temperature imu: type: diagnostic_aggregator/GenericAnalyzer path: IMU contains: IMU gps: type: diagnostic_aggregator/GenericAnalyzer path: GPS contains: GPS altimeter: type: diagnostic_aggregator/GenericAnalyzer path: Altimeter contains: Altimeter depth_cell: type: diagnostic_aggregator/GenericAnalyzer path: DepthCell contains: DepthCell actuators: type: diagnostic_aggregator/StatusAnalyzer path: Actuators analyzers: thruster_0: type: diagnostic_aggregator/GenericAnalyzer path: Thruster0 contains: Thruster0 thruster_1: type: diagnostic_aggregator/GenericAnalyzer path: Thruster1 contains: Thruster1 thruster_2: type: diagnostic_aggregator/GenericAnalyzer path: Thruster2 contains: Thruster2 thruster_3: type: diagnostic_aggregator/GenericAnalyzer path: Thruster3 contains: Thruster3 thruster_4: type: diagnostic_aggregator/GenericAnalyzer path: Thruster4 contains: Thruster4 thruster_5: type: diagnostic_aggregator/GenericAnalyzer path: Thruster5 contains: Thruster5 power_system: type: diagnostic_aggregator/StatusAnalyzer path: Power System analyzers: batmonit: type: diagnostic_aggregator/GenericAnalyzer path: Batmonit contains: Batmonit","title":"medusa_vx config - status_aggregator"},{"location":"status-aggregator/configurations/medusaVxConfig/#medusa_vx-config-status_aggregator","text":"","title":"medusa_vx config - status_aggregator"},{"location":"status-aggregator/configurations/medusaVxConfig/#run","text":"This package is launched with medusa stack. ex: roslaunch medusa_bringup medusa_bringup.launch name:= mvector docks:=missions Please check if aggregator is set to true in the vehicle configurations. For this, please check the following block in medusa_bringup/config/docks/mvector/process.yaml file: - name: 'addons' launch_on_startup: true delay_before_start: 0.0 cmd: 'roslaunch medusa_bringup addons.launch' args: - **aggregator:= true** - console_path_parser:= true - console_server:= true - wifi_acoustic_safety:= true - rosbridge_server:= false","title":"Run"},{"location":"status-aggregator/configurations/medusaVxConfig/#launch-file","text":"You have a main launch ( medusa_bringup.launch ) that calls a node ( medusa_bringup_node ) responsible to manage all the processes in a proecss.yaml file. The node while running is responsible to launch a subset of other launch files located at /medusa_bringup/launch/dev_launch . Among the exisitng ones, here the focus is in the addons.launch where aggregator is present. Looking in some detail to the file we point out the key points: <arg name=\"name\" /> <arg name=\"mission\" default=\"example\" /> <arg name=\"wifi_acoustic_safety\" default=\"false\" /> <!-- safety features --> **<arg name=\"console_path_parser\" default=\"false\" />** <arg name=\"http_server\" default=\"false\" /> <arg name=\"aggregator\" default=\"false\" /> <arg name=\"rosbridge_server\" default=\"false\" /> <arg name=\"websocket_port\" default=\"9090\" /> <!-- arg to use in http--> By default all the nodes in the medusa_addons package are set to false and won't run if you don't change the corresponding boolean in the process.yaml like in the previous section. <group ns=\"addons\"> Every addon is part of the group addons , which means that topics will be someting like /addons/node/some_topic , here /addons/aggregator/some_topic . <group if=\"$(arg aggregator)\"> <node pkg=\"diagnostic_aggregator\" type=\"aggregator_node\" name=\"aggregator\" output=\"screen\" /> </group> As you can see the if guarantees that the node only starts if in the process.yaml , aggregator is set to true.","title":"Launch file"},{"location":"status-aggregator/configurations/medusaVxConfig/#configurations","text":"Configuration is divided between two files. The first one, medusa_bringup/config/dev_configs/ros.yaml , is responsible with ros node items (frequency and topics names). Below, the section of console_path_parser : addons/aggregator: pub_rate: 2.0 The second file, /medusa_bringup/config/mission/vehicle/addons.yaml , accommodates items more related with the node inner-workings. Below, the section of aggregator : *file, ex: /medusa_bringup/config/docks/mvector/addons.yaml aggregator: analyzers: sensors: type: diagnostic_aggregator/StatusAnalyzer path: Sensors analyzers: leaks: type: diagnostic_aggregator/GenericAnalyzer path: Leaks contains: Leaks pressure: type: diagnostic_aggregator/GenericAnalyzer path: Pressure contains: Pressure temp: type: diagnostic_aggregator/GenericAnalyzer path: Temperature contains: Temperature imu: type: diagnostic_aggregator/GenericAnalyzer path: IMU contains: IMU gps: type: diagnostic_aggregator/GenericAnalyzer path: GPS contains: GPS altimeter: type: diagnostic_aggregator/GenericAnalyzer path: Altimeter contains: Altimeter depth_cell: type: diagnostic_aggregator/GenericAnalyzer path: DepthCell contains: DepthCell actuators: type: diagnostic_aggregator/StatusAnalyzer path: Actuators analyzers: thruster_0: type: diagnostic_aggregator/GenericAnalyzer path: Thruster0 contains: Thruster0 thruster_1: type: diagnostic_aggregator/GenericAnalyzer path: Thruster1 contains: Thruster1 thruster_2: type: diagnostic_aggregator/GenericAnalyzer path: Thruster2 contains: Thruster2 thruster_3: type: diagnostic_aggregator/GenericAnalyzer path: Thruster3 contains: Thruster3 thruster_4: type: diagnostic_aggregator/GenericAnalyzer path: Thruster4 contains: Thruster4 thruster_5: type: diagnostic_aggregator/GenericAnalyzer path: Thruster5 contains: Thruster5 power_system: type: diagnostic_aggregator/StatusAnalyzer path: Power System analyzers: batmonit: type: diagnostic_aggregator/GenericAnalyzer path: Batmonit contains: Batmonit","title":"Configurations"},{"location":"status-aggregator/configurations/updater_example/","text":"Updater example To use ROS diagnostics add the following to CMakeLists.txt: find_package(catkin REQUIRED COMPONENTS std_msgs medusa_msgs roscpp **diagnostic_msgs** serial_lib nmea_msgs medusa_gimmicks_library **medusa_diagnostics_library** ) and in package.xml guarantee the following two dependencies: <depend>diagnostic_msgs</depend> <depend>medusa_diagnostics_library</depend> Code use In some header file please include the following: #include <diagnostic_msgs/KeyValue.h> #include <diagnostic_msgs/DiagnosticArray.h> #include <diagnostic_msgs/DiagnosticStatus.h> #include <medusa_diagnostics_library/MedusaDiagnostics.h> Below you can find an example, with two different key values(pressure and temperature), the status message is directly populated in the driver node: void ImsNode::reportingPressure(const medusa_msgs::Pressure &msg) { //** Instantiate diagnostic message diagnostic_msgs::DiagnosticArray diag_msg; diag_msg.header.stamp = msg.header.stamp; diag_msg.status.push_back(MedusaDiagnostics::setDiagnosisMsg(diagnostic_msgs::DiagnosticStatus::OK, \"/Sensors/Pressure\", \"IMS Pressure Good.\", \"IMS Board\")); diag_msg.status.push_back(MedusaDiagnostics::setDiagnosisMsg(diagnostic_msgs::DiagnosticStatus::OK, \"/Sensors/Temperature\", \"IMS Temperature Good.\", \"IMS Board\")); // +.+ Check pressure bounds if (MedusaDiagnostics::checkLowerBound(msg.pressure, p_min_pressure_) || MedusaDiagnostics::checkUpperBound(msg.pressure, p_max_pressure_)) MedusaDiagnostics::errorLevel(&diag_msg, ros::this_node::getName() + \": Pressure out of bounds\", 0); // +.+ Check temperature bounds if (MedusaDiagnostics::checkLowerBound(msg.temperature, p_min_temp_) || MedusaDiagnostics::checkUpperBound(msg.temperature, p_max_temp_)) MedusaDiagnostics::errorLevel(&diag_msg, ros::this_node::getName() + \": Temperature out of bounds\", 1); // +.+ Pressure and temperature key values MedusaDiagnostics::addKeyValue(&diag_msg, \"Pressure\", boost::str(boost::format(\"%.0f\") % (msg.pressure)), 0); MedusaDiagnostics::addKeyValue(&diag_msg, \"Temperature\", boost::str(boost::format(\"%.0f\") % (msg.temperature)), 1); diagnostics_pub_.publish(diag_msg); } where: diagnostics_pub_ = nh_.advertise<diagnostic_msgs::DiagnosticArray>(\"/diagnostics\", 100);","title":"Updater example"},{"location":"status-aggregator/configurations/updater_example/#updater-example","text":"To use ROS diagnostics add the following to CMakeLists.txt: find_package(catkin REQUIRED COMPONENTS std_msgs medusa_msgs roscpp **diagnostic_msgs** serial_lib nmea_msgs medusa_gimmicks_library **medusa_diagnostics_library** ) and in package.xml guarantee the following two dependencies: <depend>diagnostic_msgs</depend> <depend>medusa_diagnostics_library</depend>","title":"Updater example"},{"location":"status-aggregator/configurations/updater_example/#code-use","text":"In some header file please include the following: #include <diagnostic_msgs/KeyValue.h> #include <diagnostic_msgs/DiagnosticArray.h> #include <diagnostic_msgs/DiagnosticStatus.h> #include <medusa_diagnostics_library/MedusaDiagnostics.h> Below you can find an example, with two different key values(pressure and temperature), the status message is directly populated in the driver node: void ImsNode::reportingPressure(const medusa_msgs::Pressure &msg) { //** Instantiate diagnostic message diagnostic_msgs::DiagnosticArray diag_msg; diag_msg.header.stamp = msg.header.stamp; diag_msg.status.push_back(MedusaDiagnostics::setDiagnosisMsg(diagnostic_msgs::DiagnosticStatus::OK, \"/Sensors/Pressure\", \"IMS Pressure Good.\", \"IMS Board\")); diag_msg.status.push_back(MedusaDiagnostics::setDiagnosisMsg(diagnostic_msgs::DiagnosticStatus::OK, \"/Sensors/Temperature\", \"IMS Temperature Good.\", \"IMS Board\")); // +.+ Check pressure bounds if (MedusaDiagnostics::checkLowerBound(msg.pressure, p_min_pressure_) || MedusaDiagnostics::checkUpperBound(msg.pressure, p_max_pressure_)) MedusaDiagnostics::errorLevel(&diag_msg, ros::this_node::getName() + \": Pressure out of bounds\", 0); // +.+ Check temperature bounds if (MedusaDiagnostics::checkLowerBound(msg.temperature, p_min_temp_) || MedusaDiagnostics::checkUpperBound(msg.temperature, p_max_temp_)) MedusaDiagnostics::errorLevel(&diag_msg, ros::this_node::getName() + \": Temperature out of bounds\", 1); // +.+ Pressure and temperature key values MedusaDiagnostics::addKeyValue(&diag_msg, \"Pressure\", boost::str(boost::format(\"%.0f\") % (msg.pressure)), 0); MedusaDiagnostics::addKeyValue(&diag_msg, \"Temperature\", boost::str(boost::format(\"%.0f\") % (msg.temperature)), 1); diagnostics_pub_.publish(diag_msg); } where: diagnostics_pub_ = nh_.advertise<diagnostic_msgs::DiagnosticArray>(\"/diagnostics\", 100);","title":"Code use"},{"location":"vehicle-stabilizer/","text":"","title":"Reference"}]}